(() => {
  const Rd = Object.create; const Wr = Object.defineProperty; const Ld = Object.getOwnPropertyDescriptor; const Od = Object.getOwnPropertyNames; const Fd = Object.getPrototypeOf; const Dd = Object.prototype.hasOwnProperty; const Id = e => Wr(e, '__esModule', { value: !0 }); const ci = (e, d) => () => (d || e((d = { exports: {} }).exports, d), d.exports); const Bd = (e, d, t) => { if (d && typeof d === 'object' || typeof d === 'function') for (const i of Od(d))!Dd.call(e, i) && i !== 'default' && Wr(e, i, { get: () => d[i], enumerable: !(t = Ld(d, i)) || t.enumerable }); return e }; const Fi = e => Bd(Id(Wr(e != null ? Rd(Fd(e)) : {}, 'default', e && e.__esModule && 'default' in e ? { get: () => e.default, enumerable: !0 } : { value: e, enumerable: !0 })), e); const Kr = ci((fn, Hr) => {
    (function (d, t) { typeof fn === 'object' && typeof Hr === 'object' ? Hr.exports = t() : typeof define === 'function' && define.amd ? define('Phaser', [], t) : typeof fn === 'object' ? fn.Phaser = t() : d.Phaser = t() })(fn, function () {
      return (function (e) { const d = {}; function t (i) { if (d[i]) return d[i].exports; const h = d[i] = { i, l: !1, exports: {} }; return e[i].call(h.exports, h, h.exports, t), h.l = !0, h.exports } return t.m = e, t.c = d, t.d = function (i, h, n) { t.o(i, h) || Object.defineProperty(i, h, { enumerable: !0, get: n }) }, t.r = function (i) { typeof Symbol !== 'undefined' && Symbol.toStringTag && Object.defineProperty(i, Symbol.toStringTag, { value: 'Module' }), Object.defineProperty(i, '__esModule', { value: !0 }) }, t.t = function (i, h) { if (h & 1 && (i = t(i)), h & 8 || h & 4 && typeof i === 'object' && i && i.__esModule) return i; const n = Object.create(null); if (t.r(n), Object.defineProperty(n, 'default', { enumerable: !0, value: i }), h & 2 && typeof i !== 'string') for (const o in i)t.d(n, o, function (r) { return i[r] }.bind(null, o)); return n }, t.n = function (i) { const h = i && i.__esModule ? function () { return i.default } : function () { return i }; return t.d(h, 'a', h), h }, t.o = function (i, h) { return Object.prototype.hasOwnProperty.call(i, h) }, t.p = '', t(t.s = 1528) }([function (e, d) { function t (s) { return !!s.get && typeof s.get === 'function' || !!s.set && typeof s.set === 'function' } function i (s, a, f) { let l = f ? s[a] : Object.getOwnPropertyDescriptor(s, a); return !f && l.value && typeof l.value === 'object' && (l = l.value), l && t(l) ? (typeof l.enumerable === 'undefined' && (l.enumerable = !0), typeof l.configurable === 'undefined' && (l.configurable = !0), l) : !1 } function h (s, a) { let f = Object.getOwnPropertyDescriptor(s, a); return f ? (f.value && typeof f.value === 'object' && (f = f.value), f.configurable === !1) : !1 } function n (s, a, f, l) { for (const u in a) if (a.hasOwnProperty(u)) { const v = i(a, u, f); if (v !== !1) { const p = l || s; if (h(p.prototype, u)) { if (r.ignoreFinals) continue; throw new Error("cannot override final property '" + u + "', set Class.ignoreFinals = true to skip") }Object.defineProperty(s.prototype, u, v) } else s.prototype[u] = a[u] } } function o (s, a) { if (a) { Array.isArray(a) || (a = [a]); for (let f = 0; f < a.length; f++)n(s, a[f].prototype || a[f]) } } function r (s) { s || (s = {}); let a, f; if (s.initialize) { if (typeof s.initialize !== 'function') throw new Error('initialize must be a function'); a = s.initialize, delete s.initialize } else if (s.Extends) { const l = s.Extends; a = function () { l.apply(this, arguments) } } else a = function () {}; s.Extends ? (a.prototype = Object.create(s.Extends.prototype), a.prototype.constructor = a, f = s.Extends, delete s.Extends) : a.prototype.constructor = a; let u = null; return s.Mixins && (u = s.Mixins, delete s.Mixins), o(a, u), n(a, s, !0, f), a }r.extend = n, r.mixin = o, r.ignoreFinals = !1, e.exports = r }, function (e, d) { const t = function () {}; e.exports = t }, function (e, d) { const t = function (i, h, n) { const o = typeof i; return !i || o === 'number' || o === 'string' ? n : i.hasOwnProperty(h) && i[h] !== void 0 ? i[h] : n }; e.exports = t }, function (e, d, t) { const i = t(0); const h = t(124); var n = new i({ initialize: function (r, s) { this.x = 0, this.y = 0, typeof r === 'object' ? (this.x = r.x || 0, this.y = r.y || 0) : (s === void 0 && (s = r), this.x = r || 0, this.y = s || 0) }, clone: function () { return new n(this.x, this.y) }, copy: function (o) { return this.x = o.x || 0, this.y = o.y || 0, this }, setFromObject: function (o) { return this.x = o.x || 0, this.y = o.y || 0, this }, set: function (o, r) { return r === void 0 && (r = o), this.x = o, this.y = r, this }, setTo: function (o, r) { return this.set(o, r) }, setToPolar: function (o, r) { return r == null && (r = 1), this.x = Math.cos(o) * r, this.y = Math.sin(o) * r, this }, equals: function (o) { return this.x === o.x && this.y === o.y }, fuzzyEquals: function (o, r) { return h(this.x, o.x, r) && h(this.y, o.y, r) }, angle: function () { let o = Math.atan2(this.y, this.x); return o < 0 && (o += 2 * Math.PI), o }, setAngle: function (o) { return this.setToPolar(o, this.length()) }, add: function (o) { return this.x += o.x, this.y += o.y, this }, subtract: function (o) { return this.x -= o.x, this.y -= o.y, this }, multiply: function (o) { return this.x *= o.x, this.y *= o.y, this }, scale: function (o) { return isFinite(o) ? (this.x *= o, this.y *= o) : (this.x = 0, this.y = 0), this }, divide: function (o) { return this.x /= o.x, this.y /= o.y, this }, negate: function () { return this.x = -this.x, this.y = -this.y, this }, distance: function (o) { const r = o.x - this.x; const s = o.y - this.y; return Math.sqrt(r * r + s * s) }, distanceSq: function (o) { const r = o.x - this.x; const s = o.y - this.y; return r * r + s * s }, length: function () { const o = this.x; const r = this.y; return Math.sqrt(o * o + r * r) }, setLength: function (o) { return this.normalize().scale(o) }, lengthSq: function () { const o = this.x; const r = this.y; return o * o + r * r }, normalize: function () { const o = this.x; const r = this.y; let s = o * o + r * r; return s > 0 && (s = 1 / Math.sqrt(s), this.x = o * s, this.y = r * s), this }, normalizeRightHand: function () { const o = this.x; return this.x = this.y * -1, this.y = o, this }, normalizeLeftHand: function () { const o = this.x; return this.x = this.y, this.y = o * -1, this }, dot: function (o) { return this.x * o.x + this.y * o.y }, cross: function (o) { return this.x * o.y - this.y * o.x }, lerp: function (o, r) { r === void 0 && (r = 0); const s = this.x; const a = this.y; return this.x = s + r * (o.x - s), this.y = a + r * (o.y - a), this }, transformMat3: function (o) { const r = this.x; const s = this.y; const a = o.val; return this.x = a[0] * r + a[3] * s + a[6], this.y = a[1] * r + a[4] * s + a[7], this }, transformMat4: function (o) { const r = this.x; const s = this.y; const a = o.val; return this.x = a[0] * r + a[4] * s + a[12], this.y = a[1] * r + a[5] * s + a[13], this }, reset: function () { return this.x = 0, this.y = 0, this }, limit: function (o) { const r = this.length(); return r && r > o && this.scale(o / r), this }, reflect: function (o) { return o = o.clone().normalize(), this.subtract(o.scale(2 * this.dot(o))) }, mirror: function (o) { return this.reflect(o).negate() }, rotate: function (o) { const r = Math.cos(o); const s = Math.sin(o); return this.set(r * this.x - s * this.y, s * this.x + r * this.y) } }); n.ZERO = new n(), n.RIGHT = new n(1, 0), n.LEFT = new n(-1, 0), n.UP = new n(0, -1), n.DOWN = new n(0, 1), n.ONE = new n(1, 1), e.exports = n }, function (e, d, t) { const i = t(0); const h = t(56); const n = new i({ initialize: function (r, s) { r === void 0 && (r = 0), s === void 0 && (s = r), this.type = h.POINT, this.x = r, this.y = s }, setTo: function (o, r) { return o === void 0 && (o = 0), r === void 0 && (r = o), this.x = o, this.y = r, this } }); e.exports = n }, function (e, d, t) { const i = t(0); const h = t(24); const n = t(20); const o = new i({ initialize: function (s) { this.scene = s, this.systems = s.sys, this.events = s.sys.events, this.displayList, this.updateList, this.events.once(n.BOOT, this.boot, this), this.events.on(n.START, this.start, this) }, boot: function () { this.displayList = this.systems.displayList, this.updateList = this.systems.updateList, this.events.once(n.DESTROY, this.destroy, this) }, start: function () { this.events.once(n.SHUTDOWN, this.shutdown, this) }, existing: function (r) { return (r.renderCanvas || r.renderWebGL) && this.displayList.add(r), r.preUpdate && this.updateList.add(r), r }, shutdown: function () { this.events.off(n.SHUTDOWN, this.shutdown, this) }, destroy: function () { this.shutdown(), this.events.off(n.START, this.start, this), this.scene = null, this.systems = null, this.events = null, this.displayList = null, this.updateList = null } }); o.register = function (r, s) { o.prototype.hasOwnProperty(r) || (o.prototype[r] = s) }, o.remove = function (r) { o.prototype.hasOwnProperty(r) && delete o.prototype[r] }, h.register('GameObjectFactory', o, 'add'), e.exports = o }, function (e, d) { const t = function (i, h, n) { if (!i || typeof i === 'number') return n; if (i.hasOwnProperty(h)) return i[h]; if (h.indexOf('.') !== -1) { for (var o = h.split('.'), r = i, s = n, a = 0; a < o.length; a++) if (r.hasOwnProperty(o[a]))s = r[o[a]], r = r[o[a]]; else { s = n; break } return s } else return n }; e.exports = t }, function (e, d) { const t = function (i) { if (typeof i !== 'object' || i.nodeType || i === i.window) return !1; try { if (i.constructor && !{}.hasOwnProperty.call(i.constructor.prototype, 'isPrototypeOf')) return !1 } catch (h) { return !1 } return !0 }; e.exports = t }, function (e, d) { let t = {}; const i = { install: function (h) { for (const n in t)h[n] = t[n] }, register: function (h, n) { t[h] = n }, destroy: function () { t = {} } }; e.exports = i }, function (e, d, t) { 'use strict'; const i = Object.prototype.hasOwnProperty; let h = '~'; function n () {}Object.create && (n.prototype = Object.create(null), new n().__proto__ || (h = !1)); function o (f, l, u) { this.fn = f, this.context = l, this.once = u || !1 } function r (f, l, u, v, p) { if (typeof u !== 'function') throw new TypeError('The listener must be a function'); const c = new o(u, v || f, p); const m = h ? h + l : l; return f._events[m] ? f._events[m].fn ? f._events[m] = [f._events[m], c] : f._events[m].push(c) : (f._events[m] = c, f._eventsCount++), f } function s (f, l) { --f._eventsCount == 0 ? f._events = new n() : delete f._events[l] } function a () { this._events = new n(), this._eventsCount = 0 }a.prototype.eventNames = function () { const l = []; let u; let v; if (this._eventsCount === 0) return l; for (v in u = this._events)i.call(u, v) && l.push(h ? v.slice(1) : v); return Object.getOwnPropertySymbols ? l.concat(Object.getOwnPropertySymbols(u)) : l }, a.prototype.listeners = function (l) { const u = h ? h + l : l; const v = this._events[u]; if (!v) return []; if (v.fn) return [v.fn]; for (var p = 0, c = v.length, m = new Array(c); p < c; p++)m[p] = v[p].fn; return m }, a.prototype.listenerCount = function (l) { const u = h ? h + l : l; const v = this._events[u]; return v ? v.fn ? 1 : v.length : 0 }, a.prototype.emit = function (l, u, v, p, c, m) { const g = h ? h + l : l; if (!this._events[g]) return !1; const x = this._events[g]; const y = arguments.length; let T; let S; if (x.fn) { switch (x.once && this.removeListener(l, x.fn, void 0, !0), y) { case 1:return x.fn.call(x.context), !0; case 2:return x.fn.call(x.context, u), !0; case 3:return x.fn.call(x.context, u, v), !0; case 4:return x.fn.call(x.context, u, v, p), !0; case 5:return x.fn.call(x.context, u, v, p, c), !0; case 6:return x.fn.call(x.context, u, v, p, c, m), !0 } for (S = 1, T = new Array(y - 1); S < y; S++)T[S - 1] = arguments[S]; x.fn.apply(x.context, T) } else { const E = x.length; let C; for (S = 0; S < E; S++) switch (x[S].once && this.removeListener(l, x[S].fn, void 0, !0), y) { case 1:x[S].fn.call(x[S].context); break; case 2:x[S].fn.call(x[S].context, u); break; case 3:x[S].fn.call(x[S].context, u, v); break; case 4:x[S].fn.call(x[S].context, u, v, p); break; default:if (!T) for (C = 1, T = new Array(y - 1); C < y; C++)T[C - 1] = arguments[C]; x[S].fn.apply(x[S].context, T) } } return !0 }, a.prototype.on = function (l, u, v) { return r(this, l, u, v, !1) }, a.prototype.once = function (l, u, v) { return r(this, l, u, v, !0) }, a.prototype.removeListener = function (l, u, v, p) { const c = h ? h + l : l; if (!this._events[c]) return this; if (!u) return s(this, c), this; const m = this._events[c]; if (m.fn)m.fn === u && (!p || m.once) && (!v || m.context === v) && s(this, c); else { for (var g = 0, x = [], y = m.length; g < y; g++)(m[g].fn !== u || p && !m[g].once || v && m[g].context !== v) && x.push(m[g]); x.length ? this._events[c] = x.length === 1 ? x[0] : x : s(this, c) } return this }, a.prototype.removeAllListeners = function (l) { let u; return l ? (u = h ? h + l : l, this._events[u] && s(this, u)) : (this._events = new n(), this._eventsCount = 0), this }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = h, a.EventEmitter = a, e.exports = a }, function (e, d, t) { const i = t(0); const h = t(57); const n = t(171); const o = t(306); const r = t(56); const s = t(47); const a = t(174); const f = new i({ initialize: function (u, v, p, c) { u === void 0 && (u = 0), v === void 0 && (v = 0), p === void 0 && (p = 0), c === void 0 && (c = 0), this.type = r.RECTANGLE, this.x = u, this.y = v, this.width = p, this.height = c }, contains: function (l, u) { return h(this, l, u) }, getPoint: function (l, u) { return n(this, l, u) }, getPoints: function (l, u, v) { return o(this, l, u, v) }, getRandomPoint: function (l) { return a(this, l) }, setTo: function (l, u, v, p) { return this.x = l, this.y = u, this.width = v, this.height = p, this }, setEmpty: function () { return this.setTo(0, 0, 0, 0) }, setPosition: function (l, u) { return u === void 0 && (u = l), this.x = l, this.y = u, this }, setSize: function (l, u) { return u === void 0 && (u = l), this.width = l, this.height = u, this }, isEmpty: function () { return this.width <= 0 || this.height <= 0 }, getLineA: function (l) { return l === void 0 && (l = new s()), l.setTo(this.x, this.y, this.right, this.y), l }, getLineB: function (l) { return l === void 0 && (l = new s()), l.setTo(this.right, this.y, this.right, this.bottom), l }, getLineC: function (l) { return l === void 0 && (l = new s()), l.setTo(this.right, this.bottom, this.x, this.bottom), l }, getLineD: function (l) { return l === void 0 && (l = new s()), l.setTo(this.x, this.bottom, this.x, this.y), l }, left: { get: function () { return this.x }, set: function (l) { l >= this.right ? this.width = 0 : this.width = this.right - l, this.x = l } }, right: { get: function () { return this.x + this.width }, set: function (l) { l <= this.x ? this.width = 0 : this.width = l - this.x } }, top: { get: function () { return this.y }, set: function (l) { l >= this.bottom ? this.height = 0 : this.height = this.bottom - l, this.y = l } }, bottom: { get: function () { return this.y + this.height }, set: function (l) { l <= this.y ? this.height = 0 : this.height = l - this.y } }, centerX: { get: function () { return this.x + this.width / 2 }, set: function (l) { this.x = l - this.width / 2 } }, centerY: { get: function () { return this.y + this.height / 2 }, set: function (l) { this.y = l - this.height / 2 } } }); e.exports = f }, function (e, d, t) { e.exports = { Alpha: t(607), AlphaSingle: t(303), BlendMode: t(304), ComputedSize: t(608), Crop: t(609), Depth: t(305), Flip: t(610), GetBounds: t(611), Mask: t(309), Origin: t(632), PathFollower: t(633), Pipeline: t(167), ScrollFactor: t(312), Size: t(634), Texture: t(635), TextureCrop: t(636), Tint: t(637), ToJSON: t(176), Transform: t(313), TransformMatrix: t(25), Visible: t(314) } }, function (e, d) {
        function t (i) {
          for (var h = '', n = 0; n < i; ++n) {
            n > 0 && (h += `
else `), n < i - 1 && (h += 'if(test == ' + n + '.0){}')
          } return h
        }e.exports = {
          getTintFromFloats: function (i, h, n, o) { const r = (i * 255 | 0) & 255; const s = (h * 255 | 0) & 255; const a = (n * 255 | 0) & 255; const f = (o * 255 | 0) & 255; return (f << 24 | r << 16 | s << 8 | a) >>> 0 },
          getTintAppendFloatAlpha: function (i, h) { const n = (h * 255 | 0) & 255; return (n << 24 | i) >>> 0 },
          getTintAppendFloatAlphaAndSwap: function (i, h) { const n = (i >> 16 | 0) & 255; const o = (i >> 8 | 0) & 255; const r = (i | 0) & 255; const s = (h * 255 | 0) & 255; return (s << 24 | r << 16 | o << 8 | n) >>> 0 },
          getFloatsFromUintRGB: function (i) { const h = (i >> 16 | 0) & 255; const n = (i >> 8 | 0) & 255; const o = (i | 0) & 255; return [h / 255, n / 255, o / 255] },
          checkShaderMax: function (i, h) {
            (!h || h === -1) && (h = i.getParameter(i.MAX_TEXTURE_IMAGE_UNITS)); for (let n = i.createShader(i.FRAGMENT_SHADER), o = ['precision mediump float;', 'void main(void){', 'float test = 0.1;', '%forloop%', 'gl_FragColor = vec4(0.0);', '}'].join(`
`); ;) { const r = o.replace(/%forloop%/gi, t(h)); if (i.shaderSource(n, r), i.compileShader(n), !i.getShaderParameter(n, i.COMPILE_STATUS))h = h / 2 | 0; else break } return h
          },
          parseFragmentShaderMaxTextures: function (i, h) {
            if (!i) return ''; for (var n = '', o = 0; o < h; o++) {
              o > 0 && (n += `
	else `), o < h - 1 && (n += 'if (outTexId < ' + o + '.5)'), n += `
	{`, n += `
		texture = texture2D(uMainSampler[` + o + '], outTexCoord);', n += `
	}`
            } return i = i.replace(/%count%/gi, h.toString()), i.replace(/%forloop%/gi, n)
          }
        }
      }, function (e, d, t) { const i = t(193); const h = t(6); const n = function (o, r, s) { const a = h(o, r, null); if (a === null) return s; if (Array.isArray(a)) return i.RND.pick(a); if (typeof a === 'object') { if (a.hasOwnProperty('randInt')) return i.RND.integerInRange(a.randInt[0], a.randInt[1]); if (a.hasOwnProperty('randFloat')) return i.RND.realInRange(a.randFloat[0], a.randFloat[1]) } else if (typeof a === 'function') return a(r); return a }; e.exports = n }, function (e, d) { const t = { PI2: Math.PI * 2, TAU: Math.PI * 0.5, EPSILON: 1e-6, DEG_TO_RAD: Math.PI / 180, RAD_TO_DEG: 180 / Math.PI, RND: null, MIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER || -9007199254740991, MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991 }; e.exports = t }, function (e, d, t) { const i = t(0); const h = t(176); const n = t(101); const o = t(9); const r = t(75); const s = t(20); var a = new i({ Extends: o, initialize: function (l, u) { o.call(this), this.scene = l, this.displayList = null, this.type = u, this.state = 0, this.parentContainer = null, this.name = '', this.active = !0, this.tabIndex = -1, this.data = null, this.renderFlags = 15, this.cameraFilter = 0, this.input = null, this.body = null, this.ignoreDestroy = !1, this.on(r.ADDED_TO_SCENE, this.addedToScene, this), this.on(r.REMOVED_FROM_SCENE, this.removedFromScene, this), l.sys.queueDepthSort() }, setActive: function (f) { return this.active = f, this }, setName: function (f) { return this.name = f, this }, setState: function (f) { return this.state = f, this }, setDataEnabled: function () { return this.data || (this.data = new n(this)), this }, setData: function (f, l) { return this.data || (this.data = new n(this)), this.data.set(f, l), this }, incData: function (f, l) { return this.data || (this.data = new n(this)), this.data.inc(f, l), this }, toggleData: function (f) { return this.data || (this.data = new n(this)), this.data.toggle(f), this }, getData: function (f) { return this.data || (this.data = new n(this)), this.data.get(f) }, setInteractive: function (f, l, u) { return this.scene.sys.input.enable(this, f, l, u), this }, disableInteractive: function () { return this.input && (this.input.enabled = !1), this }, removeInteractive: function () { return this.scene.sys.input.clear(this), this.input = void 0, this }, addedToScene: function () {}, removedFromScene: function () {}, update: function () {}, toJSON: function () { return h(this) }, willRender: function (f) { return !(a.RENDER_MASK !== this.renderFlags || this.cameraFilter !== 0 && this.cameraFilter & f.id) }, getIndexList: function () { for (var f = this, l = this.parentContainer, u = []; l && (u.unshift(l.getIndex(f)), f = l, l.parentContainer);)l = l.parentContainer; return this.displayList ? u.unshift(this.displayList.getIndex(f)) : u.unshift(this.scene.sys.displayList.getIndex(f)), u }, addToDisplayList: function (f) { return f === void 0 && (f = this.scene.sys.displayList), this.displayList && this.displayList !== f && this.removeFromDisplayList(), f.exists(this) || (this.displayList = f, f.add(this, !0), f.queueDepthSort(), this.emit(r.ADDED_TO_SCENE, this, this.scene), f.events.emit(s.ADDED_TO_SCENE, this, this.scene)), this }, addToUpdateList: function () { return this.scene && this.preUpdate && this.scene.sys.updateList.add(this), this }, removeFromDisplayList: function () { const f = this.displayList || this.scene.sys.displayList; return f.exists(this) && (f.remove(this, !0), f.queueDepthSort(), this.displayList = null, this.emit(r.REMOVED_FROM_SCENE, this, this.scene), f.events.emit(s.REMOVED_FROM_SCENE, this, this.scene)), this }, removeFromUpdateList: function () { return this.scene && this.preUpdate && this.scene.sys.updateList.remove(this), this }, destroy: function (f) { !this.scene || this.ignoreDestroy || (f === void 0 && (f = !1), this.preDestroy && this.preDestroy.call(this), this.emit(r.DESTROY, this, f), this.removeAllListeners(), this.postPipelines && this.resetPostPipeline(!0), this.removeFromDisplayList(), this.removeFromUpdateList(), this.input && (this.scene.sys.input.clear(this), this.input = void 0), this.data && (this.data.destroy(), this.data = void 0), this.body && (this.body.destroy(), this.body = void 0), this.active = !1, this.visible = !1, this.scene = void 0, this.parentContainer = void 0) } }); a.RENDER_MASK = 15, e.exports = a }, function (e, d, t) { const i = t(0); const h = t(24); const n = t(20); const o = new i({ initialize: function (s) { this.scene = s, this.systems = s.sys, this.events = s.sys.events, this.displayList, this.updateList, this.events.once(n.BOOT, this.boot, this), this.events.on(n.START, this.start, this) }, boot: function () { this.displayList = this.systems.displayList, this.updateList = this.systems.updateList, this.events.once(n.DESTROY, this.destroy, this) }, start: function () { this.events.once(n.SHUTDOWN, this.shutdown, this) }, shutdown: function () { this.events.off(n.SHUTDOWN, this.shutdown, this) }, destroy: function () { this.shutdown(), this.events.off(n.START, this.start, this), this.scene = null, this.systems = null, this.events = null, this.displayList = null, this.updateList = null } }); o.register = function (r, s) { o.prototype.hasOwnProperty(r) || (o.prototype[r] = s) }, o.remove = function (r) { o.prototype.hasOwnProperty(r) && delete o.prototype[r] }, h.register('GameObjectCreator', o, 'make'), e.exports = o }, function (e, d, t) { const i = t(7); var h = function () { let n; let o; let r; let s; let a; let f; let l = arguments[0] || {}; let u = 1; const v = arguments.length; let p = !1; for (typeof l === 'boolean' && (p = l, l = arguments[1] || {}, u = 2), v === u && (l = this, --u); u < v; u++) if ((n = arguments[u]) != null) for (o in n)r = l[o], s = n[o], l !== s && (p && s && (i(s) || (a = Array.isArray(s))) ? (a ? (a = !1, f = r && Array.isArray(r) ? r : []) : f = r && i(r) ? r : {}, l[o] = h(p, f, s)) : s !== void 0 && (l[o] = s)); return l }; e.exports = h }, function (e, d) { const t = function (i, h, n) { return Math.max(h, Math.min(n, i)) }; e.exports = t }, function (e, d, t) { const i = t(25); const h = new i(); const n = new i(); const o = new i(); const r = { camera: h, sprite: n, calc: o }; const s = function (a, f, l) { const u = h; const v = n; const p = o; return v.applyITRS(a.x, a.y, a.rotation, a.scaleX, a.scaleY), u.copyFrom(f.matrix), l ? (u.multiplyWithOffset(l, -f.scrollX * a.scrollFactorX, -f.scrollY * a.scrollFactorY), v.e = a.x, v.f = a.y) : (v.e -= f.scrollX * a.scrollFactorX, v.f -= f.scrollY * a.scrollFactorY), u.multiply(v, p), r }; e.exports = s }, function (e, d, t) { e.exports = { ADDED_TO_SCENE: t(656), BOOT: t(657), CREATE: t(658), DESTROY: t(659), PAUSE: t(660), POST_UPDATE: t(661), PRE_RENDER: t(662), PRE_UPDATE: t(663), READY: t(664), REMOVED_FROM_SCENE: t(665), RENDER: t(666), RESUME: t(667), SHUTDOWN: t(668), SLEEP: t(669), START: t(670), TRANSITION_COMPLETE: t(671), TRANSITION_INIT: t(672), TRANSITION_OUT: t(673), TRANSITION_START: t(674), TRANSITION_WAKE: t(675), UPDATE: t(676), WAKE: t(677) } }, function (e, d) { const t = { LOADER_IDLE: 0, LOADER_LOADING: 1, LOADER_PROCESSING: 2, LOADER_COMPLETE: 3, LOADER_SHUTDOWN: 4, LOADER_DESTROYED: 5, FILE_PENDING: 10, FILE_LOADING: 11, FILE_LOADED: 12, FILE_FAILED: 13, FILE_PROCESSING: 14, FILE_ERRORED: 16, FILE_COMPLETE: 17, FILE_DESTROYED: 18, FILE_POPULATED: 19 }; e.exports = t }, function (e, d, t) { e.exports = { BLUR: t(612), BOOT: t(613), CONTEXT_LOST: t(614), CONTEXT_RESTORED: t(615), DESTROY: t(616), FOCUS: t(617), HIDDEN: t(618), PAUSE: t(619), POST_RENDER: t(620), POST_STEP: t(621), PRE_RENDER: t(622), PRE_STEP: t(623), READY: t(624), RESUME: t(625), STEP: t(626), VISIBLE: t(627) } }, function (e, d, t) { const i = t(0); const h = t(21); const n = t(95); const o = t(2); const r = t(155); const s = t(240); const a = t(517); const f = t(156); const l = new i({ initialize: function (v, p) { this.loader = v, this.cache = o(p, 'cache', !1), this.type = o(p, 'type', !1), this.key = o(p, 'key', !1); const c = this.key; if (v.prefix && v.prefix !== '' && (this.key = v.prefix + c), !this.type || !this.key) throw new Error('Invalid Loader.' + this.type + ' key'); let m = o(p, 'url'); m === void 0 ? m = v.path + c + '.' + o(p, 'extension', '') : typeof m === 'string' && !m.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/) && (m = v.path + m), this.url = m, this.src = '', this.xhrSettings = f(o(p, 'responseType', void 0)), o(p, 'xhrSettings', !1) && (this.xhrSettings = s(this.xhrSettings, o(p, 'xhrSettings', {}))), this.xhrLoader = null, this.state = typeof this.url === 'function' ? h.FILE_POPULATED : h.FILE_PENDING, this.bytesTotal = 0, this.bytesLoaded = -1, this.percentComplete = -1, this.crossOrigin = void 0, this.data = void 0, this.config = o(p, 'config', {}), this.multiFile, this.linkFile }, setLink: function (u) { this.linkFile = u, u.linkFile = this }, resetXHR: function () { this.xhrLoader && (this.xhrLoader.onload = void 0, this.xhrLoader.onerror = void 0, this.xhrLoader.onprogress = void 0) }, load: function () { this.state === h.FILE_POPULATED ? this.loader.nextFile(this, !0) : (this.state = h.FILE_LOADING, this.src = r(this, this.loader.baseURL), this.src.indexOf('data:') === 0 ? console.warn('Local data URIs are not supported: ' + this.key) : this.xhrLoader = a(this, this.loader.xhr)) }, onLoad: function (u, v) { const p = u.responseURL && (u.responseURL.indexOf('file://') === 0 || u.responseURL.indexOf('capacitor://') === 0); const c = p && v.target.status === 0; let m = !(v.target && v.target.status !== 200) || c; u.readyState === 4 && u.status >= 400 && u.status <= 599 && (m = !1), this.state = h.FILE_LOADED, this.resetXHR(), this.loader.nextFile(this, m) }, onError: function () { this.resetXHR(), this.loader.nextFile(this, !1) }, onProgress: function (u) { u.lengthComputable && (this.bytesLoaded = u.loaded, this.bytesTotal = u.total, this.percentComplete = Math.min(this.bytesLoaded / this.bytesTotal, 1), this.loader.emit(n.FILE_PROGRESS, this, this.percentComplete)) }, onProcess: function () { this.state = h.FILE_PROCESSING, this.onProcessComplete() }, onProcessComplete: function () { this.state = h.FILE_COMPLETE, this.multiFile && this.multiFile.onFileComplete(this), this.loader.fileProcessComplete(this) }, onProcessError: function () { this.state = h.FILE_ERRORED, this.multiFile && this.multiFile.onFileFailed(this), this.loader.fileProcessComplete(this) }, hasCacheConflict: function () { return this.cache && this.cache.exists(this.key) }, addToCache: function () { this.cache && this.cache.add(this.key, this.data), this.pendingDestroy() }, pendingDestroy: function (u) { u === void 0 && (u = this.data); const v = this.key; const p = this.type; this.loader.emit(n.FILE_COMPLETE, v, p, u), this.loader.emit(n.FILE_KEY_COMPLETE + p + '-' + v, v, p, u), this.loader.flagForRemoval(this) }, destroy: function () { this.loader = null, this.cache = null, this.xhrSettings = null, this.multiFile = null, this.linkFile = null, this.data = null } }); l.createObjectURL = function (u, v, p) { if (typeof URL === 'function')u.src = URL.createObjectURL(v); else { const c = new FileReader(); c.onload = function () { u.removeAttribute('crossOrigin'), u.src = 'data:' + (v.type || p) + ';base64,' + c.result.split(',')[1] }, c.onerror = u.onerror, c.readAsDataURL(v) } }, l.revokeObjectURL = function (u) { typeof URL === 'function' && URL.revokeObjectURL(u.src) }, e.exports = l }, function (e, d) { const t = {}; const i = {}; const h = {}; h.register = function (n, o, r, s) { s === void 0 && (s = !1), t[n] = { plugin: o, mapping: r, custom: s } }, h.registerCustom = function (n, o, r, s) { i[n] = { plugin: o, mapping: r, data: s } }, h.hasCore = function (n) { return t.hasOwnProperty(n) }, h.hasCustom = function (n) { return i.hasOwnProperty(n) }, h.getCore = function (n) { return t[n] }, h.getCustom = function (n) { return i[n] }, h.getCustomClass = function (n) { return i.hasOwnProperty(n) ? i[n].plugin : null }, h.remove = function (n) { t.hasOwnProperty(n) && delete t[n] }, h.removeCustom = function (n) { i.hasOwnProperty(n) && delete i[n] }, h.destroyCorePlugins = function () { for (const n in t)t.hasOwnProperty(n) && delete t[n] }, h.destroyCustomPlugins = function () { for (const n in i)i.hasOwnProperty(n) && delete i[n] }, e.exports = h }, function (e, d, t) { const i = t(0); const h = t(14); const n = t(3); const o = new i({ initialize: function (s, a, f, l, u, v) { s === void 0 && (s = 1), a === void 0 && (a = 0), f === void 0 && (f = 0), l === void 0 && (l = 1), u === void 0 && (u = 0), v === void 0 && (v = 0), this.matrix = new Float32Array([s, a, f, l, u, v, 0, 0, 1]), this.decomposedMatrix = { translateX: 0, translateY: 0, scaleX: 1, scaleY: 1, rotation: 0 } }, a: { get: function () { return this.matrix[0] }, set: function (r) { this.matrix[0] = r } }, b: { get: function () { return this.matrix[1] }, set: function (r) { this.matrix[1] = r } }, c: { get: function () { return this.matrix[2] }, set: function (r) { this.matrix[2] = r } }, d: { get: function () { return this.matrix[3] }, set: function (r) { this.matrix[3] = r } }, e: { get: function () { return this.matrix[4] }, set: function (r) { this.matrix[4] = r } }, f: { get: function () { return this.matrix[5] }, set: function (r) { this.matrix[5] = r } }, tx: { get: function () { return this.matrix[4] }, set: function (r) { this.matrix[4] = r } }, ty: { get: function () { return this.matrix[5] }, set: function (r) { this.matrix[5] = r } }, rotation: { get: function () { return Math.acos(this.a / this.scaleX) * (Math.atan(-this.c / this.a) < 0 ? -1 : 1) } }, rotationNormalized: { get: function () { const r = this.matrix; const s = r[0]; const a = r[1]; const f = r[2]; const l = r[3]; return s || a ? a > 0 ? Math.acos(s / this.scaleX) : -Math.acos(s / this.scaleX) : f || l ? h.TAU - (l > 0 ? Math.acos(-f / this.scaleY) : -Math.acos(f / this.scaleY)) : 0 } }, scaleX: { get: function () { return Math.sqrt(this.a * this.a + this.b * this.b) } }, scaleY: { get: function () { return Math.sqrt(this.c * this.c + this.d * this.d) } }, loadIdentity: function () { const r = this.matrix; return r[0] = 1, r[1] = 0, r[2] = 0, r[3] = 1, r[4] = 0, r[5] = 0, this }, translate: function (r, s) { const a = this.matrix; return a[4] = a[0] * r + a[2] * s + a[4], a[5] = a[1] * r + a[3] * s + a[5], this }, scale: function (r, s) { const a = this.matrix; return a[0] *= r, a[1] *= r, a[2] *= s, a[3] *= s, this }, rotate: function (r) { const s = Math.sin(r); const a = Math.cos(r); const f = this.matrix; const l = f[0]; const u = f[1]; const v = f[2]; const p = f[3]; return f[0] = l * a + v * s, f[1] = u * a + p * s, f[2] = l * -s + v * a, f[3] = u * -s + p * a, this }, multiply: function (r, s) { const a = this.matrix; const f = r.matrix; const l = a[0]; const u = a[1]; const v = a[2]; const p = a[3]; const c = a[4]; const m = a[5]; const g = f[0]; const x = f[1]; const y = f[2]; const T = f[3]; const S = f[4]; const E = f[5]; const C = s === void 0 ? this : s; return C.a = g * l + x * v, C.b = g * u + x * p, C.c = y * l + T * v, C.d = y * u + T * p, C.e = S * l + E * v + c, C.f = S * u + E * p + m, C }, multiplyWithOffset: function (r, s, a) { const f = this.matrix; const l = r.matrix; const u = f[0]; const v = f[1]; const p = f[2]; const c = f[3]; const m = f[4]; const g = f[5]; const x = s * u + a * p + m; const y = s * v + a * c + g; const T = l[0]; const S = l[1]; const E = l[2]; const C = l[3]; const P = l[4]; const A = l[5]; return f[0] = T * u + S * p, f[1] = T * v + S * c, f[2] = E * u + C * p, f[3] = E * v + C * c, f[4] = P * u + A * p + x, f[5] = P * v + A * c + y, this }, transform: function (r, s, a, f, l, u) { const v = this.matrix; const p = v[0]; const c = v[1]; const m = v[2]; const g = v[3]; const x = v[4]; const y = v[5]; return v[0] = r * p + s * m, v[1] = r * c + s * g, v[2] = a * p + f * m, v[3] = a * c + f * g, v[4] = l * p + u * m + x, v[5] = l * c + u * g + y, this }, transformPoint: function (r, s, a) { a === void 0 && (a = { x: 0, y: 0 }); const f = this.matrix; const l = f[0]; const u = f[1]; const v = f[2]; const p = f[3]; const c = f[4]; const m = f[5]; return a.x = r * l + s * v + c, a.y = r * u + s * p + m, a }, invert: function () { const r = this.matrix; const s = r[0]; const a = r[1]; const f = r[2]; const l = r[3]; const u = r[4]; const v = r[5]; const p = s * l - a * f; return r[0] = l / p, r[1] = -a / p, r[2] = -f / p, r[3] = s / p, r[4] = (f * v - l * u) / p, r[5] = -(s * v - a * u) / p, this }, copyFrom: function (r) { const s = this.matrix; return s[0] = r.a, s[1] = r.b, s[2] = r.c, s[3] = r.d, s[4] = r.e, s[5] = r.f, this }, copyFromArray: function (r) { const s = this.matrix; return s[0] = r[0], s[1] = r[1], s[2] = r[2], s[3] = r[3], s[4] = r[4], s[5] = r[5], this }, copyToContext: function (r) { const s = this.matrix; return r.transform(s[0], s[1], s[2], s[3], s[4], s[5]), r }, setToContext: function (r) { const s = this.matrix; return r.setTransform(s[0], s[1], s[2], s[3], s[4], s[5]), r }, copyToArray: function (r) { const s = this.matrix; return r === void 0 ? r = [s[0], s[1], s[2], s[3], s[4], s[5]] : (r[0] = s[0], r[1] = s[1], r[2] = s[2], r[3] = s[3], r[4] = s[4], r[5] = s[5]), r }, setTransform: function (r, s, a, f, l, u) { const v = this.matrix; return v[0] = r, v[1] = s, v[2] = a, v[3] = f, v[4] = l, v[5] = u, this }, decomposeMatrix: function () { const r = this.decomposedMatrix; const s = this.matrix; const a = s[0]; const f = s[1]; const l = s[2]; const u = s[3]; const v = a * u - f * l; if (r.translateX = s[4], r.translateY = s[5], a || f) { const p = Math.sqrt(a * a + f * f); r.rotation = f > 0 ? Math.acos(a / p) : -Math.acos(a / p), r.scaleX = p, r.scaleY = v / p } else if (l || u) { const c = Math.sqrt(l * l + u * u); r.rotation = Math.PI * 0.5 - (u > 0 ? Math.acos(-l / c) : -Math.acos(l / c)), r.scaleX = v / c, r.scaleY = c } else r.rotation = 0, r.scaleX = 0, r.scaleY = 0; return r }, applyITRS: function (r, s, a, f, l) { const u = this.matrix; const v = Math.sin(a); const p = Math.cos(a); return u[4] = r, u[5] = s, u[0] = p * f, u[1] = v * f, u[2] = -v * l, u[3] = p * l, this }, applyInverse: function (r, s, a) { a === void 0 && (a = new n()); const f = this.matrix; const l = f[0]; const u = f[1]; const v = f[2]; const p = f[3]; const c = f[4]; const m = f[5]; const g = 1 / (l * p + v * -u); return a.x = p * g * r + -v * g * s + (m * v - c * p) * g, a.y = l * g * s + -u * g * r + (-m * l + c * u) * g, a }, getX: function (r, s) { return r * this.a + s * this.c + this.e }, getY: function (r, s) { return r * this.b + s * this.d + this.f }, getXRound: function (r, s, a) { let f = this.getX(r, s); return a && (f = Math.round(f)), f }, getYRound: function (r, s, a) { let f = this.getY(r, s); return a && (f = Math.round(f)), f }, getCSSMatrix: function () { const r = this.matrix; return 'matrix(' + r[0] + ',' + r[1] + ',' + r[2] + ',' + r[3] + ',' + r[4] + ',' + r[5] + ')' }, destroy: function () { this.matrix = null, this.decomposedMatrix = null } }); e.exports = o }, function (e, d, t) { const i = t(2); const h = function (n, o, r, s, a, f) { n === void 0 && (n = 0), o === void 0 && (o = 0), r === void 0 && (r = f.width), s === void 0 && (s = f.height), a || (a = {}); const l = i(a, 'isNotEmpty', !1); const u = i(a, 'isColliding', !1); const v = i(a, 'hasInterestingFace', !1); n < 0 && (r += n, n = 0), o < 0 && (s += o, o = 0), n + r > f.width && (r = Math.max(f.width - n, 0)), o + s > f.height && (s = Math.max(f.height - o, 0)); for (var p = [], c = o; c < o + s; c++) for (let m = n; m < n + r; m++) { const g = f.data[c][m]; if (g !== null) { if (l && g.index === -1 || u && !g.collides || v && !g.hasInterestingFace) continue; p.push(g) } } return p }; e.exports = h }, function (e, d) { const t = function (i, h, n, o, r, s) { o === void 0 && (o = 0), r === void 0 && (r = 0), s === void 0 && (s = 1); let a; let f = 0; const l = i.length; if (s === 1) for (a = r; a < l; a++)i[a][h] = n + f * o, f++; else for (a = r; a >= 0; a--)i[a][h] = n + f * o, f++; return i }; e.exports = t }, function (e, d, t) { const i = t(35); const h = t(13); const n = function (o, r, s) { r.x = h(s, 'x', 0), r.y = h(s, 'y', 0), r.depth = h(s, 'depth', 0), r.flipX = h(s, 'flipX', !1), r.flipY = h(s, 'flipY', !1); const a = h(s, 'scale', null); typeof a === 'number' ? r.setScale(a) : a !== null && (r.scaleX = h(a, 'x', 1), r.scaleY = h(a, 'y', 1)); const f = h(s, 'scrollFactor', null); typeof f === 'number' ? r.setScrollFactor(f) : f !== null && (r.scrollFactorX = h(f, 'x', 1), r.scrollFactorY = h(f, 'y', 1)), r.rotation = h(s, 'rotation', 0); const l = h(s, 'angle', null); l !== null && (r.angle = l), r.alpha = h(s, 'alpha', 1); const u = h(s, 'origin', null); if (typeof u === 'number')r.setOrigin(u); else if (u !== null) { const v = h(u, 'x', 0.5); const p = h(u, 'y', 0.5); r.setOrigin(v, p) }r.blendMode = h(s, 'blendMode', i.NORMAL), r.visible = h(s, 'visible', !0); const c = h(s, 'add', !0); return c && o.sys.displayList.add(r), r.preUpdate && o.sys.updateList.add(r), r }; e.exports = n }, function (e, d) { e.exports = { ORTHOGONAL: 0, ISOMETRIC: 1, STAGGERED: 2, HEXAGONAL: 3 } }, function (e, d, t) { const i = t(19); const h = function (n, o, r, s, a) { const f = s.alpha * r.alpha; if (f <= 0) return !1; const l = i(r, s, a).calc; return o.globalCompositeOperation = n.blendModes[r.blendMode], o.globalAlpha = f, o.save(), l.setToContext(o), o.imageSmoothingEnabled = !(!n.antialias || r.frame && r.frame.source.scaleMode), !0 }; e.exports = h }, function (e, d, t) { const i = t(33); const h = t(192); const n = []; let o = !1; const r = function () { const s = function (g, x, y, T, S) { x === void 0 && (x = 1), y === void 0 && (y = 1), T === void 0 && (T = i.CANVAS), S === void 0 && (S = !1); let E; let C = l(T); return C === null ? (C = { parent: g, canvas: document.createElement('canvas'), type: T }, T === i.CANVAS && n.push(C), E = C.canvas) : (C.parent = g, E = C.canvas), S && (C.parent = E), E.width = x, E.height = y, o && T === i.CANVAS && h.disable(E.getContext('2d')), E }; const a = function (g, x, y) { return s(g, x, y, i.CANVAS) }; const f = function (g, x, y) { return s(g, x, y, i.WEBGL) }; var l = function (g) { if (g === void 0 && (g = i.CANVAS), g === i.WEBGL) return null; for (let x = 0; x < n.length; x++) { const y = n[x]; if (!y.parent && y.type === g) return y } return null }; const u = function (g) { const x = g instanceof HTMLCanvasElement; n.forEach(function (y) { (x && y.canvas === g || !x && y.parent === g) && (y.parent = null, y.canvas.width = 1, y.canvas.height = 1) }) }; const v = function () { let g = 0; return n.forEach(function (x) { x.parent && g++ }), g }; const p = function () { return n.length - v() }; const c = function () { o = !0 }; const m = function () { o = !1 }; return { create2D: a, create: s, createWebGL: f, disableSmoothing: c, enableSmoothing: m, first: l, free: p, pool: n, remove: u, total: v } }; e.exports = r() }, function (e, d) { const t = {}; e.exports = t, (function () { t._nextId = 0, t._seed = 0, t._nowStartTime = +new Date(), t.extend = function (h, n) { let o, r, s; typeof n === 'boolean' ? (o = 2, s = n) : (o = 1, s = !0); for (let a = o; a < arguments.length; a++) { const f = arguments[a]; if (f) for (const l in f)s && f[l] && f[l].constructor === Object && (!h[l] || h[l].constructor === Object) ? (h[l] = h[l] || {}, t.extend(h[l], s, f[l])) : h[l] = f[l] } return h }, t.clone = function (h, n) { return t.extend({}, n, h) }, t.keys = function (h) { if (Object.keys) return Object.keys(h); const n = []; for (const o in h)n.push(o); return n }, t.values = function (h) { const n = []; if (Object.keys) { for (let o = Object.keys(h), r = 0; r < o.length; r++)n.push(h[o[r]]); return n } for (const s in h)n.push(h[s]); return n }, t.get = function (h, n, o, r) { n = n.split('.').slice(o, r); for (let s = 0; s < n.length; s += 1)h = h[n[s]]; return h }, t.set = function (h, n, o, r, s) { const a = n.split('.').slice(r, s); return t.get(h, n, 0, -1)[a[a.length - 1]] = o, o }, t.shuffle = function (h) { for (let n = h.length - 1; n > 0; n--) { const o = Math.floor(t.random() * (n + 1)); const r = h[n]; h[n] = h[o], h[o] = r } return h }, t.choose = function (h) { return h[Math.floor(t.random() * h.length)] }, t.isElement = function (h) { return typeof HTMLElement !== 'undefined' ? h instanceof HTMLElement : !!(h && h.nodeType && h.nodeName) }, t.isArray = function (h) { return Object.prototype.toString.call(h) === '[object Array]' }, t.isFunction = function (h) { return typeof h === 'function' }, t.isPlainObject = function (h) { return typeof h === 'object' && h.constructor === Object }, t.isString = function (h) { return Object.prototype.toString.call(h) === '[object String]' }, t.clamp = function (h, n, o) { return h < n ? n : h > o ? o : h }, t.sign = function (h) { return h < 0 ? -1 : 1 }, t.now = function () { if (typeof window !== 'undefined' && window.performance) { if (window.performance.now) return window.performance.now(); if (window.performance.webkitNow) return window.performance.webkitNow() } return new Date() - t._nowStartTime }, t.random = function (h, n) { return h = typeof h !== 'undefined' ? h : 0, n = typeof n !== 'undefined' ? n : 1, h + i() * (n - h) }; var i = function () { return t._seed = (t._seed * 9301 + 49297) % 233280, t._seed / 233280 }; t.colorToNumber = function (h) { return h = h.replace('#', ''), h.length == 3 && (h = h.charAt(0) + h.charAt(0) + h.charAt(1) + h.charAt(1) + h.charAt(2) + h.charAt(2)), parseInt(h, 16) }, t.logLevel = 1, t.log = function () { console && t.logLevel > 0 && t.logLevel <= 3 && console.log.apply(console, ['matter-js:'].concat(Array.prototype.slice.call(arguments))) }, t.info = function () { console && t.logLevel > 0 && t.logLevel <= 2 && console.info.apply(console, ['matter-js:'].concat(Array.prototype.slice.call(arguments))) }, t.warn = function () { console && t.logLevel > 0 && t.logLevel <= 3 && console.warn.apply(console, ['matter-js:'].concat(Array.prototype.slice.call(arguments))) }, t.nextId = function () { return t._nextId++ }, t.indexOf = function (h, n) { if (h.indexOf) return h.indexOf(n); for (let o = 0; o < h.length; o++) if (h[o] === n) return o; return -1 }, t.map = function (h, n) { if (h.map) return h.map(n); for (var o = [], r = 0; r < h.length; r += 1)o.push(n(h[r])); return o }, t.topologicalSort = function (h) { const n = []; const o = []; const r = []; for (const s in h)!o[s] && !r[s] && t._topologicalSort(s, o, r, h, n); return n }, t._topologicalSort = function (h, n, o, r, s) { const a = r[h] || []; o[h] = !0; for (let f = 0; f < a.length; f += 1) { const l = a[f]; o[l] || n[l] || t._topologicalSort(l, n, o, r, s) }o[h] = !1, n[h] = !0, s.push(h) }, t.chain = function () { for (var h = [], n = 0; n < arguments.length; n += 1) { const o = arguments[n]; o._chained ? h.push.apply(h, o._chained) : h.push(o) } const r = function () { for (var s, a = new Array(arguments.length), f = 0, l = arguments.length; f < l; f++)a[f] = arguments[f]; for (f = 0; f < h.length; f += 1) { const u = h[f].apply(s, a); typeof u !== 'undefined' && (s = u) } return s }; return r._chained = h, r }, t.chainPathBefore = function (h, n, o) { return t.set(h, n, t.chain(o, t.get(h, n))) }, t.chainPathAfter = function (h, n, o) { return t.set(h, n, t.chain(t.get(h, n), o)) } }()) }, function (e, d, t) { const i = { VERSION: '3.55.2', BlendModes: t(35), ScaleModes: t(168), AUTO: 0, CANVAS: 1, WEBGL: 2, HEADLESS: 3, FOREVER: -1, NONE: 4, UP: 5, DOWN: 6, LEFT: 7, RIGHT: 8 }; e.exports = i }, function (e, d, t) { const i = t(0); const h = t(11); const n = t(15); const o = t(47); const r = new i({ Extends: n, Mixins: [h.AlphaSingle, h.BlendMode, h.Depth, h.GetBounds, h.Mask, h.Origin, h.Pipeline, h.ScrollFactor, h.Transform, h.Visible], initialize: function (a, f, l) { f === void 0 && (f = 'Shape'), n.call(this, a, f), this.geom = l, this.pathData = [], this.pathIndexes = [], this.fillColor = 16777215, this.fillAlpha = 1, this.strokeColor = 16777215, this.strokeAlpha = 1, this.lineWidth = 1, this.isFilled = !1, this.isStroked = !1, this.closePath = !0, this._tempLine = new o(), this.width = 0, this.height = 0, this.initPipeline() }, setFillStyle: function (s, a) { return a === void 0 && (a = 1), s === void 0 ? this.isFilled = !1 : (this.fillColor = s, this.fillAlpha = a, this.isFilled = !0), this }, setStrokeStyle: function (s, a, f) { return f === void 0 && (f = 1), s === void 0 ? this.isStroked = !1 : (this.lineWidth = s, this.strokeColor = a, this.strokeAlpha = f, this.isStroked = !0), this }, setClosePath: function (s) { return this.closePath = s, this }, setSize: function (s, a) { return this.width = s, this.height = a, this }, setDisplaySize: function (s, a) { return this.displayWidth = s, this.displayHeight = a, this }, preDestroy: function () { this.geom = null, this._tempLine = null, this.pathData = [], this.pathIndexes = [] }, displayWidth: { get: function () { return this.scaleX * this.width }, set: function (s) { this.scaleX = s / this.width } }, displayHeight: { get: function () { return this.scaleY * this.height }, set: function (s) { this.scaleY = s / this.height } } }); e.exports = r }, function (e, d) { e.exports = { SKIP_CHECK: -1, NORMAL: 0, ADD: 1, MULTIPLY: 2, SCREEN: 3, OVERLAY: 4, DARKEN: 5, LIGHTEN: 6, COLOR_DODGE: 7, COLOR_BURN: 8, HARD_LIGHT: 9, SOFT_LIGHT: 10, DIFFERENCE: 11, EXCLUSION: 12, HUE: 13, SATURATION: 14, COLOR: 15, LUMINOSITY: 16, ERASE: 17, SOURCE_IN: 18, SOURCE_OUT: 19, SOURCE_ATOP: 20, DESTINATION_OVER: 21, DESTINATION_IN: 22, DESTINATION_OUT: 23, DESTINATION_ATOP: 24, LIGHTER: 25, COPY: 26, XOR: 27 } }, function (e, d, t) { const i = t(14); const h = function (n) { return n * i.DEG_TO_RAD }; e.exports = h }, function (e, d, t) { e.exports = { DESTROY: t(743), FADE_IN_COMPLETE: t(744), FADE_IN_START: t(745), FADE_OUT_COMPLETE: t(746), FADE_OUT_START: t(747), FLASH_COMPLETE: t(748), FLASH_START: t(749), FOLLOW_UPDATE: t(750), PAN_COMPLETE: t(751), PAN_START: t(752), POST_RENDER: t(753), PRE_RENDER: t(754), ROTATE_COMPLETE: t(755), ROTATE_START: t(756), SHAKE_COMPLETE: t(757), SHAKE_START: t(758), ZOOM_COMPLETE: t(759), ZOOM_START: t(760) } }, function (e, d, t) { const i = t(0); const h = t(103); const n = t(328); const o = t(188); const r = t(329); var s = new i({ initialize: function (f, l, u, v) { f === void 0 && (f = 0), l === void 0 && (l = 0), u === void 0 && (u = 0), v === void 0 && (v = 255), this.r = 0, this.g = 0, this.b = 0, this.a = 255, this._h = 0, this._s = 0, this._v = 0, this._locked = !1, this.gl = [0, 0, 0, 1], this._color = 0, this._color32 = 0, this._rgba = '', this.setTo(f, l, u, v) }, transparent: function () { return this._locked = !0, this.red = 0, this.green = 0, this.blue = 0, this.alpha = 0, this._locked = !1, this.update(!0) }, setTo: function (a, f, l, u, v) { return u === void 0 && (u = 255), v === void 0 && (v = !0), this._locked = !0, this.red = a, this.green = f, this.blue = l, this.alpha = u, this._locked = !1, this.update(v) }, setGLTo: function (a, f, l, u) { return u === void 0 && (u = 1), this._locked = !0, this.redGL = a, this.greenGL = f, this.blueGL = l, this.alphaGL = u, this._locked = !1, this.update(!0) }, setFromRGB: function (a) { return this._locked = !0, this.red = a.r, this.green = a.g, this.blue = a.b, a.hasOwnProperty('a') && (this.alpha = a.a), this._locked = !1, this.update(!0) }, setFromHSV: function (a, f, l) { return o(a, f, l, this) }, update: function (a) { if (a === void 0 && (a = !1), this._locked) return this; const f = this.r; const l = this.g; const u = this.b; const v = this.a; return this._color = h(f, l, u), this._color32 = n(f, l, u, v), this._rgba = 'rgba(' + f + ',' + l + ',' + u + ',' + v / 255 + ')', a && r(f, l, u, this), this }, updateHSV: function () { const a = this.r; const f = this.g; const l = this.b; return r(a, f, l, this), this }, clone: function () { return new s(this.r, this.g, this.b, this.a) }, gray: function (a) { return this.setTo(a, a, a) }, random: function (a, f) { a === void 0 && (a = 0), f === void 0 && (f = 255); const l = Math.floor(a + Math.random() * (f - a)); const u = Math.floor(a + Math.random() * (f - a)); const v = Math.floor(a + Math.random() * (f - a)); return this.setTo(l, u, v) }, randomGray: function (a, f) { a === void 0 && (a = 0), f === void 0 && (f = 255); const l = Math.floor(a + Math.random() * (f - a)); return this.setTo(l, l, l) }, saturate: function (a) { return this.s += a / 100, this }, desaturate: function (a) { return this.s -= a / 100, this }, lighten: function (a) { return this.v += a / 100, this }, darken: function (a) { return this.v -= a / 100, this }, brighten: function (a) { let f = this.r; let l = this.g; let u = this.b; return f = Math.max(0, Math.min(255, f - Math.round(255 * -(a / 100)))), l = Math.max(0, Math.min(255, l - Math.round(255 * -(a / 100)))), u = Math.max(0, Math.min(255, u - Math.round(255 * -(a / 100)))), this.setTo(f, l, u) }, color: { get: function () { return this._color } }, color32: { get: function () { return this._color32 } }, rgba: { get: function () { return this._rgba } }, redGL: { get: function () { return this.gl[0] }, set: function (a) { this.gl[0] = Math.min(Math.abs(a), 1), this.r = Math.floor(this.gl[0] * 255), this.update(!0) } }, greenGL: { get: function () { return this.gl[1] }, set: function (a) { this.gl[1] = Math.min(Math.abs(a), 1), this.g = Math.floor(this.gl[1] * 255), this.update(!0) } }, blueGL: { get: function () { return this.gl[2] }, set: function (a) { this.gl[2] = Math.min(Math.abs(a), 1), this.b = Math.floor(this.gl[2] * 255), this.update(!0) } }, alphaGL: { get: function () { return this.gl[3] }, set: function (a) { this.gl[3] = Math.min(Math.abs(a), 1), this.a = Math.floor(this.gl[3] * 255), this.update() } }, red: { get: function () { return this.r }, set: function (a) { a = Math.floor(Math.abs(a)), this.r = Math.min(a, 255), this.gl[0] = a / 255, this.update(!0) } }, green: { get: function () { return this.g }, set: function (a) { a = Math.floor(Math.abs(a)), this.g = Math.min(a, 255), this.gl[1] = a / 255, this.update(!0) } }, blue: { get: function () { return this.b }, set: function (a) { a = Math.floor(Math.abs(a)), this.b = Math.min(a, 255), this.gl[2] = a / 255, this.update(!0) } }, alpha: { get: function () { return this.a }, set: function (a) { a = Math.floor(Math.abs(a)), this.a = Math.min(a, 255), this.gl[3] = a / 255, this.update() } }, h: { get: function () { return this._h }, set: function (a) { this._h = a, o(a, this._s, this._v, this) } }, s: { get: function () { return this._s }, set: function (a) { this._s = a, o(this._h, a, this._v, this) } }, v: { get: function () { return this._v }, set: function (a) { this._v = a, o(this._h, this._s, a, this) } } }); e.exports = s }, function (e, d, t) { const i = t(0); var h = new i({ initialize: function (o, r, s) { this.x = 0, this.y = 0, this.z = 0, typeof o === 'object' ? (this.x = o.x || 0, this.y = o.y || 0, this.z = o.z || 0) : (this.x = o || 0, this.y = r || 0, this.z = s || 0) }, up: function () { return this.x = 0, this.y = 1, this.z = 0, this }, min: function (n) { return this.x = Math.min(this.x, n.x), this.y = Math.min(this.y, n.y), this.z = Math.min(this.z, n.z), this }, max: function (n) { return this.x = Math.max(this.x, n.x), this.y = Math.max(this.y, n.y), this.z = Math.max(this.z, n.z), this }, clone: function () { return new h(this.x, this.y, this.z) }, addVectors: function (n, o) { return this.x = n.x + o.x, this.y = n.y + o.y, this.z = n.z + o.z, this }, crossVectors: function (n, o) { const r = n.x; const s = n.y; const a = n.z; const f = o.x; const l = o.y; const u = o.z; return this.x = s * u - a * l, this.y = a * f - r * u, this.z = r * l - s * f, this }, equals: function (n) { return this.x === n.x && this.y === n.y && this.z === n.z }, copy: function (n) { return this.x = n.x, this.y = n.y, this.z = n.z || 0, this }, set: function (n, o, r) { return typeof n === 'object' ? (this.x = n.x || 0, this.y = n.y || 0, this.z = n.z || 0) : (this.x = n || 0, this.y = o || 0, this.z = r || 0), this }, setFromMatrixPosition: function (n) { return this.fromArray(n.val, 12) }, setFromMatrixColumn: function (n, o) { return this.fromArray(n.val, o * 4) }, fromArray: function (n, o) { return o === void 0 && (o = 0), this.x = n[o], this.y = n[o + 1], this.z = n[o + 2], this }, add: function (n) { return this.x += n.x, this.y += n.y, this.z += n.z || 0, this }, addScalar: function (n) { return this.x += n, this.y += n, this.z += n, this }, addScale: function (n, o) { return this.x += n.x * o, this.y += n.y * o, this.z += n.z * o || 0, this }, subtract: function (n) { return this.x -= n.x, this.y -= n.y, this.z -= n.z || 0, this }, multiply: function (n) { return this.x *= n.x, this.y *= n.y, this.z *= n.z || 1, this }, scale: function (n) { return isFinite(n) ? (this.x *= n, this.y *= n, this.z *= n) : (this.x = 0, this.y = 0, this.z = 0), this }, divide: function (n) { return this.x /= n.x, this.y /= n.y, this.z /= n.z || 1, this }, negate: function () { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this }, distance: function (n) { const o = n.x - this.x; const r = n.y - this.y; const s = n.z - this.z || 0; return Math.sqrt(o * o + r * r + s * s) }, distanceSq: function (n) { const o = n.x - this.x; const r = n.y - this.y; const s = n.z - this.z || 0; return o * o + r * r + s * s }, length: function () { const n = this.x; const o = this.y; const r = this.z; return Math.sqrt(n * n + o * o + r * r) }, lengthSq: function () { const n = this.x; const o = this.y; const r = this.z; return n * n + o * o + r * r }, normalize: function () { const n = this.x; const o = this.y; const r = this.z; let s = n * n + o * o + r * r; return s > 0 && (s = 1 / Math.sqrt(s), this.x = n * s, this.y = o * s, this.z = r * s), this }, dot: function (n) { return this.x * n.x + this.y * n.y + this.z * n.z }, cross: function (n) { const o = this.x; const r = this.y; const s = this.z; const a = n.x; const f = n.y; const l = n.z; return this.x = r * l - s * f, this.y = s * a - o * l, this.z = o * f - r * a, this }, lerp: function (n, o) { o === void 0 && (o = 0); const r = this.x; const s = this.y; const a = this.z; return this.x = r + o * (n.x - r), this.y = s + o * (n.y - s), this.z = a + o * (n.z - a), this }, applyMatrix3: function (n) { const o = this.x; const r = this.y; const s = this.z; const a = n.val; return this.x = a[0] * o + a[3] * r + a[6] * s, this.y = a[1] * o + a[4] * r + a[7] * s, this.z = a[2] * o + a[5] * r + a[8] * s, this }, applyMatrix4: function (n) { const o = this.x; const r = this.y; const s = this.z; const a = n.val; const f = 1 / (a[3] * o + a[7] * r + a[11] * s + a[15]); return this.x = (a[0] * o + a[4] * r + a[8] * s + a[12]) * f, this.y = (a[1] * o + a[5] * r + a[9] * s + a[13]) * f, this.z = (a[2] * o + a[6] * r + a[10] * s + a[14]) * f, this }, transformMat3: function (n) { const o = this.x; const r = this.y; const s = this.z; const a = n.val; return this.x = o * a[0] + r * a[3] + s * a[6], this.y = o * a[1] + r * a[4] + s * a[7], this.z = o * a[2] + r * a[5] + s * a[8], this }, transformMat4: function (n) { const o = this.x; const r = this.y; const s = this.z; const a = n.val; return this.x = a[0] * o + a[4] * r + a[8] * s + a[12], this.y = a[1] * o + a[5] * r + a[9] * s + a[13], this.z = a[2] * o + a[6] * r + a[10] * s + a[14], this }, transformCoordinates: function (n) { const o = this.x; const r = this.y; const s = this.z; const a = n.val; const f = o * a[0] + r * a[4] + s * a[8] + a[12]; const l = o * a[1] + r * a[5] + s * a[9] + a[13]; const u = o * a[2] + r * a[6] + s * a[10] + a[14]; const v = o * a[3] + r * a[7] + s * a[11] + a[15]; return this.x = f / v, this.y = l / v, this.z = u / v, this }, transformQuat: function (n) { const o = this.x; const r = this.y; const s = this.z; const a = n.x; const f = n.y; const l = n.z; const u = n.w; const v = u * o + f * s - l * r; const p = u * r + l * o - a * s; const c = u * s + a * r - f * o; const m = -a * o - f * r - l * s; return this.x = v * u + m * -a + p * -l - c * -f, this.y = p * u + m * -f + c * -a - v * -l, this.z = c * u + m * -l + v * -f - p * -a, this }, project: function (n) { const o = this.x; const r = this.y; const s = this.z; const a = n.val; const f = a[0]; const l = a[1]; const u = a[2]; const v = a[3]; const p = a[4]; const c = a[5]; const m = a[6]; const g = a[7]; const x = a[8]; const y = a[9]; const T = a[10]; const S = a[11]; const E = a[12]; const C = a[13]; const P = a[14]; const A = a[15]; const M = 1 / (o * v + r * g + s * S + A); return this.x = (o * f + r * p + s * x + E) * M, this.y = (o * l + r * c + s * y + C) * M, this.z = (o * u + r * m + s * T + P) * M, this }, projectViewMatrix: function (n, o) { return this.applyMatrix4(n).applyMatrix4(o) }, unprojectViewMatrix: function (n, o) { return this.applyMatrix4(n).applyMatrix4(o) }, unproject: function (n, o) { const r = n.x; const s = n.y; const a = n.z; const f = n.w; const l = this.x - r; const u = f - this.y - 1 - s; const v = this.z; return this.x = 2 * l / a - 1, this.y = 2 * u / f - 1, this.z = 2 * v - 1, this.project(o) }, reset: function () { return this.x = 0, this.y = 0, this.z = 0, this } }); h.ZERO = new h(), h.RIGHT = new h(1, 0, 0), h.LEFT = new h(-1, 0, 0), h.UP = new h(0, -1, 0), h.DOWN = new h(0, 1, 0), h.FORWARD = new h(0, 0, 1), h.BACK = new h(0, 0, -1), h.ONE = new h(1, 1, 1), e.exports = h }, function (e, d) { e.exports = { CSV: 0, TILED_JSON: 1, ARRAY_2D: 2, WELTMEISTER: 3 } }, function (e, d, t) { const i = {}; e.exports = i; const h = t(64); const n = t(83); const o = t(165); const r = t(32); const s = t(84); const a = t(271); (function () { i._inertiaScale = 4, i._nextCollidingGroupId = 1, i._nextNonCollidingGroupId = -1, i._nextCategory = 1, i.create = function (l) { const u = { id: r.nextId(), type: 'body', label: 'Body', parts: [], plugin: {}, angle: 0, vertices: null, position: { x: 0, y: 0 }, force: { x: 0, y: 0 }, torque: 0, positionImpulse: { x: 0, y: 0 }, previousPositionImpulse: { x: 0, y: 0 }, constraintImpulse: { x: 0, y: 0, angle: 0 }, totalContacts: 0, speed: 0, angularSpeed: 0, velocity: { x: 0, y: 0 }, angularVelocity: 0, isSensor: !1, isStatic: !1, isSleeping: !1, motion: 0, sleepThreshold: 60, density: 0.001, restitution: 0, friction: 0.1, frictionStatic: 0.5, frictionAir: 0.01, collisionFilter: { category: 1, mask: 4294967295, group: 0 }, slop: 0.05, timeScale: 1, events: null, bounds: null, chamfer: null, circleRadius: 0, positionPrev: null, anglePrev: 0, parent: null, axes: null, area: 0, mass: 0, inverseMass: 0, inertia: 0, inverseInertia: 0, _original: null, render: { visible: !0, opacity: 1, sprite: { xOffset: 0, yOffset: 0 }, fillColor: null, fillOpacity: null, lineColor: null, lineOpacity: null, lineThickness: null }, gameObject: null, scale: { x: 1, y: 1 }, centerOfMass: { x: 0, y: 0 }, centerOffset: { x: 0, y: 0 }, gravityScale: { x: 1, y: 1 }, ignoreGravity: !1, ignorePointer: !1, onCollideCallback: null, onCollideEndCallback: null, onCollideActiveCallback: null, onCollideWith: {} }; !l.hasOwnProperty('position') && l.hasOwnProperty('vertices') ? l.position = h.centre(l.vertices) : l.hasOwnProperty('vertices') || (u.vertices = h.fromPath('L 0 0 L 40 0 L 40 40 L 0 40')); const v = r.extend(u, l); return f(v, l), v.setOnCollideWith = function (p, c) { return c ? this.onCollideWith[p.id] = c : delete this.onCollideWith[p.id], this }, v }, i.nextGroup = function (l) { return l ? i._nextNonCollidingGroupId-- : i._nextCollidingGroupId++ }, i.nextCategory = function () { return i._nextCategory = i._nextCategory << 1, i._nextCategory }; var f = function (l, u) { u = u || {}, i.set(l, { bounds: l.bounds || s.create(l.vertices), positionPrev: l.positionPrev || n.clone(l.position), anglePrev: l.anglePrev || l.angle, vertices: l.vertices, parts: l.parts || [l], isStatic: l.isStatic, isSleeping: l.isSleeping, parent: l.parent || l }); const v = l.bounds; if (h.rotate(l.vertices, l.angle, l.position), a.rotate(l.axes, l.angle), s.update(v, l.vertices, l.velocity), i.set(l, { axes: u.axes || l.axes, area: u.area || l.area, mass: u.mass || l.mass, inertia: u.inertia || l.inertia }), l.parts.length === 1) { const p = l.centerOfMass; const c = l.centerOffset; const m = v.max.x - v.min.x; const g = v.max.y - v.min.y; p.x = -(v.min.x - l.position.x) / m, p.y = -(v.min.y - l.position.y) / g, c.x = m * p.x, c.y = g * p.y } }; i.set = function (l, u, v) { let p; typeof u === 'string' && (p = u, u = {}, u[p] = v); for (p in u) if (Object.prototype.hasOwnProperty.call(u, p)) switch (v = u[p], p) { case 'isStatic':i.setStatic(l, v); break; case 'isSleeping':o.set(l, v); break; case 'mass':i.setMass(l, v); break; case 'density':i.setDensity(l, v); break; case 'inertia':i.setInertia(l, v); break; case 'vertices':i.setVertices(l, v); break; case 'position':i.setPosition(l, v); break; case 'angle':i.setAngle(l, v); break; case 'velocity':i.setVelocity(l, v); break; case 'angularVelocity':i.setAngularVelocity(l, v); break; case 'parts':i.setParts(l, v); break; case 'centre':i.setCentre(l, v); break; default:l[p] = v } }, i.setStatic = function (l, u) { for (let v = 0; v < l.parts.length; v++) { const p = l.parts[v]; p.isStatic = u, u ? (p._original = { restitution: p.restitution, friction: p.friction, mass: p.mass, inertia: p.inertia, density: p.density, inverseMass: p.inverseMass, inverseInertia: p.inverseInertia }, p.restitution = 0, p.friction = 1, p.mass = p.inertia = p.density = 1 / 0, p.inverseMass = p.inverseInertia = 0, p.positionPrev.x = p.position.x, p.positionPrev.y = p.position.y, p.anglePrev = p.angle, p.angularVelocity = 0, p.speed = 0, p.angularSpeed = 0, p.motion = 0) : p._original && (p.restitution = p._original.restitution, p.friction = p._original.friction, p.mass = p._original.mass, p.inertia = p._original.inertia, p.density = p._original.density, p.inverseMass = p._original.inverseMass, p.inverseInertia = p._original.inverseInertia, p._original = null) } }, i.setMass = function (l, u) { const v = l.inertia / (l.mass / 6); l.inertia = v * (u / 6), l.inverseInertia = 1 / l.inertia, l.mass = u, l.inverseMass = 1 / l.mass, l.density = l.mass / l.area }, i.setDensity = function (l, u) { i.setMass(l, u * l.area), l.density = u }, i.setInertia = function (l, u) { l.inertia = u, l.inverseInertia = 1 / l.inertia }, i.setVertices = function (l, u) { u[0].body === l ? l.vertices = u : l.vertices = h.create(u, l), l.axes = a.fromVertices(l.vertices), l.area = h.area(l.vertices), i.setMass(l, l.density * l.area); const v = h.centre(l.vertices); h.translate(l.vertices, v, -1), i.setInertia(l, i._inertiaScale * h.inertia(l.vertices, l.mass)), h.translate(l.vertices, l.position), s.update(l.bounds, l.vertices, l.velocity) }, i.setParts = function (l, u, v) { let p; for (u = u.slice(0), l.parts.length = 0, l.parts.push(l), l.parent = l, p = 0; p < u.length; p++) { const c = u[p]; c !== l && (c.parent = l, l.parts.push(c)) } if (l.parts.length !== 1) { if (v = typeof v !== 'undefined' ? v : !0, v) { let m = []; for (p = 0; p < u.length; p++)m = m.concat(u[p].vertices); h.clockwiseSort(m); const g = h.hull(m); const x = h.centre(g); i.setVertices(l, g), h.translate(l.vertices, x) } const y = i._totalProperties(l); const T = y.centre.x; const S = y.centre.y; const E = l.bounds; const C = l.centerOfMass; const P = l.centerOffset; s.update(E, l.vertices, l.velocity), C.x = -(E.min.x - T) / (E.max.x - E.min.x), C.y = -(E.min.y - S) / (E.max.y - E.min.y), P.x = T, P.y = S, l.area = y.area, l.parent = l, l.position.x = T, l.position.y = S, l.positionPrev.x = T, l.positionPrev.y = S, i.setMass(l, y.mass), i.setInertia(l, y.inertia), i.setPosition(l, y.centre) } }, i.setCentre = function (l, u, v) { v ? (l.positionPrev.x += u.x, l.positionPrev.y += u.y, l.position.x += u.x, l.position.y += u.y) : (l.positionPrev.x = u.x - (l.position.x - l.positionPrev.x), l.positionPrev.y = u.y - (l.position.y - l.positionPrev.y), l.position.x = u.x, l.position.y = u.y) }, i.setPosition = function (l, u) { const v = n.sub(u, l.position); l.positionPrev.x += v.x, l.positionPrev.y += v.y; for (let p = 0; p < l.parts.length; p++) { const c = l.parts[p]; c.position.x += v.x, c.position.y += v.y, h.translate(c.vertices, v), s.update(c.bounds, c.vertices, l.velocity) } }, i.setAngle = function (l, u) { const v = u - l.angle; l.anglePrev += v; for (let p = 0; p < l.parts.length; p++) { const c = l.parts[p]; c.angle += v, h.rotate(c.vertices, v, l.position), a.rotate(c.axes, v), s.update(c.bounds, c.vertices, l.velocity), p > 0 && n.rotateAbout(c.position, v, l.position, c.position) } }, i.setVelocity = function (l, u) { l.positionPrev.x = l.position.x - u.x, l.positionPrev.y = l.position.y - u.y, l.velocity.x = u.x, l.velocity.y = u.y, l.speed = n.magnitude(l.velocity) }, i.setAngularVelocity = function (l, u) { l.anglePrev = l.angle - u, l.angularVelocity = u, l.angularSpeed = Math.abs(l.angularVelocity) }, i.translate = function (l, u) { i.setPosition(l, n.add(l.position, u)) }, i.rotate = function (l, u, v) { if (!v)i.setAngle(l, l.angle + u); else { const p = Math.cos(u); const c = Math.sin(u); const m = l.position.x - v.x; const g = l.position.y - v.y; i.setPosition(l, { x: v.x + (m * p - g * c), y: v.y + (m * c + g * p) }), i.setAngle(l, l.angle + u) } }, i.scale = function (l, u, v, p) { let c = 0; let m = 0; p = p || l.position; for (let g = 0; g < l.parts.length; g++) { const x = l.parts[g]; x.scale.x = u, x.scale.y = v, h.scale(x.vertices, u, v, p), x.axes = a.fromVertices(x.vertices), x.area = h.area(x.vertices), i.setMass(x, l.density * x.area), h.translate(x.vertices, { x: -x.position.x, y: -x.position.y }), i.setInertia(x, i._inertiaScale * h.inertia(x.vertices, x.mass)), h.translate(x.vertices, { x: x.position.x, y: x.position.y }), g > 0 && (c += x.area, m += x.inertia), x.position.x = p.x + (x.position.x - p.x) * u, x.position.y = p.y + (x.position.y - p.y) * v, s.update(x.bounds, x.vertices, l.velocity) }l.parts.length > 1 && (l.area = c, l.isStatic || (i.setMass(l, l.density * c), i.setInertia(l, m))), l.circleRadius && (u === v ? l.circleRadius *= u : l.circleRadius = null) }, i.update = function (l, u, v, p) { const c = Math.pow(u * v * l.timeScale, 2); const m = 1 - l.frictionAir * v * l.timeScale; const g = l.position.x - l.positionPrev.x; const x = l.position.y - l.positionPrev.y; l.velocity.x = g * m * p + l.force.x / l.mass * c, l.velocity.y = x * m * p + l.force.y / l.mass * c, l.positionPrev.x = l.position.x, l.positionPrev.y = l.position.y, l.position.x += l.velocity.x, l.position.y += l.velocity.y, l.angularVelocity = (l.angle - l.anglePrev) * m * p + l.torque / l.inertia * c, l.anglePrev = l.angle, l.angle += l.angularVelocity, l.speed = n.magnitude(l.velocity), l.angularSpeed = Math.abs(l.angularVelocity); for (let y = 0; y < l.parts.length; y++) { const T = l.parts[y]; h.translate(T.vertices, l.velocity), y > 0 && (T.position.x += l.velocity.x, T.position.y += l.velocity.y), l.angularVelocity !== 0 && (h.rotate(T.vertices, l.angularVelocity, l.position), a.rotate(T.axes, l.angularVelocity), y > 0 && n.rotateAbout(T.position, l.angularVelocity, l.position, T.position)), s.update(T.bounds, T.vertices, l.velocity) } }, i.applyForce = function (l, u, v) { l.force.x += v.x, l.force.y += v.y; const p = { x: u.x - l.position.x, y: u.y - l.position.y }; l.torque += p.x * v.y - p.y * v.x }, i._totalProperties = function (l) { for (var u = { mass: 0, area: 0, inertia: 0, centre: { x: 0, y: 0 } }, v = l.parts.length === 1 ? 0 : 1; v < l.parts.length; v++) { const p = l.parts[v]; const c = p.mass !== 1 / 0 ? p.mass : 1; u.mass += c, u.area += p.area, u.inertia += p.inertia, u.centre = n.add(u.centre, n.mult(p.position, c)) } return u.centre = n.div(u.centre, u.mass), u } })() }, function (e, d) { const t = function (i) { return i.y + i.height - i.height * i.originY }; e.exports = t }, function (e, d) { const t = function (i) { return i.x - i.width * i.originX }; e.exports = t }, function (e, d) { const t = function (i) { return i.x + i.width - i.width * i.originX }; e.exports = t }, function (e, d) { const t = function (i) { return i.y - i.height * i.originY }; e.exports = t }, function (e, d) { const t = function (i, h, n, o, r, s) { o === void 0 && (o = 0), r === void 0 && (r = 0), s === void 0 && (s = 1); let a; let f = 0; const l = i.length; if (s === 1) for (a = r; a < l; a++)i[a][h] += n + f * o, f++; else for (a = r; a >= 0; a--)i[a][h] += n + f * o, f++; return i }; e.exports = t }, function (e, d, t) { const i = t(0); const h = t(307); const n = t(172); const o = t(56); const r = t(173); const s = t(3); const a = new i({ initialize: function (l, u, v, p) { l === void 0 && (l = 0), u === void 0 && (u = 0), v === void 0 && (v = 0), p === void 0 && (p = 0), this.type = o.LINE, this.x1 = l, this.y1 = u, this.x2 = v, this.y2 = p }, getPoint: function (f, l) { return h(this, f, l) }, getPoints: function (f, l, u) { return n(this, f, l, u) }, getRandomPoint: function (f) { return r(this, f) }, setTo: function (f, l, u, v) { return f === void 0 && (f = 0), l === void 0 && (l = 0), u === void 0 && (u = 0), v === void 0 && (v = 0), this.x1 = f, this.y1 = l, this.x2 = u, this.y2 = v, this }, getPointA: function (f) { return f === void 0 && (f = new s()), f.set(this.x1, this.y1), f }, getPointB: function (f) { return f === void 0 && (f = new s()), f.set(this.x2, this.y2), f }, left: { get: function () { return Math.min(this.x1, this.x2) }, set: function (f) { this.x1 <= this.x2 ? this.x1 = f : this.x2 = f } }, right: { get: function () { return Math.max(this.x1, this.x2) }, set: function (f) { this.x1 > this.x2 ? this.x1 = f : this.x2 = f } }, top: { get: function () { return Math.min(this.y1, this.y2) }, set: function (f) { this.y1 <= this.y2 ? this.y1 = f : this.y2 = f } }, bottom: { get: function () { return Math.max(this.y1, this.y2) }, set: function (f) { this.y1 > this.y2 ? this.y1 = f : this.y2 = f } } }); e.exports = a }, function (e, d) { const t = function (i, h, n, o) { const r = n || h.fillColor; const s = o || h.fillAlpha; const a = (r & 16711680) >>> 16; const f = (r & 65280) >>> 8; const l = r & 255; i.fillStyle = 'rgba(' + a + ',' + f + ',' + l + ',' + s + ')' }; e.exports = t }, function (e, d, t) { const i = t(0); const h = new i({ initialize: function (o, r, s, a) { const f = []; a.forEach(function (u) { u && f.push(u) }), this.loader = o, this.type = r, this.key = s, this.multiKeyIndex = o.multiKeyIndex++, this.files = f, this.complete = !1, this.pending = f.length, this.failed = 0, this.config = {}, this.baseURL = o.baseURL, this.path = o.path, this.prefix = o.prefix; for (let l = 0; l < f.length; l++)f[l].multiFile = this }, isReadyToProcess: function () { return this.pending === 0 && this.failed === 0 && !this.complete }, addToMultiFile: function (n) { return this.files.push(n), n.multiFile = this, this.pending++, this.complete = !1, this }, onFileComplete: function (n) { const o = this.files.indexOf(n); o !== -1 && this.pending-- }, onFileFailed: function (n) { const o = this.files.indexOf(n); o !== -1 && this.failed++ } }); e.exports = h }, function (e, d) { const t = function (i, h, n, o) { const r = i - n; const s = h - o; return Math.sqrt(r * r + s * s) }; e.exports = t }, function (e, d, t) { e.exports = { BOOT: t(922), DESTROY: t(923), DRAG_END: t(924), DRAG_ENTER: t(925), DRAG: t(926), DRAG_LEAVE: t(927), DRAG_OVER: t(928), DRAG_START: t(929), DROP: t(930), GAME_OUT: t(931), GAME_OVER: t(932), GAMEOBJECT_DOWN: t(933), GAMEOBJECT_DRAG_END: t(934), GAMEOBJECT_DRAG_ENTER: t(935), GAMEOBJECT_DRAG: t(936), GAMEOBJECT_DRAG_LEAVE: t(937), GAMEOBJECT_DRAG_OVER: t(938), GAMEOBJECT_DRAG_START: t(939), GAMEOBJECT_DROP: t(940), GAMEOBJECT_MOVE: t(941), GAMEOBJECT_OUT: t(942), GAMEOBJECT_OVER: t(943), GAMEOBJECT_POINTER_DOWN: t(944), GAMEOBJECT_POINTER_MOVE: t(945), GAMEOBJECT_POINTER_OUT: t(946), GAMEOBJECT_POINTER_OVER: t(947), GAMEOBJECT_POINTER_UP: t(948), GAMEOBJECT_POINTER_WHEEL: t(949), GAMEOBJECT_UP: t(950), GAMEOBJECT_WHEEL: t(951), MANAGER_BOOT: t(952), MANAGER_PROCESS: t(953), MANAGER_UPDATE: t(954), POINTER_DOWN: t(955), POINTER_DOWN_OUTSIDE: t(956), POINTER_MOVE: t(957), POINTER_OUT: t(958), POINTER_OVER: t(959), POINTER_UP: t(960), POINTER_UP_OUTSIDE: t(961), POINTER_WHEEL: t(962), POINTERLOCK_CHANGE: t(963), PRE_UPDATE: t(964), SHUTDOWN: t(965), START: t(966), UPDATE: t(967) } }, function (e, d) { const t = function (i, h) { return i.y = h + i.height * i.originY, i }; e.exports = t }, function (e, d) { const t = function (i, h) { return i.x = h + i.width * i.originX, i }; e.exports = t }, function (e, d) { const t = function (i, h) { return i.x = h - i.width + i.width * i.originX, i }; e.exports = t }, function (e, d) { const t = function (i, h) { return i.y = h - i.height + i.height * i.originY, i }; e.exports = t }, function (e, d) { const t = { CIRCLE: 0, ELLIPSE: 1, LINE: 2, POINT: 3, POLYGON: 4, RECTANGLE: 5, TRIANGLE: 6 }; e.exports = t }, function (e, d) { const t = function (i, h, n) { return i.width <= 0 || i.height <= 0 ? !1 : i.x <= h && i.x + i.width >= h && i.y <= n && i.y + i.height >= n }; e.exports = t }, function (e, d, t) { const i = t(0); const h = t(175); const n = t(9); const o = t(374); const r = t(2); const s = t(69); const a = t(91); const f = t(141); const l = t(12); const u = t(375); const v = new i({ Extends: n, initialize: function (c) { n.call(this); const m = c.game; const g = m.renderer; const x = g.gl; this.name = r(c, 'name', 'WebGLPipeline'), this.game = m, this.renderer = g, this.manager, this.gl = x, this.view = m.canvas, this.width = 0, this.height = 0, this.vertexCount = 0, this.vertexCapacity = 0, this.vertexData, this.vertexBuffer, this.topology = r(c, 'topology', x.TRIANGLES), this.bytes, this.vertexViewF32, this.vertexViewU32, this.active = !0, this.currentUnit = 0, this.forceZero = r(c, 'forceZero', !1), this.hasBooted = !1, this.isPostFX = !1, this.renderTargets = [], this.currentRenderTarget, this.shaders = [], this.currentShader, this.projectionMatrix, this.projectionWidth = 0, this.projectionHeight = 0, this.config = c, this.glReset = !1 }, boot: function () { let p; const c = this.gl; const m = this.config; const g = this.renderer; this.isPostFX || (this.projectionMatrix = new s().identity()); const x = this.renderTargets; let y = r(m, 'renderTarget', !1); typeof y === 'boolean' && y && (y = 1); const T = g.width; const S = g.height; if (typeof y === 'number') for (p = 0; p < y; p++)x.push(new f(g, T, S, 1, 0, !0)); else if (Array.isArray(y)) for (p = 0; p < y.length; p++) { const E = r(y[p], 'scale', 1); const C = r(y[p], 'minFilter', 0); const P = r(y[p], 'autoClear', 1); x.push(new f(g, T, S, E, C, P)) }x.length && (this.currentRenderTarget = x[0]), this.setShadersFromConfig(m); const A = this.shaders; let M = 0; for (p = 0; p < A.length; p++)A[p].vertexSize > M && (M = A[p].vertexSize); const L = r(m, 'batchSize', g.config.batchSize); this.vertexCapacity = L * 6; const F = new ArrayBuffer(this.vertexCapacity * M); this.vertexData = F, this.bytes = new Uint8Array(F), this.vertexViewF32 = new Float32Array(F), this.vertexViewU32 = new Uint32Array(F); const I = r(m, 'vertices', null); for (I ? (this.vertexViewF32.set(I), this.vertexBuffer = g.createVertexBuffer(F, c.STATIC_DRAW)) : this.vertexBuffer = g.createVertexBuffer(F.byteLength, c.DYNAMIC_DRAW), this.setVertexBuffer(), p = A.length - 1; p >= 0; p--)A[p].rebind(); this.hasBooted = !0, g.on(a.RESIZE, this.resize, this), g.on(a.PRE_RENDER, this.onPreRender, this), g.on(a.RENDER, this.onRender, this), g.on(a.POST_RENDER, this.onPostRender, this), this.emit(o.BOOT, this), this.onBoot() }, onBoot: function () {}, onResize: function () {}, setShader: function (p, c) { const m = this.renderer; if (p !== this.currentShader || m.currentProgram !== this.currentShader.program) { this.flush(), m.resetTextures(); const g = this.setVertexBuffer(); g && !c && (c = !0), p.bind(c, !1), this.currentShader = p } return this }, getShaderByName: function (p) { for (let c = this.shaders, m = 0; m < c.length; m++) if (c[m].name === p) return c[m] }, setShadersFromConfig: function (p) { let c; const m = this.shaders; const g = this.renderer; for (c = 0; c < m.length; c++)m[c].destroy(); const x = 'vertShader'; const y = 'fragShader'; const T = 'attributes'; const S = r(p, x, null); const E = l.parseFragmentShaderMaxTextures(r(p, y, null), g.maxTextures); const C = r(p, T, null); const P = r(p, 'shaders', []); const A = P.length; if (A === 0)S && E && (this.shaders = [new u(this, 'default', S, E, h(C))]); else { const M = []; for (c = 0; c < A; c++) { const L = P[c]; const F = r(L, 'name', 'default'); const I = r(L, x, S); const G = l.parseFragmentShaderMaxTextures(r(L, y, E), g.maxTextures); const U = r(L, T, C); I && G && M.push(new u(this, F, I, G, h(U))) } this.shaders = M } return this.shaders.length === 0 ? console.warn('Pipeline: ' + this.name + ' - Invalid shader config') : this.currentShader = this.shaders[0], this }, setGameObject: function (p, c) { return c === void 0 && (c = p.frame), this.currentUnit = this.renderer.setTextureSource(c.source), this.currentUnit }, shouldFlush: function (p) { return p === void 0 && (p = 0), this.vertexCount + p > this.vertexCapacity }, resize: function (p, c) { (p !== this.width || c !== this.height) && this.flush(), this.width = p, this.height = c; for (let m = this.renderTargets, g = 0; g < m.length; g++)m[g].resize(p, c); return this.setProjectionMatrix(p, c), this.emit(o.RESIZE, p, c, this), this.onResize(p, c), this }, setProjectionMatrix: function (p, c) { const m = this.projectionMatrix; if (!m) return this; this.projectionWidth = p, this.projectionHeight = c, m.ortho(0, p, c, 0, -1e3, 1e3); for (let g = this.shaders, x = 'uProjectionMatrix', y = 0; y < g.length; y++) { const T = g[y]; T.hasUniform(x) && (T.resetUniform(x), T.setMatrix4fv(x, !1, m.val, T)) } return this }, updateProjectionMatrix: function () { if (this.projectionMatrix) { const p = this.renderer.projectionWidth; const c = this.renderer.projectionHeight; (this.projectionWidth !== p || this.projectionHeight !== c) && this.setProjectionMatrix(p, c) } }, bind: function (p) { if (p === void 0 && (p = this.currentShader), this.glReset) return this.rebind(p); const c = this.setVertexBuffer(); return p.bind(c), this.currentShader = p, this.emit(o.BIND, this, p), this.onActive(p), this }, rebind: function (p) { this.setVertexBuffer(); for (let c = this.shaders, m = c.length - 1; m >= 0; m--) { const g = c[m].rebind(); (!p || g === p) && (this.currentShader = g) } return this.emit(o.REBIND, this.currentShader), this.onActive(this.currentShader), this.onRebind(), this.glReset = !1, this }, setVertexBuffer: function () { const p = this.gl; const c = this.vertexBuffer; return p.getParameter(p.ARRAY_BUFFER_BINDING) !== c ? (p.bindBuffer(p.ARRAY_BUFFER, c), !0) : !1 }, preBatch: function (p) { return this.currentRenderTarget && this.currentRenderTarget.bind(), this.onPreBatch(p), this }, postBatch: function (p) { return this.onDraw(this.currentRenderTarget), this.onPostBatch(p), this }, onDraw: function () {}, unbind: function () { this.currentRenderTarget && this.currentRenderTarget.unbind() }, flush: function (p) { if (p === void 0 && (p = !1), this.vertexCount > 0) { this.emit(o.BEFORE_FLUSH, this, p), this.onBeforeFlush(p); const c = this.gl; const m = this.vertexCount; const g = this.currentShader.vertexSize; this.active && (this.setVertexBuffer(), m === this.vertexCapacity ? c.bufferData(c.ARRAY_BUFFER, this.vertexData, c.DYNAMIC_DRAW) : c.bufferSubData(c.ARRAY_BUFFER, 0, this.bytes.subarray(0, m * g)), c.drawArrays(this.topology, 0, m)), this.vertexCount = 0, this.emit(o.AFTER_FLUSH, this, p), this.onAfterFlush(p) } return this }, onActive: function () {}, onBind: function () {}, onRebind: function () {}, onBatch: function () {}, onPreBatch: function () {}, onPostBatch: function () {}, onPreRender: function () {}, onRender: function () {}, onPostRender: function () {}, onBeforeFlush: function () {}, onAfterFlush: function () {}, batchVert: function (p, c, m, g, x, y, T) { const S = this.vertexViewF32; const E = this.vertexViewU32; let C = this.vertexCount * this.currentShader.vertexComponentCount - 1; S[++C] = p, S[++C] = c, S[++C] = m, S[++C] = g, S[++C] = x, S[++C] = y, E[++C] = T, this.vertexCount++ }, batchQuad: function (p, c, m, g, x, y, T, S, E, C, P, A, M, L, F, I, G, U, Y, X) { X === void 0 && (X = this.currentUnit); let O = !1; return this.shouldFlush(6) && (this.flush(), O = !0, X = this.setTexture2D(Y)), this.batchVert(c, m, C, P, X, U, L), this.batchVert(g, x, C, M, X, U, I), this.batchVert(y, T, A, M, X, U, G), this.batchVert(c, m, C, P, X, U, L), this.batchVert(y, T, A, M, X, U, G), this.batchVert(S, E, A, P, X, U, F), this.onBatch(p), O }, batchTri: function (p, c, m, g, x, y, T, S, E, C, P, A, M, L, F, I, G) { G === void 0 && (G = this.currentUnit); let U = !1; return this.shouldFlush(3) && (this.flush(), U = !0, G = this.setTexture2D(I)), this.batchVert(c, m, S, E, G, F, A), this.batchVert(g, x, S, P, G, F, M), this.batchVert(y, T, C, P, G, F, L), this.onBatch(p), U }, drawFillRect: function (p, c, m, g, x, y, T, S) { T === void 0 && (T = this.renderer.whiteTexture.glTexture), S === void 0 && (S = !0), p = Math.floor(p), c = Math.floor(c); const E = Math.floor(p + m); const C = Math.floor(c + g); const P = this.setTexture2D(T); const A = l.getTintAppendFloatAlphaAndSwap(x, y); const M = 0; let L = 0; const F = 1; let I = 1; S && (L = 1, I = 0), this.batchQuad(null, p, c, p, C, E, C, E, c, M, L, F, I, A, A, A, A, 0, T, P) }, setTexture2D: function (p) { return p === void 0 && (p = this.renderer.whiteTexture.glTexture), this.currentUnit = this.renderer.setTexture2D(p), this.currentUnit }, bindTexture: function (p, c) { c === void 0 && (c = 0); const m = this.gl; return m.activeTexture(m.TEXTURE0 + c), m.bindTexture(m.TEXTURE_2D, p), this }, bindRenderTarget: function (p, c) { return this.bindTexture(p.texture, c) }, setTime: function (p) { return this.set1f(p, this.game.loop.getDuration()), this }, set1f: function (p, c, m) { return m === void 0 && (m = this.currentShader), m.set1f(p, c), this }, set2f: function (p, c, m, g) { return g === void 0 && (g = this.currentShader), g.set2f(p, c, m), this }, set3f: function (p, c, m, g, x) { return x === void 0 && (x = this.currentShader), x.set3f(p, c, m, g), this }, set4f: function (p, c, m, g, x, y) { return y === void 0 && (y = this.currentShader), y.set4f(p, c, m, g, x), this }, set1fv: function (p, c, m) { return m === void 0 && (m = this.currentShader), m.set1fv(p, c), this }, set2fv: function (p, c, m) { return m === void 0 && (m = this.currentShader), m.set2fv(p, c), this }, set3fv: function (p, c, m) { return m === void 0 && (m = this.currentShader), m.set3fv(p, c), this }, set4fv: function (p, c, m) { return m === void 0 && (m = this.currentShader), m.set4fv(p, c), this }, set1iv: function (p, c, m) { return m === void 0 && (m = this.currentShader), m.set1iv(p, c), this }, set2iv: function (p, c, m) { return m === void 0 && (m = this.currentShader), m.set2iv(p, c), this }, set3iv: function (p, c, m) { return m === void 0 && (m = this.currentShader), m.set3iv(p, c), this }, set4iv: function (p, c, m) { return m === void 0 && (m = this.currentShader), m.set4iv(p, c), this }, set1i: function (p, c, m) { return m === void 0 && (m = this.currentShader), m.set1i(p, c), this }, set2i: function (p, c, m, g) { return g === void 0 && (g = this.currentShader), g.set2i(p, c, m), this }, set3i: function (p, c, m, g, x) { return x === void 0 && (x = this.currentShader), x.set3i(p, c, m, g), this }, set4i: function (p, c, m, g, x, y) { return y === void 0 && (y = this.currentShader), y.set4i(p, c, m, g, x), this }, setMatrix2fv: function (p, c, m, g) { return g === void 0 && (g = this.currentShader), g.setMatrix2fv(p, c, m), this }, setMatrix3fv: function (p, c, m, g) { return g === void 0 && (g = this.currentShader), g.setMatrix3fv(p, c, m), this }, setMatrix4fv: function (p, c, m, g) { return g === void 0 && (g = this.currentShader), g.setMatrix4fv(p, c, m), this }, destroy: function () { this.emit(o.DESTROY, this); let p; const c = this.shaders; for (p = 0; p < c.length; p++)c[p].destroy(); const m = this.renderTargets; for (p = 0; p < m.length; p++)m[p].destroy(); this.gl.deleteBuffer(this.vertexBuffer); const g = this.renderer; return g.off(a.RESIZE, this.resize, this), g.off(a.PRE_RENDER, this.onPreRender, this), g.off(a.RENDER, this.onRender, this), g.off(a.POST_RENDER, this.onPostRender, this), this.removeAllListeners(), this.game = null, this.renderer = null, this.manager = null, this.gl = null, this.view = null, this.shaders = null, this.renderTargets = null, this.bytes = null, this.vertexViewF32 = null, this.vertexViewU32 = null, this.vertexData = null, this.vertexBuffer = null, this.currentShader = null, this.currentRenderTarget = null, this } }); e.exports = v }, function (e, d, t) { 'use strict'; function i (R, D, B) { B = B || 2; const N = D && D.length; const w = N ? D[0] * B : R.length; let z = h(R, 0, w, B, !0); const V = []; if (!z || z.next === z.prev) return V; let W, H, K, Q, J, q, j; if (N && (z = l(R, D, z, B)), R.length > 80 * B) { W = K = R[0], H = Q = R[1]; for (let _ = B; _ < w; _ += B)J = R[_], q = R[_ + 1], J < W && (W = J), q < H && (H = q), J > K && (K = J), q > Q && (Q = q); j = Math.max(K - W, Q - H), j = j !== 0 ? 1 / j : 0 } return o(z, V, B, W, H, j), V } function h (R, D, B, N, w) { let z, V; if (w === O(R, D, B, N) > 0) for (z = D; z < B; z += N)V = U(z, R[z], R[z + 1], V); else for (z = B - N; z >= D; z -= N)V = U(z, R[z], R[z + 1], V); return V && C(V, V.next) && (Y(V), V = V.next), V } function n (R, D) { if (!R) return R; D || (D = R); let B = R; let N; do if (N = !1, !B.steiner && (C(B, B.next) || E(B.prev, B, B.next) === 0)) { if (Y(B), B = D = B.prev, B === B.next) break; N = !0 } else B = B.next; while (N || B !== D); return D } function o (R, D, B, N, w, z, V) { if (R) { !V && z && m(R, N, w, z); for (var W = R, H, K; R.prev !== R.next;) { if (H = R.prev, K = R.next, z ? s(R, N, w, z) : r(R)) { D.push(H.i / B), D.push(R.i / B), D.push(K.i / B), Y(R), R = K.next, W = K.next; continue } if (R = K, R === W) { V ? V === 1 ? (R = a(n(R), D, B), o(R, D, B, N, w, z, 2)) : V === 2 && f(R, D, B, N, w, z) : o(n(R), D, B, N, w, z, 1); break } } } } function r (R) { const D = R.prev; const B = R; const N = R.next; if (E(D, B, N) >= 0) return !1; for (let w = R.next.next; w !== R.prev;) { if (T(D.x, D.y, B.x, B.y, N.x, N.y, w.x, w.y) && E(w.prev, w, w.next) >= 0) return !1; w = w.next } return !0 } function s (R, D, B, N) { const w = R.prev; const z = R; const V = R.next; if (E(w, z, V) >= 0) return !1; for (var W = w.x < z.x ? w.x < V.x ? w.x : V.x : z.x < V.x ? z.x : V.x, H = w.y < z.y ? w.y < V.y ? w.y : V.y : z.y < V.y ? z.y : V.y, K = w.x > z.x ? w.x > V.x ? w.x : V.x : z.x > V.x ? z.x : V.x, Q = w.y > z.y ? w.y > V.y ? w.y : V.y : z.y > V.y ? z.y : V.y, J = x(W, H, D, B, N), q = x(K, Q, D, B, N), j = R.prevZ, _ = R.nextZ; j && j.z >= J && _ && _.z <= q;) { if (j !== R.prev && j !== R.next && T(w.x, w.y, z.x, z.y, V.x, V.y, j.x, j.y) && E(j.prev, j, j.next) >= 0 || (j = j.prevZ, _ !== R.prev && _ !== R.next && T(w.x, w.y, z.x, z.y, V.x, V.y, _.x, _.y) && E(_.prev, _, _.next) >= 0)) return !1; _ = _.nextZ } for (;j && j.z >= J;) { if (j !== R.prev && j !== R.next && T(w.x, w.y, z.x, z.y, V.x, V.y, j.x, j.y) && E(j.prev, j, j.next) >= 0) return !1; j = j.prevZ } for (;_ && _.z <= q;) { if (_ !== R.prev && _ !== R.next && T(w.x, w.y, z.x, z.y, V.x, V.y, _.x, _.y) && E(_.prev, _, _.next) >= 0) return !1; _ = _.nextZ } return !0 } function a (R, D, B) { let N = R; do { const w = N.prev; const z = N.next.next; !C(w, z) && P(w, N, N.next, z) && F(w, z) && F(z, w) && (D.push(w.i / B), D.push(N.i / B), D.push(z.i / B), Y(N), Y(N.next), N = R = z), N = N.next } while (N !== R); return n(N) } function f (R, D, B, N, w, z) { let V = R; do { for (let W = V.next.next; W !== V.prev;) { if (V.i !== W.i && S(V, W)) { let H = G(V, W); V = n(V, V.next), H = n(H, H.next), o(V, D, B, N, w, z), o(H, D, B, N, w, z); return }W = W.next }V = V.next } while (V !== R) } function l (R, D, B, N) { const w = []; let z; let V; let W; let H; let K; for (z = 0, V = D.length; z < V; z++)W = D[z] * N, H = z < V - 1 ? D[z + 1] * N : R.length, K = h(R, W, H, N, !1), K === K.next && (K.steiner = !0), w.push(y(K)); for (w.sort(u), z = 0; z < w.length; z++)v(w[z], B), B = n(B, B.next); return B } function u (R, D) { return R.x - D.x } function v (R, D) { if (D = p(R, D), D) { const B = G(D, R); n(D, D.next), n(B, B.next) } } function p (R, D) { let B = D; const N = R.x; const w = R.y; let z = -1 / 0; let V; do { if (w <= B.y && w >= B.next.y && B.next.y !== B.y) { const W = B.x + (w - B.y) * (B.next.x - B.x) / (B.next.y - B.y); if (W <= N && W > z) { if (z = W, W === N) { if (w === B.y) return B; if (w === B.next.y) return B.next }V = B.x < B.next.x ? B : B.next } }B = B.next } while (B !== D); if (!V) return null; if (N === z) return V; const H = V; const K = V.x; const Q = V.y; let J = 1 / 0; let q; B = V; do N >= B.x && B.x >= K && N !== B.x && T(w < Q ? N : z, w, K, Q, w < Q ? z : N, w, B.x, B.y) && (q = Math.abs(w - B.y) / (N - B.x), F(B, R) && (q < J || q === J && (B.x > V.x || B.x === V.x && c(V, B))) && (V = B, J = q)), B = B.next; while (B !== H); return V } function c (R, D) { return E(R.prev, R, D.prev) < 0 && E(D.next, R, R.next) < 0 } function m (R, D, B, N) { let w = R; do w.z === null && (w.z = x(w.x, w.y, D, B, N)), w.prevZ = w.prev, w.nextZ = w.next, w = w.next; while (w !== R); w.prevZ.nextZ = null, w.prevZ = null, g(w) } function g (R) { let D; let B; let N; let w; let z; let V; let W; let H; let K = 1; do { for (B = R, R = null, z = null, V = 0; B;) { for (V++, N = B, W = 0, D = 0; D < K && (W++, N = N.nextZ, !!N); D++);for (H = K; W > 0 || H > 0 && N;)W !== 0 && (H === 0 || !N || B.z <= N.z) ? (w = B, B = B.nextZ, W--) : (w = N, N = N.nextZ, H--), z ? z.nextZ = w : R = w, w.prevZ = z, z = w; B = N }z.nextZ = null, K *= 2 } while (V > 1); return R } function x (R, D, B, N, w) { return R = 32767 * (R - B) * w, D = 32767 * (D - N) * w, R = (R | R << 8) & 16711935, R = (R | R << 4) & 252645135, R = (R | R << 2) & 858993459, R = (R | R << 1) & 1431655765, D = (D | D << 8) & 16711935, D = (D | D << 4) & 252645135, D = (D | D << 2) & 858993459, D = (D | D << 1) & 1431655765, R | D << 1 } function y (R) { let D = R; let B = R; do (D.x < B.x || D.x === B.x && D.y < B.y) && (B = D), D = D.next; while (D !== R); return B } function T (R, D, B, N, w, z, V, W) { return (w - V) * (D - W) - (R - V) * (z - W) >= 0 && (R - V) * (N - W) - (B - V) * (D - W) >= 0 && (B - V) * (z - W) - (w - V) * (N - W) >= 0 } function S (R, D) { return R.next.i !== D.i && R.prev.i !== D.i && !L(R, D) && (F(R, D) && F(D, R) && I(R, D) && (E(R.prev, R, D.prev) || E(R, D.prev, D)) || C(R, D) && E(R.prev, R, R.next) > 0 && E(D.prev, D, D.next) > 0) } function E (R, D, B) { return (D.y - R.y) * (B.x - D.x) - (D.x - R.x) * (B.y - D.y) } function C (R, D) { return R.x === D.x && R.y === D.y } function P (R, D, B, N) { const w = M(E(R, D, B)); const z = M(E(R, D, N)); const V = M(E(B, N, R)); const W = M(E(B, N, D)); return !!(w !== z && V !== W || w === 0 && A(R, B, D) || z === 0 && A(R, N, D) || V === 0 && A(B, R, N) || W === 0 && A(B, D, N)) } function A (R, D, B) { return D.x <= Math.max(R.x, B.x) && D.x >= Math.min(R.x, B.x) && D.y <= Math.max(R.y, B.y) && D.y >= Math.min(R.y, B.y) } function M (R) { return R > 0 ? 1 : R < 0 ? -1 : 0 } function L (R, D) { let B = R; do { if (B.i !== R.i && B.next.i !== R.i && B.i !== D.i && B.next.i !== D.i && P(B, B.next, R, D)) return !0; B = B.next } while (B !== R); return !1 } function F (R, D) { return E(R.prev, R, R.next) < 0 ? E(R, D, R.next) >= 0 && E(R, R.prev, D) >= 0 : E(R, D, R.prev) < 0 || E(R, R.next, D) < 0 } function I (R, D) { let B = R; let N = !1; const w = (R.x + D.x) / 2; const z = (R.y + D.y) / 2; do B.y > z != B.next.y > z && B.next.y !== B.y && w < (B.next.x - B.x) * (z - B.y) / (B.next.y - B.y) + B.x && (N = !N), B = B.next; while (B !== R); return N } function G (R, D) { const B = new X(R.i, R.x, R.y); const N = new X(D.i, D.x, D.y); const w = R.next; const z = D.prev; return R.next = D, D.prev = R, B.next = w, w.prev = B, N.next = B, B.prev = N, z.next = N, N.prev = z, N } function U (R, D, B, N) { const w = new X(R, D, B); return N ? (w.next = N.next, w.prev = N, N.next.prev = w, N.next = w) : (w.prev = w, w.next = w), w } function Y (R) { R.next.prev = R.prev, R.prev.next = R.next, R.prevZ && (R.prevZ.nextZ = R.nextZ), R.nextZ && (R.nextZ.prevZ = R.prevZ) } function X (R, D, B) { this.i = R, this.x = D, this.y = B, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1 }i.deviation = function (R, D, B, N) { const w = D && D.length; const z = w ? D[0] * B : R.length; let V = Math.abs(O(R, 0, z, B)); if (w) for (var W = 0, H = D.length; W < H; W++) { const K = D[W] * B; const Q = W < H - 1 ? D[W + 1] * B : R.length; V -= Math.abs(O(R, K, Q, B)) } let J = 0; for (W = 0; W < N.length; W += 3) { const q = N[W] * B; const j = N[W + 1] * B; const _ = N[W + 2] * B; J += Math.abs((R[q] - R[_]) * (R[j + 1] - R[q + 1]) - (R[q] - R[j]) * (R[_ + 1] - R[q + 1])) } return V === 0 && J === 0 ? 0 : Math.abs((J - V) / V) }; function O (R, D, B, N) { for (var w = 0, z = D, V = B - N; z < B; z += N)w += (R[V] - R[z]) * (R[z + 1] + R[V + 1]), V = z; return w }i.flatten = function (R) { for (var D = R[0][0].length, B = { vertices: [], holes: [], dimensions: D }, N = 0, w = 0; w < R.length; w++) { for (let z = 0; z < R[w].length; z++) for (let V = 0; V < D; V++)B.vertices.push(R[w][z][V]); w > 0 && (N += R[w - 1].length, B.holes.push(N)) } return B }, e.exports = i }, function (e, d) { const t = function (i, h, n, o) { const r = n || h.strokeColor; const s = o || h.strokeAlpha; const a = (r & 16711680) >>> 16; const f = (r & 65280) >>> 8; const l = r & 255; i.strokeStyle = 'rgba(' + a + ',' + f + ',' + l + ',' + s + ')', i.lineWidth = h.lineWidth }; e.exports = t }, function (e, d, t) { const i = t(0); const h = t(21); const n = t(23); const o = t(8); const r = t(2); const s = t(6); const a = t(7); const f = new i({ Extends: n, initialize: function (u, v, p, c, m) { let g = 'json'; if (a(v)) { const x = v; v = r(x, 'key'), p = r(x, 'url'), c = r(x, 'xhrSettings'), g = r(x, 'extension', g), m = r(x, 'dataKey', m) } const y = { type: 'json', cache: u.cacheManager.json, extension: g, responseType: 'text', key: v, url: p, xhrSettings: c, config: m }; n.call(this, u, y), a(p) && (m ? this.data = s(p, m) : this.data = p, this.state = h.FILE_POPULATED) }, onProcess: function () { if (this.state !== h.FILE_POPULATED) { this.state = h.FILE_PROCESSING; try { var l = JSON.parse(this.xhrLoader.responseText) } catch (v) { throw console.warn('Invalid JSON: ' + this.key), this.onProcessError(), v } const u = this.config; typeof u === 'string' ? this.data = s(l, u, l) : this.data = l } this.onProcessComplete() } }); o.register('json', function (l, u, v, p) { if (Array.isArray(l)) for (let c = 0; c < l.length; c++) this.addFile(new f(this, l[c])); else this.addFile(new f(this, l, u, p, v)); return this }), e.exports = f }, function (e, d) { const t = { DYNAMIC_BODY: 0, STATIC_BODY: 1, GROUP: 2, TILEMAPLAYER: 3, FACING_NONE: 10, FACING_UP: 11, FACING_DOWN: 12, FACING_LEFT: 13, FACING_RIGHT: 14 }; e.exports = t }, function (e, d, t) { const i = t(158); const h = t(26); const n = function (o, r, s, a, f) { for (let l = null, u = null, v = null, p = null, c = h(o, r, s, a, null, f), m = 0; m < c.length; m++) { const g = c[m]; g && (g.collides ? (l = i(g.x, g.y - 1, !0, f), u = i(g.x, g.y + 1, !0, f), v = i(g.x - 1, g.y, !0, f), p = i(g.x + 1, g.y, !0, f), g.faceTop = !(l && l.collides), g.faceBottom = !(u && u.collides), g.faceLeft = !(v && v.collides), g.faceRight = !(p && p.collides)) : g.resetFaces()) } }; e.exports = n }, function (e, d, t) { const i = {}; e.exports = i; const h = t(83); const n = t(32); (function () { i.create = function (o, r) { for (var s = [], a = 0; a < o.length; a++) { const f = o[a]; const l = { x: f.x, y: f.y, index: a, body: r, isInternal: !1, contact: null, offset: null }; l.contact = { vertex: l, normalImpulse: 0, tangentImpulse: 0 }, s.push(l) } return s }, i.fromPath = function (o, r) { const s = /L?\s*([-\d.e]+)[\s,]*([-\d.e]+)*/ig; const a = []; return o.replace(s, function (f, l, u) { a.push({ x: parseFloat(l), y: parseFloat(u) }) }), i.create(a, r) }, i.centre = function (o) { for (var r = i.area(o, !0), s = { x: 0, y: 0 }, a, f, l, u = 0; u < o.length; u++)l = (u + 1) % o.length, a = h.cross(o[u], o[l]), f = h.mult(h.add(o[u], o[l]), a), s = h.add(s, f); return h.div(s, 6 * r) }, i.mean = function (o) { for (var r = { x: 0, y: 0 }, s = 0; s < o.length; s++)r.x += o[s].x, r.y += o[s].y; return h.div(r, o.length) }, i.area = function (o, r) { for (var s = 0, a = o.length - 1, f = 0; f < o.length; f++)s += (o[a].x - o[f].x) * (o[a].y + o[f].y), a = f; return r ? s / 2 : Math.abs(s) / 2 }, i.inertia = function (o, r) { for (var s = 0, a = 0, f = o, l, u, v = 0; v < f.length; v++)u = (v + 1) % f.length, l = Math.abs(h.cross(f[u], f[v])), s += l * (h.dot(f[u], f[u]) + h.dot(f[u], f[v]) + h.dot(f[v], f[v])), a += l; return r / 6 * (s / a) }, i.translate = function (o, r, s) { let a; if (s) for (a = 0; a < o.length; a++)o[a].x += r.x * s, o[a].y += r.y * s; else for (a = 0; a < o.length; a++)o[a].x += r.x, o[a].y += r.y; return o }, i.rotate = function (o, r, s) { if (r !== 0) { for (let a = Math.cos(r), f = Math.sin(r), l = 0; l < o.length; l++) { const u = o[l]; const v = u.x - s.x; const p = u.y - s.y; u.x = s.x + (v * a - p * f), u.y = s.y + (v * f + p * a) } return o } }, i.contains = function (o, r) { for (let s = 0; s < o.length; s++) { const a = o[s]; const f = o[(s + 1) % o.length]; if ((r.x - a.x) * (f.y - a.y) + (r.y - a.y) * (a.x - f.x) > 0) return !1 } return !0 }, i.scale = function (o, r, s, a) { if (r === 1 && s === 1) return o; a = a || i.centre(o); for (var f, l, u = 0; u < o.length; u++)f = o[u], l = h.sub(f, a), o[u].x = a.x + l.x * r, o[u].y = a.y + l.y * s; return o }, i.chamfer = function (o, r, s, a, f) { typeof r === 'number' ? r = [r] : r = r || [8], s = typeof s !== 'undefined' ? s : -1, a = a || 2, f = f || 14; for (var l = [], u = 0; u < o.length; u++) { const v = o[u - 1 >= 0 ? u - 1 : o.length - 1]; const p = o[u]; const c = o[(u + 1) % o.length]; const m = r[u < r.length ? u : r.length - 1]; if (m === 0) { l.push(p); continue } const g = h.normalise({ x: p.y - v.y, y: v.x - p.x }); const x = h.normalise({ x: c.y - p.y, y: p.x - c.x }); const y = Math.sqrt(2 * Math.pow(m, 2)); const T = h.mult(n.clone(g), m); const S = h.normalise(h.mult(h.add(g, x), 0.5)); const E = h.sub(p, h.mult(S, y)); let C = s; s === -1 && (C = Math.pow(m, 0.32) * 1.75), C = n.clamp(C, a, f), C % 2 == 1 && (C += 1); for (let P = Math.acos(h.dot(g, x)), A = P / C, M = 0; M < C; M++)l.push(h.add(h.rotate(T, A * M), E)) } return l }, i.clockwiseSort = function (o) { const r = i.mean(o); return o.sort(function (s, a) { return h.angle(r, s) - h.angle(r, a) }), o }, i.isConvex = function (o) { let r = 0; const s = o.length; let a; let f; let l; let u; if (s < 3) return null; for (a = 0; a < s; a++) if (f = (a + 1) % s, l = (a + 2) % s, u = (o[f].x - o[a].x) * (o[l].y - o[f].y), u -= (o[f].y - o[a].y) * (o[l].x - o[f].x), u < 0 ? r |= 1 : u > 0 && (r |= 2), r === 3) return !1; return r !== 0 ? !0 : null }, i.hull = function (o) { const r = []; const s = []; let a; let f; for (o = o.slice(0), o.sort(function (l, u) { const v = l.x - u.x; return v !== 0 ? v : l.y - u.y }), f = 0; f < o.length; f += 1) { for (a = o[f]; s.length >= 2 && h.cross3(s[s.length - 2], s[s.length - 1], a) <= 0;)s.pop(); s.push(a) } for (f = o.length - 1; f >= 0; f -= 1) { for (a = o[f]; r.length >= 2 && h.cross3(r[r.length - 2], r[r.length - 1], a) <= 0;)r.pop(); r.push(a) } return r.pop(), s.pop(), r.concat(s) } })() }, function (e, d, t) { const i = t(0); const h = t(66); const n = t(300); const o = t(301); const r = t(56); const s = t(170); const a = new i({ initialize: function (l, u, v) { l === void 0 && (l = 0), u === void 0 && (u = 0), v === void 0 && (v = 0), this.type = r.CIRCLE, this.x = l, this.y = u, this._radius = v, this._diameter = v * 2 }, contains: function (f, l) { return h(this, f, l) }, getPoint: function (f, l) { return n(this, f, l) }, getPoints: function (f, l, u) { return o(this, f, l, u) }, getRandomPoint: function (f) { return s(this, f) }, setTo: function (f, l, u) { return this.x = f, this.y = l, this._radius = u, this._diameter = u * 2, this }, setEmpty: function () { return this._radius = 0, this._diameter = 0, this }, setPosition: function (f, l) { return l === void 0 && (l = f), this.x = f, this.y = l, this }, isEmpty: function () { return this._radius <= 0 }, radius: { get: function () { return this._radius }, set: function (f) { this._radius = f, this._diameter = f * 2 } }, diameter: { get: function () { return this._diameter }, set: function (f) { this._diameter = f, this._radius = f * 0.5 } }, left: { get: function () { return this.x - this._radius }, set: function (f) { this.x = f + this._radius } }, right: { get: function () { return this.x + this._radius }, set: function (f) { this.x = f - this._radius } }, top: { get: function () { return this.y - this._radius }, set: function (f) { this.y = f + this._radius } }, bottom: { get: function () { return this.y + this._radius }, set: function (f) { this.y = f - this._radius } } }); e.exports = a }, function (e, d) { const t = function (i, h, n) { if (i.radius > 0 && h >= i.left && h <= i.right && n >= i.top && n <= i.bottom) { const o = (i.x - h) * (i.x - h); const r = (i.y - n) * (i.y - n); return o + r <= i.radius * i.radius } else return !1 }; e.exports = t }, function (e, d) { const t = function (i) { return Math.sqrt((i.x2 - i.x1) * (i.x2 - i.x1) + (i.y2 - i.y1) * (i.y2 - i.y1)) }; e.exports = t }, function (e, d) { const t = function (i, h, n) { const o = n - h; return h + ((i - h) % o + o) % o }; e.exports = t }, function (e, d, t) { const i = t(0); const h = t(39); const n = 1e-6; var o = new i({ initialize: function (v) { this.val = new Float32Array(16), v ? this.copy(v) : this.identity() }, clone: function () { return new o(this) }, set: function (u) { return this.copy(u) }, setValues: function (u, v, p, c, m, g, x, y, T, S, E, C, P, A, M, L) { const F = this.val; return F[0] = u, F[1] = v, F[2] = p, F[3] = c, F[4] = m, F[5] = g, F[6] = x, F[7] = y, F[8] = T, F[9] = S, F[10] = E, F[11] = C, F[12] = P, F[13] = A, F[14] = M, F[15] = L, this }, copy: function (u) { const v = u.val; return this.setValues(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7], v[8], v[9], v[10], v[11], v[12], v[13], v[14], v[15]) }, fromArray: function (u) { return this.setValues(u[0], u[1], u[2], u[3], u[4], u[5], u[6], u[7], u[8], u[9], u[10], u[11], u[12], u[13], u[14], u[15]) }, zero: function () { return this.setValues(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) }, transform: function (u, v, p) { const c = r.fromQuat(p); const m = c.val; const g = v.x; const x = v.y; const y = v.z; return this.setValues(m[0] * g, m[1] * g, m[2] * g, 0, m[4] * x, m[5] * x, m[6] * x, 0, m[8] * y, m[9] * y, m[10] * y, 0, u.x, u.y, u.z, 1) }, xyz: function (u, v, p) { this.identity(); const c = this.val; return c[12] = u, c[13] = v, c[14] = p, this }, scaling: function (u, v, p) { this.zero(); const c = this.val; return c[0] = u, c[5] = v, c[10] = p, c[15] = 1, this }, identity: function () { return this.setValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1) }, transpose: function () { const u = this.val; const v = u[1]; const p = u[2]; const c = u[3]; const m = u[6]; const g = u[7]; const x = u[11]; return u[1] = u[4], u[2] = u[8], u[3] = u[12], u[4] = v, u[6] = u[9], u[7] = u[13], u[8] = p, u[9] = m, u[11] = u[14], u[12] = c, u[13] = g, u[14] = x, this }, getInverse: function (u) { return this.copy(u), this.invert() }, invert: function () { const u = this.val; const v = u[0]; const p = u[1]; const c = u[2]; const m = u[3]; const g = u[4]; const x = u[5]; const y = u[6]; const T = u[7]; const S = u[8]; const E = u[9]; const C = u[10]; const P = u[11]; const A = u[12]; const M = u[13]; const L = u[14]; const F = u[15]; const I = v * x - p * g; const G = v * y - c * g; const U = v * T - m * g; const Y = p * y - c * x; const X = p * T - m * x; const O = c * T - m * y; const R = S * M - E * A; const D = S * L - C * A; const B = S * F - P * A; const N = E * L - C * M; const w = E * F - P * M; const z = C * F - P * L; let V = I * z - G * w + U * N + Y * B - X * D + O * R; return V ? (V = 1 / V, this.setValues((x * z - y * w + T * N) * V, (c * w - p * z - m * N) * V, (M * O - L * X + F * Y) * V, (C * X - E * O - P * Y) * V, (y * B - g * z - T * D) * V, (v * z - c * B + m * D) * V, (L * U - A * O - F * G) * V, (S * O - C * U + P * G) * V, (g * w - x * B + T * R) * V, (p * B - v * w - m * R) * V, (A * X - M * U + F * I) * V, (E * U - S * X - P * I) * V, (x * D - g * N - y * R) * V, (v * N - p * D + c * R) * V, (M * G - A * Y - L * I) * V, (S * Y - E * G + C * I) * V)) : this }, adjoint: function () { const u = this.val; const v = u[0]; const p = u[1]; const c = u[2]; const m = u[3]; const g = u[4]; const x = u[5]; const y = u[6]; const T = u[7]; const S = u[8]; const E = u[9]; const C = u[10]; const P = u[11]; const A = u[12]; const M = u[13]; const L = u[14]; const F = u[15]; return this.setValues(x * (C * F - P * L) - E * (y * F - T * L) + M * (y * P - T * C), -(p * (C * F - P * L) - E * (c * F - m * L) + M * (c * P - m * C)), p * (y * F - T * L) - x * (c * F - m * L) + M * (c * T - m * y), -(p * (y * P - T * C) - x * (c * P - m * C) + E * (c * T - m * y)), -(g * (C * F - P * L) - S * (y * F - T * L) + A * (y * P - T * C)), v * (C * F - P * L) - S * (c * F - m * L) + A * (c * P - m * C), -(v * (y * F - T * L) - g * (c * F - m * L) + A * (c * T - m * y)), v * (y * P - T * C) - g * (c * P - m * C) + S * (c * T - m * y), g * (E * F - P * M) - S * (x * F - T * M) + A * (x * P - T * E), -(v * (E * F - P * M) - S * (p * F - m * M) + A * (p * P - m * E)), v * (x * F - T * M) - g * (p * F - m * M) + A * (p * T - m * x), -(v * (x * P - T * E) - g * (p * P - m * E) + S * (p * T - m * x)), -(g * (E * L - C * M) - S * (x * L - y * M) + A * (x * C - y * E)), v * (E * L - C * M) - S * (p * L - c * M) + A * (p * C - c * E), -(v * (x * L - y * M) - g * (p * L - c * M) + A * (p * y - c * x)), v * (x * C - y * E) - g * (p * C - c * E) + S * (p * y - c * x)) }, determinant: function () { const u = this.val; const v = u[0]; const p = u[1]; const c = u[2]; const m = u[3]; const g = u[4]; const x = u[5]; const y = u[6]; const T = u[7]; const S = u[8]; const E = u[9]; const C = u[10]; const P = u[11]; const A = u[12]; const M = u[13]; const L = u[14]; const F = u[15]; const I = v * x - p * g; const G = v * y - c * g; const U = v * T - m * g; const Y = p * y - c * x; const X = p * T - m * x; const O = c * T - m * y; const R = S * M - E * A; const D = S * L - C * A; const B = S * F - P * A; const N = E * L - C * M; const w = E * F - P * M; const z = C * F - P * L; return I * z - G * w + U * N + Y * B - X * D + O * R }, multiply: function (u) { const v = this.val; const p = v[0]; const c = v[1]; const m = v[2]; const g = v[3]; const x = v[4]; const y = v[5]; const T = v[6]; const S = v[7]; const E = v[8]; const C = v[9]; const P = v[10]; const A = v[11]; const M = v[12]; const L = v[13]; const F = v[14]; const I = v[15]; const G = u.val; let U = G[0]; let Y = G[1]; let X = G[2]; let O = G[3]; return v[0] = U * p + Y * x + X * E + O * M, v[1] = U * c + Y * y + X * C + O * L, v[2] = U * m + Y * T + X * P + O * F, v[3] = U * g + Y * S + X * A + O * I, U = G[4], Y = G[5], X = G[6], O = G[7], v[4] = U * p + Y * x + X * E + O * M, v[5] = U * c + Y * y + X * C + O * L, v[6] = U * m + Y * T + X * P + O * F, v[7] = U * g + Y * S + X * A + O * I, U = G[8], Y = G[9], X = G[10], O = G[11], v[8] = U * p + Y * x + X * E + O * M, v[9] = U * c + Y * y + X * C + O * L, v[10] = U * m + Y * T + X * P + O * F, v[11] = U * g + Y * S + X * A + O * I, U = G[12], Y = G[13], X = G[14], O = G[15], v[12] = U * p + Y * x + X * E + O * M, v[13] = U * c + Y * y + X * C + O * L, v[14] = U * m + Y * T + X * P + O * F, v[15] = U * g + Y * S + X * A + O * I, this }, multiplyLocal: function (u) { const v = this.val; const p = u.val; return this.setValues(v[0] * p[0] + v[1] * p[4] + v[2] * p[8] + v[3] * p[12], v[0] * p[1] + v[1] * p[5] + v[2] * p[9] + v[3] * p[13], v[0] * p[2] + v[1] * p[6] + v[2] * p[10] + v[3] * p[14], v[0] * p[3] + v[1] * p[7] + v[2] * p[11] + v[3] * p[15], v[4] * p[0] + v[5] * p[4] + v[6] * p[8] + v[7] * p[12], v[4] * p[1] + v[5] * p[5] + v[6] * p[9] + v[7] * p[13], v[4] * p[2] + v[5] * p[6] + v[6] * p[10] + v[7] * p[14], v[4] * p[3] + v[5] * p[7] + v[6] * p[11] + v[7] * p[15], v[8] * p[0] + v[9] * p[4] + v[10] * p[8] + v[11] * p[12], v[8] * p[1] + v[9] * p[5] + v[10] * p[9] + v[11] * p[13], v[8] * p[2] + v[9] * p[6] + v[10] * p[10] + v[11] * p[14], v[8] * p[3] + v[9] * p[7] + v[10] * p[11] + v[11] * p[15], v[12] * p[0] + v[13] * p[4] + v[14] * p[8] + v[15] * p[12], v[12] * p[1] + v[13] * p[5] + v[14] * p[9] + v[15] * p[13], v[12] * p[2] + v[13] * p[6] + v[14] * p[10] + v[15] * p[14], v[12] * p[3] + v[13] * p[7] + v[14] * p[11] + v[15] * p[15]) }, premultiply: function (u) { return this.multiplyMatrices(u, this) }, multiplyMatrices: function (u, v) { const p = u.val; const c = v.val; const m = p[0]; const g = p[4]; const x = p[8]; const y = p[12]; const T = p[1]; const S = p[5]; const E = p[9]; const C = p[13]; const P = p[2]; const A = p[6]; const M = p[10]; const L = p[14]; const F = p[3]; const I = p[7]; const G = p[11]; const U = p[15]; const Y = c[0]; const X = c[4]; const O = c[8]; const R = c[12]; const D = c[1]; const B = c[5]; const N = c[9]; const w = c[13]; const z = c[2]; const V = c[6]; const W = c[10]; const H = c[14]; const K = c[3]; const Q = c[7]; const J = c[11]; const q = c[15]; return this.setValues(m * Y + g * D + x * z + y * K, T * Y + S * D + E * z + C * K, P * Y + A * D + M * z + L * K, F * Y + I * D + G * z + U * K, m * X + g * B + x * V + y * Q, T * X + S * B + E * V + C * Q, P * X + A * B + M * V + L * Q, F * X + I * B + G * V + U * Q, m * O + g * N + x * W + y * J, T * O + S * N + E * W + C * J, P * O + A * N + M * W + L * J, F * O + I * N + G * W + U * J, m * R + g * w + x * H + y * q, T * R + S * w + E * H + C * q, P * R + A * w + M * H + L * q, F * R + I * w + G * H + U * q) }, translate: function (u) { return this.translateXYZ(u.x, u.y, u.z) }, translateXYZ: function (u, v, p) { const c = this.val; return c[12] = c[0] * u + c[4] * v + c[8] * p + c[12], c[13] = c[1] * u + c[5] * v + c[9] * p + c[13], c[14] = c[2] * u + c[6] * v + c[10] * p + c[14], c[15] = c[3] * u + c[7] * v + c[11] * p + c[15], this }, scale: function (u) { return this.scaleXYZ(u.x, u.y, u.z) }, scaleXYZ: function (u, v, p) { const c = this.val; return c[0] = c[0] * u, c[1] = c[1] * u, c[2] = c[2] * u, c[3] = c[3] * u, c[4] = c[4] * v, c[5] = c[5] * v, c[6] = c[6] * v, c[7] = c[7] * v, c[8] = c[8] * p, c[9] = c[9] * p, c[10] = c[10] * p, c[11] = c[11] * p, this }, makeRotationAxis: function (u, v) { const p = Math.cos(v); const c = Math.sin(v); const m = 1 - p; const g = u.x; const x = u.y; const y = u.z; const T = m * g; const S = m * x; return this.setValues(T * g + p, T * x - c * y, T * y + c * x, 0, T * x + c * y, S * x + p, S * y - c * g, 0, T * y - c * x, S * y + c * g, m * y * y + p, 0, 0, 0, 0, 1) }, rotate: function (u, v) { const p = this.val; let c = v.x; let m = v.y; let g = v.z; let x = Math.sqrt(c * c + m * m + g * g); if (Math.abs(x) < n) return this; x = 1 / x, c *= x, m *= x, g *= x; const y = Math.sin(u); const T = Math.cos(u); const S = 1 - T; const E = p[0]; const C = p[1]; const P = p[2]; const A = p[3]; const M = p[4]; const L = p[5]; const F = p[6]; const I = p[7]; const G = p[8]; const U = p[9]; const Y = p[10]; const X = p[11]; const O = p[12]; const R = p[13]; const D = p[14]; const B = p[15]; const N = c * c * S + T; const w = m * c * S + g * y; const z = g * c * S - m * y; const V = c * m * S - g * y; const W = m * m * S + T; const H = g * m * S + c * y; const K = c * g * S + m * y; const Q = m * g * S - c * y; const J = g * g * S + T; return this.setValues(E * N + M * w + G * z, C * N + L * w + U * z, P * N + F * w + Y * z, A * N + I * w + X * z, E * V + M * W + G * H, C * V + L * W + U * H, P * V + F * W + Y * H, A * V + I * W + X * H, E * K + M * Q + G * J, C * K + L * Q + U * J, P * K + F * Q + Y * J, A * K + I * Q + X * J, O, R, D, B) }, rotateX: function (u) { const v = this.val; const p = Math.sin(u); const c = Math.cos(u); const m = v[4]; const g = v[5]; const x = v[6]; const y = v[7]; const T = v[8]; const S = v[9]; const E = v[10]; const C = v[11]; return v[4] = m * c + T * p, v[5] = g * c + S * p, v[6] = x * c + E * p, v[7] = y * c + C * p, v[8] = T * c - m * p, v[9] = S * c - g * p, v[10] = E * c - x * p, v[11] = C * c - y * p, this }, rotateY: function (u) { const v = this.val; const p = Math.sin(u); const c = Math.cos(u); const m = v[0]; const g = v[1]; const x = v[2]; const y = v[3]; const T = v[8]; const S = v[9]; const E = v[10]; const C = v[11]; return v[0] = m * c - T * p, v[1] = g * c - S * p, v[2] = x * c - E * p, v[3] = y * c - C * p, v[8] = m * p + T * c, v[9] = g * p + S * c, v[10] = x * p + E * c, v[11] = y * p + C * c, this }, rotateZ: function (u) { const v = this.val; const p = Math.sin(u); const c = Math.cos(u); const m = v[0]; const g = v[1]; const x = v[2]; const y = v[3]; const T = v[4]; const S = v[5]; const E = v[6]; const C = v[7]; return v[0] = m * c + T * p, v[1] = g * c + S * p, v[2] = x * c + E * p, v[3] = y * c + C * p, v[4] = T * c - m * p, v[5] = S * c - g * p, v[6] = E * c - x * p, v[7] = C * c - y * p, this }, fromRotationTranslation: function (u, v) { const p = u.x; const c = u.y; const m = u.z; const g = u.w; const x = p + p; const y = c + c; const T = m + m; const S = p * x; const E = p * y; const C = p * T; const P = c * y; const A = c * T; const M = m * T; const L = g * x; const F = g * y; const I = g * T; return this.setValues(1 - (P + M), E + I, C - F, 0, E - I, 1 - (S + M), A + L, 0, C + F, A - L, 1 - (S + P), 0, v.x, v.y, v.z, 1) }, fromQuat: function (u) { const v = u.x; const p = u.y; const c = u.z; const m = u.w; const g = v + v; const x = p + p; const y = c + c; const T = v * g; const S = v * x; const E = v * y; const C = p * x; const P = p * y; const A = c * y; const M = m * g; const L = m * x; const F = m * y; return this.setValues(1 - (C + A), S + F, E - L, 0, S - F, 1 - (T + A), P + M, 0, E + L, P - M, 1 - (T + C), 0, 0, 0, 0, 1) }, frustum: function (u, v, p, c, m, g) { const x = 1 / (v - u); const y = 1 / (c - p); const T = 1 / (m - g); return this.setValues(m * 2 * x, 0, 0, 0, 0, m * 2 * y, 0, 0, (v + u) * x, (c + p) * y, (g + m) * T, -1, 0, 0, g * m * 2 * T, 0) }, perspective: function (u, v, p, c) { const m = 1 / Math.tan(u / 2); const g = 1 / (p - c); return this.setValues(m / v, 0, 0, 0, 0, m, 0, 0, 0, 0, (c + p) * g, -1, 0, 0, 2 * c * p * g, 0) }, perspectiveLH: function (u, v, p, c) { return this.setValues(2 * p / u, 0, 0, 0, 0, 2 * p / v, 0, 0, 0, 0, -c / (p - c), 1, 0, 0, p * c / (p - c), 0) }, ortho: function (u, v, p, c, m, g) { let x = u - v; let y = p - c; let T = m - g; return x = x === 0 ? x : 1 / x, y = y === 0 ? y : 1 / y, T = T === 0 ? T : 1 / T, this.setValues(-2 * x, 0, 0, 0, 0, -2 * y, 0, 0, 0, 0, 2 * T, 0, (u + v) * x, (c + p) * y, (g + m) * T, 1) }, lookAtRH: function (u, v, p) { const c = this.val; return l.subVectors(u, v), l.getLengthSquared() === 0 && (l.z = 1), l.normalize(), a.crossVectors(p, l), a.getLengthSquared() === 0 && (Math.abs(p.z) === 1 ? l.x += 1e-4 : l.z += 1e-4, l.normalize(), a.crossVectors(p, l)), a.normalize(), f.crossVectors(l, a), c[0] = a.x, c[1] = a.y, c[2] = a.z, c[4] = f.x, c[5] = f.y, c[6] = f.z, c[8] = l.x, c[9] = l.y, c[10] = l.z, this }, lookAt: function (u, v, p) { const c = u.x; const m = u.y; const g = u.z; const x = p.x; const y = p.y; const T = p.z; const S = v.x; const E = v.y; const C = v.z; if (Math.abs(c - S) < n && Math.abs(m - E) < n && Math.abs(g - C) < n) return this.identity(); let P = c - S; let A = m - E; let M = g - C; let L = 1 / Math.sqrt(P * P + A * A + M * M); P *= L, A *= L, M *= L; let F = y * M - T * A; let I = T * P - x * M; let G = x * A - y * P; L = Math.sqrt(F * F + I * I + G * G), L ? (L = 1 / L, F *= L, I *= L, G *= L) : (F = 0, I = 0, G = 0); let U = A * G - M * I; let Y = M * F - P * G; let X = P * I - A * F; return L = Math.sqrt(U * U + Y * Y + X * X), L ? (L = 1 / L, U *= L, Y *= L, X *= L) : (U = 0, Y = 0, X = 0), this.setValues(F, U, P, 0, I, Y, A, 0, G, X, M, 0, -(F * c + I * m + G * g), -(U * c + Y * m + X * g), -(P * c + A * m + M * g), 1) }, yawPitchRoll: function (u, v, p) { this.zero(), r.zero(), s.zero(); const c = this.val; const m = r.val; const g = s.val; let x = Math.sin(p); let y = Math.cos(p); return c[10] = 1, c[15] = 1, c[0] = y, c[1] = x, c[4] = -x, c[5] = y, x = Math.sin(v), y = Math.cos(v), m[0] = 1, m[15] = 1, m[5] = y, m[10] = y, m[9] = -x, m[6] = x, x = Math.sin(u), y = Math.cos(u), g[5] = 1, g[15] = 1, g[0] = y, g[2] = -x, g[8] = x, g[10] = y, this.multiplyLocal(r), this.multiplyLocal(s), this }, setWorldMatrix: function (u, v, p, c, m) { return this.yawPitchRoll(u.y, u.x, u.z), r.scaling(p.x, p.y, p.z), s.xyz(v.x, v.y, v.z), this.multiplyLocal(r), this.multiplyLocal(s), c && this.multiplyLocal(c), m && this.multiplyLocal(m), this }, multiplyToMat4: function (u, v) { const p = this.val; const c = u.val; const m = p[0]; const g = p[1]; const x = p[2]; const y = p[3]; const T = p[4]; const S = p[5]; const E = p[6]; const C = p[7]; const P = p[8]; const A = p[9]; const M = p[10]; const L = p[11]; const F = p[12]; const I = p[13]; const G = p[14]; const U = p[15]; const Y = c[0]; const X = c[1]; const O = c[2]; const R = c[3]; const D = c[4]; const B = c[5]; const N = c[6]; const w = c[7]; const z = c[8]; const V = c[9]; const W = c[10]; const H = c[11]; const K = c[12]; const Q = c[13]; const J = c[14]; const q = c[15]; return v.setValues(Y * m + X * T + O * P + R * F, X * g + X * S + O * A + R * I, O * x + X * E + O * M + R * G, R * y + X * C + O * L + R * U, D * m + B * T + N * P + w * F, D * g + B * S + N * A + w * I, D * x + B * E + N * M + w * G, D * y + B * C + N * L + w * U, z * m + V * T + W * P + H * F, z * g + V * S + W * A + H * I, z * x + V * E + W * M + H * G, z * y + V * C + W * L + H * U, K * m + Q * T + J * P + q * F, K * g + Q * S + J * A + q * I, K * x + Q * E + J * M + q * G, K * y + Q * C + J * L + q * U) }, fromRotationXYTranslation: function (u, v, p) { const c = v.x; const m = v.y; const g = v.z; const x = Math.sin(u.x); const y = Math.cos(u.x); const T = Math.sin(u.y); const S = Math.cos(u.y); let E = c; let C = m; let P = g; const A = -x; const M = 0 - A * T; const L = 0 - y * T; const F = A * S; const I = y * S; return p || (E = S * c + T * g, C = M * c + y * m + F * g, P = L * c + x * m + I * g), this.setValues(S, M, L, 0, 0, y, x, 0, T, F, I, 0, E, C, P, 1) }, getMaxScaleOnAxis: function () { const u = this.val; const v = u[0] * u[0] + u[1] * u[1] + u[2] * u[2]; const p = u[4] * u[4] + u[5] * u[5] + u[6] * u[6]; const c = u[8] * u[8] + u[9] * u[9] + u[10] * u[10]; return Math.sqrt(Math.max(v, p, c)) } }); var r = new o(); var s = new o(); var a = new h(); var f = new h(); var l = new h(); e.exports = o }, function (e, d, t) { e.exports = { COMPLETE: t(987), DECODED: t(988), DECODED_ALL: t(989), DESTROY: t(990), DETUNE: t(991), GLOBAL_DETUNE: t(992), GLOBAL_MUTE: t(993), GLOBAL_RATE: t(994), GLOBAL_VOLUME: t(995), LOOP: t(996), LOOPED: t(997), MUTE: t(998), PAN: t(999), PAUSE_ALL: t(1e3), PAUSE: t(1001), PLAY: t(1002), RATE: t(1003), RESUME_ALL: t(1004), RESUME: t(1005), SEEK: t(1006), STOP_ALL: t(1007), STOP: t(1008), UNLOCKED: t(1009), VOLUME: t(1010) } }, function (e, d, t) { const i = t(0); const h = t(21); const n = t(23); const o = t(8); const r = t(2); const s = t(7); const a = new i({ Extends: n, initialize: function f (l, u, v, p, c) { let m = 'png'; let g; if (s(u)) { const x = u; u = r(x, 'key'), v = r(x, 'url'), g = r(x, 'normalMap'), p = r(x, 'xhrSettings'), m = r(x, 'extension', m), c = r(x, 'frameConfig') }Array.isArray(v) && (g = v[1], v = v[0]); const y = { type: 'image', cache: l.textureManager, extension: m, responseType: 'blob', key: u, url: v, xhrSettings: p, config: c }; if (n.call(this, l, y), g) { const T = new f(l, this.key, g, p, c); T.type = 'normalMap', this.setLink(T), l.addFile(T) } }, onProcess: function () { this.state = h.FILE_PROCESSING, this.data = new Image(), this.data.crossOrigin = this.crossOrigin; const f = this; this.data.onload = function () { n.revokeObjectURL(f.data), f.onProcessComplete() }, this.data.onerror = function () { n.revokeObjectURL(f.data), f.onProcessError() }, n.createObjectURL(this.data, this.xhrLoader.response, 'image/png') }, addToCache: function () { let f; const l = this.linkFile; l && l.state === h.FILE_COMPLETE ? (this.type === 'image' ? f = this.cache.addImage(this.key, this.data, l.data) : f = this.cache.addImage(l.key, l.data, this.data), this.pendingDestroy(f), l.pendingDestroy(f)) : l || (f = this.cache.addImage(this.key, this.data), this.pendingDestroy(f)) } }); o.register('image', function (f, l, u) { if (Array.isArray(f)) for (let v = 0; v < f.length; v++) this.addFile(new a(this, f[v])); else this.addFile(new a(this, f, l, u)); return this }), e.exports = a }, function (e, d) { const t = function (i, h) { h ? i.setCollision(!0, !0, !0, !0, !1) : i.resetCollision(!1) }; e.exports = t }, function (e, d, t) { const i = t(164); const h = t(0); const n = t(11); const o = t(15); const r = t(1065); const s = new h({ Extends: o, Mixins: [n.Alpha, n.BlendMode, n.Depth, n.Flip, n.GetBounds, n.Mask, n.Origin, n.Pipeline, n.ScrollFactor, n.Size, n.TextureCrop, n.Tint, n.Transform, n.Visible, r], initialize: function (f, l, u, v, p) { o.call(this, f, 'Sprite'), this._crop = this.resetCropObject(), this.anims = new i(this), this.setTexture(v, p), this.setPosition(l, u), this.setSizeToFrame(), this.setOriginFromFrame(), this.initPipeline() }, addedToScene: function () { this.scene.sys.updateList.add(this) }, removedFromScene: function () { this.scene.sys.updateList.remove(this) }, preUpdate: function (a, f) { this.anims.update(a, f) }, play: function (a, f) { return this.anims.play(a, f) }, playReverse: function (a, f) { return this.anims.playReverse(a, f) }, playAfterDelay: function (a, f) { return this.anims.playAfterDelay(a, f) }, playAfterRepeat: function (a, f) { return this.anims.playAfterRepeat(a, f) }, chain: function (a) { return this.anims.chain(a) }, stop: function () { return this.anims.stop() }, stopAfterDelay: function (a) { return this.anims.stopAfterDelay(a) }, stopAfterRepeat: function (a) { return this.anims.stopAfterRepeat(a) }, stopOnFrame: function (a) { return this.anims.stopOnFrame(a) }, toJSON: function () { return n.ToJSON(this) }, preDestroy: function () { this.anims.destroy(), this.anims = void 0 } }); e.exports = s }, function (e, d) { const t = function (i, h) { if (!(h >= i.length)) { for (var n = i.length - 1, o = i[h], r = h; r < n; r++)i[r] = i[r + 1]; return i.length = n, o } }; e.exports = t }, function (e, d, t) { e.exports = { ADDED_TO_SCENE: t(643), DESTROY: t(644), REMOVED_FROM_SCENE: t(645), VIDEO_COMPLETE: t(646), VIDEO_CREATED: t(647), VIDEO_ERROR: t(648), VIDEO_LOOP: t(649), VIDEO_PLAY: t(650), VIDEO_SEEKED: t(651), VIDEO_SEEKING: t(652), VIDEO_STOP: t(653), VIDEO_TIMEOUT: t(654), VIDEO_UNLOCKED: t(655) } }, function (e, d) { const t = function (i, h, n, o) { return n === void 0 && (n = 0), h === 0 ? i : (i -= n, i = h * Math.floor(i / h), o ? (n + i) / h : n + i) }; e.exports = t }, function (e, d) { const t = function (i) { const h = {}; for (const n in i)Array.isArray(i[n]) ? h[n] = i[n].slice(0) : h[n] = i[n]; return h }; e.exports = t }, function (e, d) { const t = function (i, h, n, o) { const r = i.length; if (h < 0 || h > r || h >= n || n > r || h + n > r) { if (o) throw new Error('Range Error: Values outside acceptable range'); return !1 } else return !0 }; e.exports = t }, function (e, d) { function t (o, r) { return String(o).localeCompare(r) } function i (o, r) { const s = o.length; if (s <= 1) return o; for (let a = new Array(s), f = 1; f < s; f *= 2) { h(o, r, f, a); const l = o; o = a, a = l } return o } function h (o, r, s, a) { const f = o.length; let l = 0; const u = s * 2; let v; let p; let c; let m; let g; for (v = 0; v < f; v += u) for (p = v + s, c = p + s, p > f && (p = f), c > f && (c = f), m = v, g = p; ;) if (m < p && g < c)r(o[m], o[g]) <= 0 ? a[l++] = o[m++] : a[l++] = o[g++]; else if (m < p)a[l++] = o[m++]; else if (g < c)a[l++] = o[g++]; else break } const n = function (o, r) { r === void 0 && (r = t); const s = i(o, r); return s !== o && h(s, null, o.length, o), o }; e.exports = n }, function (e, d, t) { const i = t(134); const h = t(205); const n = function (o, r) { let s = i.Power0; if (typeof o === 'string') if (i.hasOwnProperty(o))s = i[o]; else { let a = ''; o.indexOf('.') && (a = o.substr(o.indexOf('.') + 1), a.toLowerCase() === 'in' ? a = 'easeIn' : a.toLowerCase() === 'out' ? a = 'easeOut' : a.toLowerCase() === 'inout' && (a = 'easeInOut')), o = h(o.substr(0, o.indexOf('.') + 1) + a), i.hasOwnProperty(o) && (s = i[o]) } else typeof o === 'function' ? s = o : Array.isArray(o) && o.length === 4; if (!r) return s; const f = r.slice(0); return f.unshift(0), function (l) { return f[0] = l, s.apply(this, f) } }; e.exports = n }, function (e, d, t) { const i = t(12); const h = function (n, o, r, s, a) { const f = n.strokeTint; const l = i.getTintAppendFloatAlpha(o.strokeColor, o.strokeAlpha * r); f.TL = l, f.TR = l, f.BL = l, f.BR = l; const u = o.pathData; let v = u.length - 1; const p = o.lineWidth; const c = p / 2; let m = u[0] - s; let g = u[1] - a; o.closePath || (v -= 2); for (let x = 2; x < v; x += 2) { const y = u[x] - s; const T = u[x + 1] - a; n.batchLine(m, g, y, T, c, c, p, x - 2, o.closePath ? x === v - 1 : !1), m = y, g = T } }; e.exports = h }, function (e, d, t) { const i = t(0); const h = t(115); const n = t(476); const o = t(477); const r = t(56); const s = t(47); const a = t(181); const f = new i({ initialize: function (u, v, p, c, m, g) { u === void 0 && (u = 0), v === void 0 && (v = 0), p === void 0 && (p = 0), c === void 0 && (c = 0), m === void 0 && (m = 0), g === void 0 && (g = 0), this.type = r.TRIANGLE, this.x1 = u, this.y1 = v, this.x2 = p, this.y2 = c, this.x3 = m, this.y3 = g }, contains: function (l, u) { return h(this, l, u) }, getPoint: function (l, u) { return n(this, l, u) }, getPoints: function (l, u, v) { return o(this, l, u, v) }, getRandomPoint: function (l) { return a(this, l) }, setTo: function (l, u, v, p, c, m) { return l === void 0 && (l = 0), u === void 0 && (u = 0), v === void 0 && (v = 0), p === void 0 && (p = 0), c === void 0 && (c = 0), m === void 0 && (m = 0), this.x1 = l, this.y1 = u, this.x2 = v, this.y2 = p, this.x3 = c, this.y3 = m, this }, getLineA: function (l) { return l === void 0 && (l = new s()), l.setTo(this.x1, this.y1, this.x2, this.y2), l }, getLineB: function (l) { return l === void 0 && (l = new s()), l.setTo(this.x2, this.y2, this.x3, this.y3), l }, getLineC: function (l) { return l === void 0 && (l = new s()), l.setTo(this.x3, this.y3, this.x1, this.y1), l }, left: { get: function () { return Math.min(this.x1, this.x2, this.x3) }, set: function (l) { let u = 0; this.x1 <= this.x2 && this.x1 <= this.x3 ? u = this.x1 - l : this.x2 <= this.x1 && this.x2 <= this.x3 ? u = this.x2 - l : u = this.x3 - l, this.x1 -= u, this.x2 -= u, this.x3 -= u } }, right: { get: function () { return Math.max(this.x1, this.x2, this.x3) }, set: function (l) { let u = 0; this.x1 >= this.x2 && this.x1 >= this.x3 ? u = this.x1 - l : this.x2 >= this.x1 && this.x2 >= this.x3 ? u = this.x2 - l : u = this.x3 - l, this.x1 -= u, this.x2 -= u, this.x3 -= u } }, top: { get: function () { return Math.min(this.y1, this.y2, this.y3) }, set: function (l) { let u = 0; this.y1 <= this.y2 && this.y1 <= this.y3 ? u = this.y1 - l : this.y2 <= this.y1 && this.y2 <= this.y3 ? u = this.y2 - l : u = this.y3 - l, this.y1 -= u, this.y2 -= u, this.y3 -= u } }, bottom: { get: function () { return Math.max(this.y1, this.y2, this.y3) }, set: function (l) { let u = 0; this.y1 >= this.y2 && this.y1 >= this.y3 ? u = this.y1 - l : this.y2 >= this.y1 && this.y2 >= this.y3 ? u = this.y2 - l : u = this.y3 - l, this.y1 -= u, this.y2 -= u, this.y3 -= u } } }); e.exports = f }, function (e, d) { const t = {}; e.exports = t, (function () { t.create = function (i, h) { return { x: i || 0, y: h || 0 } }, t.clone = function (i) { return { x: i.x, y: i.y } }, t.magnitude = function (i) { return Math.sqrt(i.x * i.x + i.y * i.y) }, t.magnitudeSquared = function (i) { return i.x * i.x + i.y * i.y }, t.rotate = function (i, h, n) { const o = Math.cos(h); const r = Math.sin(h); n || (n = {}); const s = i.x * o - i.y * r; return n.y = i.x * r + i.y * o, n.x = s, n }, t.rotateAbout = function (i, h, n, o) { const r = Math.cos(h); const s = Math.sin(h); o || (o = {}); const a = n.x + ((i.x - n.x) * r - (i.y - n.y) * s); return o.y = n.y + ((i.x - n.x) * s + (i.y - n.y) * r), o.x = a, o }, t.normalise = function (i) { const h = t.magnitude(i); return h === 0 ? { x: 0, y: 0 } : { x: i.x / h, y: i.y / h } }, t.dot = function (i, h) { return i.x * h.x + i.y * h.y }, t.cross = function (i, h) { return i.x * h.y - i.y * h.x }, t.cross3 = function (i, h, n) { return (h.x - i.x) * (n.y - i.y) - (h.y - i.y) * (n.x - i.x) }, t.add = function (i, h, n) { return n || (n = {}), n.x = i.x + h.x, n.y = i.y + h.y, n }, t.sub = function (i, h, n) { return n || (n = {}), n.x = i.x - h.x, n.y = i.y - h.y, n }, t.mult = function (i, h) { return { x: i.x * h, y: i.y * h } }, t.div = function (i, h) { return { x: i.x / h, y: i.y / h } }, t.perp = function (i, h) { return h = h === !0 ? -1 : 1, { x: h * -i.y, y: h * i.x } }, t.neg = function (i) { return { x: -i.x, y: -i.y } }, t.angle = function (i, h) { return Math.atan2(h.y - i.y, h.x - i.x) }, t._temp = [t.create(), t.create(), t.create(), t.create(), t.create(), t.create()] }()) }, function (e, d) { const t = {}; e.exports = t, (function () { t.create = function (i) { const h = { min: { x: 0, y: 0 }, max: { x: 0, y: 0 } }; return i && t.update(h, i), h }, t.update = function (i, h, n) { i.min.x = 1 / 0, i.max.x = -1 / 0, i.min.y = 1 / 0, i.max.y = -1 / 0; for (let o = 0; o < h.length; o++) { const r = h[o]; r.x > i.max.x && (i.max.x = r.x), r.x < i.min.x && (i.min.x = r.x), r.y > i.max.y && (i.max.y = r.y), r.y < i.min.y && (i.min.y = r.y) }n && (n.x > 0 ? i.max.x += n.x : i.min.x += n.x, n.y > 0 ? i.max.y += n.y : i.min.y += n.y) }, t.contains = function (i, h) { return h.x >= i.min.x && h.x <= i.max.x && h.y >= i.min.y && h.y <= i.max.y }, t.overlaps = function (i, h) { return i.min.x <= h.max.x && i.max.x >= h.min.x && i.max.y >= h.min.y && i.min.y <= h.max.y }, t.translate = function (i, h) { i.min.x += h.x, i.max.x += h.x, i.min.y += h.y, i.max.y += h.y }, t.shift = function (i, h) { const n = i.max.x - i.min.x; const o = i.max.y - i.min.y; i.min.x = h.x, i.max.x = h.x + n, i.min.y = h.y, i.max.y = h.y + o } }()) }, function (e, d, t) { const i = t(29); const h = t(0); const n = t(11); const o = t(502); const r = new h({ Mixins: [n.Alpha, n.Flip, n.Visible], initialize: function (a, f, l, u, v, p, c, m) { this.layer = a, this.index = f, this.x = l, this.y = u, this.width = v, this.height = p, this.right, this.bottom, this.baseWidth = c !== void 0 ? c : v, this.baseHeight = m !== void 0 ? m : p, this.pixelX = 0, this.pixelY = 0, this.updatePixelXY(), this.properties = {}, this.rotation = 0, this.collideLeft = !1, this.collideRight = !1, this.collideUp = !1, this.collideDown = !1, this.faceLeft = !1, this.faceRight = !1, this.faceTop = !1, this.faceBottom = !1, this.collisionCallback = void 0, this.collisionCallbackContext = this, this.tint = 16777215, this.physics = {} }, containsPoint: function (s, a) { return !(s < this.pixelX || a < this.pixelY || s > this.right || a > this.bottom) }, copy: function (s) { return this.index = s.index, this.alpha = s.alpha, this.properties = s.properties, this.visible = s.visible, this.setFlip(s.flipX, s.flipY), this.tint = s.tint, this.rotation = s.rotation, this.collideUp = s.collideUp, this.collideDown = s.collideDown, this.collideLeft = s.collideLeft, this.collideRight = s.collideRight, this.collisionCallback = s.collisionCallback, this.collisionCallbackContext = s.collisionCallbackContext, this }, getCollisionGroup: function () { return this.tileset ? this.tileset.getTileCollisionGroup(this.index) : null }, getTileData: function () { return this.tileset ? this.tileset.getTileData(this.index) : null }, getLeft: function (s) { const a = this.tilemapLayer; return a ? a.tileToWorldX(this.x, s) : this.x * this.baseWidth }, getRight: function (s) { const a = this.tilemapLayer; return a ? this.getLeft(s) + this.width * a.scaleX : this.getLeft(s) + this.width }, getTop: function (s) { const a = this.tilemapLayer; return a ? a.tileToWorldY(this.y, s) - (this.height - this.baseHeight) * a.scaleY : this.y * this.baseHeight - (this.height - this.baseHeight) }, getBottom: function (s) { const a = this.tilemapLayer; return a ? this.getTop(s) + this.height * a.scaleY : this.getTop(s) + this.height }, getBounds: function (s, a) { return a === void 0 && (a = new o()), a.x = this.getLeft(), a.y = this.getTop(), a.width = this.getRight() - a.x, a.height = this.getBottom() - a.y, a }, getCenterX: function (s) { return (this.getLeft(s) + this.getRight(s)) / 2 }, getCenterY: function (s) { return (this.getTop(s) + this.getBottom(s)) / 2 }, intersects: function (s, a, f, l) { return !(f <= this.pixelX || l <= this.pixelY || s >= this.right || a >= this.bottom) }, isInteresting: function (s, a) { return s && a ? this.canCollide || this.hasInterestingFace : s ? this.collides : a ? this.hasInterestingFace : !1 }, resetCollision: function (s) { if (s === void 0 && (s = !0), this.collideLeft = !1, this.collideRight = !1, this.collideUp = !1, this.collideDown = !1, this.faceTop = !1, this.faceBottom = !1, this.faceLeft = !1, this.faceRight = !1, s) { const a = this.tilemapLayer; a && this.tilemapLayer.calculateFacesAt(this.x, this.y) } return this }, resetFaces: function () { return this.faceTop = !1, this.faceBottom = !1, this.faceLeft = !1, this.faceRight = !1, this }, setCollision: function (s, a, f, l, u) { if (a === void 0 && (a = s), f === void 0 && (f = s), l === void 0 && (l = s), u === void 0 && (u = !0), this.collideLeft = s, this.collideRight = a, this.collideUp = f, this.collideDown = l, this.faceLeft = s, this.faceRight = a, this.faceTop = f, this.faceBottom = l, u) { const v = this.tilemapLayer; v && this.tilemapLayer.calculateFacesAt(this.x, this.y) } return this }, setCollisionCallback: function (s, a) { return s === null ? (this.collisionCallback = void 0, this.collisionCallbackContext = void 0) : (this.collisionCallback = s, this.collisionCallbackContext = a), this }, setSize: function (s, a, f, l) { return s !== void 0 && (this.width = s), a !== void 0 && (this.height = a), f !== void 0 && (this.baseWidth = f), l !== void 0 && (this.baseHeight = l), this.updatePixelXY(), this }, updatePixelXY: function () { const s = this.layer.orientation; if (s === i.ORTHOGONAL) this.pixelX = this.x * this.baseWidth, this.pixelY = this.y * this.baseHeight; else if (s === i.ISOMETRIC) this.pixelX = (this.x - this.y) * this.baseWidth * 0.5, this.pixelY = (this.x + this.y) * this.baseHeight * 0.5; else if (s === i.STAGGERED) this.pixelX = this.x * this.baseWidth + this.y % 2 * (this.baseWidth / 2), this.pixelY = this.y * (this.baseHeight / 2); else if (s === i.HEXAGONAL) { const a = this.layer.hexSideLength; const f = (this.baseHeight - a) / 2 + a; this.pixelX = this.x * this.baseWidth + this.y % 2 * (this.baseWidth / 2), this.pixelY = this.y * f } return this.right = this.pixelX + this.baseWidth, this.bottom = this.pixelY + this.baseHeight, this }, destroy: function () { this.collisionCallback = void 0, this.collisionCallbackContext = void 0, this.properties = void 0 }, canCollide: { get: function () { return this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.collisionCallback !== void 0 } }, collides: { get: function () { return this.collideLeft || this.collideRight || this.collideUp || this.collideDown } }, hasInterestingFace: { get: function () { return this.faceTop || this.faceBottom || this.faceLeft || this.faceRight } }, tileset: { get: function () { const s = this.layer.tilemapLayer; if (s) { const a = s.gidMap[this.index]; if (a) return a } return null } }, tilemapLayer: { get: function () { return this.layer.tilemapLayer } }, tilemap: { get: function () { const s = this.tilemapLayer; return s ? s.tilemap : null } } }); e.exports = r }, function (e, d, t) { const i = {}; e.exports = i; const h = t(64); const n = t(32); const o = t(41); const r = t(84); const s = t(83); const a = t(1393); (function () { i.rectangle = function (f, l, u, v, p) { p = p || {}; const c = { label: 'Rectangle Body', position: { x: f, y: l }, vertices: h.fromPath('L 0 0 L ' + u + ' 0 L ' + u + ' ' + v + ' L 0 ' + v) }; if (p.chamfer) { const m = p.chamfer; c.vertices = h.chamfer(c.vertices, m.radius, m.quality, m.qualityMin, m.qualityMax), delete p.chamfer } return o.create(n.extend({}, c, p)) }, i.trapezoid = function (f, l, u, v, p, c) { c = c || {}, p *= 0.5; const m = (1 - p * 2) * u; const g = u * p; const x = g + m; const y = x + g; let T; p < 0.5 ? T = 'L 0 0 L ' + g + ' ' + -v + ' L ' + x + ' ' + -v + ' L ' + y + ' 0' : T = 'L 0 0 L ' + x + ' ' + -v + ' L ' + y + ' 0'; const S = { label: 'Trapezoid Body', position: { x: f, y: l }, vertices: h.fromPath(T) }; if (c.chamfer) { const E = c.chamfer; S.vertices = h.chamfer(S.vertices, E.radius, E.quality, E.qualityMin, E.qualityMax), delete c.chamfer } return o.create(n.extend({}, S, c)) }, i.circle = function (f, l, u, v, p) { v = v || {}; const c = { label: 'Circle Body', circleRadius: u }; p = p || 25; let m = Math.ceil(Math.max(10, Math.min(p, u))); return m % 2 == 1 && (m += 1), i.polygon(f, l, m, u, n.extend({}, c, v)) }, i.polygon = function (f, l, u, v, p) { if (p = p || {}, u < 3) return i.circle(f, l, v, p); for (var c = 2 * Math.PI / u, m = '', g = c * 0.5, x = 0; x < u; x += 1) { const y = g + x * c; const T = Math.cos(y) * v; const S = Math.sin(y) * v; m += 'L ' + T.toFixed(3) + ' ' + S.toFixed(3) + ' ' } const E = { label: 'Polygon Body', position: { x: f, y: l }, vertices: h.fromPath(m) }; if (p.chamfer) { const C = p.chamfer; E.vertices = h.chamfer(E.vertices, C.radius, C.quality, C.qualityMin, C.qualityMax), delete p.chamfer } return o.create(n.extend({}, E, p)) }, i.fromVertices = function (f, l, u, v, p, c, m) { let g, x, y, T, S, E, C, P, A; for (v = v || {}, x = [], p = typeof p !== 'undefined' ? p : !1, c = typeof c !== 'undefined' ? c : 0.01, m = typeof m !== 'undefined' ? m : 10, a || n.warn('Bodies.fromVertices: poly-decomp.js required. Could not decompose vertices. Fallback to convex hull.'), n.isArray(u[0]) || (u = [u]), P = 0; P < u.length; P += 1) if (T = u[P], y = h.isConvex(T), y || !a)y ? T = h.clockwiseSort(T) : T = h.hull(T), x.push({ position: { x: f, y: l }, vertices: T }); else { const M = T.map(function (G) { return [G.x, G.y] }); a.makeCCW(M), c !== !1 && a.removeCollinearPoints(M, c); const L = a.quickDecomp(M); for (S = 0; S < L.length; S++) { const F = L[S]; const I = F.map(function (G) { return { x: G[0], y: G[1] } }); m > 0 && h.area(I) < m || x.push({ position: h.centre(I), vertices: I }) } } for (S = 0; S < x.length; S++)x[S] = o.create(n.extend(x[S], v)); return p && i.flagCoincidentParts(x, 5), x.length > 1 ? (g = o.create(n.extend({ parts: x.slice(0) }, v)), o.setPosition(g, { x: f, y: l }), g) : x[0] }, i.flagCoincidentParts = function (f, l) { l === void 0 && (l = 5); for (let u = 0; u < f.length; u++) for (let v = f[u], p = u + 1; p < f.length; p++) { const c = f[p]; if (r.overlaps(v.bounds, c.bounds)) for (let m = v.vertices, g = c.vertices, x = 0; x < v.vertices.length; x++) for (let y = 0; y < c.vertices.length; y++) { const T = s.magnitudeSquared(s.sub(m[(x + 1) % m.length], g[y])); const S = s.magnitudeSquared(s.sub(m[x], g[(y + 1) % g.length])); T < l && S < l && (m[x].isInternal = !0, g[y].isInternal = !0) } } return f } })() }, function (e, d) { const t = function (i) { return i.x - i.width * i.originX + i.width * 0.5 }; e.exports = t }, function (e, d) { const t = function (i, h) { const n = i.width * i.originX; return i.x = h + n - i.width * 0.5, i }; e.exports = t }, function (e, d) { const t = function (i) { return i.y - i.height * i.originY + i.height * 0.5 }; e.exports = t }, function (e, d) { const t = function (i, h) { const n = i.height * i.originY; return i.y = h + n - i.height * 0.5, i }; e.exports = t }, function (e, d, t) { e.exports = { POST_RENDER: t(628), PRE_RENDER: t(629), RENDER: t(630), RESIZE: t(631) } }, function (e, d) { const t = { BITMAPMASK_PIPELINE: 'BitmapMaskPipeline', LIGHT_PIPELINE: 'Light2D', POINTLIGHT_PIPELINE: 'PointLightPipeline', SINGLE_PIPELINE: 'SinglePipeline', MULTI_PIPELINE: 'MultiPipeline', ROPE_PIPELINE: 'RopePipeline', GRAPHICS_PIPELINE: 'GraphicsPipeline', POSTFX_PIPELINE: 'PostFXPipeline', UTILITY_PIPELINE: 'UtilityPipeline' }; e.exports = t }, function (e, d, t) { const i = t(74); const h = function (n, o, r, s) { s === void 0 && (s = n); let a; if (!Array.isArray(o)) return a = n.indexOf(o), a !== -1 ? (i(n, a), r && r.call(s, o), o) : null; for (var f = o.length - 1, l = []; f >= 0;) { const u = o[f]; a = n.indexOf(u), a !== -1 && (i(n, a), l.push(u), r && r.call(s, u)), f-- } return l }; e.exports = h }, function (e, d, t) { const i = t(0); const h = t(199); const n = t(10); const o = t(3); const r = new i({ initialize: function (a) { this.type = a, this.defaultDivisions = 5, this.arcLengthDivisions = 100, this.cacheArcLengths = [], this.needsUpdate = !0, this.active = !0, this._tmpVec2A = new o(), this._tmpVec2B = new o() }, draw: function (s, a) { return a === void 0 && (a = 32), s.strokePoints(this.getPoints(a)) }, getBounds: function (s, a) { s || (s = new n()), a === void 0 && (a = 16); const f = this.getLength(); a > f && (a = f / 2); const l = Math.max(1, Math.round(f / a)); return h(this.getSpacedPoints(l), s) }, getDistancePoints: function (s) { const a = this.getLength(); const f = Math.max(1, a / s); return this.getSpacedPoints(f) }, getEndPoint: function (s) { return s === void 0 && (s = new o()), this.getPointAt(1, s) }, getLength: function () { const s = this.getLengths(); return s[s.length - 1] }, getLengths: function (s) { if (s === void 0 && (s = this.arcLengthDivisions), this.cacheArcLengths.length === s + 1 && !this.needsUpdate) return this.cacheArcLengths; this.needsUpdate = !1; const a = []; let f; const l = this.getPoint(0, this._tmpVec2A); let u = 0; a.push(0); for (let v = 1; v <= s; v++)f = this.getPoint(v / s, this._tmpVec2B), u += f.distance(l), a.push(u), l.copy(f); return this.cacheArcLengths = a, a }, getPointAt: function (s, a) { const f = this.getUtoTmapping(s); return this.getPoint(f, a) }, getPoints: function (s, a, f) { f === void 0 && (f = []), s || (a ? s = this.getLength() / a : s = this.defaultDivisions); for (let l = 0; l <= s; l++)f.push(this.getPoint(l / s)); return f }, getRandomPoint: function (s) { return s === void 0 && (s = new o()), this.getPoint(Math.random(), s) }, getSpacedPoints: function (s, a, f) { f === void 0 && (f = []), s || (a ? s = this.getLength() / a : s = this.defaultDivisions); for (let l = 0; l <= s; l++) { const u = this.getUtoTmapping(l / s, null, s); f.push(this.getPoint(u)) } return f }, getStartPoint: function (s) { return s === void 0 && (s = new o()), this.getPointAt(0, s) }, getTangent: function (s, a) { a === void 0 && (a = new o()); const f = 1e-4; let l = s - f; let u = s + f; return l < 0 && (l = 0), u > 1 && (u = 1), this.getPoint(l, this._tmpVec2A), this.getPoint(u, a), a.subtract(this._tmpVec2A).normalize() }, getTangentAt: function (s, a) { const f = this.getUtoTmapping(s); return this.getTangent(f, a) }, getTFromDistance: function (s, a) { return s <= 0 ? 0 : this.getUtoTmapping(0, s, a) }, getUtoTmapping: function (s, a, f) { const l = this.getLengths(f); let u = 0; const v = l.length; let p; a ? p = Math.min(a, l[v - 1]) : p = s * l[v - 1]; for (var c = 0, m = v - 1, g; c <= m;) if (u = Math.floor(c + (m - c) / 2), g = l[u] - p, g < 0)c = u + 1; else if (g > 0)m = u - 1; else { m = u; break } if (u = m, l[u] === p) return u / (v - 1); const x = l[u]; const y = l[u + 1]; const T = y - x; const S = (p - x) / T; return (u + S) / (v - 1) }, updateArcLengths: function () { this.needsUpdate = !0, this.getLengths() } }); e.exports = r }, function (e, d, t) { e.exports = { ADD: t(968), COMPLETE: t(969), FILE_COMPLETE: t(970), FILE_KEY_COMPLETE: t(971), FILE_LOAD_ERROR: t(972), FILE_LOAD: t(973), FILE_PROGRESS: t(974), POST_PROCESS: t(975), PROGRESS: t(976), START: t(977) } }, function (e, d, t) { const i = t(4); const h = function (n, o, r) { r === void 0 && (r = new i()); const s = n.x1; const a = n.y1; const f = n.x2; const l = n.y2; const u = o.x1; const v = o.y1; const p = o.x2; const c = o.y2; const m = (p - u) * (a - v) - (c - v) * (s - u); const g = (f - s) * (a - v) - (l - a) * (s - u); const x = (c - v) * (f - s) - (p - u) * (l - a); if (x === 0) return !1; const y = m / x; const T = g / x; return y >= 0 && y <= 1 && T >= 0 && T <= 1 ? (r.x = s + y * (f - s), r.y = a + y * (l - a), !0) : !1 }; e.exports = h }, function (e, d) { const t = function (i) { return Math.atan2(i.y2 - i.y1, i.x2 - i.x1) }; e.exports = t }, function (e, d, t) { const i = t(18); const h = function (n, o, r) { return n = i(n, 0, 1), (r - o) * n + o }; e.exports = h }, function (e, d) { const t = function (i, h, n) { return i && i.hasOwnProperty(h) ? i[h] : n }; e.exports = t }, function (e, d) { const t = { CREATED: 0, INIT: 1, DELAY: 2, OFFSET_DELAY: 3, PENDING_RENDER: 4, PLAYING_FORWARD: 5, PLAYING_BACKWARD: 6, HOLD_DELAY: 7, REPEAT_DELAY: 8, COMPLETE: 9, PENDING_ADD: 20, PAUSED: 21, LOOP_DELAY: 22, ACTIVE: 23, COMPLETE_DELAY: 24, PENDING_REMOVE: 25, REMOVED: 26 }; e.exports = t }, function (e, d, t) { const i = t(0); const h = t(315); const n = new i({ initialize: function (r, s) { this.parent = r, this.events = s, s || (this.events = r.events ? r.events : r), this.list = {}, this.values = {}, this._frozen = !1, !r.hasOwnProperty('sys') && this.events && this.events.once(h.DESTROY, this.destroy, this) }, get: function (o) { const r = this.list; if (Array.isArray(o)) { for (var s = [], a = 0; a < o.length; a++)s.push(r[o[a]]); return s } else return r[o] }, getAll: function () { const o = {}; for (const r in this.list) this.list.hasOwnProperty(r) && (o[r] = this.list[r]); return o }, query: function (o) { const r = {}; for (const s in this.list) this.list.hasOwnProperty(s) && s.match(o) && (r[s] = this.list[s]); return r }, set: function (o, r) { if (this._frozen) return this; if (typeof o === 'string') return this.setValue(o, r); for (const s in o) this.setValue(s, o[s]); return this }, inc: function (o, r) { if (this._frozen) return this; r === void 0 && (r = 1); let s = this.get(o); return s === void 0 && (s = 0), this.set(o, s + r), this }, toggle: function (o) { return this._frozen ? this : (this.set(o, !this.get(o)), this) }, setValue: function (o, r) { if (this._frozen) return this; if (this.has(o)) this.values[o] = r; else { const s = this; const a = this.list; const f = this.events; const l = this.parent; Object.defineProperty(this.values, o, { enumerable: !0, configurable: !0, get: function () { return a[o] }, set: function (u) { if (!s._frozen) { const v = a[o]; a[o] = u, f.emit(h.CHANGE_DATA, l, o, u, v), f.emit(h.CHANGE_DATA_KEY + o, l, u, v) } } }), a[o] = r, f.emit(h.SET_DATA, l, o, r) } return this }, each: function (o, r) { for (var s = [this.parent, null, void 0], a = 1; a < arguments.length; a++)s.push(arguments[a]); for (const f in this.list)s[1] = f, s[2] = this.list[f], o.apply(r, s); return this }, merge: function (o, r) { r === void 0 && (r = !0); for (const s in o)o.hasOwnProperty(s) && (r || !r && !this.has(s)) && this.setValue(s, o[s]); return this }, remove: function (o) { if (this._frozen) return this; if (Array.isArray(o)) for (let r = 0; r < o.length; r++) this.removeValue(o[r]); else return this.removeValue(o); return this }, removeValue: function (o) { if (this.has(o)) { const r = this.list[o]; delete this.list[o], delete this.values[o], this.events.emit(h.REMOVE_DATA, this.parent, o, r) } return this }, pop: function (o) { let r = void 0; return !this._frozen && this.has(o) && (r = this.list[o], delete this.list[o], delete this.values[o], this.events.emit(h.REMOVE_DATA, this.parent, o, r)), r }, has: function (o) { return this.list.hasOwnProperty(o) }, setFreeze: function (o) { return this._frozen = o, this }, reset: function () { for (const o in this.list) delete this.list[o], delete this.values[o]; return this._frozen = !1, this }, destroy: function () { this.reset(), this.events.off(h.CHANGE_DATA), this.events.off(h.SET_DATA), this.events.off(h.REMOVE_DATA), this.parent = null }, freeze: { get: function () { return this._frozen }, set: function (o) { this._frozen = !!o } }, count: { get: function () { let o = 0; for (const r in this.list) this.list[r] !== void 0 && o++; return o } } }); e.exports = n }, function (e, d, t) { const i = t(0); const h = new i({ initialize: function (o) { if (this.entries = {}, this.size = 0, Array.isArray(o)) for (let r = 0; r < o.length; r++) this.set(o[r][0], o[r][1]) }, set: function (n, o) { return this.has(n) || this.size++, this.entries[n] = o, this }, get: function (n) { if (this.has(n)) return this.entries[n] }, getArray: function () { const n = []; const o = this.entries; for (const r in o)n.push(o[r]); return n }, has: function (n) { return this.entries.hasOwnProperty(n) }, delete: function (n) { return this.has(n) && (delete this.entries[n], this.size--), this }, clear: function () { return Object.keys(this.entries).forEach(function (n) { delete this.entries[n] }, this), this.size = 0, this }, keys: function () { return Object.keys(this.entries) }, values: function () { const n = []; const o = this.entries; for (const r in o)n.push(o[r]); return n }, dump: function () { const n = this.entries; console.group('Map'); for (const o in n)console.log(o, n[o]); console.groupEnd() }, each: function (n) { const o = this.entries; for (const r in o) if (n(r, o[r]) === !1) break; return this }, contains: function (n) { const o = this.entries; for (const r in o) if (o[r] === n) return !0; return !1 }, merge: function (n, o) { o === void 0 && (o = !1); const r = this.entries; const s = n.entries; for (const a in s)r.hasOwnProperty(a) && o ? r[a] = s[a] : this.set(a, s[a]); return this } }); e.exports = h }, function (e, d) { const t = function (i, h, n) { return i << 16 | h << 8 | n }; e.exports = t }, function (e, d, t) { e.exports = { ENTER_FULLSCREEN: t(800), FULLSCREEN_FAILED: t(801), FULLSCREEN_UNSUPPORTED: t(802), LEAVE_FULLSCREEN: t(803), ORIENTATION_CHANGE: t(804), RESIZE: t(805) } }, function (e, d, t) { (function (i) { const h = { android: !1, chromeOS: !1, cordova: !1, crosswalk: !1, desktop: !1, ejecta: !1, electron: !1, iOS: !1, iOSVersion: 0, iPad: !1, iPhone: !1, kindle: !1, linux: !1, macOS: !1, node: !1, nodeWebkit: !1, pixelRatio: 1, webApp: !1, windows: !1, windowsPhone: !1 }; function n () { if (typeof importScripts === 'function') return h; const o = navigator.userAgent; /Windows/.test(o) ? h.windows = !0 : /Mac OS/.test(o) && !/like Mac OS/.test(o) ? navigator.maxTouchPoints && navigator.maxTouchPoints > 2 ? (h.iOS = !0, h.iPad = !0, navigator.appVersion.match(/Version\/(\d+)/), h.iOSVersion = parseInt(RegExp.$1, 10)) : h.macOS = !0 : /Android/.test(o) ? h.android = !0 : /Linux/.test(o) ? h.linux = !0 : /iP[ao]d|iPhone/i.test(o) ? (h.iOS = !0, navigator.appVersion.match(/OS (\d+)/), h.iOSVersion = parseInt(RegExp.$1, 10), h.iPhone = o.toLowerCase().indexOf('iphone') !== -1, h.iPad = o.toLowerCase().indexOf('ipad') !== -1) : /Kindle/.test(o) || /\bKF[A-Z][A-Z]+/.test(o) || /Silk.*Mobile Safari/.test(o) ? h.kindle = !0 : /CrOS/.test(o) && (h.chromeOS = !0), (/Windows Phone/i.test(o) || /IEMobile/i.test(o)) && (h.android = !1, h.iOS = !1, h.macOS = !1, h.windows = !0, h.windowsPhone = !0); const r = /Silk/.test(o); return (h.windows || h.macOS || h.linux && !r || h.chromeOS) && (h.desktop = !0), (h.windowsPhone || /Windows NT/i.test(o) && /Touch/i.test(o)) && (h.desktop = !1), navigator.standalone && (h.webApp = !0), typeof importScripts !== 'function' && (window.cordova !== void 0 && (h.cordova = !0), window.ejecta !== void 0 && (h.ejecta = !0)), typeof i !== 'undefined' && i.versions && i.versions.node && (h.node = !0), h.node && typeof i.versions === 'object' && (h.nodeWebkit = !!i.versions['node-webkit'], h.electron = !!i.versions.electron), /Crosswalk/.test(o) && (h.crosswalk = !0), h.pixelRatio = window.devicePixelRatio || 1, h }e.exports = n() }).call(this, t(807)) }, function (e, d, t) { e.exports = { ADD: t(861), ERROR: t(862), LOAD: t(863), READY: t(864), REMOVE: t(865) } }, function (e, d) { const t = { BYTE: { enum: 5120, size: 1 }, UNSIGNED_BYTE: { enum: 5121, size: 1 }, SHORT: { enum: 5122, size: 2 }, UNSIGNED_SHORT: { enum: 5123, size: 2 }, INT: { enum: 5124, size: 4 }, UNSIGNED_INT: { enum: 5125, size: 4 }, FLOAT: { enum: 5126, size: 4 } }; e.exports = t }, function (e, d, t) { const i = t(0); const h = t(59); const n = t(2); const o = t(878); const r = t(879); const s = t(25); const a = t(12); const f = t(107); const l = t(58); const u = new i({ Extends: l, initialize: function (p) { const c = p.game.renderer; const m = n(p, 'fragShader', o); p.fragShader = a.parseFragmentShaderMaxTextures(m, c.maxTextures), p.vertShader = n(p, 'vertShader', r), p.attributes = n(p, 'attributes', [{ name: 'inPosition', size: 2 }, { name: 'inTexCoord', size: 2 }, { name: 'inTexId' }, { name: 'inTintEffect' }, { name: 'inTint', size: 4, type: f.UNSIGNED_BYTE, normalized: !0 }]), l.call(this, p), this._tempMatrix1 = new s(), this._tempMatrix2 = new s(), this._tempMatrix3 = new s(), this.calcMatrix = new s(), this.tempTriangle = [{ x: 0, y: 0, width: 0 }, { x: 0, y: 0, width: 0 }, { x: 0, y: 0, width: 0 }, { x: 0, y: 0, width: 0 }], this.strokeTint = { TL: 0, TR: 0, BL: 0, BR: 0 }, this.fillTint = { TL: 0, TR: 0, BL: 0, BR: 0 }, this.currentFrame = { u0: 0, v0: 0, u1: 1, v1: 1 }, this.firstQuad = [0, 0, 0, 0, 0], this.prevQuad = [0, 0, 0, 0, 0], this.polygonCache = [] }, boot: function () { l.prototype.boot.call(this), this.currentShader.set1iv('uMainSampler', this.renderer.textureIndexes) }, batchSprite: function (v, p, c) { this.manager.set(this, v); const m = this._tempMatrix1; const g = this._tempMatrix2; const x = this._tempMatrix3; const y = v.frame; const T = y.glTexture; let S = y.u0; let E = y.v0; let C = y.u1; let P = y.v1; let A = y.x; let M = y.y; let L = y.cutWidth; let F = y.cutHeight; const I = y.customPivot; const G = v.displayOriginX; const U = v.displayOriginY; let Y = -G + A; let X = -U + M; if (v.isCropped) { const O = v._crop; (O.flipX !== v.flipX || O.flipY !== v.flipY) && y.updateCropUVs(O, v.flipX, v.flipY), S = O.u0, E = O.v0, C = O.u1, P = O.v1, L = O.width, F = O.height, A = O.x, M = O.y, Y = -G + A, X = -U + M } let R = 1; let D = 1; v.flipX && (I || (Y += -y.realWidth + G * 2), R = -1), (v.flipY || y.source.isGLTexture && !T.flipY) && (I || (X += -y.realHeight + U * 2), D = -1), g.applyITRS(v.x, v.y, v.rotation, v.scaleX * R, v.scaleY * D), m.copyFrom(p.matrix), c ? (m.multiplyWithOffset(c, -p.scrollX * v.scrollFactorX, -p.scrollY * v.scrollFactorY), g.e = v.x, g.f = v.y) : (g.e -= p.scrollX * v.scrollFactorX, g.f -= p.scrollY * v.scrollFactorY), m.multiply(g, x); const B = Y + L; const N = X + F; const w = p.roundPixels; const z = x.getXRound(Y, X, w); const V = x.getYRound(Y, X, w); const W = x.getXRound(Y, N, w); const H = x.getYRound(Y, N, w); const K = x.getXRound(B, N, w); const Q = x.getYRound(B, N, w); const J = x.getXRound(B, X, w); const q = x.getYRound(B, X, w); const j = a.getTintAppendFloatAlpha; const _ = p.alpha; const rt = j(v.tintTopLeft, _ * v._alphaTL); const nt = j(v.tintTopRight, _ * v._alphaTR); const et = j(v.tintBottomLeft, _ * v._alphaBL); const b = j(v.tintBottomRight, _ * v._alphaBR); this.shouldFlush(6) && this.flush(); const at = this.setGameObject(v, y); this.manager.preBatch(v), this.batchQuad(v, z, V, W, H, K, Q, J, q, S, E, C, P, rt, nt, et, b, v.tintFill, T, at), this.manager.postBatch(v) }, batchTexture: function (v, p, c, m, g, x, y, T, S, E, C, P, A, M, L, F, I, G, U, Y, X, O, R, D, B, N, w, z, V, W, H, K) { this.manager.set(this, v); const Q = this._tempMatrix1; const J = this._tempMatrix2; const q = this._tempMatrix3; let j = G / c + w; let _ = U / m + z; let rt = (G + Y) / c + w; let nt = (U + X) / m + z; let et = y; let b = T; let at = -F; let it = -I; if (v.isCropped) { const st = v._crop; const Kt = st.width; const Zt = st.height; et = Kt, b = Zt, y = Kt, T = Zt, G = st.x, U = st.y; let ct = G; let lt = U; P && (ct = Y - st.x - Kt), A && (lt = X - st.y - Zt), j = ct / c + w, _ = lt / m + z, rt = (ct + Kt) / c + w, nt = (lt + Zt) / m + z, at = -F + G, it = -I + U }A = A ^ (!H && p.isRenderTexture ? 1 : 0), P && (et *= -1, at += y), A && (b *= -1, it += T); const Pt = at + et; const Ct = it + b; J.applyITRS(g, x, C, S, E), Q.copyFrom(V.matrix), W ? (Q.multiplyWithOffset(W, -V.scrollX * M, -V.scrollY * L), J.e = g, J.f = x) : (J.e -= V.scrollX * M, J.f -= V.scrollY * L), Q.multiply(J, q); const St = V.roundPixels; const Qt = q.getXRound(at, it, St); const Oe = q.getYRound(at, it, St); const Fe = q.getXRound(at, Ct, St); const De = q.getYRound(at, Ct, St); const Ie = q.getXRound(Pt, Ct, St); const Be = q.getYRound(Pt, Ct, St); const Ne = q.getXRound(Pt, it, St); const Md = q.getYRound(Pt, it, St); K === void 0 && (K = this.renderer.setTexture2D(p)), v && this.manager.preBatch(v), this.batchQuad(v, Qt, Oe, Fe, De, Ie, Be, Ne, Md, j, _, rt, nt, O, R, D, B, N, p, K), v && this.manager.postBatch(v) }, batchTextureFrame: function (v, p, c, m, g, x, y) { this.manager.set(this); const T = this._tempMatrix1.copyFrom(x); let S = this._tempMatrix2; const E = p + v.width; const C = c + v.height; y ? T.multiply(y, S) : S = T; const P = S.getX(p, c); const A = S.getY(p, c); const M = S.getX(p, C); const L = S.getY(p, C); const F = S.getX(E, C); const I = S.getY(E, C); const G = S.getX(E, c); const U = S.getY(E, c); const Y = this.renderer.setTextureSource(v.source); m = a.getTintAppendFloatAlpha(m, g), this.batchQuad(null, P, A, M, L, F, I, G, U, v.u0, v.v0, v.u1, v.v1, m, m, m, m, 0, v.glTexture, Y) }, batchFillRect: function (v, p, c, m, g, x) { this.renderer.pipelines.set(this); const y = this.calcMatrix; x && x.multiply(g, y); const T = v + c; const S = p + m; const E = y.getX(v, p); const C = y.getY(v, p); const P = y.getX(v, S); const A = y.getY(v, S); const M = y.getX(T, S); const L = y.getY(T, S); const F = y.getX(T, p); const I = y.getY(T, p); const G = this.fillTint; this.batchQuad(null, E, C, P, A, M, L, F, I, 0, 0, 1, 1, G.TL, G.TR, G.BL, G.BR, 2) }, batchFillTriangle: function (v, p, c, m, g, x, y, T) { this.renderer.pipelines.set(this); const S = this.calcMatrix; T && T.multiply(y, S); const E = S.getX(v, p); const C = S.getY(v, p); const P = S.getX(c, m); const A = S.getY(c, m); const M = S.getX(g, x); const L = S.getY(g, x); const F = this.fillTint; this.batchTri(null, E, C, P, A, M, L, 0, 0, 1, 1, F.TL, F.TR, F.BL, 2) }, batchStrokeTriangle: function (v, p, c, m, g, x, y, T, S) { const E = this.tempTriangle; E[0].x = v, E[0].y = p, E[0].width = y, E[1].x = c, E[1].y = m, E[1].width = y, E[2].x = g, E[2].y = x, E[2].width = y, E[3].x = v, E[3].y = p, E[3].width = y, this.batchStrokePath(E, y, !1, T, S) }, batchFillPath: function (v, p, c) { this.renderer.pipelines.set(this); const m = this.calcMatrix; c && c.multiply(p, m); for (var g = v.length, x = this.polygonCache, y, T, S = this.fillTint.TL, E = this.fillTint.TR, C = this.fillTint.BL, P = 0; P < g; ++P)T = v[P], x.push(T.x, T.y); y = h(x), g = y.length; for (let A = 0; A < g; A += 3) { const M = y[A + 0] * 2; const L = y[A + 1] * 2; const F = y[A + 2] * 2; const I = x[M + 0]; const G = x[M + 1]; const U = x[L + 0]; const Y = x[L + 1]; const X = x[F + 0]; const O = x[F + 1]; const R = m.getX(I, G); const D = m.getY(I, G); const B = m.getX(U, Y); const N = m.getY(U, Y); const w = m.getX(X, O); const z = m.getY(X, O); this.batchTri(null, R, D, B, N, w, z, 0, 0, 1, 1, S, E, C, 2) }x.length = 0 }, batchStrokePath: function (v, p, c, m, g) { this.renderer.pipelines.set(this), this.prevQuad[4] = 0, this.firstQuad[4] = 0; for (let x = v.length - 1, y = 0; y < x; y++) { const T = v[y]; const S = v[y + 1]; this.batchLine(T.x, T.y, S.x, S.y, T.width / 2, S.width / 2, p, y, !c && y === x - 1, m, g) } }, batchLine: function (v, p, c, m, g, x, y, T, S, E, C) { this.renderer.pipelines.set(this); const P = this.calcMatrix; C && C.multiply(E, P); const A = c - v; const M = m - p; const L = Math.sqrt(A * A + M * M); const F = g * (m - p) / L; const I = g * (v - c) / L; const G = x * (m - p) / L; const U = x * (v - c) / L; const Y = c - G; const X = m - U; const O = v - F; const R = p - I; const D = c + G; const B = m + U; const N = v + F; const w = p + I; const z = P.getX(Y, X); const V = P.getY(Y, X); const W = P.getX(O, R); const H = P.getY(O, R); const K = P.getX(D, B); const Q = P.getY(D, B); const J = P.getX(N, w); const q = P.getY(N, w); const j = this.strokeTint; const _ = j.TL; const rt = j.TR; const nt = j.BL; const et = j.BR; if (this.batchQuad(null, J, q, W, H, z, V, K, Q, 0, 0, 1, 1, _, rt, nt, et, 2), !(y <= 2)) { const b = this.prevQuad; const at = this.firstQuad; T > 0 && b[4] ? this.batchQuad(null, J, q, W, H, b[0], b[1], b[2], b[3], 0, 0, 1, 1, _, rt, nt, et, 2) : (at[0] = J, at[1] = q, at[2] = W, at[3] = H, at[4] = 1), S && at[4] ? this.batchQuad(null, z, V, K, Q, at[0], at[1], at[2], at[3], 0, 0, 1, 1, _, rt, nt, et, 2) : (b[0] = z, b[1] = V, b[2] = K, b[3] = Q, b[4] = 1) } } }); e.exports = u }, function (e, d, t) { const i = t(0); const h = t(18); const n = t(17); var o = new i({ initialize: function (s, a, f, l, u, v, p) { this.texture = s, this.name = a, this.source = s.source[f], this.sourceIndex = f, this.glTexture = this.source.glTexture, this.cutX, this.cutY, this.cutWidth, this.cutHeight, this.x = 0, this.y = 0, this.width, this.height, this.halfWidth, this.halfHeight, this.centerX, this.centerY, this.pivotX = 0, this.pivotY = 0, this.customPivot = !1, this.rotated = !1, this.autoRound = -1, this.customData = {}, this.u0 = 0, this.v0 = 0, this.u1 = 0, this.v1 = 0, this.data = { cut: { x: 0, y: 0, w: 0, h: 0, r: 0, b: 0 }, trim: !1, sourceSize: { w: 0, h: 0 }, spriteSourceSize: { x: 0, y: 0, w: 0, h: 0, r: 0, b: 0 }, radius: 0, drawImage: { x: 0, y: 0, width: 0, height: 0 } }, this.setSize(v, p, l, u) }, setSize: function (r, s, a, f) { a === void 0 && (a = 0), f === void 0 && (f = 0), this.cutX = a, this.cutY = f, this.cutWidth = r, this.cutHeight = s, this.width = r, this.height = s, this.halfWidth = Math.floor(r * 0.5), this.halfHeight = Math.floor(s * 0.5), this.centerX = Math.floor(r / 2), this.centerY = Math.floor(s / 2); const l = this.data; const u = l.cut; u.x = a, u.y = f, u.w = r, u.h = s, u.r = a + r, u.b = f + s, l.sourceSize.w = r, l.sourceSize.h = s, l.spriteSourceSize.w = r, l.spriteSourceSize.h = s, l.radius = 0.5 * Math.sqrt(r * r + s * s); const v = l.drawImage; return v.x = a, v.y = f, v.width = r, v.height = s, this.updateUVs() }, setTrim: function (r, s, a, f, l, u) { const v = this.data; const p = v.spriteSourceSize; return v.trim = !0, v.sourceSize.w = r, v.sourceSize.h = s, p.x = a, p.y = f, p.w = l, p.h = u, p.r = a + l, p.b = f + u, this.x = a, this.y = f, this.width = l, this.height = u, this.halfWidth = l * 0.5, this.halfHeight = u * 0.5, this.centerX = Math.floor(l / 2), this.centerY = Math.floor(u / 2), this.updateUVs() }, setCropUVs: function (r, s, a, f, l, u, v) { const p = this.cutX; const c = this.cutY; const m = this.cutWidth; const g = this.cutHeight; const x = this.realWidth; const y = this.realHeight; s = h(s, 0, x), a = h(a, 0, y), f = h(f, 0, x - s), l = h(l, 0, y - a); let T = p + s; let S = c + a; let E = f; let C = l; const P = this.data; if (P.trim) { const A = P.spriteSourceSize; f = h(f, 0, m - s), l = h(l, 0, g - a); const M = s + f; const L = a + l; const F = !(A.r < s || A.b < a || A.x > M || A.y > L); if (F) { const I = Math.max(A.x, s); const G = Math.max(A.y, a); const U = Math.min(A.r, M) - I; const Y = Math.min(A.b, L) - G; E = U, C = Y, u ? T = p + (m - (I - A.x) - U) : T = p + (I - A.x), v ? S = c + (g - (G - A.y) - Y) : S = c + (G - A.y), s = I, a = G, f = U, l = Y } else T = 0, S = 0, E = 0, C = 0 } else u && (T = p + (m - s - f)), v && (S = c + (g - a - l)); const X = this.source.width; const O = this.source.height; return r.u0 = Math.max(0, T / X), r.v0 = Math.max(0, S / O), r.u1 = Math.min(1, (T + E) / X), r.v1 = Math.min(1, (S + C) / O), r.x = s, r.y = a, r.cx = T, r.cy = S, r.cw = E, r.ch = C, r.width = f, r.height = l, r.flipX = u, r.flipY = v, r }, updateCropUVs: function (r, s, a) { return this.setCropUVs(r, r.x, r.y, r.width, r.height, s, a) }, setUVs: function (r, s, a, f, l, u) { const v = this.data.drawImage; return v.width = r, v.height = s, this.u0 = a, this.v0 = f, this.u1 = l, this.v1 = u, this }, updateUVs: function () { const r = this.cutX; const s = this.cutY; const a = this.cutWidth; const f = this.cutHeight; const l = this.data.drawImage; l.width = a, l.height = f; const u = this.source.width; const v = this.source.height; return this.u0 = r / u, this.v0 = s / v, this.u1 = (r + a) / u, this.v1 = (s + f) / v, this }, updateUVsInverted: function () { const r = this.source.width; const s = this.source.height; return this.u0 = (this.cutX + this.cutHeight) / r, this.v0 = this.cutY / s, this.u1 = this.cutX / r, this.v1 = (this.cutY + this.cutWidth) / s, this }, clone: function () { const r = new o(this.texture, this.name, this.sourceIndex); return r.cutX = this.cutX, r.cutY = this.cutY, r.cutWidth = this.cutWidth, r.cutHeight = this.cutHeight, r.x = this.x, r.y = this.y, r.width = this.width, r.height = this.height, r.halfWidth = this.halfWidth, r.halfHeight = this.halfHeight, r.centerX = this.centerX, r.centerY = this.centerY, r.rotated = this.rotated, r.data = n(!0, r.data, this.data), r.updateUVs(), r }, destroy: function () { this.source = null, this.texture = null, this.glTexture = null, this.customData = null, this.data = null }, realWidth: { get: function () { return this.data.sourceSize.w } }, realHeight: { get: function () { return this.data.sourceSize.h } }, radius: { get: function () { return this.data.radius } }, trimmed: { get: function () { return this.data.trim } }, canvasData: { get: function () { return this.data.drawImage } } }); e.exports = o }, function (e, d, t) { const i = t(208); const h = t(0); const n = t(1); const o = t(79); const r = new h({ initialize: function (a) { this.parent = a, this.list = [], this.position = 0, this.addCallback = n, this.removeCallback = n, this._sortKey = '' }, add: function (s, a) { return a ? i.Add(this.list, s) : i.Add(this.list, s, 0, this.addCallback, this) }, addAt: function (s, a, f) { return f ? i.AddAt(this.list, s, a) : i.AddAt(this.list, s, a, 0, this.addCallback, this) }, getAt: function (s) { return this.list[s] }, getIndex: function (s) { return this.list.indexOf(s) }, sort: function (s, a) { return s ? (a === void 0 && (a = function (f, l) { return f[s] - l[s] }), o(this.list, a), this) : this }, getByName: function (s) { return i.GetFirst(this.list, 'name', s) }, getRandom: function (s, a) { return i.GetRandom(this.list, s, a) }, getFirst: function (s, a, f, l) { return i.GetFirst(this.list, s, a, f, l) }, getAll: function (s, a, f, l) { return i.GetAll(this.list, s, a, f, l) }, count: function (s, a) { return i.CountAllMatching(this.list, s, a) }, swap: function (s, a) { i.Swap(this.list, s, a) }, moveTo: function (s, a) { return i.MoveTo(this.list, s, a) }, moveAbove: function (s, a) { return i.MoveAbove(this.list, s, a) }, moveBelow: function (s, a) { return i.MoveBelow(this.list, s, a) }, remove: function (s, a) { return a ? i.Remove(this.list, s) : i.Remove(this.list, s, this.removeCallback, this) }, removeAt: function (s, a) { return a ? i.RemoveAt(this.list, s) : i.RemoveAt(this.list, s, this.removeCallback, this) }, removeBetween: function (s, a, f) { return f ? i.RemoveBetween(this.list, s, a) : i.RemoveBetween(this.list, s, a, this.removeCallback, this) }, removeAll: function (s) { for (let a = this.list.length; a--;) this.remove(this.list[a], s); return this }, bringToTop: function (s) { return i.BringToTop(this.list, s) }, sendToBack: function (s) { return i.SendToBack(this.list, s) }, moveUp: function (s) { return i.MoveUp(this.list, s), s }, moveDown: function (s) { return i.MoveDown(this.list, s), s }, reverse: function () { return this.list.reverse(), this }, shuffle: function () { return i.Shuffle(this.list), this }, replace: function (s, a) { return i.Replace(this.list, s, a) }, exists: function (s) { return this.list.indexOf(s) > -1 }, setAll: function (s, a, f, l) { return i.SetAll(this.list, s, a, f, l), this }, each: function (s, a) { for (var f = [null], l = 2; l < arguments.length; l++)f.push(arguments[l]); for (l = 0; l < this.list.length; l++)f[0] = this.list[l], s.apply(a, f) }, shutdown: function () { this.removeAll(), this.list = [] }, destroy: function () { this.removeAll(), this.parent = null, this.addCallback = null, this.removeCallback = null }, length: { get: function () { return this.list.length } }, first: { get: function () { return this.position = 0, this.list.length > 0 ? this.list[0] : null } }, last: { get: function () { return this.list.length > 0 ? (this.position = this.list.length - 1, this.list[this.position]) : null } }, next: { get: function () { return this.position < this.list.length ? (this.position++, this.list[this.position]) : null } }, previous: { get: function () { return this.position > 0 ? (this.position--, this.list[this.position]) : null } } }); e.exports = r }, function (e, d, t) { const i = t(0); const h = t(112); const n = t(445); const o = t(446); const r = t(56); const s = t(180); const a = new i({ initialize: function (l, u, v, p) { l === void 0 && (l = 0), u === void 0 && (u = 0), v === void 0 && (v = 0), p === void 0 && (p = 0), this.type = r.ELLIPSE, this.x = l, this.y = u, this.width = v, this.height = p }, contains: function (f, l) { return h(this, f, l) }, getPoint: function (f, l) { return n(this, f, l) }, getPoints: function (f, l, u) { return o(this, f, l, u) }, getRandomPoint: function (f) { return s(this, f) }, setTo: function (f, l, u, v) { return this.x = f, this.y = l, this.width = u, this.height = v, this }, setEmpty: function () { return this.width = 0, this.height = 0, this }, setPosition: function (f, l) { return l === void 0 && (l = f), this.x = f, this.y = l, this }, setSize: function (f, l) { return l === void 0 && (l = f), this.width = f, this.height = l, this }, isEmpty: function () { return this.width <= 0 || this.height <= 0 }, getMinorRadius: function () { return Math.min(this.width, this.height) / 2 }, getMajorRadius: function () { return Math.max(this.width, this.height) / 2 }, left: { get: function () { return this.x - this.width / 2 }, set: function (f) { this.x = f + this.width / 2 } }, right: { get: function () { return this.x + this.width / 2 }, set: function (f) { this.x = f - this.width / 2 } }, top: { get: function () { return this.y - this.height / 2 }, set: function (f) { this.y = f + this.height / 2 } }, bottom: { get: function () { return this.y + this.height / 2 }, set: function (f) { this.y = f - this.height / 2 } } }); e.exports = a }, function (e, d) { const t = function (i, h, n) { if (i.width <= 0 || i.height <= 0) return !1; let o = (h - i.x) / i.width; let r = (n - i.y) / i.height; return o *= o, r *= r, o + r < 0.25 }; e.exports = t }, function (e, d, t) { const i = t(275); const h = t(0); const n = t(75); const o = t(9); const r = t(207); const s = t(2); const a = t(6); const f = t(7); const l = t(437); const u = t(149); const v = t(73); const p = new h({ Extends: o, initialize: function (m, g, x) { o.call(this), x ? g && !Array.isArray(g) && (g = [g]) : Array.isArray(g) ? f(g[0]) && (x = g, g = null) : f(g) && (x = g, g = null), this.scene = m, this.children = new u(), this.isParent = !0, this.type = 'Group', this.classType = s(x, 'classType', v), this.name = s(x, 'name', ''), this.active = s(x, 'active', !0), this.maxSize = s(x, 'maxSize', -1), this.defaultKey = s(x, 'defaultKey', null), this.defaultFrame = s(x, 'defaultFrame', null), this.runChildUpdate = s(x, 'runChildUpdate', !1), this.createCallback = s(x, 'createCallback', null), this.removeCallback = s(x, 'removeCallback', null), this.createMultipleCallback = s(x, 'createMultipleCallback', null), this.internalCreateCallback = s(x, 'internalCreateCallback', null), this.internalRemoveCallback = s(x, 'internalRemoveCallback', null), g && this.addMultiple(g), x && this.createMultiple(x), this.on(n.ADDED_TO_SCENE, this.addedToScene, this), this.on(n.REMOVED_FROM_SCENE, this.removedFromScene, this) }, addedToScene: function () { this.scene.sys.updateList.add(this) }, removedFromScene: function () { this.scene.sys.updateList.remove(this) }, create: function (c, m, g, x, y, T) { if (c === void 0 && (c = 0), m === void 0 && (m = 0), g === void 0 && (g = this.defaultKey), x === void 0 && (x = this.defaultFrame), y === void 0 && (y = !0), T === void 0 && (T = !0), this.isFull()) return null; const S = new this.classType(this.scene, c, m, g, x); return S.addToDisplayList(this.scene.sys.displayList), S.addToUpdateList(), S.visible = y, S.setActive(T), this.add(S), S }, createMultiple: function (c) { if (this.isFull()) return []; Array.isArray(c) || (c = [c]); let m = []; if (c[0].key) for (let g = 0; g < c.length; g++) { const x = this.createFromConfig(c[g]); m = m.concat(x) } return m }, createFromConfig: function (c) { if (this.isFull()) return []; this.classType = s(c, 'classType', this.classType); let m = s(c, 'key', void 0); let g = s(c, 'frame', null); const x = s(c, 'visible', !0); const y = s(c, 'active', !0); const T = []; if (m === void 0) return T; Array.isArray(m) || (m = [m]), Array.isArray(g) || (g = [g]); const S = s(c, 'repeat', 0); const E = s(c, 'randomKey', !1); const C = s(c, 'randomFrame', !1); const P = s(c, 'yoyo', !1); const A = s(c, 'quantity', !1); const M = s(c, 'frameQuantity', 1); const L = s(c, 'max', 0); const F = l(m, g, { max: L, qty: A || M, random: E, randomB: C, repeat: S, yoyo: P }); c.createCallback && (this.createCallback = c.createCallback), c.removeCallback && (this.removeCallback = c.removeCallback); for (let I = 0; I < F.length; I++) { const G = this.create(0, 0, F[I].a, F[I].b, x, y); if (!G) break; T.push(G) } const U = a(c, 'setXY.x', 0); const Y = a(c, 'setXY.y', 0); const X = a(c, 'setXY.stepX', 0); const O = a(c, 'setXY.stepY', 0); i.SetXY(T, U, Y, X, O); const R = a(c, 'setRotation.value', 0); const D = a(c, 'setRotation.step', 0); i.SetRotation(T, R, D); const B = a(c, 'setScale.x', 1); const N = a(c, 'setScale.y', B); const w = a(c, 'setScale.stepX', 0); const z = a(c, 'setScale.stepY', 0); i.SetScale(T, B, N, w, z); const V = a(c, 'setOrigin.x', 0.5); const W = a(c, 'setOrigin.y', V); const H = a(c, 'setOrigin.stepX', 0); const K = a(c, 'setOrigin.stepY', 0); i.SetOrigin(T, V, W, H, K); const Q = a(c, 'setAlpha.value', 1); const J = a(c, 'setAlpha.step', 0); i.SetAlpha(T, Q, J); const q = a(c, 'setDepth.value', 0); const j = a(c, 'setDepth.step', 0); i.SetDepth(T, q, j); const _ = a(c, 'setScrollFactor.x', 1); const rt = a(c, 'setScrollFactor.y', _); const nt = a(c, 'setScrollFactor.stepX', 0); const et = a(c, 'setScrollFactor.stepY', 0); i.SetScrollFactor(T, _, rt, nt, et); const b = s(c, 'hitArea', null); const at = s(c, 'hitAreaCallback', null); b && i.SetHitArea(T, b, at); const it = s(c, 'gridAlign', !1); return it && i.GridAlign(T, it), this.createMultipleCallback && this.createMultipleCallback.call(this, T), T }, preUpdate: function (c, m) { if (!(!this.runChildUpdate || this.children.size === 0)) for (let g = this.children.entries.slice(), x = 0; x < g.length; x++) { const y = g[x]; y.active && y.update(c, m) } }, add: function (c, m) { return m === void 0 && (m = !1), this.isFull() ? this : (this.children.set(c), this.internalCreateCallback && this.internalCreateCallback.call(this, c), this.createCallback && this.createCallback.call(this, c), m && (c.addToDisplayList(this.scene.sys.displayList), c.addToUpdateList()), c.on(n.DESTROY, this.remove, this), this) }, addMultiple: function (c, m) { if (m === void 0 && (m = !1), Array.isArray(c)) for (let g = 0; g < c.length; g++) this.add(c[g], m); return this }, remove: function (c, m, g) { return m === void 0 && (m = !1), g === void 0 && (g = !1), this.children.contains(c) ? (this.children.delete(c), this.internalRemoveCallback && this.internalRemoveCallback.call(this, c), this.removeCallback && this.removeCallback.call(this, c), c.off(n.DESTROY, this.remove, this), g ? c.destroy() : m && (c.removeFromDisplayList(), c.removeFromUpdateList()), this) : this }, clear: function (c, m) { c === void 0 && (c = !1), m === void 0 && (m = !1); for (let g = this.children, x = 0; x < g.size; x++) { const y = g.entries[x]; y.off(n.DESTROY, this.remove, this), m ? y.destroy() : c && (y.removeFromDisplayList(), y.removeFromUpdateList()) } return this.children.clear(), this }, contains: function (c) { return this.children.contains(c) }, getChildren: function () { return this.children.entries }, getLength: function () { return this.children.size }, getMatching: function (c, m, g, x) { return r(this.children.entries, c, m, g, x) }, getFirst: function (c, m, g, x, y, T, S) { return this.getHandler(!0, 1, c, m, g, x, y, T, S) }, getFirstNth: function (c, m, g, x, y, T, S, E) { return this.getHandler(!0, c, m, g, x, y, T, S, E) }, getLast: function (c, m, g, x, y, T, S) { return this.getHandler(!1, 1, c, m, g, x, y, T, S) }, getLastNth: function (c, m, g, x, y, T, S, E) { return this.getHandler(!1, c, m, g, x, y, T, S, E) }, getHandler: function (c, m, g, x, y, T, S, E, C) { g === void 0 && (g = !1), x === void 0 && (x = !1); let P; let A; let M = 0; const L = this.children.entries; if (c) for (A = 0; A < L.length; A++) if (P = L[A], P.active === g) { if (M++, M === m) break } else P = null; else for (A = L.length - 1; A >= 0; A--) if (P = L[A], P.active === g) { if (M++, M === m) break } else P = null; return P ? (typeof y === 'number' && (P.x = y), typeof T === 'number' && (P.y = T), P) : x ? this.create(y, T, S, E, C) : null }, get: function (c, m, g, x, y) { return this.getFirst(!1, !0, c, m, g, x, y) }, getFirstAlive: function (c, m, g, x, y, T) { return this.getFirst(!0, c, m, g, x, y, T) }, getFirstDead: function (c, m, g, x, y, T) { return this.getFirst(!1, c, m, g, x, y, T) }, playAnimation: function (c, m) { return i.PlayAnimation(this.children.entries, c, m), this }, isFull: function () { return this.maxSize === -1 ? !1 : this.children.size >= this.maxSize }, countActive: function (c) { c === void 0 && (c = !0); for (var m = 0, g = 0; g < this.children.size; g++) this.children.entries[g].active === c && m++; return m }, getTotalUsed: function () { return this.countActive() }, getTotalFree: function () { const c = this.getTotalUsed(); const m = this.maxSize === -1 ? 999999999999 : this.maxSize; return m - c }, setActive: function (c) { return this.active = c, this }, setName: function (c) { return this.name = c, this }, propertyValueSet: function (c, m, g, x, y) { return i.PropertyValueSet(this.children.entries, c, m, g, x, y), this }, propertyValueInc: function (c, m, g, x, y) { return i.PropertyValueInc(this.children.entries, c, m, g, x, y), this }, setX: function (c, m) { return i.SetX(this.children.entries, c, m), this }, setY: function (c, m) { return i.SetY(this.children.entries, c, m), this }, setXY: function (c, m, g, x) { return i.SetXY(this.children.entries, c, m, g, x), this }, incX: function (c, m) { return i.IncX(this.children.entries, c, m), this }, incY: function (c, m) { return i.IncY(this.children.entries, c, m), this }, incXY: function (c, m, g, x) { return i.IncXY(this.children.entries, c, m, g, x), this }, shiftPosition: function (c, m, g) { return i.ShiftPosition(this.children.entries, c, m, g), this }, angle: function (c, m) { return i.Angle(this.children.entries, c, m), this }, rotate: function (c, m) { return i.Rotate(this.children.entries, c, m), this }, rotateAround: function (c, m) { return i.RotateAround(this.children.entries, c, m), this }, rotateAroundDistance: function (c, m, g) { return i.RotateAroundDistance(this.children.entries, c, m, g), this }, setAlpha: function (c, m) { return i.SetAlpha(this.children.entries, c, m), this }, setTint: function (c, m, g, x) { return i.SetTint(this.children.entries, c, m, g, x), this }, setOrigin: function (c, m, g, x) { return i.SetOrigin(this.children.entries, c, m, g, x), this }, scaleX: function (c, m) { return i.ScaleX(this.children.entries, c, m), this }, scaleY: function (c, m) { return i.ScaleY(this.children.entries, c, m), this }, scaleXY: function (c, m, g, x) { return i.ScaleXY(this.children.entries, c, m, g, x), this }, setDepth: function (c, m) { return i.SetDepth(this.children.entries, c, m), this }, setBlendMode: function (c) { return i.SetBlendMode(this.children.entries, c), this }, setHitArea: function (c, m) { return i.SetHitArea(this.children.entries, c, m), this }, shuffle: function () { return i.Shuffle(this.children.entries), this }, kill: function (c) { this.children.contains(c) && c.setActive(!1) }, killAndHide: function (c) { this.children.contains(c) && (c.setActive(!1), c.setVisible(!1)) }, setVisible: function (c, m, g) { return i.SetVisible(this.children.entries, c, m, g), this }, toggleVisible: function () { return i.ToggleVisible(this.children.entries), this }, destroy: function (c, m) { c === void 0 && (c = !1), m === void 0 && (m = !1), !(!this.scene || this.ignoreDestroy) && (this.emit(n.DESTROY, this), this.removeAllListeners(), this.scene.sys.updateList.remove(this), this.clear(m, c), this.scene = void 0, this.children = void 0) } }); e.exports = p }, function (e, d, t) { const i = t(12); const h = function (n, o, r, s, a, f) { for (let l = i.getTintAppendFloatAlpha(r.fillColor, r.fillAlpha * s), u = r.pathData, v = r.pathIndexes, p = 0; p < v.length; p += 3) { const c = v[p] * 2; const m = v[p + 1] * 2; const g = v[p + 2] * 2; const x = u[c + 0] - a; const y = u[c + 1] - f; const T = u[m + 0] - a; const S = u[m + 1] - f; const E = u[g + 0] - a; const C = u[g + 1] - f; const P = o.getX(x, y); const A = o.getY(x, y); const M = o.getX(T, S); const L = o.getY(T, S); const F = o.getX(E, C); const I = o.getY(E, C); n.batchTri(r, P, A, M, L, F, I, 0, 0, 1, 1, l, l, l, 2) } }; e.exports = h }, function (e, d) { const t = function (i, h, n) { const o = i.x3 - i.x1; const r = i.y3 - i.y1; const s = i.x2 - i.x1; const a = i.y2 - i.y1; const f = h - i.x1; const l = n - i.y1; const u = o * o + r * r; const v = o * s + r * a; const p = o * f + r * l; const c = s * s + a * a; const m = s * f + a * l; const g = u * c - v * v; const x = g === 0 ? 0 : 1 / g; const y = (c * p - v * m) * x; const T = (u * m - v * p) * x; return y >= 0 && T >= 0 && y + T < 1 }; e.exports = t }, function (e, d, t) { const i = t(0); const h = t(10); const n = t(3); function o (s, a, f, l) { const u = s - f; const v = a - l; const p = u * u + v * v; return Math.sqrt(p) } const r = new i({ initialize: function (a, f, l) { this.vertex1 = a, this.vertex2 = f, this.vertex3 = l, this.bounds = new h(), this._inCenter = new n() }, getInCenter: function (s) { s === void 0 && (s = !0); const a = this.vertex1; const f = this.vertex2; const l = this.vertex3; let u; let v; let p; let c; let m; let g; s ? (u = a.x, v = a.y, p = f.x, c = f.y, m = l.x, g = l.y) : (u = a.vx, v = a.vy, p = f.vx, c = f.vy, m = l.vx, g = l.vy); const x = o(m, g, p, c); const y = o(u, v, m, g); const T = o(p, c, u, v); const S = x + y + T; return this._inCenter.set((u * x + p * y + m * T) / S, (v * x + c * y + g * T) / S) }, contains: function (s, a, f) { const l = this.vertex1; const u = this.vertex2; const v = this.vertex3; let p = l.vx; let c = l.vy; let m = u.vx; let g = u.vy; let x = v.vx; let y = v.vy; if (f) { const T = f.a; const S = f.b; const E = f.c; const C = f.d; const P = f.e; const A = f.f; p = l.vx * T + l.vy * E + P, c = l.vx * S + l.vy * C + A, m = u.vx * T + u.vy * E + P, g = u.vx * S + u.vy * C + A, x = v.vx * T + v.vy * E + P, y = v.vx * S + v.vy * C + A } const M = x - p; const L = y - c; const F = m - p; const I = g - c; const G = s - p; const U = a - c; const Y = M * M + L * L; const X = M * F + L * I; const O = M * G + L * U; const R = F * F + I * I; const D = F * G + I * U; const B = Y * R - X * X; const N = B === 0 ? 0 : 1 / B; const w = (R * O - X * D) * N; const z = (Y * D - X * O) * N; return w >= 0 && z >= 0 && w + z < 1 }, isCounterClockwise: function (s) { const a = this.vertex1; const f = this.vertex2; const l = this.vertex3; const u = (f.vx - a.vx) * (l.vy - a.vy) - (f.vy - a.vy) * (l.vx - a.vx); return s <= 0 ? u >= 0 : u < 0 }, load: function (s, a, f, l, u) { return f = this.vertex1.load(s, a, f, l, u), f = this.vertex2.load(s, a, f, l, u), f = this.vertex3.load(s, a, f, l, u), f }, transformCoordinatesLocal: function (s, a, f, l) { return this.vertex1.transformCoordinatesLocal(s, a, f, l), this.vertex2.transformCoordinatesLocal(s, a, f, l), this.vertex3.transformCoordinatesLocal(s, a, f, l), this }, updateBounds: function () { const s = this.vertex1; const a = this.vertex2; const f = this.vertex3; const l = this.bounds; return l.x = Math.min(s.vx, a.vx, f.vx), l.y = Math.min(s.vy, a.vy, f.vy), l.width = Math.max(s.vx, a.vx, f.vx) - l.x, l.height = Math.max(s.vy, a.vy, f.vy) - l.y, this }, isInView: function (s, a, f, l, u, v, p, c, m, g, x) { const y = this.vertex1.update(u, v, p, c, m, g, x, l); const T = this.vertex2.update(u, v, p, c, m, g, x, l); const S = this.vertex3.update(u, v, p, c, m, g, x, l); if (y.ta <= 0 && T.ta <= 0 && S.ta <= 0 || a && !this.isCounterClockwise(f)) return !1; const E = this.bounds; E.x = Math.min(y.tx, T.tx, S.tx), E.y = Math.min(y.ty, T.ty, S.ty), E.width = Math.max(y.tx, T.tx, S.tx) - E.x, E.height = Math.max(y.ty, T.ty, S.ty) - E.y; const C = s.x + s.width; const P = s.y + s.height; return E.width <= 0 || E.height <= 0 || s.width <= 0 || s.height <= 0 ? !1 : !(E.right < s.x || E.bottom < s.y || E.x > C || E.y > P) }, translate: function (s, a) { a === void 0 && (a = 0); const f = this.vertex1; const l = this.vertex2; const u = this.vertex3; return f.x += s, f.y += a, l.x += s, l.y += a, u.x += s, u.y += a, this }, x: { get: function () { return this.getInCenter().x }, set: function (s) { const a = this.getInCenter(); this.translate(s - a.x, 0) } }, y: { get: function () { return this.getInCenter().y }, set: function (s) { const a = this.getInCenter(); this.translate(0, s - a.y) } }, alpha: { get: function () { const s = this.vertex1; const a = this.vertex2; const f = this.vertex3; return (s.alpha + a.alpha + f.alpha) / 3 }, set: function (s) { this.vertex1.alpha = s, this.vertex2.alpha = s, this.vertex3.alpha = s } }, depth: { get: function () { const s = this.vertex1; const a = this.vertex2; const f = this.vertex3; return (s.vz + a.vz + f.vz) / 3 } }, destroy: function () { this.vertex1 = null, this.vertex2 = null, this.vertex3 = null } }); e.exports = r }, function (e, d, t) { const i = t(0); const h = t(12); const n = t(39); const o = new i({ Extends: n, initialize: function (s, a, f, l, u, v, p, c, m, g) { v === void 0 && (v = 16777215), p === void 0 && (p = 1), c === void 0 && (c = 0), m === void 0 && (m = 0), g === void 0 && (g = 0), n.call(this, s, a, f), this.vx = 0, this.vy = 0, this.vz = 0, this.nx = c, this.ny = m, this.nz = g, this.u = l, this.v = u, this.color = v, this.alpha = p, this.tx = 0, this.ty = 0, this.ta = 0 }, setUVs: function (r, s) { return this.u = r, this.v = s, this }, transformCoordinatesLocal: function (r, s, a, f) { const l = this.x; const u = this.y; const v = this.z; const p = r.val; const c = l * p[0] + u * p[4] + v * p[8] + p[12]; const m = l * p[1] + u * p[5] + v * p[9] + p[13]; const g = l * p[2] + u * p[6] + v * p[10] + p[14]; const x = l * p[3] + u * p[7] + v * p[11] + p[15]; this.vx = c / x * s, this.vy = -(m / x) * a, f <= 0 ? this.vz = g / x : this.vz = -(g / x) }, update: function (r, s, a, f, l, u, v, p) { let c = this.vx * r + this.vy * a + l; let m = this.vx * s + this.vy * f + u; return v && (c = Math.round(c), m = Math.round(m)), this.tx = c, this.ty = m, this.ta = this.alpha * p, this }, load: function (r, s, a, f, l) { return r[++a] = this.tx, r[++a] = this.ty, r[++a] = this.u, r[++a] = this.v, r[++a] = f, r[++a] = l, s[++a] = h.getTintAppendFloatAlpha(this.color, this.ta), a } }); e.exports = o }, function (e, d, t) { const i = {}; e.exports = i; const h = t(166); const n = t(32); const o = t(84); const r = t(41); (function () { i.create = function (s) { return n.extend({ id: n.nextId(), type: 'composite', parent: null, isModified: !1, bodies: [], constraints: [], composites: [], label: 'Composite', plugin: {} }, s) }, i.setModified = function (s, a, f, l) { if (h.trigger(s, 'compositeModified', s), s.isModified = a, f && s.parent && i.setModified(s.parent, a, f, l), l) for (let u = 0; u < s.composites.length; u++) { const v = s.composites[u]; i.setModified(v, a, f, l) } }, i.add = function (s, a) { const f = [].concat(a); h.trigger(s, 'beforeAdd', { object: a }); for (let l = 0; l < f.length; l++) { const u = f[l]; switch (u.type) { case 'body':if (u.parent !== u) { n.warn('Composite.add: skipped adding a compound body part (you must add its parent instead)'); break }i.addBody(s, u); break; case 'constraint':i.addConstraint(s, u); break; case 'composite':i.addComposite(s, u); break; case 'mouseConstraint':i.addConstraint(s, u.constraint); break } } return h.trigger(s, 'afterAdd', { object: a }), s }, i.remove = function (s, a, f) { const l = [].concat(a); h.trigger(s, 'beforeRemove', { object: a }); for (let u = 0; u < l.length; u++) { const v = l[u]; switch (v.type) { case 'body':i.removeBody(s, v, f); break; case 'constraint':i.removeConstraint(s, v, f); break; case 'composite':i.removeComposite(s, v, f); break; case 'mouseConstraint':i.removeConstraint(s, v.constraint); break } } return h.trigger(s, 'afterRemove', { object: a }), s }, i.addComposite = function (s, a) { return s.composites.push(a), a.parent = s, i.setModified(s, !0, !0, !1), s }, i.removeComposite = function (s, a, f) { const l = s.composites.indexOf(a); if (l !== -1 && (i.removeCompositeAt(s, l), i.setModified(s, !0, !0, !1)), f) for (let u = 0; u < s.composites.length; u++)i.removeComposite(s.composites[u], a, !0); return s }, i.removeCompositeAt = function (s, a) { return s.composites.splice(a, 1), i.setModified(s, !0, !0, !1), s }, i.addBody = function (s, a) { return s.bodies.push(a), i.setModified(s, !0, !0, !1), s }, i.removeBody = function (s, a, f) { const l = s.bodies.indexOf(a); if (l !== -1 && (i.removeBodyAt(s, l), i.setModified(s, !0, !0, !1)), f) for (let u = 0; u < s.composites.length; u++)i.removeBody(s.composites[u], a, !0); return s }, i.removeBodyAt = function (s, a) { return s.bodies.splice(a, 1), i.setModified(s, !0, !0, !1), s }, i.addConstraint = function (s, a) { return s.constraints.push(a), i.setModified(s, !0, !0, !1), s }, i.removeConstraint = function (s, a, f) { const l = s.constraints.indexOf(a); if (l !== -1 && i.removeConstraintAt(s, l), f) for (let u = 0; u < s.composites.length; u++)i.removeConstraint(s.composites[u], a, !0); return s }, i.removeConstraintAt = function (s, a) { return s.constraints.splice(a, 1), i.setModified(s, !0, !0, !1), s }, i.clear = function (s, a, f) { if (f) for (let l = 0; l < s.composites.length; l++)i.clear(s.composites[l], a, !0); return a ? s.bodies = s.bodies.filter(function (u) { return u.isStatic }) : s.bodies.length = 0, s.constraints.length = 0, s.composites.length = 0, i.setModified(s, !0, !0, !1), s }, i.allBodies = function (s) { for (var a = [].concat(s.bodies), f = 0; f < s.composites.length; f++)a = a.concat(i.allBodies(s.composites[f])); return a }, i.allConstraints = function (s) { for (var a = [].concat(s.constraints), f = 0; f < s.composites.length; f++)a = a.concat(i.allConstraints(s.composites[f])); return a }, i.allComposites = function (s) { for (var a = [].concat(s.composites), f = 0; f < s.composites.length; f++)a = a.concat(i.allComposites(s.composites[f])); return a }, i.get = function (s, a, f) { let l, u; switch (f) { case 'body':l = i.allBodies(s); break; case 'constraint':l = i.allConstraints(s); break; case 'composite':l = i.allComposites(s).concat(s); break } return l ? (u = l.filter(function (v) { return v.id.toString() === a.toString() }), u.length === 0 ? null : u[0]) : null }, i.move = function (s, a, f) { return i.remove(s, a), i.add(f, a), s }, i.rebase = function (s) { for (let a = i.allBodies(s).concat(i.allConstraints(s)).concat(i.allComposites(s)), f = 0; f < a.length; f++)a[f].id = n.nextId(); return i.setModified(s, !0, !0, !1), s }, i.translate = function (s, a, f) { for (let l = f ? i.allBodies(s) : s.bodies, u = 0; u < l.length; u++)r.translate(l[u], a); return i.setModified(s, !0, !0, !1), s }, i.rotate = function (s, a, f, l) { for (let u = Math.cos(a), v = Math.sin(a), p = l ? i.allBodies(s) : s.bodies, c = 0; c < p.length; c++) { const m = p[c]; const g = m.position.x - f.x; const x = m.position.y - f.y; r.setPosition(m, { x: f.x + (g * u - x * v), y: f.y + (g * v + x * u) }), r.rotate(m, a) } return i.setModified(s, !0, !0, !1), s }, i.scale = function (s, a, f, l, u) { for (let v = u ? i.allBodies(s) : s.bodies, p = 0; p < v.length; p++) { const c = v[p]; const m = c.position.x - l.x; const g = c.position.y - l.y; r.setPosition(c, { x: l.x + m * a, y: l.y + g * f }), r.scale(c, a, f) } return i.setModified(s, !0, !0, !1), s }, i.bounds = function (s) { for (var a = i.allBodies(s), f = [], l = 0; l < a.length; l += 1) { const u = a[l]; f.push(u.bounds.min, u.bounds.max) } return o.create(f) } })() }, function (e, d) { const t = function (i, h, n) { return i >= 0 && i < n.width && h >= 0 && h < n.height }; e.exports = t }, function (e, d, t) { const i = t(0); const h = t(29); const n = t(2); const o = new i({ initialize: function (s) { s === void 0 && (s = {}), this.name = n(s, 'name', 'layer'), this.x = n(s, 'x', 0), this.y = n(s, 'y', 0), this.width = n(s, 'width', 0), this.height = n(s, 'height', 0), this.tileWidth = n(s, 'tileWidth', 0), this.tileHeight = n(s, 'tileHeight', 0), this.baseTileWidth = n(s, 'baseTileWidth', this.tileWidth), this.baseTileHeight = n(s, 'baseTileHeight', this.tileHeight), this.orientation = n(s, 'orientation', h.ORTHOGONAL), this.widthInPixels = n(s, 'widthInPixels', this.width * this.baseTileWidth), this.heightInPixels = n(s, 'heightInPixels', this.height * this.baseTileHeight), this.alpha = n(s, 'alpha', 1), this.visible = n(s, 'visible', !0), this.properties = n(s, 'properties', []), this.indexes = n(s, 'indexes', []), this.collideIndexes = n(s, 'collideIndexes', []), this.callbacks = n(s, 'callbacks', []), this.bodies = n(s, 'bodies', []), this.data = n(s, 'data', []), this.tilemapLayer = n(s, 'tilemapLayer', null), this.hexSideLength = n(s, 'hexSideLength', 0) } }); e.exports = o }, function (e, d, t) { const i = t(0); const h = t(29); const n = t(2); const o = new i({ initialize: function (s) { s === void 0 && (s = {}), this.name = n(s, 'name', 'map'), this.width = n(s, 'width', 0), this.height = n(s, 'height', 0), this.infinite = n(s, 'infinite', !1), this.tileWidth = n(s, 'tileWidth', 0), this.tileHeight = n(s, 'tileHeight', 0), this.widthInPixels = n(s, 'widthInPixels', this.width * this.tileWidth), this.heightInPixels = n(s, 'heightInPixels', this.height * this.tileHeight), this.format = n(s, 'format', null), this.orientation = n(s, 'orientation', h.ORTHOGONAL), this.renderOrder = n(s, 'renderOrder', 'right-down'), this.version = n(s, 'version', '1'), this.properties = n(s, 'properties', {}), this.layers = n(s, 'layers', []), this.images = n(s, 'images', []), this.objects = n(s, 'objects', {}), this.collision = n(s, 'collision', {}), this.tilesets = n(s, 'tilesets', []), this.imageCollections = n(s, 'imageCollections', []), this.tiles = n(s, 'tiles', []), this.hexSideLength = n(s, 'hexSideLength', 0) } }); e.exports = o }, function (e, d, t) { const i = t(0); const h = new i({ initialize: function (o, r, s, a, f, l, u, v) { (s === void 0 || s <= 0) && (s = 32), (a === void 0 || a <= 0) && (a = 32), f === void 0 && (f = 0), l === void 0 && (l = 0), u === void 0 && (u = {}), v === void 0 && (v = {}), this.name = o, this.firstgid = r, this.tileWidth = s, this.tileHeight = a, this.tileMargin = f, this.tileSpacing = l, this.tileProperties = u, this.tileData = v, this.image = null, this.glTexture = null, this.rows = 0, this.columns = 0, this.total = 0, this.texCoordinates = [] }, getTileProperties: function (n) { return this.containsTileIndex(n) ? this.tileProperties[n - this.firstgid] : null }, getTileData: function (n) { return this.containsTileIndex(n) ? this.tileData[n - this.firstgid] : null }, getTileCollisionGroup: function (n) { const o = this.getTileData(n); return o && o.objectgroup ? o.objectgroup : null }, containsTileIndex: function (n) { return n >= this.firstgid && n < this.firstgid + this.total }, getTileTextureCoordinates: function (n) { return this.containsTileIndex(n) ? this.texCoordinates[n - this.firstgid] : null }, setImage: function (n) { return this.image = n, this.glTexture = n.get().source.glTexture, this.updateTileData(this.image.source[0].width, this.image.source[0].height), this }, setTileSize: function (n, o) { return n !== void 0 && (this.tileWidth = n), o !== void 0 && (this.tileHeight = o), this.image && this.updateTileData(this.image.source[0].width, this.image.source[0].height), this }, setSpacing: function (n, o) { return n !== void 0 && (this.tileMargin = n), o !== void 0 && (this.tileSpacing = o), this.image && this.updateTileData(this.image.source[0].width, this.image.source[0].height), this }, updateTileData: function (n, o) { let r = (o - this.tileMargin * 2 + this.tileSpacing) / (this.tileHeight + this.tileSpacing); let s = (n - this.tileMargin * 2 + this.tileSpacing) / (this.tileWidth + this.tileSpacing); (r % 1 != 0 || s % 1 != 0) && console.warn('Image tile area not tile size multiple in: ' + this.name), r = Math.floor(r), s = Math.floor(s), this.rows = r, this.columns = s, this.total = r * s, this.texCoordinates.length = 0; for (let a = this.tileMargin, f = this.tileMargin, l = 0; l < this.rows; l++) { for (let u = 0; u < this.columns; u++) this.texCoordinates.push({ x: a, y: f }), a += this.tileWidth + this.tileSpacing; a = this.tileMargin, f += this.tileHeight + this.tileSpacing } return this } }); e.exports = h }, function (e, d) { const t = { TOP_LEFT: 0, TOP_CENTER: 1, TOP_RIGHT: 2, LEFT_TOP: 3, LEFT_CENTER: 4, LEFT_BOTTOM: 5, CENTER: 6, RIGHT_TOP: 7, RIGHT_CENTER: 8, RIGHT_BOTTOM: 9, BOTTOM_LEFT: 10, BOTTOM_CENTER: 11, BOTTOM_RIGHT: 12 }; e.exports = t }, function (e, d) { const t = function (i, h, n) { return n === void 0 && (n = 1e-4), Math.abs(i - h) < n }; e.exports = t }, function (e, d, t) { const i = t(0); const h = t(11); const n = t(15); const o = t(1068); const r = new i({ Extends: n, Mixins: [h.Alpha, h.BlendMode, h.Depth, h.Flip, h.GetBounds, h.Mask, h.Origin, h.Pipeline, h.ScrollFactor, h.Size, h.TextureCrop, h.Tint, h.Transform, h.Visible, o], initialize: function (a, f, l, u, v) { n.call(this, a, 'Image'), this._crop = this.resetCropObject(), this.setTexture(u, v), this.setPosition(f, l), this.setSizeToFrame(), this.setOriginFromFrame(), this.initPipeline() } }); e.exports = r }, function (e, d) { const t = function (i, h) { return i.hasOwnProperty(h) }; e.exports = t }, function (e, d, t) { const i = t(77); const h = function (n, o) { const r = i(n); for (const s in o)r.hasOwnProperty(s) || (r[s] = o[s]); return r }; e.exports = h }, function (e, d, t) { const i = {}; e.exports = i; const h = t(64); const n = t(83); const o = t(165); const r = t(84); const s = t(271); const a = t(32); (function () { i._warming = 0.4, i._torqueDampen = 1, i._minLength = 1e-6, i.create = function (f) { const l = f; l.bodyA && !l.pointA && (l.pointA = { x: 0, y: 0 }), l.bodyB && !l.pointB && (l.pointB = { x: 0, y: 0 }); const u = l.bodyA ? n.add(l.bodyA.position, l.pointA) : l.pointA; const v = l.bodyB ? n.add(l.bodyB.position, l.pointB) : l.pointB; const p = n.magnitude(n.sub(u, v)); l.length = typeof l.length !== 'undefined' ? l.length : p, l.id = l.id || a.nextId(), l.label = l.label || 'Constraint', l.type = 'constraint', l.stiffness = l.stiffness || (l.length > 0 ? 1 : 0.7), l.damping = l.damping || 0, l.angularStiffness = l.angularStiffness || 0, l.angleA = l.bodyA ? l.bodyA.angle : l.angleA, l.angleB = l.bodyB ? l.bodyB.angle : l.angleB, l.plugin = {}; const c = { visible: !0, type: 'line', anchors: !0, lineColor: null, lineOpacity: null, lineThickness: null, pinSize: null, anchorColor: null, anchorSize: null }; return l.length === 0 && l.stiffness > 0.1 ? (c.type = 'pin', c.anchors = !1) : l.stiffness < 0.9 && (c.type = 'spring'), l.render = a.extend(c, l.render), l }, i.preSolveAll = function (f) { for (let l = 0; l < f.length; l += 1) { const u = f[l]; const v = u.constraintImpulse; u.isStatic || v.x === 0 && v.y === 0 && v.angle === 0 || (u.position.x += v.x, u.position.y += v.y, u.angle += v.angle) } }, i.solveAll = function (f, l) { for (var u = 0; u < f.length; u += 1) { var v = f[u]; var p = !v.bodyA || v.bodyA && v.bodyA.isStatic; var c = !v.bodyB || v.bodyB && v.bodyB.isStatic; (p || c) && i.solve(f[u], l) } for (u = 0; u < f.length; u += 1)v = f[u], p = !v.bodyA || v.bodyA && v.bodyA.isStatic, c = !v.bodyB || v.bodyB && v.bodyB.isStatic, !p && !c && i.solve(f[u], l) }, i.solve = function (f, l) { const u = f.bodyA; const v = f.bodyB; const p = f.pointA; const c = f.pointB; if (!(!u && !v)) { u && !u.isStatic && (n.rotate(p, u.angle - f.angleA, p), f.angleA = u.angle), v && !v.isStatic && (n.rotate(c, v.angle - f.angleB, c), f.angleB = v.angle); let m = p; let g = c; if (u && (m = n.add(u.position, p)), v && (g = n.add(v.position, c)), !(!m || !g)) { const x = n.sub(m, g); let y = n.magnitude(x); y < i._minLength && (y = i._minLength); const T = (y - f.length) / y; const S = f.stiffness < 1 ? f.stiffness * l : f.stiffness; const E = n.mult(x, T * S); const C = (u ? u.inverseMass : 0) + (v ? v.inverseMass : 0); const P = (u ? u.inverseInertia : 0) + (v ? v.inverseInertia : 0); const A = C + P; let M; let L; let F; let I; let G; if (f.damping) { const U = n.create(); F = n.div(x, y), G = n.sub(v && n.sub(v.position, v.positionPrev) || U, u && n.sub(u.position, u.positionPrev) || U), I = n.dot(F, G) }u && !u.isStatic && (L = u.inverseMass / C, u.constraintImpulse.x -= E.x * L, u.constraintImpulse.y -= E.y * L, u.position.x -= E.x * L, u.position.y -= E.y * L, f.damping && (u.positionPrev.x -= f.damping * F.x * I * L, u.positionPrev.y -= f.damping * F.y * I * L), M = n.cross(p, E) / A * i._torqueDampen * u.inverseInertia * (1 - f.angularStiffness), u.constraintImpulse.angle -= M, u.angle -= M), v && !v.isStatic && (L = v.inverseMass / C, v.constraintImpulse.x += E.x * L, v.constraintImpulse.y += E.y * L, v.position.x += E.x * L, v.position.y += E.y * L, f.damping && (v.positionPrev.x += f.damping * F.x * I * L, v.positionPrev.y += f.damping * F.y * I * L), M = n.cross(c, E) / A * i._torqueDampen * v.inverseInertia * (1 - f.angularStiffness), v.constraintImpulse.angle += M, v.angle += M) } } }, i.postSolveAll = function (f) { for (let l = 0; l < f.length; l++) { const u = f[l]; const v = u.constraintImpulse; if (!(u.isStatic || v.x === 0 && v.y === 0 && v.angle === 0)) { o.set(u, !1); for (let p = 0; p < u.parts.length; p++) { const c = u.parts[p]; h.translate(c.vertices, v), p > 0 && (c.position.x += v.x, c.position.y += v.y), v.angle !== 0 && (h.rotate(c.vertices, v.angle, u.position), s.rotate(c.axes, v.angle), p > 0 && n.rotateAbout(c.position, v.angle, u.position, c.position)), r.update(c.bounds, c.vertices, u.velocity) }v.angle *= i._warming, v.x *= i._warming, v.y *= i._warming } } }, i.pointAWorld = function (f) { return { x: (f.bodyA ? f.bodyA.position.x : 0) + f.pointA.x, y: (f.bodyA ? f.bodyA.position.y : 0) + f.pointA.y } }, i.pointBWorld = function (f) { return { x: (f.bodyB ? f.bodyB.position.x : 0) + f.pointB.x, y: (f.bodyB ? f.bodyB.position.y : 0) + f.pointB.y } } })() }, function (e, d, t) { const i = t(35); const h = t(65); const n = t(66); const o = t(0); const r = t(11); const s = t(15); const a = t(10); const f = t(57); const l = new o({ Extends: s, Mixins: [r.Depth, r.GetBounds, r.Origin, r.Transform, r.ScrollFactor, r.Visible], initialize: function (v, p, c, m, g) { m === void 0 && (m = 1), g === void 0 && (g = m), s.call(this, v, 'Zone'), this.setPosition(p, c), this.width = m, this.height = g, this.blendMode = i.NORMAL, this.updateDisplayOrigin() }, displayWidth: { get: function () { return this.scaleX * this.width }, set: function (u) { this.scaleX = u / this.width } }, displayHeight: { get: function () { return this.scaleY * this.height }, set: function (u) { this.scaleY = u / this.height } }, setSize: function (u, v, p) { p === void 0 && (p = !0), this.width = u, this.height = v, this.updateDisplayOrigin(); const c = this.input; return p && c && !c.customHitArea && (c.hitArea.width = u, c.hitArea.height = v), this }, setDisplaySize: function (u, v) { return this.displayWidth = u, this.displayHeight = v, this }, setCircleDropZone: function (u) { return this.setDropZone(new h(0, 0, u), n) }, setRectangleDropZone: function (u, v) { return this.setDropZone(new a(0, 0, u, v), f) }, setDropZone: function (u, v) { return u === void 0 ? this.setRectangleDropZone(this.width, this.height) : this.input || this.setInteractive(u, v, !0), this }, setAlpha: function () {}, setBlendMode: function () {}, renderCanvas: function (u, v, p) { p.addToRenderList(v) }, renderWebGL: function (u, v, p) { p.addToRenderList(v) } }); e.exports = l }, function (e, d) { const t = function (i) { return 2 * (i.width + i.height) }; e.exports = t }, function (e, d) { const t = function (i) { for (let h = i.length - 1; h > 0; h--) { const n = Math.floor(Math.random() * (h + 1)); const o = i[h]; i[h] = i[n], i[n] = o } return i }; e.exports = t }, function (e, d, t) { e.exports = { ADD_ANIMATION: t(724), ANIMATION_COMPLETE: t(725), ANIMATION_COMPLETE_KEY: t(726), ANIMATION_REPEAT: t(727), ANIMATION_RESTART: t(728), ANIMATION_START: t(729), ANIMATION_STOP: t(730), ANIMATION_UPDATE: t(731), PAUSE_ALL: t(732), REMOVE_ANIMATION: t(733), RESUME_ALL: t(734) } }, function (e, d, t) { const i = t(0); const h = t(11); const n = t(36); const o = t(9); const r = t(37); const s = t(10); const a = t(25); const f = t(187); const l = t(3); const u = new i({ Extends: o, Mixins: [h.Alpha, h.Visible], initialize: function (p, c, m, g) { p === void 0 && (p = 0), c === void 0 && (c = 0), m === void 0 && (m = 0), g === void 0 && (g = 0), o.call(this), this.scene, this.sceneManager, this.scaleManager, this.cameraManager, this.id = 0, this.name = '', this.roundPixels = !1, this.useBounds = !1, this.worldView = new s(), this.dirty = !0, this._x = p, this._y = c, this._width = m, this._height = g, this._bounds = new s(), this._scrollX = 0, this._scrollY = 0, this._zoomX = 1, this._zoomY = 1, this._rotation = 0, this.matrix = new a(), this.transparent = !0, this.backgroundColor = f('rgba(0,0,0,0)'), this.disableCull = !1, this.culledObjects = [], this.midPoint = new l(m / 2, g / 2), this.originX = 0.5, this.originY = 0.5, this._customViewport = !1, this.mask = null, this._maskCamera = null, this.renderList = [] }, addToRenderList: function (v) { this.renderList.push(v) }, setOrigin: function (v, p) { return v === void 0 && (v = 0.5), p === void 0 && (p = v), this.originX = v, this.originY = p, this }, getScroll: function (v, p, c) { c === void 0 && (c = new l()); const m = this.width * 0.5; const g = this.height * 0.5; return c.x = v - m, c.y = p - g, this.useBounds && (c.x = this.clampX(c.x), c.y = this.clampY(c.y)), c }, centerOnX: function (v) { const p = this.width * 0.5; return this.midPoint.x = v, this.scrollX = v - p, this.useBounds && (this.scrollX = this.clampX(this.scrollX)), this }, centerOnY: function (v) { const p = this.height * 0.5; return this.midPoint.y = v, this.scrollY = v - p, this.useBounds && (this.scrollY = this.clampY(this.scrollY)), this }, centerOn: function (v, p) { return this.centerOnX(v), this.centerOnY(p), this }, centerToBounds: function () { if (this.useBounds) { const v = this._bounds; const p = this.width * 0.5; const c = this.height * 0.5; this.midPoint.set(v.centerX, v.centerY), this.scrollX = v.centerX - p, this.scrollY = v.centerY - c } return this }, centerToSize: function () { return this.scrollX = this.width * 0.5, this.scrollY = this.height * 0.5, this }, cull: function (v) { if (this.disableCull) return v; const p = this.matrix.matrix; const c = p[0]; const m = p[1]; const g = p[2]; const x = p[3]; let y = c * x - m * g; if (!y) return v; const T = p[4]; const S = p[5]; const E = this.scrollX; const C = this.scrollY; const P = this.width; const A = this.height; const M = this.y; const L = M + A; const F = this.x; const I = F + P; const G = this.culledObjects; const U = v.length; y = 1 / y, G.length = 0; for (let Y = 0; Y < U; ++Y) { const X = v[Y]; if (!X.hasOwnProperty('width') || X.parentContainer) { G.push(X); continue } const O = X.width; const R = X.height; const D = X.x - E * X.scrollFactorX - O * X.originX; const B = X.y - C * X.scrollFactorY - R * X.originY; const N = D * c + B * g + T; const w = D * m + B * x + S; const z = (D + O) * c + (B + R) * g + T; const V = (D + O) * m + (B + R) * x + S; z > F && N < I && V > M && w < L && G.push(X) } return G }, getWorldPoint: function (v, p, c) { c === void 0 && (c = new l()); const m = this.matrix.matrix; const g = m[0]; const x = m[1]; const y = m[2]; const T = m[3]; const S = m[4]; const E = m[5]; let C = g * T - x * y; if (!C) return c.x = v, c.y = p, c; C = 1 / C; const P = T * C; const A = -x * C; const M = -y * C; const L = g * C; const F = (y * E - T * S) * C; const I = (x * S - g * E) * C; const G = Math.cos(this.rotation); const U = Math.sin(this.rotation); const Y = this.zoomX; const X = this.zoomY; const O = this.scrollX; const R = this.scrollY; const D = v + (O * G - R * U) * Y; const B = p + (O * U + R * G) * X; return c.x = D * P + B * M + F, c.y = D * A + B * L + I, c }, ignore: function (v) { const p = this.id; Array.isArray(v) || (v = [v]); for (let c = 0; c < v.length; c++) { const m = v[c]; Array.isArray(m) ? this.ignore(m) : m.isParent ? this.ignore(m.getChildren()) : m.cameraFilter |= p } return this }, preRender: function () { this.renderList.length = 0; const v = this.width; const p = this.height; const c = v * 0.5; const m = p * 0.5; const g = this.zoomX; const x = this.zoomY; const y = this.matrix; let T = v * this.originX; let S = p * this.originY; let E = this.scrollX; let C = this.scrollY; this.useBounds && (E = this.clampX(E), C = this.clampY(C)), this.roundPixels && (T = Math.round(T), S = Math.round(S)), this.scrollX = E, this.scrollY = C; const P = E + c; const A = C + m; this.midPoint.set(P, A); const M = v / g; const L = p / x; this.worldView.setTo(P - M / 2, A - L / 2, M, L), y.applyITRS(this.x + T, this.y + S, this.rotation, g, x), y.translate(-T, -S) }, clampX: function (v) { const p = this._bounds; const c = this.displayWidth; const m = p.x + (c - this.width) / 2; const g = Math.max(m, m + p.width - c); return v < m ? v = m : v > g && (v = g), v }, clampY: function (v) { const p = this._bounds; const c = this.displayHeight; const m = p.y + (c - this.height) / 2; const g = Math.max(m, m + p.height - c); return v < m ? v = m : v > g && (v = g), v }, removeBounds: function () { return this.useBounds = !1, this.dirty = !0, this._bounds.setEmpty(), this }, setAngle: function (v) { return v === void 0 && (v = 0), this.rotation = n(v), this }, setBackgroundColor: function (v) { return v === void 0 && (v = 'rgba(0,0,0,0)'), this.backgroundColor = f(v), this.transparent = this.backgroundColor.alpha === 0, this }, setBounds: function (v, p, c, m, g) { return g === void 0 && (g = !1), this._bounds.setTo(v, p, c, m), this.dirty = !0, this.useBounds = !0, g ? this.centerToBounds() : (this.scrollX = this.clampX(this.scrollX), this.scrollY = this.clampY(this.scrollY)), this }, getBounds: function (v) { v === void 0 && (v = new s()); const p = this._bounds; return v.setTo(p.x, p.y, p.width, p.height), v }, setName: function (v) { return v === void 0 && (v = ''), this.name = v, this }, setPosition: function (v, p) { return p === void 0 && (p = v), this.x = v, this.y = p, this }, setRotation: function (v) { return v === void 0 && (v = 0), this.rotation = v, this }, setRoundPixels: function (v) { return this.roundPixels = v, this }, setScene: function (v) { this.scene && this._customViewport && this.sceneManager.customViewports--, this.scene = v; const p = v.sys; return this.sceneManager = p.game.scene, this.scaleManager = p.scale, this.cameraManager = p.cameras, this.updateSystem(), this }, setScroll: function (v, p) { return p === void 0 && (p = v), this.scrollX = v, this.scrollY = p, this }, setSize: function (v, p) { return p === void 0 && (p = v), this.width = v, this.height = p, this }, setViewport: function (v, p, c, m) { return this.x = v, this.y = p, this.width = c, this.height = m, this }, setZoom: function (v, p) { return v === void 0 && (v = 1), p === void 0 && (p = v), v === 0 && (v = 0.001), p === 0 && (p = 0.001), this.zoomX = v, this.zoomY = p, this }, setMask: function (v, p) { return p === void 0 && (p = !0), this.mask = v, this._maskCamera = p ? this.cameraManager.default : this, this }, clearMask: function (v) { return v === void 0 && (v = !1), v && this.mask && this.mask.destroy(), this.mask = null, this }, toJSON: function () { const v = { name: this.name, x: this.x, y: this.y, width: this.width, height: this.height, zoom: this.zoom, rotation: this.rotation, roundPixels: this.roundPixels, scrollX: this.scrollX, scrollY: this.scrollY, backgroundColor: this.backgroundColor.rgba }; return this.useBounds && (v.bounds = { x: this._bounds.x, y: this._bounds.y, width: this._bounds.width, height: this._bounds.height }), v }, update: function () {}, updateSystem: function () { if (this.scaleManager) { const v = this._x !== 0 || this._y !== 0 || this.scaleManager.width !== this._width || this.scaleManager.height !== this._height; const p = this.sceneManager; v && !this._customViewport ? p.customViewports++ : !v && this._customViewport && p.customViewports--, this.dirty = !0, this._customViewport = v } }, destroy: function () { this.emit(r.DESTROY, this), this.removeAllListeners(), this.matrix.destroy(), this.culledObjects = [], this._customViewport && this.sceneManager.customViewports--, this.renderList = [], this._bounds = null, this.scene = null, this.scaleManager = null, this.sceneManager = null, this.cameraManager = null }, x: { get: function () { return this._x }, set: function (v) { this._x = v, this.updateSystem() } }, y: { get: function () { return this._y }, set: function (v) { this._y = v, this.updateSystem() } }, width: { get: function () { return this._width }, set: function (v) { this._width = v, this.updateSystem() } }, height: { get: function () { return this._height }, set: function (v) { this._height = v, this.updateSystem() } }, scrollX: { get: function () { return this._scrollX }, set: function (v) { this._scrollX = v, this.dirty = !0 } }, scrollY: { get: function () { return this._scrollY }, set: function (v) { this._scrollY = v, this.dirty = !0 } }, zoom: { get: function () { return (this._zoomX + this._zoomY) / 2 }, set: function (v) { this._zoomX = v, this._zoomY = v, this.dirty = !0 } }, zoomX: { get: function () { return this._zoomX }, set: function (v) { this._zoomX = v, this.dirty = !0 } }, zoomY: { get: function () { return this._zoomY }, set: function (v) { this._zoomY = v, this.dirty = !0 } }, rotation: { get: function () { return this._rotation }, set: function (v) { this._rotation = v, this.dirty = !0 } }, centerX: { get: function () { return this.x + 0.5 * this.width } }, centerY: { get: function () { return this.y + 0.5 * this.height } }, displayWidth: { get: function () { return this.width / this.zoomX } }, displayHeight: { get: function () { return this.height / this.zoomY } } }); e.exports = u }, function (e, d, t) { const i = t(334); const h = t(335); const n = t(336); const o = t(337); const r = t(338); const s = t(339); const a = t(340); const f = t(341); const l = t(342); const u = t(343); const v = t(344); const p = t(345); e.exports = { Power0: a, Power1: f.Out, Power2: o.Out, Power3: l.Out, Power4: u.Out, Linear: a, Quad: f.Out, Cubic: o.Out, Quart: l.Out, Quint: u.Out, Sine: v.Out, Expo: s.Out, Circ: n.Out, Elastic: r.Out, Back: i.Out, Bounce: h.Out, Stepped: p, 'Quad.easeIn': f.In, 'Cubic.easeIn': o.In, 'Quart.easeIn': l.In, 'Quint.easeIn': u.In, 'Sine.easeIn': v.In, 'Expo.easeIn': s.In, 'Circ.easeIn': n.In, 'Elastic.easeIn': r.In, 'Back.easeIn': i.In, 'Bounce.easeIn': h.In, 'Quad.easeOut': f.Out, 'Cubic.easeOut': o.Out, 'Quart.easeOut': l.Out, 'Quint.easeOut': u.Out, 'Sine.easeOut': v.Out, 'Expo.easeOut': s.Out, 'Circ.easeOut': n.Out, 'Elastic.easeOut': r.Out, 'Back.easeOut': i.Out, 'Bounce.easeOut': h.Out, 'Quad.easeInOut': f.InOut, 'Cubic.easeInOut': o.InOut, 'Quart.easeInOut': l.InOut, 'Quint.easeInOut': u.InOut, 'Sine.easeInOut': v.InOut, 'Expo.easeInOut': s.InOut, 'Circ.easeInOut': n.InOut, 'Elastic.easeInOut': r.InOut, 'Back.easeInOut': i.InOut, 'Bounce.easeInOut': h.InOut } }, function (e, d) { const t = function (i, h, n) { return (h - i) * n + i }; e.exports = t }, function (e, d, t) { const i = t(105); const h = { chrome: !1, chromeVersion: 0, edge: !1, firefox: !1, firefoxVersion: 0, ie: !1, ieVersion: 0, mobileSafari: !1, opera: !1, safari: !1, safariVersion: 0, silk: !1, trident: !1, tridentVersion: 0 }; function n () { const o = navigator.userAgent; return /Edge\/\d+/.test(o) ? h.edge = !0 : /Chrome\/(\d+)/.test(o) && !i.windowsPhone ? (h.chrome = !0, h.chromeVersion = parseInt(RegExp.$1, 10)) : /Firefox\D+(\d+)/.test(o) ? (h.firefox = !0, h.firefoxVersion = parseInt(RegExp.$1, 10)) : /AppleWebKit/.test(o) && i.iOS ? h.mobileSafari = !0 : /MSIE (\d+\.\d+);/.test(o) ? (h.ie = !0, h.ieVersion = parseInt(RegExp.$1, 10)) : /Opera/.test(o) ? h.opera = !0 : /Safari/.test(o) && !i.windowsPhone ? h.safari = !0 : /Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/.test(o) && (h.ie = !0, h.trident = !0, h.tridentVersion = parseInt(RegExp.$1, 10), h.ieVersion = parseInt(RegExp.$3, 10)), /Silk/.test(o) && (h.silk = !0), h }e.exports = n() }, function (e, d) { const t = function (i, h) { return Math.random() * (h - i) + i }; e.exports = t }, function (e, d) { const t = function (i, h) { return i > 0 && (i & i - 1) == 0 && h > 0 && (h & h - 1) == 0 }; e.exports = t }, function (e, d) { const t = function (i, h, n, o) { return n === void 0 && (n = 0), h === 0 ? i : (i -= n, i = h * Math.ceil(i / h), o ? (n + i) / h : n + i) }; e.exports = t }, function (e, d, t) { const i = t(0); var h = new i({ initialize: function (o, r, s, a) { this.x = 0, this.y = 0, this.z = 0, this.w = 0, typeof o === 'object' ? (this.x = o.x || 0, this.y = o.y || 0, this.z = o.z || 0, this.w = o.w || 0) : (this.x = o || 0, this.y = r || 0, this.z = s || 0, this.w = a || 0) }, clone: function () { return new h(this.x, this.y, this.z, this.w) }, copy: function (n) { return this.x = n.x, this.y = n.y, this.z = n.z || 0, this.w = n.w || 0, this }, equals: function (n) { return this.x === n.x && this.y === n.y && this.z === n.z && this.w === n.w }, set: function (n, o, r, s) { return typeof n === 'object' ? (this.x = n.x || 0, this.y = n.y || 0, this.z = n.z || 0, this.w = n.w || 0) : (this.x = n || 0, this.y = o || 0, this.z = r || 0, this.w = s || 0), this }, add: function (n) { return this.x += n.x, this.y += n.y, this.z += n.z || 0, this.w += n.w || 0, this }, subtract: function (n) { return this.x -= n.x, this.y -= n.y, this.z -= n.z || 0, this.w -= n.w || 0, this }, scale: function (n) { return this.x *= n, this.y *= n, this.z *= n, this.w *= n, this }, length: function () { const n = this.x; const o = this.y; const r = this.z; const s = this.w; return Math.sqrt(n * n + o * o + r * r + s * s) }, lengthSq: function () { const n = this.x; const o = this.y; const r = this.z; const s = this.w; return n * n + o * o + r * r + s * s }, normalize: function () { const n = this.x; const o = this.y; const r = this.z; const s = this.w; let a = n * n + o * o + r * r + s * s; return a > 0 && (a = 1 / Math.sqrt(a), this.x = n * a, this.y = o * a, this.z = r * a, this.w = s * a), this }, dot: function (n) { return this.x * n.x + this.y * n.y + this.z * n.z + this.w * n.w }, lerp: function (n, o) { o === void 0 && (o = 0); const r = this.x; const s = this.y; const a = this.z; const f = this.w; return this.x = r + o * (n.x - r), this.y = s + o * (n.y - s), this.z = a + o * (n.z - a), this.w = f + o * (n.w - f), this }, multiply: function (n) { return this.x *= n.x, this.y *= n.y, this.z *= n.z || 1, this.w *= n.w || 1, this }, divide: function (n) { return this.x /= n.x, this.y /= n.y, this.z /= n.z || 1, this.w /= n.w || 1, this }, distance: function (n) { const o = n.x - this.x; const r = n.y - this.y; const s = n.z - this.z || 0; const a = n.w - this.w || 0; return Math.sqrt(o * o + r * r + s * s + a * a) }, distanceSq: function (n) { const o = n.x - this.x; const r = n.y - this.y; const s = n.z - this.z || 0; const a = n.w - this.w || 0; return o * o + r * r + s * s + a * a }, negate: function () { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this }, transformMat4: function (n) { const o = this.x; const r = this.y; const s = this.z; const a = this.w; const f = n.val; return this.x = f[0] * o + f[4] * r + f[8] * s + f[12] * a, this.y = f[1] * o + f[5] * r + f[9] * s + f[13] * a, this.z = f[2] * o + f[6] * r + f[10] * s + f[14] * a, this.w = f[3] * o + f[7] * r + f[11] * s + f[15] * a, this }, transformQuat: function (n) { const o = this.x; const r = this.y; const s = this.z; const a = n.x; const f = n.y; const l = n.z; const u = n.w; const v = u * o + f * s - l * r; const p = u * r + l * o - a * s; const c = u * s + a * r - f * o; const m = -a * o - f * r - l * s; return this.x = v * u + m * -a + p * -l - c * -f, this.y = p * u + m * -f + c * -a - v * -l, this.z = c * u + m * -l + v * -f - p * -a, this }, reset: function () { return this.x = 0, this.y = 0, this.z = 0, this.w = 0, this } }); h.prototype.sub = h.prototype.subtract, h.prototype.mul = h.prototype.multiply, h.prototype.div = h.prototype.divide, h.prototype.dist = h.prototype.distance, h.prototype.distSq = h.prototype.distanceSq, h.prototype.len = h.prototype.length, h.prototype.lenSq = h.prototype.lengthSq, e.exports = h }, function (e, d, t) { const i = t(0); const h = t(91); const n = new i({ initialize: function (r, s, a, f, l, u, v) { f === void 0 && (f = 1), l === void 0 && (l = 0), u === void 0 && (u = !0), v === void 0 && (v = !1), this.renderer = r, this.framebuffer = null, this.texture = null, this.width = 0, this.height = 0, this.scale = f, this.minFilter = l, this.autoClear = u, this.autoResize = !1, this.resize(s, a), v && this.setAutoResize(!0) }, setAutoResize: function (o) { return o && !this.autoResize ? (this.renderer.on(h.RESIZE, this.resize, this), this.autoResize = !0) : !o && this.autoResize && (this.renderer.off(h.RESIZE, this.resize, this), this.autoResize = !1), this }, resize: function (o, r) { const s = o * this.scale; const a = r * this.scale; if (s !== this.width || a !== this.height) { const f = this.renderer; f.deleteFramebuffer(this.framebuffer), f.deleteTexture(this.texture), o *= this.scale, r *= this.scale, o = Math.round(o), r = Math.round(r), o <= 0 && (o = 1), r <= 0 && (r = 1), this.texture = f.createTextureFromSource(null, o, r, this.minFilter), this.framebuffer = f.createFramebuffer(o, r, this.texture, !1), this.width = o, this.height = r } return this }, bind: function (o, r, s) { if (o === void 0 && (o = !1), o && this.renderer.flush(), r && s && this.resize(r, s), this.renderer.pushFramebuffer(this.framebuffer, !1, !1, !1), o && this.adjustViewport(), this.autoClear) { const a = this.renderer.gl; a.clearColor(0, 0, 0, 0), a.clear(a.COLOR_BUFFER_BIT) } }, adjustViewport: function () { const o = this.renderer.gl; o.viewport(0, 0, this.width, this.height), o.disable(o.SCISSOR_TEST) }, clear: function () { const o = this.renderer; const r = o.gl; o.pushFramebuffer(this.framebuffer), r.disable(r.SCISSOR_TEST), r.clearColor(0, 0, 0, 0), r.clear(r.COLOR_BUFFER_BIT), o.popFramebuffer(), o.resetScissor() }, unbind: function (o) { o === void 0 && (o = !1); const r = this.renderer; return o && r.flush(), r.popFramebuffer() }, destroy: function () { const o = this.renderer; o.deleteFramebuffer(this.framebuffer), o.deleteTexture(this.texture), o.off(h.RESIZE, this.resize, this), this.renderer = null, this.framebuffer = null, this.texture = null } }); e.exports = n }, function (e, d) { const t = function (i, h) { let n; if (h) typeof h === 'string' ? n = document.getElementById(h) : typeof h === 'object' && h.nodeType === 1 && (n = h); else if (i.parentElement || h === null) return i; return n || (n = document.body), n.appendChild(i), i }; e.exports = t }, function (e, d) { const t = { BACKSPACE: 8, TAB: 9, ENTER: 13, SHIFT: 16, CTRL: 17, ALT: 18, PAUSE: 19, CAPS_LOCK: 20, ESC: 27, SPACE: 32, PAGE_UP: 33, PAGE_DOWN: 34, END: 35, HOME: 36, LEFT: 37, UP: 38, RIGHT: 39, DOWN: 40, PRINT_SCREEN: 42, INSERT: 45, DELETE: 46, ZERO: 48, ONE: 49, TWO: 50, THREE: 51, FOUR: 52, FIVE: 53, SIX: 54, SEVEN: 55, EIGHT: 56, NINE: 57, NUMPAD_ZERO: 96, NUMPAD_ONE: 97, NUMPAD_TWO: 98, NUMPAD_THREE: 99, NUMPAD_FOUR: 100, NUMPAD_FIVE: 101, NUMPAD_SIX: 102, NUMPAD_SEVEN: 103, NUMPAD_EIGHT: 104, NUMPAD_NINE: 105, NUMPAD_ADD: 107, NUMPAD_SUBTRACT: 109, A: 65, B: 66, C: 67, D: 68, E: 69, F: 70, G: 71, H: 72, I: 73, J: 74, K: 75, L: 76, M: 77, N: 78, O: 79, P: 80, Q: 81, R: 82, S: 83, T: 84, U: 85, V: 86, W: 87, X: 88, Y: 89, Z: 90, F1: 112, F2: 113, F3: 114, F4: 115, F5: 116, F6: 117, F7: 118, F8: 119, F9: 120, F10: 121, F11: 122, F12: 123, SEMICOLON: 186, PLUS: 187, COMMA: 188, MINUS: 189, PERIOD: 190, FORWARD_SLASH: 191, BACK_SLASH: 220, QUOTES: 222, BACKTICK: 192, OPEN_BRACKET: 219, CLOSED_BRACKET: 221, SEMICOLON_FIREFOX: 59, COLON: 58, COMMA_FIREFOX_WINDOWS: 60, COMMA_FIREFOX: 62, BRACKET_RIGHT_FIREFOX: 174, BRACKET_LEFT_FIREFOX: 175 }; e.exports = t }, function (e, d) { const t = { PENDING: 0, INIT: 1, START: 2, LOADING: 3, CREATING: 4, RUNNING: 5, PAUSED: 6, SLEEPING: 7, SHUTDOWN: 8, DESTROYED: 9 }; e.exports = t }, function (e, d, t) { const i = t(0); const h = t(77); const n = t(9); const o = t(70); const r = t(22); const s = t(1); const a = t(207); const f = t(428); const l = new i({ Extends: n, initialize: function (v) { n.call(this), this.game = v, this.jsonCache = v.cache.json, this.sounds = [], this.mute = !1, this.volume = 1, this.pauseOnBlur = !0, this._rate = 1, this._detune = 0, this.locked = this.locked || !1, this.unlocked = !1, v.events.on(r.BLUR, this.onGameBlur, this), v.events.on(r.FOCUS, this.onGameFocus, this), v.events.on(r.PRE_STEP, this.update, this), v.events.once(r.DESTROY, this.destroy, this) }, add: s, addAudioSprite: function (u, v) { v === void 0 && (v = {}); const p = this.add(u, v); p.spritemap = this.jsonCache.get(u).spritemap; for (const c in p.spritemap) if (p.spritemap.hasOwnProperty(c)) { const m = h(v); const g = p.spritemap[c]; m.loop = g.hasOwnProperty('loop') ? g.loop : !1, p.addMarker({ name: c, start: g.start, duration: g.end - g.start, config: m }) } return p }, get: function (u) { return f(this.sounds, 'key', u) }, getAll: function (u) { return a(this.sounds, 'key', u) }, play: function (u, v) { const p = this.add(u); return p.once(o.COMPLETE, p.destroy, p), v ? v.name ? (p.addMarker(v), p.play(v.name)) : p.play(v) : p.play() }, playAudioSprite: function (u, v, p) { const c = this.addAudioSprite(u); return c.once(o.COMPLETE, c.destroy, c), c.play(v, p) }, remove: function (u) { const v = this.sounds.indexOf(u); return v !== -1 ? (u.destroy(), this.sounds.splice(v, 1), !0) : !1 }, removeAll: function () { this.sounds.forEach(function (u) { u.destroy() }), this.sounds.length = 0 }, removeByKey: function (u) { for (var v = 0, p = this.sounds.length - 1; p >= 0; p--) { const c = this.sounds[p]; c.key === u && (c.destroy(), this.sounds.splice(p, 1), v++) } return v }, pauseAll: function () { this.forEachActiveSound(function (u) { u.pause() }), this.emit(o.PAUSE_ALL, this) }, resumeAll: function () { this.forEachActiveSound(function (u) { u.resume() }), this.emit(o.RESUME_ALL, this) }, stopAll: function () { this.forEachActiveSound(function (u) { u.stop() }), this.emit(o.STOP_ALL, this) }, stopByKey: function (u) { let v = 0; return this.getAll(u).forEach(function (p) { p.stop() && v++ }), v }, unlock: s, onBlur: s, onFocus: s, onGameBlur: function () { this.pauseOnBlur && this.onBlur() }, onGameFocus: function () { this.pauseOnBlur && this.onFocus() }, update: function (u, v) { this.unlocked && (this.unlocked = !1, this.locked = !1, this.emit(o.UNLOCKED, this)); for (let p = this.sounds.length - 1; p >= 0; p--) this.sounds[p].pendingRemove && this.sounds.splice(p, 1); this.sounds.forEach(function (c) { c.update(u, v) }) }, destroy: function () { this.game.events.off(r.BLUR, this.onGameBlur, this), this.game.events.off(r.FOCUS, this.onGameFocus, this), this.game.events.off(r.PRE_STEP, this.update, this), this.removeAllListeners(), this.removeAll(), this.sounds.length = 0, this.sounds = null, this.game = null }, forEachActiveSound: function (u, v) { const p = this; this.sounds.forEach(function (c, m) { c && !c.pendingRemove && u.call(v || p, c, m, p.sounds) }) }, setRate: function (u) { return this.rate = u, this }, rate: { get: function () { return this._rate }, set: function (u) { this._rate = u, this.forEachActiveSound(function (v) { v.calculateRate() }), this.emit(o.GLOBAL_RATE, this, u) } }, setDetune: function (u) { return this.detune = u, this }, detune: { get: function () { return this._detune }, set: function (u) { this._detune = u, this.forEachActiveSound(function (v) { v.calculateRate() }), this.emit(o.GLOBAL_DETUNE, this, u) } } }); e.exports = l }, function (e, d, t) { const i = t(0); const h = t(9); const n = t(70); const o = t(17); const r = t(1); const s = new i({ Extends: h, initialize: function (f, l, u) { h.call(this), this.manager = f, this.key = l, this.isPlaying = !1, this.isPaused = !1, this.totalRate = 1, this.duration = this.duration || 0, this.totalDuration = this.totalDuration || 0, this.config = { mute: !1, volume: 1, rate: 1, detune: 0, seek: 0, loop: !1, delay: 0, pan: 0 }, this.currentConfig = this.config, this.config = o(this.config, u), this.markers = {}, this.currentMarker = null, this.pendingRemove = !1 }, addMarker: function (a) { return !a || !a.name || typeof a.name !== 'string' ? !1 : this.markers[a.name] ? (console.error('addMarker ' + a.name + ' already exists in Sound'), !1) : (a = o(!0, { name: '', start: 0, duration: this.totalDuration - (a.start || 0), config: { mute: !1, volume: 1, rate: 1, detune: 0, seek: 0, loop: !1, delay: 0, pan: 0 } }, a), this.markers[a.name] = a, !0) }, updateMarker: function (a) { return !a || !a.name || typeof a.name !== 'string' ? !1 : this.markers[a.name] ? (this.markers[a.name] = o(!0, this.markers[a.name], a), !0) : (console.warn('Audio Marker: ' + a.name + ' missing in Sound: ' + this.key), !1) }, removeMarker: function (a) { const f = this.markers[a]; return f ? (this.markers[a] = null, f) : null }, play: function (a, f) { if (a === void 0 && (a = ''), typeof a === 'object' && (f = a, a = ''), typeof a !== 'string') return !1; if (!a) this.currentMarker = null, this.currentConfig = this.config, this.duration = this.totalDuration; else { if (!this.markers[a]) return console.warn('Marker: ' + a + ' missing in Sound: ' + this.key), !1; this.currentMarker = this.markers[a], this.currentConfig = this.currentMarker.config, this.duration = this.currentMarker.duration } return this.resetConfig(), this.currentConfig = o(this.currentConfig, f), this.isPlaying = !0, this.isPaused = !1, !0 }, pause: function () { return this.isPaused || !this.isPlaying ? !1 : (this.isPlaying = !1, this.isPaused = !0, !0) }, resume: function () { return !this.isPaused || this.isPlaying ? !1 : (this.isPlaying = !0, this.isPaused = !1, !0) }, stop: function () { return !this.isPaused && !this.isPlaying ? !1 : (this.isPlaying = !1, this.isPaused = !1, this.resetConfig(), !0) }, applyConfig: function () { this.mute = this.currentConfig.mute, this.volume = this.currentConfig.volume, this.rate = this.currentConfig.rate, this.detune = this.currentConfig.detune, this.loop = this.currentConfig.loop, this.pan = this.currentConfig.pan }, resetConfig: function () { this.currentConfig.seek = 0, this.currentConfig.delay = 0 }, update: r, calculateRate: function () { const a = 1.0005777895065548; const f = this.currentConfig.detune + this.manager.detune; const l = Math.pow(a, f); this.totalRate = this.currentConfig.rate * this.manager.rate * l }, destroy: function () { this.pendingRemove || (this.emit(n.DESTROY, this), this.pendingRemove = !0, this.manager = null, this.key = '', this.removeAllListeners(), this.isPlaying = !1, this.isPaused = !1, this.config = null, this.currentConfig = null, this.markers = null, this.currentMarker = null) } }); e.exports = s }, function (e, d, t) { const i = t(209); const h = t(435); const n = function (o, r) { if (r === void 0 && (r = 90), !i(o)) return null; if (typeof r !== 'string' && (r = (r % 360 + 360) % 360), r === 90 || r === -270 || r === 'rotateLeft')o = h(o), o.reverse(); else if (r === -90 || r === 270 || r === 'rotateRight')o.reverse(), o = h(o); else if (Math.abs(r) === 180 || r === 'rotate180') { for (let s = 0; s < o.length; s++)o[s].reverse(); o.reverse() } return o }; e.exports = n }, function (e, d, t) {
        const i = t(0); const h = t(18); const n = t(11); const o = t(15); const r = t(1043); const s = t(1044); const a = t(212); const f = t(10); const l = t(1045); var u = new i({
          Extends: o,
          Mixins: [n.Alpha, n.BlendMode, n.Depth, n.Mask, n.Origin, n.Pipeline, n.ScrollFactor, n.Texture, n.Tint, n.Transform, n.Visible, l],
          initialize: function (p, c, m, g, x, y, T) { x === void 0 && (x = ''), T === void 0 && (T = 0), o.call(this, p, 'BitmapText'), this.font = g; const S = this.scene.sys.cache.bitmapFont.get(g); S || console.warn('Invalid BitmapText key: ' + g), this.fontData = S.data, this._text = '', this._fontSize = y || this.fontData.size, this._letterSpacing = 0, this._align = T, this._bounds = r(), this._dirty = !0, this._maxWidth = 0, this.wordWrapCharCode = 32, this.charColors = [], this.dropShadowX = 0, this.dropShadowY = 0, this.dropShadowColor = 0, this.dropShadowAlpha = 0.5, this.fromAtlas = S.fromAtlas, this.setTexture(S.texture, S.frame), this.setPosition(c, m), this.setOrigin(0, 0), this.initPipeline(), this.setText(x) },
          setLeftAlign: function () { return this._align = u.ALIGN_LEFT, this._dirty = !0, this },
          setCenterAlign: function () { return this._align = u.ALIGN_CENTER, this._dirty = !0, this },
          setRightAlign: function () { return this._align = u.ALIGN_RIGHT, this._dirty = !0, this },
          setFontSize: function (v) { return this._fontSize = v, this._dirty = !0, this },
          setLetterSpacing: function (v) { return v === void 0 && (v = 0), this._letterSpacing = v, this._dirty = !0, this },
          setText: function (v) {
            return !v && v !== 0 && (v = ''), Array.isArray(v) && (v = v.join(`
`)), v !== this.text && (this._text = v.toString(), this._dirty = !0, this.updateDisplayOrigin()), this
          },
          setDropShadow: function (v, p, c, m) { return v === void 0 && (v = 0), p === void 0 && (p = 0), c === void 0 && (c = 0), m === void 0 && (m = 0.5), this.dropShadowX = v, this.dropShadowY = p, this.dropShadowColor = c, this.dropShadowAlpha = m, this },
          setCharacterTint: function (v, p, c, m, g, x, y) { v === void 0 && (v = 0), p === void 0 && (p = 1), c === void 0 && (c = !1), m === void 0 && (m = -1), g === void 0 && (g = m, x = m, y = m); const T = this.text.length; p === -1 && (p = T), v < 0 && (v = T + v), v = h(v, 0, T - 1); for (let S = h(v + p, v, T), E = this.charColors, C = v; C < S; C++) { const P = E[C]; if (m === -1)E[C] = null; else { const A = c ? 1 : 0; P ? (P.tintEffect = A, P.tintTL = m, P.tintTR = g, P.tintBL = x, P.tintBR = y) : E[C] = { tintEffect: A, tintTL: m, tintTR: g, tintBL: x, tintBR: y } } } return this },
          setWordTint: function (v, p, c, m, g, x, y) { p === void 0 && (p = 1); for (let T = this.getTextBounds(), S = T.words, E = typeof v === 'number', C = 0, P = 0; P < S.length; P++) { const A = S[P]; if ((E && P === v || !E && A.word === v) && (this.setCharacterTint(A.i, A.word.length, c, m, g, x, y), C++, C === p)) return this } return this },
          getTextBounds: function (v) { const p = this._bounds; return (this._dirty || v || this.scaleX !== p.scaleX || this.scaleY !== p.scaleY) && (r(this, v, !0, p), this._dirty = !1), p },
          getCharacterAt: function (v, p, c) { for (let m = this.getLocalPoint(v, p, null, c), g = this.getTextBounds(), x = g.characters, y = new f(), T = 0; T < x.length; T++) { const S = x[T]; if (y.setTo(S.x, S.t, S.r - S.x, S.b), y.contains(m.x, m.y)) return S } return null },
          updateDisplayOrigin: function () { return this._dirty = !0, this.getTextBounds(!1), this },
          setFont: function (v, p, c) { if (p === void 0 && (p = this._fontSize), c === void 0 && (c = this._align), v !== this.font) { const m = this.scene.sys.cache.bitmapFont.get(v); m && (this.font = v, this.fontData = m.data, this._fontSize = p, this._align = c, this.fromAtlas = m.fromAtlas === !0, this.setTexture(m.texture, m.frame), r(this, !1, !0, this._bounds)) } return this },
          setMaxWidth: function (v, p) { return this._maxWidth = v, this._dirty = !0, p !== void 0 && (this.wordWrapCharCode = p), this },
          align: { set: function (v) { this._align = v, this._dirty = !0 }, get: function () { return this._align } },
          text: { set: function (v) { this.setText(v) }, get: function () { return this._text } },
          fontSize: { set: function (v) { this._fontSize = v, this._dirty = !0 }, get: function () { return this._fontSize } },
          letterSpacing: { set: function (v) { this._letterSpacing = v, this._dirty = !0 }, get: function () { return this._letterSpacing } },
          maxWidth: { set: function (v) { this._maxWidth = v, this._dirty = !0 }, get: function () { return this._maxWidth } },
          width: { get: function () { return this.getTextBounds(!1), this._bounds.global.width } },
          height: { get: function () { return this.getTextBounds(!1), this._bounds.global.height } },
          toJSON: function () { const v = n.ToJSON(this); const p = { font: this.font, text: this.text, fontSize: this.fontSize, letterSpacing: this.letterSpacing, align: this.align }; return v.data = p, v },
          preDestroy: function () { this.charColors.length = 0, this._bounds = null, this.fontData = null }
        }); u.ALIGN_LEFT = 0, u.ALIGN_CENTER = 1, u.ALIGN_RIGHT = 2, u.ParseFromAtlas = s, u.ParseXMLBitmapFont = a, e.exports = u
      }, function (e, d, t) { const i = t(0); var h = new i({ initialize: function (o) { if (this.entries = [], Array.isArray(o)) for (let r = 0; r < o.length; r++) this.set(o[r]) }, set: function (n) { return this.entries.indexOf(n) === -1 && this.entries.push(n), this }, get: function (n, o) { for (let r = 0; r < this.entries.length; r++) { const s = this.entries[r]; if (s[n] === o) return s } }, getArray: function () { return this.entries.slice(0) }, delete: function (n) { const o = this.entries.indexOf(n); return o > -1 && this.entries.splice(o, 1), this }, dump: function () { console.group('Set'); for (let n = 0; n < this.entries.length; n++) { const o = this.entries[n]; console.log(o) }console.groupEnd() }, each: function (n, o) { let r; const s = this.entries.slice(); const a = s.length; if (o) for (r = 0; r < a && n.call(o, s[r], r) !== !1; r++);else for (r = 0; r < a && n(s[r], r) !== !1; r++);return this }, iterate: function (n, o) { let r; const s = this.entries.length; if (o) for (r = 0; r < s && n.call(o, this.entries[r], r) !== !1; r++);else for (r = 0; r < s && n(this.entries[r], r) !== !1; r++);return this }, iterateLocal: function (n) { let o; const r = []; for (o = 1; o < arguments.length; o++)r.push(arguments[o]); const s = this.entries.length; for (o = 0; o < s; o++) { const a = this.entries[o]; a[n].apply(a, r) } return this }, clear: function () { return this.entries.length = 0, this }, contains: function (n) { return this.entries.indexOf(n) > -1 }, union: function (n) { const o = new h(); return n.entries.forEach(function (r) { o.set(r) }), this.entries.forEach(function (r) { o.set(r) }), o }, intersect: function (n) { const o = new h(); return this.entries.forEach(function (r) { n.contains(r) && o.set(r) }), o }, difference: function (n) { const o = new h(); return this.entries.forEach(function (r) { n.contains(r) || o.set(r) }), o }, size: { get: function () { return this.entries.length }, set: function (n) { return n < this.entries.length ? this.entries.length = n : this.entries.length } } }); e.exports = h }, function (e, d, t) { const i = t(0); const h = t(11); const n = t(15); const o = t(189); const r = t(92); const s = t(1182); const a = new i({ Extends: n, Mixins: [h.AlphaSingle, h.BlendMode, h.Depth, h.GetBounds, h.Mask, h.Pipeline, h.ScrollFactor, h.Transform, h.Visible, s], initialize: function (l, u, v, p, c, m, g) { p === void 0 && (p = 16777215), c === void 0 && (c = 128), m === void 0 && (m = 1), g === void 0 && (g = 0.1), n.call(this, l, 'PointLight'), this.initPipeline(r.POINTLIGHT_PIPELINE), this.setPosition(u, v), this.color = o(p), this.intensity = m, this.attenuation = g, this.width = c * 2, this.height = c * 2, this._radius = c }, radius: { get: function () { return this._radius }, set: function (f) { this._radius = f, this.width = f * 2, this.height = f * 2 } }, originX: { get: function () { return 0.5 } }, originY: { get: function () { return 0.5 } }, displayOriginX: { get: function () { return this._radius } }, displayOriginY: { get: function () { return this._radius } } }); e.exports = a }, function (e, d) { const t = function (i, h) { const n = h.width / 2; const o = h.height / 2; const r = Math.abs(i.x - h.x - n); const s = Math.abs(i.y - h.y - o); const a = n + i.radius; const f = o + i.radius; if (r > a || s > f) return !1; if (r <= n || s <= o) return !0; const l = r - n; const u = s - o; const v = l * l; const p = u * u; const c = i.radius * i.radius; return v + p <= c }; e.exports = t }, function (e, d) { const t = function (i, h) { return i.width <= 0 || i.height <= 0 || h.width <= 0 || h.height <= 0 ? !1 : !(i.right < h.x || i.bottom < h.y || i.x > h.right || i.y > h.bottom) }; e.exports = t }, function (e, d, t) { const i = t(6); const h = {}; const n = {}; n.register = function (o, r, s, a, f) { h[o] = { plugin: r, mapping: s, settingsKey: a, configKey: f } }, n.getPlugin = function (o) { return h[o] }, n.install = function (o) { const r = o.scene.sys; const s = r.settings.input; const a = r.game.config; for (const f in h) { const l = h[f].plugin; const u = h[f].mapping; const v = h[f].settingsKey; const p = h[f].configKey; i(s, v, a[p]) && (o[u] = new l(o)) } }, n.remove = function (o) { h.hasOwnProperty(o) && delete h[o] }, e.exports = n }, function (e, d, t) { e.exports = { ANY_KEY_DOWN: t(1323), ANY_KEY_UP: t(1324), COMBO_MATCH: t(1325), DOWN: t(1326), KEY_DOWN: t(1327), KEY_UP: t(1328), UP: t(1329) } }, function (e, d) { const t = function (i, h) { return i.url ? i.url.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/) ? i.url : h + i.url : !1 }; e.exports = t }, function (e, d) { const t = function (i, h, n, o, r, s) { return i === void 0 && (i = ''), h === void 0 && (h = !0), n === void 0 && (n = ''), o === void 0 && (o = ''), r === void 0 && (r = 0), s === void 0 && (s = !1), { responseType: i, async: h, user: n, password: o, timeout: r, headers: void 0, header: void 0, headerValue: void 0, requestedWith: !1, overrideMimeType: void 0, withCredentials: s } }; e.exports = t }, function (e, d, t) { const i = t(0); const h = t(243); const n = t(73); const o = new i({ Extends: n, Mixins: [h.Acceleration, h.Angular, h.Bounce, h.Debug, h.Drag, h.Enable, h.Friction, h.Gravity, h.Immovable, h.Mass, h.Pushable, h.Size, h.Velocity], initialize: function (s, a, f, l, u) { n.call(this, s, a, f, l, u), this.body = null } }); e.exports = o }, function (e, d, t) { const i = t(119); const h = function (n, o, r, s) { if (r === void 0 && (r = !1), i(n, o, s)) { const a = s.data[o][n] || null; return a ? a.index === -1 ? r ? a : null : a : null } else return null }; e.exports = h }, function (e, d) { const t = function (i, h, n, o) { const r = i.data; const s = i.width; const a = i.height; const f = i.tilemapLayer; const l = Math.max(0, h.left); const u = Math.min(s, h.right); const v = Math.max(0, h.top); const p = Math.min(a, h.bottom); let c; let m; let g; if (n === 0) for (m = v; m < p; m++) for (c = l; r[m] && c < u; c++)g = r[m][c], !(!g || g.index === -1 || !g.visible || g.alpha === 0) && o.push(g); else if (n === 1) for (m = v; m < p; m++) for (c = u; r[m] && c >= l; c--)g = r[m][c], !(!g || g.index === -1 || !g.visible || g.alpha === 0) && o.push(g); else if (n === 2) for (m = p; m >= v; m--) for (c = l; r[m] && c < u; c++)g = r[m][c], !(!g || g.index === -1 || !g.visible || g.alpha === 0) && o.push(g); else if (n === 3) for (m = p; m >= v; m--) for (c = u; r[m] && c >= l; c--)g = r[m][c], !(!g || g.index === -1 || !g.visible || g.alpha === 0) && o.push(g); return f.tilesDrawn = o.length, f.tilesTotal = s * a, o }; e.exports = t }, function (e, d) { const t = function (i, h, n) { const o = n.collideIndexes.indexOf(i); h && o === -1 ? n.collideIndexes.push(i) : !h && o !== -1 && n.collideIndexes.splice(o, 1) }; e.exports = t }, function (e, d, t) { const i = t(2); const h = function (n, o, r) { if (!o) return { i: 0, layers: n.layers, name: '', opacity: 1, visible: !0, x: 0, y: 0 }; const s = o.x + i(o, 'startx', 0) * n.tilewidth + i(o, 'offsetx', 0); const a = o.y + i(o, 'starty', 0) * n.tileheight + i(o, 'offsety', 0); return { i: 0, layers: o.layers, name: r.name + o.name + '/', opacity: r.opacity * o.opacity, visible: r.visible && o.visible, x: r.x + s, y: r.y + a } }; e.exports = h }, function (e, d) { const t = function (i, h, n) { let o; if (i.hasOwnProperty(h)) { const r = typeof i[h]; r === 'function' ? o = function (s, a, f, l, u, v) { return i[h](s, a, f, l, u, v) } : o = function () { return i[h] } } else typeof n === 'function' ? o = n : o = function () { return n }; return o }; e.exports = t }, function (e, d, t) { const i = t(265); const h = t(13); const n = t(99); const o = t(80); const r = t(162); const s = t(583); const a = t(263); const f = t(6); const l = t(264); const u = t(266); const v = t(268); const p = function (c, m, g) { g === void 0 && (g = i); for (var x = g.targets ? g.targets : a(m), y = s(m), T = r(m, 'delay', g.delay), S = r(m, 'duration', g.duration), E = f(m, 'easeParams', g.easeParams), C = o(f(m, 'ease', g.ease), E), P = r(m, 'hold', g.hold), A = r(m, 'repeat', g.repeat), M = r(m, 'repeatDelay', g.repeatDelay), L = n(m, 'yoyo', g.yoyo), F = n(m, 'flipX', g.flipX), I = n(m, 'flipY', g.flipY), G = [], U = 0; U < y.length; U++) for (let Y = y[U].key, X = y[U].value, O = 0; O < x.length; O++) { const R = l(Y, X); const D = v(x[O], O, Y, R.getEnd, R.getStart, R.getActive, o(f(X, 'ease', C), f(X, 'easeParams', E)), r(X, 'delay', T), r(X, 'duration', S), n(X, 'yoyo', L), r(X, 'hold', P), r(X, 'repeat', A), r(X, 'repeatDelay', M), n(X, 'flipX', F), n(X, 'flipY', I)); G.push(D) } const B = new u(c, G, x); B.offset = h(m, 'offset', null), B.completeDelay = h(m, 'completeDelay', 0), B.loop = Math.round(h(m, 'loop', 0)), B.loopDelay = Math.round(h(m, 'loopDelay', 0)), B.paused = n(m, 'paused', !1), B.useFrames = n(m, 'useFrames', !1); for (let N = f(m, 'callbackScope', B), w = [B, null], z = u.TYPES, V = 0; V < z.length; V++) { const W = z[V]; const H = f(m, W, !1); if (H) { const K = f(m, W + 'Scope', N); const Q = f(m, W + 'Params', []); B.setCallback(W, H, w.concat(Q), K) } } return B }; e.exports = p }, function (e, d, t) { const i = t(0); const h = t(102); const n = t(2); const o = t(132); const r = t(185); const s = new i({ initialize: function (f) { this.parent = f, this.animationManager = f.scene.sys.anims, this.animationManager.on(o.REMOVE_ANIMATION, this.globalRemove, this), this.textureManager = this.animationManager.textureManager, this.anims = null, this.isPlaying = !1, this.hasStarted = !1, this.currentAnim = null, this.currentFrame = null, this.nextAnim = null, this.nextAnimsQueue = [], this.timeScale = 1, this.frameRate = 0, this.duration = 0, this.msPerFrame = 0, this.skipMissedFrames = !0, this.delay = 0, this.repeat = 0, this.repeatDelay = 0, this.yoyo = !1, this.showOnStart = !1, this.hideOnComplete = !1, this.forward = !0, this.inReverse = !1, this.accumulator = 0, this.nextTick = 0, this.delayCounter = 0, this.repeatCounter = 0, this.pendingRepeat = !1, this._paused = !1, this._wasPlaying = !1, this._pendingStop = 0, this._pendingStopValue }, chain: function (a) { const f = this.parent; if (a === void 0) return this.nextAnimsQueue.length = 0, this.nextAnim = null, f; Array.isArray(a) || (a = [a]); for (let l = 0; l < a.length; l++) { const u = a[l]; this.nextAnim === null ? this.nextAnim = u : this.nextAnimsQueue.push(u) } return this.parent }, getName: function () { return this.currentAnim ? this.currentAnim.key : '' }, getFrameName: function () { return this.currentFrame ? this.currentFrame.textureFrame : '' }, load: function (a) { this.isPlaying && this.stop(); const f = this.animationManager; const l = typeof a === 'string' ? a : n(a, 'key', null); const u = this.exists(l) ? this.get(l) : f.get(l); if (!u)console.warn('Missing animation: ' + l); else { this.currentAnim = u; const v = u.getTotalFrames(); const p = n(a, 'frameRate', u.frameRate); const c = n(a, 'duration', u.duration); u.calculateDuration(this, v, c, p), this.delay = n(a, 'delay', u.delay), this.repeat = n(a, 'repeat', u.repeat), this.repeatDelay = n(a, 'repeatDelay', u.repeatDelay), this.yoyo = n(a, 'yoyo', u.yoyo), this.showOnStart = n(a, 'showOnStart', u.showOnStart), this.hideOnComplete = n(a, 'hideOnComplete', u.hideOnComplete), this.skipMissedFrames = n(a, 'skipMissedFrames', u.skipMissedFrames), this.timeScale = n(a, 'timeScale', this.timeScale); let m = n(a, 'startFrame', 0); m > u.getTotalFrames() && (m = 0); let g = u.frames[m]; m === 0 && !this.forward && (g = u.getLastFrame()), this.currentFrame = g } return this.parent }, pause: function (a) { return this._paused || (this._paused = !0, this._wasPlaying = this.isPlaying, this.isPlaying = !1), a !== void 0 && this.setCurrentFrame(a), this.parent }, resume: function (a) { return this._paused && (this._paused = !1, this.isPlaying = this._wasPlaying), a !== void 0 && this.setCurrentFrame(a), this.parent }, playAfterDelay: function (a, f) { if (!this.isPlaying) this.delayCounter = f, this.play(a, !0); else { const l = this.nextAnim; const u = this.nextAnimsQueue; l && u.unshift(l), this.nextAnim = a, this._pendingStop = 1, this._pendingStopValue = f } return this.parent }, playAfterRepeat: function (a, f) { if (f === void 0 && (f = 1), !this.isPlaying) this.play(a); else { const l = this.nextAnim; const u = this.nextAnimsQueue; l && u.unshift(l), this.repeatCounter !== -1 && f > this.repeatCounter && (f = this.repeatCounter), this.nextAnim = a, this._pendingStop = 2, this._pendingStopValue = f } return this.parent }, play: function (a, f) { f === void 0 && (f = !1); const l = this.currentAnim; const u = this.parent; const v = typeof a === 'string' ? a : a.key; if (f && this.isPlaying && l.key === v) return u; if (l && this.isPlaying) { const p = this.animationManager.getMix(l.key, a); if (p > 0) return this.playAfterDelay(a, p) } return this.forward = !0, this.inReverse = !1, this._paused = !1, this._wasPlaying = !0, this.startAnimation(a) }, playReverse: function (a, f) { f === void 0 && (f = !1); const l = typeof a === 'string' ? a : a.key; return f && this.isPlaying && this.currentAnim.key === l ? this.parent : (this.forward = !1, this.inReverse = !0, this._paused = !1, this._wasPlaying = !0, this.startAnimation(a)) }, startAnimation: function (a) { this.load(a); const f = this.currentAnim; const l = this.parent; return f && (this.repeatCounter = this.repeat === -1 ? Number.MAX_VALUE : this.repeat, f.getFirstTick(this), this.isPlaying = !0, this.pendingRepeat = !1, this.hasStarted = !1, this._pendingStop = 0, this._pendingStopValue = 0, this._paused = !1, this.delayCounter += this.delay, this.delayCounter === 0 && this.handleStart()), l }, handleStart: function () { this.showOnStart && this.parent.setVisible(!0), this.setCurrentFrame(this.currentFrame), this.hasStarted = !0, this.emitEvents(o.ANIMATION_START) }, handleRepeat: function () { this.pendingRepeat = !1, this.emitEvents(o.ANIMATION_REPEAT) }, handleStop: function () { this._pendingStop = 0, this.isPlaying = !1, this.emitEvents(o.ANIMATION_STOP) }, handleComplete: function () { this._pendingStop = 0, this.isPlaying = !1, this.hideOnComplete && this.parent.setVisible(!1), this.emitEvents(o.ANIMATION_COMPLETE, o.ANIMATION_COMPLETE_KEY) }, emitEvents: function (a, f) { const l = this.currentAnim; const u = this.currentFrame; const v = this.parent; const p = u.textureFrame; v.emit(a, l, u, v, p), f && v.emit(f + l.key, l, u, v, p) }, reverse: function () { return this.isPlaying && (this.inReverse = !this.inReverse, this.forward = !this.forward), this.parent }, getProgress: function () { const a = this.currentFrame; if (!a) return 0; let f = a.progress; return this.inReverse && (f *= -1), f }, setProgress: function (a) { return this.forward || (a = 1 - a), this.setCurrentFrame(this.currentAnim.getFrameByProgress(a)), this.parent }, setRepeat: function (a) { return this.repeatCounter = a === -1 ? Number.MAX_VALUE : a, this.parent }, globalRemove: function (a, f) { f === void 0 && (f = this.currentAnim), this.isPlaying && f.key === this.currentAnim.key && (this.stop(), this.setCurrentFrame(this.currentAnim.frames[0])) }, restart: function (a, f) { a === void 0 && (a = !1), f === void 0 && (f = !1); const l = this.currentAnim; const u = this.parent; return l ? (f && (this.repeatCounter = this.repeat === -1 ? Number.MAX_VALUE : this.repeat), l.getFirstTick(this), this.emitEvents(o.ANIMATION_RESTART), this.isPlaying = !0, this.pendingRepeat = !1, this.hasStarted = !a, this._pendingStop = 0, this._pendingStopValue = 0, this._paused = !1, this.setCurrentFrame(l.frames[0]), this.parent) : u }, complete: function () { if (this._pendingStop = 0, this.isPlaying = !1, this.currentAnim && this.handleComplete(), this.nextAnim) { const a = this.nextAnim; this.nextAnim = this.nextAnimsQueue.length > 0 ? this.nextAnimsQueue.shift() : null, this.play(a) } return this.parent }, stop: function () { if (this._pendingStop = 0, this.isPlaying = !1, this.currentAnim && this.handleStop(), this.nextAnim) { const a = this.nextAnim; this.nextAnim = this.nextAnimsQueue.shift(), this.play(a) } return this.parent }, stopAfterDelay: function (a) { return this._pendingStop = 1, this._pendingStopValue = a, this.parent }, stopAfterRepeat: function (a) { return a === void 0 && (a = 1), this.repeatCounter !== -1 && a > this.repeatCounter && (a = this.repeatCounter), this._pendingStop = 2, this._pendingStopValue = a, this.parent }, stopOnFrame: function (a) { return this._pendingStop = 3, this._pendingStopValue = a, this.parent }, getTotalFrames: function () { return this.currentAnim ? this.currentAnim.getTotalFrames() : 0 }, update: function (a, f) { const l = this.currentAnim; if (!(!this.isPlaying || !l || l.paused)) { if (this.accumulator += f * this.timeScale, this._pendingStop === 1 && (this._pendingStopValue -= f, this._pendingStopValue <= 0)) return this.stop(); if (!this.hasStarted) this.accumulator >= this.delayCounter && (this.accumulator -= this.delayCounter, this.handleStart()); else if (this.accumulator >= this.nextTick && (this.forward ? l.nextFrame(this) : l.previousFrame(this), this.isPlaying && this._pendingStop === 0 && this.skipMissedFrames && this.accumulator > this.nextTick)) { let u = 0; do this.forward ? l.nextFrame(this) : l.previousFrame(this), u++; while (this.isPlaying && this.accumulator > this.nextTick && u < 60) } } }, setCurrentFrame: function (a) { const f = this.parent; return this.currentFrame = a, f.texture = a.frame.texture, f.frame = a.frame, f.isCropped && f.frame.updateCropUVs(f._crop, f.flipX, f.flipY), a.setAlpha && (f.alpha = a.alpha), f.setSizeToFrame(), f._originComponent && (a.frame.customPivot ? f.setOrigin(a.frame.pivotX, a.frame.pivotY) : f.updateDisplayOrigin()), this.isPlaying && this.hasStarted && (this.emitEvents(o.ANIMATION_UPDATE), this._pendingStop === 3 && this._pendingStopValue === a && this.stop()), f }, nextFrame: function () { return this.currentAnim && this.currentAnim.nextFrame(this), this.parent }, previousFrame: function () { return this.currentAnim && this.currentAnim.previousFrame(this), this.parent }, get: function (a) { return this.anims ? this.anims.get(a) : null }, exists: function (a) { return this.anims ? this.anims.has(a) : !1 }, create: function (a) { const f = a.key; let l = !1; return f && (l = this.get(f), l || (l = new r(this, f, a), this.anims || (this.anims = new h()), this.anims.set(f, l))), l }, generateFrameNames: function (a, f) { return this.animationManager.generateFrameNames(a, f) }, generateFrameNumbers: function (a, f) { return this.animationManager.generateFrameNumbers(a, f) }, remove: function (a) { const f = this.get(a); return f && (this.currentAnim === f && this.stop(), this.anims.delete(a)), f }, destroy: function () { this.animationManager.off(o.REMOVE_ANIMATION, this.globalRemove, this), this.anims && this.anims.clear(), this.animationManager = null, this.parent = null, this.nextAnim = null, this.nextAnimsQueue.length = 0, this.currentAnim = null, this.currentFrame = null }, isPaused: { get: function () { return this._paused } } }); e.exports = s }, function (e, d, t) { const i = {}; e.exports = i; const h = t(166); (function () { i._motionWakeThreshold = 0.18, i._motionSleepThreshold = 0.08, i._minBias = 0.9, i.update = function (n, o) { for (let r = o * o * o, s = 0; s < n.length; s++) { const a = n[s]; const f = a.speed * a.speed + a.angularSpeed * a.angularSpeed; if (a.force.x !== 0 || a.force.y !== 0) { i.set(a, !1); continue } const l = Math.min(a.motion, f); const u = Math.max(a.motion, f); a.motion = i._minBias * l + (1 - i._minBias) * u, a.sleepThreshold > 0 && a.motion < i._motionSleepThreshold * r ? (a.sleepCounter += 1, a.sleepCounter >= a.sleepThreshold && i.set(a, !0)) : a.sleepCounter > 0 && (a.sleepCounter -= 1) } }, i.afterCollisions = function (n, o) { for (let r = o * o * o, s = 0; s < n.length; s++) { const a = n[s]; if (a.isActive) { const f = a.collision; const l = f.bodyA.parent; const u = f.bodyB.parent; if (!(l.isSleeping && u.isSleeping || l.isStatic || u.isStatic) && (l.isSleeping || u.isSleeping)) { const v = l.isSleeping && !l.isStatic ? l : u; const p = v === l ? u : l; !v.isStatic && p.motion > i._motionWakeThreshold * r && i.set(v, !1) } } } }, i.set = function (n, o) { const r = n.isSleeping; o ? (n.isSleeping = !0, n.sleepCounter = n.sleepThreshold, n.positionImpulse.x = 0, n.positionImpulse.y = 0, n.positionPrev.x = n.position.x, n.positionPrev.y = n.position.y, n.anglePrev = n.angle, n.speed = 0, n.angularSpeed = 0, n.motion = 0, r || h.trigger(n, 'sleepStart')) : (n.isSleeping = !1, n.sleepCounter = 0, r && h.trigger(n, 'sleepEnd')) } })() }, function (e, d, t) { const i = {}; e.exports = i; const h = t(32); (function () { i.on = function (n, o, r) { for (var s = o.split(' '), a, f = 0; f < s.length; f++)a = s[f], n.events = n.events || {}, n.events[a] = n.events[a] || [], n.events[a].push(r); return r }, i.off = function (n, o, r) { if (!o) { n.events = {}; return } typeof o === 'function' && (r = o, o = h.keys(n.events).join(' ')); for (let s = o.split(' '), a = 0; a < s.length; a++) { const f = n.events[s[a]]; const l = []; if (r && f) for (let u = 0; u < f.length; u++)f[u] !== r && l.push(f[u]); n.events[s[a]] = l } }, i.trigger = function (n, o, r) { let s; let a; let f; let l; const u = n.events; if (u && h.keys(u).length > 0) { r || (r = {}), s = o.split(' '); for (let v = 0; v < s.length; v++) if (a = s[v], f = u[a], f) { l = h.clone(r, !1), l.name = a, l.source = n; for (let p = 0; p < f.length; p++)f[p].apply(n, [l]) } } } })() }, function (e, d, t) { const i = t(175); const h = t(92); const n = t(74); const o = { defaultPipeline: null, pipeline: null, hasPostPipeline: !1, postPipelines: null, pipelineData: null, initPipeline: function (r) { r === void 0 && (r = h.MULTI_PIPELINE); const s = this.scene.sys.renderer; if (!s) return !1; const a = s.pipelines; if (this.postPipelines = [], this.pipelineData = {}, a) { const f = a.get(r); if (f) return this.defaultPipeline = f, this.pipeline = f, !0 } return !1 }, setPipeline: function (r, s, a) { const f = this.scene.sys.renderer; if (!f) return this; const l = f.pipelines; if (l) { const u = l.get(r); u && (this.pipeline = u), s && (this.pipelineData = a ? i(s) : s) } return this }, setPostPipeline: function (r, s, a) { const f = this.scene.sys.renderer; if (!f) return this; const l = f.pipelines; if (l) { Array.isArray(r) || (r = [r]); for (let u = 0; u < r.length; u++) { const v = l.getPostPipeline(r[u], this); v && this.postPipelines.push(v) }s && (this.pipelineData = a ? i(s) : s) } return this.hasPostPipeline = this.postPipelines.length > 0, this }, setPipelineData: function (r, s) { const a = this.pipelineData; return s === void 0 ? delete a[r] : a[r] = s, this }, getPostPipeline: function (r) { for (var s = this.postPipelines, a = [], f = 0; f < s.length; f++) { const l = s[f]; (typeof r === 'string' && l.name === r || l instanceof r) && a.push(l) } return a.length === 1 ? a[0] : a }, resetPipeline: function (r, s) { return r === void 0 && (r = !1), s === void 0 && (s = !1), this.pipeline = this.defaultPipeline, r && (this.postPipelines = [], this.hasPostPipeline = !1), s && (this.pipelineData = {}), this.pipeline !== null }, resetPostPipeline: function (r) { r === void 0 && (r = !1); for (let s = this.postPipelines, a = 0; a < s.length; a++)s[a].destroy(); this.postPipelines = [], this.hasPostPipeline = !1, r && (this.pipelineData = {}) }, removePostPipeline: function (r) { for (let s = this.postPipelines, a = s.length - 1; a >= 0; a--) { const f = s[a]; (typeof r === 'string' && f.name === r || typeof r !== 'string' && f instanceof r) && (f.destroy(), n(s, a)) } return this.hasPostPipeline = this.postPipelines.length > 0, this }, getPipelineName: function () { return this.pipeline.name } }; e.exports = o }, function (e, d) { const t = { DEFAULT: 0, LINEAR: 0, NEAREST: 1 }; e.exports = t }, function (e, d, t) { const i = t(4); const h = function (n, o, r) { return r === void 0 && (r = new i()), r.x = n.x + n.radius * Math.cos(o), r.y = n.y + n.radius * Math.sin(o), r }; e.exports = h }, function (e, d, t) { const i = t(4); const h = function (n, o) { o === void 0 && (o = new i()); const r = 2 * Math.PI * Math.random(); const s = Math.random() + Math.random(); const a = s > 1 ? 2 - s : s; const f = a * Math.cos(r); const l = a * Math.sin(r); return o.x = n.x + f * n.radius, o.y = n.y + l * n.radius, o }; e.exports = h }, function (e, d, t) { const i = t(130); const h = t(4); const n = function (o, r, s) { if (s === void 0 && (s = new h()), r <= 0 || r >= 1) return s.x = o.x, s.y = o.y, s; let a = i(o) * r; return r > 0.5 ? (a -= o.width + o.height, a <= o.width ? (s.x = o.right - a, s.y = o.bottom) : (s.x = o.x, s.y = o.bottom - (a - o.width))) : a <= o.width ? (s.x = o.x + a, s.y = o.y) : (s.x = o.right, s.y = o.y + (a - o.width)), s }; e.exports = n }, function (e, d, t) { const i = t(67); const h = t(4); const n = function (o, r, s, a) { a === void 0 && (a = []), !r && s > 0 && (r = i(o) / s); for (let f = o.x1, l = o.y1, u = o.x2, v = o.y2, p = 0; p < r; p++) { const c = p / r; const m = f + (u - f) * c; const g = l + (v - l) * c; a.push(new h(m, g)) } return a }; e.exports = n }, function (e, d, t) { const i = t(4); const h = function (n, o) { o === void 0 && (o = new i()); const r = Math.random(); return o.x = n.x1 + r * (n.x2 - n.x1), o.y = n.y1 + r * (n.y2 - n.y1), o }; e.exports = h }, function (e, d, t) { const i = t(4); const h = function (n, o) { return o === void 0 && (o = new i()), o.x = n.x + Math.random() * n.width, o.y = n.y + Math.random() * n.height, o }; e.exports = h }, function (e, d) { var t = function (i) { let h, n, o; if (typeof i !== 'object' || i === null) return i; h = Array.isArray(i) ? [] : {}; for (o in i)n = i[o], h[o] = t(n); return h }; e.exports = t }, function (e, d) { const t = function (i) { const h = { name: i.name, type: i.type, x: i.x, y: i.y, depth: i.depth, scale: { x: i.scaleX, y: i.scaleY }, origin: { x: i.originX, y: i.originY }, flipX: i.flipX, flipY: i.flipY, rotation: i.rotation, alpha: i.alpha, visible: i.visible, blendMode: i.blendMode, textureKey: '', frameKey: '', data: {} }; return i.texture && (h.textureKey = i.texture.key, h.frameKey = i.frame.name), h }; e.exports = t }, function (e, d, t) { const i = t(3); const h = function (n, o, r, s, a, f, l, u) { u === void 0 && (u = new i()); const v = Math.sin(a); const p = Math.cos(a); const c = p * f; const m = v * f; const g = -v * l; const x = p * l; const y = 1 / (c * x + g * -m); return u.x = x * y * n + -g * y * o + (s * g - r * x) * y, u.y = c * y * o + -m * y * n + (-s * c + r * m) * y, u }; e.exports = h }, function (e, d) { const t = function (i, h) { h === void 0 && (h = 1); for (var n = null, o = 0; o < h; o++)n = i.shift(), i.push(n); return n }; e.exports = t }, function (e, d) { const t = function (i, h) { h === void 0 && (h = 1); for (var n = null, o = 0; o < h; o++)n = i.pop(), i.unshift(n); return n }; e.exports = t }, function (e, d, t) { const i = t(4); const h = function (n, o) { o === void 0 && (o = new i()); const r = Math.random() * Math.PI * 2; const s = Math.sqrt(Math.random()); return o.x = n.x + s * Math.cos(r) * n.width / 2, o.y = n.y + s * Math.sin(r) * n.height / 2, o }; e.exports = h }, function (e, d, t) { const i = t(4); const h = function (n, o) { o === void 0 && (o = new i()); const r = n.x2 - n.x1; const s = n.y2 - n.y1; const a = n.x3 - n.x1; const f = n.y3 - n.y1; let l = Math.random(); let u = Math.random(); return l + u >= 1 && (l = 1 - l, u = 1 - u), o.x = n.x1 + (r * l + a * u), o.y = n.y1 + (s * l + f * u), o }; e.exports = h }, function (e, d) { const t = function (i, h, n, o, r) { const s = o + Math.atan2(i.y - n, i.x - h); return i.x = h + r * Math.cos(s), i.y = n + r * Math.sin(s), i }; e.exports = t }, function (e, d) { const t = function (i, h, n) { return i = Math.max(0, Math.min(1, (i - h) / (n - h))), i * i * i * (i * (i * 6 - 15) + 10) }; e.exports = t }, function (e, d) { const t = function (i, h, n) { return i <= h ? 0 : i >= n ? 1 : (i = (i - h) / (n - h), i * i * (3 - 2 * i)) }; e.exports = t }, function (e, d, t) { const i = t(18); const h = t(0); const n = t(132); const o = t(318); const r = t(319); const s = t(6); const a = t(320); const f = new h({ initialize: function (u, v, p) { this.manager = u, this.key = v, this.type = 'frame', this.frames = this.getFrames(u.textureManager, s(p, 'frames', []), s(p, 'defaultTextureKey', null), s(p, 'sortFrames', !0)), this.frameRate = s(p, 'frameRate', null), this.duration = s(p, 'duration', null), this.msPerFrame, this.skipMissedFrames = s(p, 'skipMissedFrames', !0), this.delay = s(p, 'delay', 0), this.repeat = s(p, 'repeat', 0), this.repeatDelay = s(p, 'repeatDelay', 0), this.yoyo = s(p, 'yoyo', !1), this.showOnStart = s(p, 'showOnStart', !1), this.hideOnComplete = s(p, 'hideOnComplete', !1), this.paused = !1, this.calculateDuration(this, this.getTotalFrames(), this.duration, this.frameRate), this.manager.on && (this.manager.on(n.PAUSE_ALL, this.pause, this), this.manager.on(n.RESUME_ALL, this.resume, this)) }, getTotalFrames: function () { return this.frames.length }, calculateDuration: function (l, u, v, p) { v === null && p === null ? (l.frameRate = 24, l.duration = 24 / u * 1e3) : v && p === null ? (l.duration = v, l.frameRate = u / (v / 1e3)) : (l.frameRate = p, l.duration = u / p * 1e3), l.msPerFrame = 1e3 / l.frameRate }, addFrame: function (l) { return this.addFrameAt(this.frames.length, l) }, addFrameAt: function (l, u) { const v = this.getFrames(this.manager.textureManager, u); if (v.length > 0) { if (l === 0) this.frames = v.concat(this.frames); else if (l === this.frames.length) this.frames = this.frames.concat(v); else { const p = this.frames.slice(0, l); const c = this.frames.slice(l); this.frames = p.concat(v, c) } this.updateFrameSequence() } return this }, checkFrame: function (l) { return l >= 0 && l < this.frames.length }, getFirstTick: function (l) { l.accumulator = 0, l.nextTick = l.msPerFrame + l.currentFrame.duration }, getFrameAt: function (l) { return this.frames[l] }, getFrames: function (l, u, v, p) { p === void 0 && (p = !0); const c = []; let m; let g; let x = 1; let y; let T; if (typeof u === 'string') { T = u; const S = l.get(T); const E = S.getFrameNames(); p && a(E), u = [], E.forEach(function (F) { u.push({ key: T, frame: F }) }) } if (!Array.isArray(u) || u.length === 0) return c; for (y = 0; y < u.length; y++) { const C = u[y]; const P = s(C, 'key', v); if (P) { const A = s(C, 'frame', 0); const M = l.getFrame(P, A); g = new r(P, A, x, M), g.duration = s(C, 'duration', 0), g.isFirst = !m, m && (m.nextFrame = g, g.prevFrame = m), c.push(g), m = g, x++ } } if (c.length > 0) { g.isLast = !0, g.nextFrame = c[0], c[0].prevFrame = g; const L = 1 / (c.length - 1); for (y = 0; y < c.length; y++)c[y].progress = y * L } return c }, getNextTick: function (l) { l.accumulator -= l.nextTick, l.nextTick = l.msPerFrame + l.currentFrame.duration }, getFrameByProgress: function (l) { return l = i(l, 0, 1), o(l, this.frames, 'progress') }, nextFrame: function (l) { const u = l.currentFrame; u.isLast ? l.yoyo ? this.handleYoyoFrame(l, !1) : l.repeatCounter > 0 ? l.inReverse && l.forward ? l.forward = !1 : this.repeatAnimation(l) : l.complete() : this.updateAndGetNextTick(l, u.nextFrame) }, handleYoyoFrame: function (l, u) { if (u || (u = !1), l.inReverse === !u && l.repeatCounter > 0) { (l.repeatDelay === 0 || l.pendingRepeat) && (l.forward = u), this.repeatAnimation(l); return } if (l.inReverse !== u && l.repeatCounter === 0) { l.complete(); return }l.forward = u; const v = u ? l.currentFrame.nextFrame : l.currentFrame.prevFrame; this.updateAndGetNextTick(l, v) }, getLastFrame: function () { return this.frames[this.frames.length - 1] }, previousFrame: function (l) { const u = l.currentFrame; u.isFirst ? l.yoyo ? this.handleYoyoFrame(l, !0) : l.repeatCounter > 0 ? l.inReverse && !l.forward ? this.repeatAnimation(l) : (l.forward = !0, this.repeatAnimation(l)) : l.complete() : this.updateAndGetNextTick(l, u.prevFrame) }, updateAndGetNextTick: function (l, u) { l.setCurrentFrame(u), this.getNextTick(l) }, removeFrame: function (l) { const u = this.frames.indexOf(l); return u !== -1 && this.removeFrameAt(u), this }, removeFrameAt: function (l) { return this.frames.splice(l, 1), this.updateFrameSequence(), this }, repeatAnimation: function (l) { if (l._pendingStop === 2) { if (l._pendingStopValue === 0) return l.stop(); l._pendingStopValue-- }l.repeatDelay > 0 && !l.pendingRepeat ? (l.pendingRepeat = !0, l.accumulator -= l.nextTick, l.nextTick += l.repeatDelay) : (l.repeatCounter--, l.forward ? l.setCurrentFrame(l.currentFrame.nextFrame) : l.setCurrentFrame(l.currentFrame.prevFrame), l.isPlaying && (this.getNextTick(l), l.handleRepeat())) }, toJSON: function () { const l = { key: this.key, type: this.type, frames: [], frameRate: this.frameRate, duration: this.duration, skipMissedFrames: this.skipMissedFrames, delay: this.delay, repeat: this.repeat, repeatDelay: this.repeatDelay, yoyo: this.yoyo, showOnStart: this.showOnStart, hideOnComplete: this.hideOnComplete }; return this.frames.forEach(function (u) { l.frames.push(u.toJSON()) }), l }, updateFrameSequence: function () { for (var l = this.frames.length, u = 1 / (l - 1), v, p = 0; p < l; p++)v = this.frames[p], v.index = p + 1, v.isFirst = !1, v.isLast = !1, v.progress = p * u, p === 0 ? (v.isFirst = !0, l === 1 ? (v.isLast = !0, v.nextFrame = v, v.prevFrame = v) : (v.isLast = !1, v.prevFrame = this.frames[l - 1], v.nextFrame = this.frames[p + 1])) : p === l - 1 && l > 1 ? (v.isLast = !0, v.prevFrame = this.frames[l - 2], v.nextFrame = this.frames[0]) : l > 1 && (v.prevFrame = this.frames[p - 1], v.nextFrame = this.frames[p + 1]); return this }, pause: function () { return this.paused = !0, this }, resume: function () { return this.paused = !1, this }, destroy: function () { this.manager.off && (this.manager.off(n.PAUSE_ALL, this.pause, this), this.manager.off(n.RESUME_ALL, this.resume, this)), this.manager.remove(this.key); for (let l = 0; l < this.frames.length; l++) this.frames[l].destroy(); this.frames = [], this.manager = null } }); e.exports = f }, function (e, d) { const t = function (i, h, n, o) { h === void 0 && (h = 0), n === void 0 && (n = ' '), o === void 0 && (o = 3), i = i.toString(); let r = 0; if (h + 1 >= i.length) switch (o) { case 1:i = new Array(h + 1 - i.length).join(n) + i; break; case 3:var s = Math.ceil((r = h - i.length) / 2); var a = r - s; i = new Array(a + 1).join(n) + i + new Array(s + 1).join(n); break; default:i = i + new Array(h + 1 - i.length).join(n); break } return i }; e.exports = t }, function (e, d, t) { const i = t(327); const h = t(189); const n = t(331); const o = t(332); const r = function (s) { const a = typeof s; switch (a) { case 'string':return s.substr(0, 3).toLowerCase() === 'rgb' ? o(s) : i(s); case 'number':return h(s); case 'object':return n(s) } }; e.exports = r }, function (e, d, t) { const i = t(103); function h (o, r, s, a) { const f = (o + r * 6) % 6; const l = Math.min(f, 4 - f, 1); return Math.round(255 * (a - a * s * Math.max(0, l))) } const n = function (o, r, s, a) { r === void 0 && (r = 1), s === void 0 && (s = 1); const f = h(5, o, r, s); const l = h(3, o, r, s); const u = h(1, o, r, s); return a ? a.setTo ? a.setTo(f, l, u, a.alpha, !1) : (a.r = f, a.g = l, a.b = u, a.color = i(f, l, u), a) : { r: f, g: l, b: u, color: i(f, l, u) } }; e.exports = n }, function (e, d, t) { const i = t(38); const h = t(330); const n = function (o) { const r = h(o); return new i(r.r, r.g, r.b, r.a) }; e.exports = n }, function (e, d) { const t = function (i, h, n) { return i.x = h - i.width / 2, i.y = n - i.height / 2, i }; e.exports = t }, function (e, d, t) { const i = t(105); const h = t(136); const n = t(31); const o = { canvas: !1, canvasBitBltShift: null, file: !1, fileSystem: !1, getUserMedia: !0, littleEndian: !1, localStorage: !1, pointerLock: !1, support32bit: !1, vibration: !1, webGL: !1, worker: !1 }; function r () { const a = new ArrayBuffer(4); const f = new Uint8Array(a); const l = new Uint32Array(a); return f[0] = 161, f[1] = 178, f[2] = 195, f[3] = 212, l[0] === 3569595041 ? !0 : l[0] === 2712847316 ? !1 : null } function s () { if (typeof importScripts === 'function') return o; o.canvas = !!window.CanvasRenderingContext2D; try { o.localStorage = !!localStorage.getItem } catch (l) { o.localStorage = !1 }o.file = !!window.File && !!window.FileReader && !!window.FileList && !!window.Blob, o.fileSystem = !!window.requestFileSystem; let a = !1; const f = function () { if (window.WebGLRenderingContext) try { const l = n.createWebGL(this); const u = l.getContext('webgl') || l.getContext('experimental-webgl'); const v = n.create2D(this); const p = v.getContext('2d'); const c = p.createImageData(1, 1); return a = c.data instanceof Uint8ClampedArray, n.remove(l), n.remove(v), !!u } catch (m) { return !1 } return !1 }; return o.webGL = f(), o.worker = !!window.Worker, o.pointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document, navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia, window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL, o.getUserMedia = o.getUserMedia && !!navigator.getUserMedia && !!window.URL, h.firefox && h.firefoxVersion < 21 && (o.getUserMedia = !1), !i.iOS && (h.ie || h.firefox || h.chrome) && (o.canvasBitBltShift = !0), (h.safari || h.mobileSafari) && (o.canvasBitBltShift = !1), navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate, navigator.vibrate && (o.vibration = !0), typeof ArrayBuffer !== 'undefined' && typeof Uint8Array !== 'undefined' && typeof Uint32Array !== 'undefined' && (o.littleEndian = r()), o.support32bit = typeof ArrayBuffer !== 'undefined' && typeof Uint8ClampedArray !== 'undefined' && typeof Int32Array !== 'undefined' && o.littleEndian !== null && a, o }e.exports = s() }, function (e, d) { let t = ''; const i = function () { const h = function (s) { for (let a = ['i', 'webkitI', 'msI', 'mozI', 'oI'], f = 0; f < a.length; f++) { const l = a[f] + 'mageSmoothingEnabled'; if (l in s) return l } return null }; const n = function (s) { return t === '' && (t = h(s)), t && (s[t] = !0), s }; const o = function (s) { return t === '' && (t = h(s)), t && (s[t] = !1), s }; const r = function (s) { return t !== null ? s[t] : null }; return { disable: o, enable: n, getPrefix: h, isEnabled: r } }; e.exports = i() }, function (e, d, t) { const i = t(14); const h = t(17); let n = { Angle: t(812), Distance: t(821), Easing: t(826), Fuzzy: t(827), Interpolation: t(830), Pow2: t(835), Snap: t(837), RandomDataGenerator: t(839), Average: t(840), Bernstein: t(356), Between: t(195), CatmullRom: t(194), CeilTo: t(841), Clamp: t(18), DegToRad: t(36), Difference: t(842), Euler: t(843), Factorial: t(357), FloatBetween: t(137), FloorTo: t(844), FromPercent: t(98), GetSpeed: t(845), IsEven: t(846), IsEvenStrict: t(847), Linear: t(135), MaxAdd: t(848), Median: t(849), MinSub: t(850), Percent: t(851), RadToDeg: t(196), RandomXY: t(852), RandomXYZ: t(853), RandomXYZW: t(854), Rotate: t(362), RotateAround: t(308), RotateAroundDistance: t(182), RotateTo: t(855), RoundAwayFromZero: t(363), RoundTo: t(856), SinCosTableGenerator: t(857), SmootherStep: t(183), SmoothStep: t(184), ToXY: t(858), TransformXY: t(177), Within: t(859), Wrap: t(68), Vector2: t(3), Vector3: t(39), Vector4: t(140), Matrix3: t(364), Matrix4: t(69), Quaternion: t(365), RotateVec3: t(860) }; n = h(!1, n, i), e.exports = n }, function (e, d) { const t = function (i, h, n, o, r) { const s = (o - h) * 0.5; const a = (r - n) * 0.5; const f = i * i; const l = i * f; return (2 * n - 2 * o + s + a) * l + (-3 * n + 3 * o - 2 * s - a) * f + s * i + n }; e.exports = t }, function (e, d) { const t = function (i, h) { return Math.floor(Math.random() * (h - i + 1) + i) }; e.exports = t }, function (e, d, t) { const i = t(14); const h = function (n) { return n * i.RAD_TO_DEG }; e.exports = h }, function (e, d, t) { const i = { Global: ['game', 'anims', 'cache', 'plugins', 'registry', 'scale', 'sound', 'textures', 'renderer'], CoreScene: ['EventEmitter', 'CameraManager', 'GameObjectCreator', 'GameObjectFactory', 'ScenePlugin', 'DisplayList', 'UpdateList'], DefaultScene: ['Clock', 'DataManagerPlugin', 'InputPlugin', 'Loader', 'TweenManager', 'LightsPlugin'] }; e.exports = i }, function (e, d, t) { const i = t(0); const h = new i({ initialize: function () { this._matrix = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], this.alpha = 1, this._dirty = !0, this._data }, set: function (n) { return this._matrix = n, this._dirty = !0, this }, reset: function () { const n = this._matrix; return n[0] = 1, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = 0, n[6] = 1, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = 0, n[11] = 0, n[12] = 1, n[13] = 0, n[14] = 0, n[15] = 0, n[16] = 0, n[17] = 0, n[18] = 1, n[19] = 0, this._dirty = !0, this }, getData: function () { if (this._dirty) { const n = new Float32Array(this._matrix); n[4] /= 255, n[9] /= 255, n[14] /= 255, n[19] /= 255, this._data = n, this._dirty = !1 } return this._data }, brightness: function (n, o) { n === void 0 && (n = 0), o === void 0 && (o = !1); const r = n; return this.multiply([r, 0, 0, 0, 0, 0, r, 0, 0, 0, 0, 0, r, 0, 0, 0, 0, 0, 1, 0], o) }, saturate: function (n, o) { n === void 0 && (n = 0), o === void 0 && (o = !1); const r = n * 2 / 3 + 1; const s = (r - 1) * -0.5; return this.multiply([r, s, s, 0, 0, s, r, s, 0, 0, s, s, r, 0, 0, 0, 0, 0, 1, 0], o) }, desaturate: function (n) { return n === void 0 && (n = !1), this.saturate(-1, n) }, hue: function (n, o) { n === void 0 && (n = 0), o === void 0 && (o = !1), n = n / 180 * Math.PI; const r = Math.cos(n); const s = Math.sin(n); const a = 0.213; const f = 0.715; const l = 0.072; return this.multiply([a + r * (1 - a) + s * -a, f + r * -f + s * -f, l + r * -l + s * (1 - l), 0, 0, a + r * -a + s * 0.143, f + r * (1 - f) + s * 0.14, l + r * -l + s * -0.283, 0, 0, a + r * -a + s * -(1 - a), f + r * -f + s * f, l + r * (1 - l) + s * l, 0, 0, 0, 0, 0, 1, 0], o) }, grayscale: function (n, o) { return n === void 0 && (n = 1), o === void 0 && (o = !1), this.saturate(-n, o) }, blackWhite: function (n) { return n === void 0 && (n = !1), this.multiply([0.3, 0.6, 0.1, 0, 0, 0.3, 0.6, 0.1, 0, 0, 0.3, 0.6, 0.1, 0, 0, 0, 0, 0, 1, 0], n) }, contrast: function (n, o) { n === void 0 && (n = 0), o === void 0 && (o = !1); const r = n + 1; const s = -0.5 * (r - 1); return this.multiply([r, 0, 0, 0, s, 0, r, 0, 0, s, 0, 0, r, 0, s, 0, 0, 0, 1, 0], o) }, negative: function (n) { return n === void 0 && (n = !1), this.multiply([-1, 0, 0, 1, 0, 0, -1, 0, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0], n) }, desaturateLuminance: function (n) { return n === void 0 && (n = !1), this.multiply([0.2764723, 0.929708, 0.0938197, 0, -37.1, 0.2764723, 0.929708, 0.0938197, 0, -37.1, 0.2764723, 0.929708, 0.0938197, 0, -37.1, 0, 0, 0, 1, 0], n) }, sepia: function (n) { return n === void 0 && (n = !1), this.multiply([0.393, 0.7689999, 0.18899999, 0, 0, 0.349, 0.6859999, 0.16799999, 0, 0, 0.272, 0.5339999, 0.13099999, 0, 0, 0, 0, 0, 1, 0], n) }, night: function (n, o) { return n === void 0 && (n = 0.1), o === void 0 && (o = !1), this.multiply([n * -2, -n, 0, 0, 0, -n, 0, n, 0, 0, 0, n, n * 2, 0, 0, 0, 0, 0, 1, 0], o) }, lsd: function (n) { return n === void 0 && (n = !1), this.multiply([2, -0.4, 0.5, 0, 0, -0.5, 2, -0.4, 0, 0, -0.4, -0.5, 3, 0, 0, 0, 0, 0, 1, 0], n) }, brown: function (n) { return n === void 0 && (n = !1), this.multiply([0.5997023498159715, 0.34553243048391263, -0.2708298674538042, 0, 47.43192855600873, -0.037703249837783157, 0.8609577587992641, 0.15059552388459913, 0, -36.96841498319127, 0.24113635128153335, -0.07441037908422492, 0.44972182064877153, 0, -7.562075277591283, 0, 0, 0, 1, 0], n) }, vintagePinhole: function (n) { return n === void 0 && (n = !1), this.multiply([0.6279345635605994, 0.3202183420819367, -0.03965408211312453, 0, 9.651285835294123, 0.02578397704808868, 0.6441188644374771, 0.03259127616149294, 0, 7.462829176470591, 0.0466055556782719, -0.0851232987247891, 0.5241648018700465, 0, 5.159190588235296, 0, 0, 0, 1, 0], n) }, kodachrome: function (n) { return n === void 0 && (n = !1), this.multiply([1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0, 63.72958762196502, -0.16404339962244616, 1.0835251566291304, -0.05498805115633132, 0, 24.732407896706203, -0.16786010706155763, -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946, 0, 0, 0, 1, 0], n) }, technicolor: function (n) { return n === void 0 && (n = !1), this.multiply([1.9125277891456083, -0.8545344976951645, -0.09155508482755585, 0, 11.793603434377337, -0.3087833385928097, 1.7658908555458428, -0.10601743074722245, 0, -70.35205161461398, -0.231103377548616, -0.7501899197440212, 1.847597816108189, 0, 30.950940869491138, 0, 0, 0, 1, 0], n) }, polaroid: function (n) { return n === void 0 && (n = !1), this.multiply([1.438, -0.062, -0.062, 0, 0, -0.122, 1.378, -0.122, 0, 0, -0.016, -0.016, 1.483, 0, 0, 0, 0, 0, 1, 0], n) }, shiftToBGR: function (n) { return n === void 0 && (n = !1), this.multiply([0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0], n) }, multiply: function (n, o) { o || this.reset(); for (var r = this._matrix, s = [], a = 0; a < 20; a++)s[a] = r[a]; return r[0] = s[0] * n[0] + s[1] * n[5] + s[2] * n[10] + s[3] * n[15], r[1] = s[0] * n[1] + s[1] * n[6] + s[2] * n[11] + s[3] * n[16], r[2] = s[0] * n[2] + s[1] * n[7] + s[2] * n[12] + s[3] * n[17], r[3] = s[0] * n[3] + s[1] * n[8] + s[2] * n[13] + s[3] * n[18], r[4] = s[0] * n[4] + s[1] * n[9] + s[2] * n[14] + s[3] * n[19] + s[4], r[5] = s[5] * n[0] + s[6] * n[5] + s[7] * n[10] + s[8] * n[15], r[6] = s[5] * n[1] + s[6] * n[6] + s[7] * n[11] + s[8] * n[16], r[7] = s[5] * n[2] + s[6] * n[7] + s[7] * n[12] + s[8] * n[17], r[8] = s[5] * n[3] + s[6] * n[8] + s[7] * n[13] + s[8] * n[18], r[9] = s[5] * n[4] + s[6] * n[9] + s[7] * n[14] + s[8] * n[19] + s[9], r[10] = s[10] * n[0] + s[11] * n[5] + s[12] * n[10] + s[13] * n[15], r[11] = s[10] * n[1] + s[11] * n[6] + s[12] * n[11] + s[13] * n[16], r[12] = s[10] * n[2] + s[11] * n[7] + s[12] * n[12] + s[13] * n[17], r[13] = s[10] * n[3] + s[11] * n[8] + s[12] * n[13] + s[13] * n[18], r[14] = s[10] * n[4] + s[11] * n[9] + s[12] * n[14] + s[13] * n[19] + s[14], r[15] = s[15] * n[0] + s[16] * n[5] + s[17] * n[10] + s[18] * n[15], r[16] = s[15] * n[1] + s[16] * n[6] + s[17] * n[11] + s[18] * n[16], r[17] = s[15] * n[2] + s[16] * n[7] + s[17] * n[12] + s[18] * n[17], r[18] = s[15] * n[3] + s[16] * n[8] + s[17] * n[13] + s[18] * n[18], r[19] = s[15] * n[4] + s[16] * n[9] + s[17] * n[14] + s[18] * n[19] + s[19], this._dirty = !0, this } }); e.exports = h }, function (e, d, t) { const i = t(10); const h = t(14); const n = function (o, r) { if (r === void 0 && (r = new i()), o.length === 0) return r; for (var s = Number.MAX_VALUE, a = Number.MAX_VALUE, f = h.MIN_SAFE_INTEGER, l = h.MIN_SAFE_INTEGER, u, v, p, c = 0; c < o.length; c++)u = o[c], Array.isArray(u) ? (v = u[0], p = u[1]) : (v = u.x, p = u.y), s = Math.min(s, v), a = Math.min(a, p), f = Math.max(f, v), l = Math.max(l, p); return r.x = s, r.y = a, r.width = f - s, r.height = l - a, r }; e.exports = n }, function (e, d, t) { const i = t(0); const h = t(1); const n = new i({ initialize: function (r, s, a) { this._rgb = [0, 0, 0], this.onChangeCallback = h, this.dirty = !1, this.set(r, s, a) }, set: function (o, r, s) { return o === void 0 && (o = 0), r === void 0 && (r = 0), s === void 0 && (s = 0), this._rgb = [o, r, s], this.onChange(), this }, equals: function (o, r, s) { const a = this._rgb; return a.r === o && a.g === r && a.b === s }, onChange: function () { this.dirty = !0; const o = this._rgb; this.onChangeCallback.call(this, o[0], o[1], o[2]) }, r: { get: function () { return this._rgb[0] }, set: function (o) { this._rgb[0] = o, this.onChange() } }, g: { get: function () { return this._rgb[1] }, set: function (o) { this._rgb[1] = o, this.onChange() } }, b: { get: function () { return this._rgb[2] }, set: function (o) { this._rgb[2] = o, this.onChange() } }, destroy: function () { this.onChangeCallback = null } }); e.exports = n }, function (e, d, t) { const i = { CENTER: t(403), ORIENTATION: t(404), SCALE_MODE: t(405), ZOOM: t(406) }; e.exports = i }, function (e, d) { const t = function (i) { i.parentNode && i.parentNode.removeChild(i) }; e.exports = t }, function (e, d) { const t = { MOUSE_DOWN: 0, MOUSE_MOVE: 1, MOUSE_UP: 2, TOUCH_START: 3, TOUCH_MOVE: 4, TOUCH_END: 5, POINTER_LOCK_CHANGE: 6, TOUCH_CANCEL: 7, MOUSE_WHEEL: 8 }; e.exports = t }, function (e, d, t) { const i = t(0); const h = t(144); const n = t(197); const o = t(20); const r = t(419); const s = t(420); const a = t(33); const f = t(1); const l = t(421); const u = new i({ initialize: function (p, c) { this.scene = p, this.game, this.renderer, this.config = c, this.settings = l.create(c), this.canvas, this.context, this.anims, this.cache, this.plugins, this.registry, this.scale, this.sound, this.textures, this.add, this.cameras, this.displayList, this.events, this.make, this.scenePlugin, this.updateList, this.sceneUpdate = f }, init: function (v) { this.settings.status = h.INIT, this.sceneUpdate = f, this.game = v, this.renderer = v.renderer, this.canvas = v.canvas, this.context = v.context; const p = v.plugins; this.plugins = p, p.addToScene(this, n.Global, [n.CoreScene, s(this), r(this)]), this.events.emit(o.BOOT, this), this.settings.isBooted = !0 }, step: function (v, p) { const c = this.events; c.emit(o.PRE_UPDATE, v, p), c.emit(o.UPDATE, v, p), this.sceneUpdate.call(this.scene, v, p), c.emit(o.POST_UPDATE, v, p) }, render: function (v) { const p = this.displayList; p.depthSort(), this.events.emit(o.PRE_RENDER, v), this.cameras.render(v, p), this.events.emit(o.RENDER, v) }, queueDepthSort: function () { this.displayList.queueDepthSort() }, depthSort: function () { this.displayList.depthSort() }, pause: function (v) { const p = this.events; const c = this.settings; return this.settings.active && (c.status = h.PAUSED, c.active = !1, p.emit(o.PAUSE, this, v)), this }, resume: function (v) { const p = this.events; const c = this.settings; return this.settings.active || (c.status = h.RUNNING, c.active = !0, p.emit(o.RESUME, this, v)), this }, sleep: function (v) { const p = this.events; const c = this.settings; return c.status = h.SLEEPING, c.active = !1, c.visible = !1, p.emit(o.SLEEP, this, v), this }, wake: function (v) { const p = this.events; const c = this.settings; return c.status = h.RUNNING, c.active = !0, c.visible = !0, p.emit(o.WAKE, this, v), c.isTransition && p.emit(o.TRANSITION_WAKE, c.transitionFrom, c.transitionDuration), this }, getData: function () { return this.settings.data }, isSleeping: function () { return this.settings.status === h.SLEEPING }, isActive: function () { return this.settings.status === h.RUNNING }, isPaused: function () { return this.settings.status === h.PAUSED }, isTransitioning: function () { return this.settings.isTransition || this.scenePlugin._target !== null }, isTransitionOut: function () { return this.scenePlugin._target !== null && this.scenePlugin._duration > 0 }, isTransitionIn: function () { return this.settings.isTransition }, isVisible: function () { return this.settings.visible }, setVisible: function (v) { return this.settings.visible = v, this }, setActive: function (v, p) { return v ? this.resume(p) : this.pause(p) }, start: function (v) { const p = this.events; const c = this.settings; v && (c.data = v), c.status = h.START, c.active = !0, c.visible = !0, p.emit(o.START, this), p.emit(o.READY, this, v) }, shutdown: function (v) { const p = this.events; const c = this.settings; p.off(o.TRANSITION_INIT), p.off(o.TRANSITION_START), p.off(o.TRANSITION_COMPLETE), p.off(o.TRANSITION_OUT), c.status = h.SHUTDOWN, c.active = !1, c.visible = !1, this.renderer === a.WEBGL && this.renderer.resetTextures(!0), p.emit(o.SHUTDOWN, this, v) }, destroy: function () { const v = this.events; const p = this.settings; p.status = h.DESTROYED, p.active = !1, p.visible = !1, v.emit(o.DESTROY, this), v.removeAllListeners(); for (let c = ['scene', 'game', 'anims', 'cache', 'plugins', 'registry', 'sound', 'textures', 'add', 'camera', 'displayList', 'events', 'make', 'scenePlugin', 'updateList'], m = 0; m < c.length; m++) this[c[m]] = null } }); e.exports = u }, function (e, d) { const t = function (i) { return i && i[0].toUpperCase() + i.slice(1) }; e.exports = t }, function (e, d, t) { const i = t(33); const h = t(0); const n = t(109); const o = t(424); const r = 'Texture.frame missing: '; const s = new h({ initialize: function (f, l, u, v, p) { Array.isArray(u) || (u = [u]), this.manager = f, this.key = l, this.source = [], this.dataSource = [], this.frames = {}, this.customData = {}, this.firstFrame = '__BASE', this.frameTotal = 0; for (let c = 0; c < u.length; c++) this.source.push(new o(this, u[c], v, p)) }, add: function (a, f, l, u, v, p) { if (this.has(a)) return null; const c = new n(this, a, f, l, u, v, p); return this.frames[a] = c, this.firstFrame === '__BASE' && (this.firstFrame = a), this.frameTotal++, c }, remove: function (a) { if (this.has(a)) { const f = this.get(a); return f.destroy(), delete this.frames[a], !0 } return !1 }, has: function (a) { return this.frames[a] }, get: function (a) { a || (a = this.firstFrame); let f = this.frames[a]; return f || (console.warn(r + a), f = this.frames[this.firstFrame]), f }, getTextureSourceIndex: function (a) { for (let f = 0; f < this.source.length; f++) if (this.source[f] === a) return f; return -1 }, getFramesFromTextureSource: function (a, f) { f === void 0 && (f = !1); const l = []; for (const u in this.frames) if (!(u === '__BASE' && !f)) { const v = this.frames[u]; v.sourceIndex === a && l.push(v) } return l }, getFrameNames: function (a) { a === void 0 && (a = !1); const f = Object.keys(this.frames); if (!a) { const l = f.indexOf('__BASE'); l !== -1 && f.splice(l, 1) } return f }, getSourceImage: function (a) { (a == null || this.frameTotal === 1) && (a = '__BASE'); const f = this.frames[a]; return f ? f.source.image : (console.warn(r + a), this.frames.__BASE.source.image) }, getDataSourceImage: function (a) { (a == null || this.frameTotal === 1) && (a = '__BASE'); const f = this.frames[a]; let l; return f ? l = f.sourceIndex : (console.warn(r + a), l = this.frames.__BASE.sourceIndex), this.dataSource[l].image }, setDataSource: function (a) { Array.isArray(a) || (a = [a]); for (let f = 0; f < a.length; f++) { const l = this.source[f]; this.dataSource.push(new o(this, a[f], l.width, l.height)) } }, setFilter: function (a) { let f; for (f = 0; f < this.source.length; f++) this.source[f].setFilter(a); for (f = 0; f < this.dataSource.length; f++) this.dataSource[f].setFilter(a) }, destroy: function () { let a; for (a = 0; a < this.source.length; a++) this.source[a].destroy(); for (a = 0; a < this.dataSource.length; a++) this.dataSource[a].destroy(); for (const f in this.frames) { const l = this.frames[f]; l.destroy() } this.source = [], this.dataSource = [], this.frames = {}, this.manager.removeKey(this.key); const u = this.manager.game.renderer; u && u.type === i.WEBGL && u.resetTextures(!0), this.manager = null } }); e.exports = s }, function (e, d, t) { const i = t(78); const h = function (n, o, r, s, a) { s === void 0 && (s = 0), a === void 0 && (a = n.length); const f = []; if (i(n, s, a)) for (let l = s; l < a; l++) { const u = n[l]; (!o || o && r === void 0 && u.hasOwnProperty(o) || o && r !== void 0 && u[o] === r) && f.push(u) } return f }; e.exports = h }, function (e, d, t) { e.exports = { Matrix: t(1013), Add: t(1021), AddAt: t(1022), BringToTop: t(1023), CountAllMatching: t(1024), Each: t(1025), EachInRange: t(1026), FindClosestInSorted: t(318), GetAll: t(207), GetFirst: t(428), GetRandom: t(210), MoveDown: t(1027), MoveTo: t(1028), MoveUp: t(1029), MoveAbove: t(1030), MoveBelow: t(1031), NumberArray: t(322), NumberArrayStep: t(1032), QuickSelect: t(436), Range: t(437), Remove: t(93), RemoveAt: t(1033), RemoveBetween: t(1034), RemoveRandomElement: t(1035), Replace: t(1036), RotateLeft: t(178), RotateRight: t(179), SafeRange: t(78), SendToBack: t(1037), SetAll: t(1038), Shuffle: t(131), SortByDigits: t(320), SpliceOne: t(74), StableSort: t(79), Swap: t(1039) } }, function (e, d) { const t = function (i) { if (!Array.isArray(i) || i.length < 2 || !Array.isArray(i[0])) return !1; for (let h = i[0].length, n = 1; n < i.length; n++) if (i[n].length !== h) return !1; return !0 }; e.exports = t }, function (e, d) { const t = function (i, h, n) { h === void 0 && (h = 0), n === void 0 && (n = i.length); const o = h + Math.floor(Math.random() * n); return i[o] === void 0 ? null : i[o] }; e.exports = t }, function (e, d, t) { const i = t(0); const h = t(9); const n = t(438); const o = new i({ Extends: h, initialize: function () { h.call(this), this._pending = [], this._active = [], this._destroy = [], this._toProcess = 0, this.checkQueue = !1 }, add: function (r) { return this._pending.push(r), this._toProcess++, r }, remove: function (r) { return this._destroy.push(r), this._toProcess++, r }, removeAll: function () { for (let r = this._active, s = this._destroy, a = r.length; a--;)s.push(r[a]), this._toProcess++; return this }, update: function () { if (this._toProcess === 0) return this._active; let r = this._destroy; const s = this._active; let a; let f; for (a = 0; a < r.length; a++) { f = r[a]; const l = s.indexOf(f); l !== -1 && (s.splice(l, 1), this.emit(n.PROCESS_QUEUE_REMOVE, f)) } for (r.length = 0, r = this._pending, a = 0; a < r.length; a++)f = r[a], (!this.checkQueue || this.checkQueue && s.indexOf(f) === -1) && (s.push(f), this.emit(n.PROCESS_QUEUE_ADD, f)); return r.length = 0, this._toProcess = 0, s }, getActive: function () { return this._active }, length: { get: function () { return this._active.length } }, destroy: function () { this._toProcess = 0, this._pending = [], this._active = [], this._destroy = [] } }); e.exports = o }, function (e, d) { function t (h, n) { return parseInt(h.getAttribute(n), 10) } const i = function (h, n, o, r, s) { o === void 0 && (o = 0), r === void 0 && (r = 0); const a = n.cutX; const f = n.cutY; const l = n.source.width; const u = n.source.height; const v = n.sourceIndex; const p = {}; const c = h.getElementsByTagName('info')[0]; const m = h.getElementsByTagName('common')[0]; p.font = c.getAttribute('face'), p.size = t(c, 'size'), p.lineHeight = t(m, 'lineHeight') + r, p.chars = {}; const g = h.getElementsByTagName('char'); const x = n !== void 0 && n.trimmed; if (x) var y = n.height, T = n.width; for (var S = 0; S < g.length; S++) { const E = g[S]; const C = t(E, 'id'); const P = String.fromCharCode(C); let A = t(E, 'x'); let M = t(E, 'y'); const L = t(E, 'width'); const F = t(E, 'height'); x && (A < T && (T = A), M < y && (y = M)), x && y !== 0 && T !== 0 && (A -= n.x, M -= n.y); const I = (a + A) / l; const G = (f + M) / u; const U = (a + A + L) / l; const Y = (f + M + F) / u; if (p.chars[C] = { x: A, y: M, width: L, height: F, centerX: Math.floor(L / 2), centerY: Math.floor(F / 2), xOffset: t(E, 'xoffset'), yOffset: t(E, 'yoffset'), xAdvance: t(E, 'xadvance') + o, data: {}, kerning: {}, u0: I, v0: G, u1: U, v1: Y }, s && L !== 0 && F !== 0) { const X = s.add(P, v, A, M, L, F); X && X.setUVs(L, F, I, G, U, Y) } } const O = h.getElementsByTagName('kerning'); for (S = 0; S < O.length; S++) { const R = O[S]; const D = t(R, 'first'); const B = t(R, 'second'); const N = t(R, 'amount'); p.chars[B].kerning[D] = N } return p }; e.exports = i }, function (e, d, t) { const i = t(1049); const h = t(440); const n = t(0); const o = t(11); const r = t(109); const s = t(15); const a = t(110); const f = new n({ Extends: s, Mixins: [o.Alpha, o.BlendMode, o.Depth, o.Mask, o.Pipeline, o.ScrollFactor, o.Size, o.Texture, o.Transform, o.Visible, i], initialize: function (u, v, p, c, m) { s.call(this, u, 'Blitter'), this.setTexture(c, m), this.setPosition(v, p), this.initPipeline(), this.children = new a(), this.renderList = [], this.dirty = !1 }, create: function (l, u, v, p, c) { p === void 0 && (p = !0), c === void 0 && (c = this.children.length), v === void 0 ? v = this.frame : v instanceof r || (v = this.texture.get(v)); const m = new h(this, l, u, v, p); return this.children.addAt(m, c, !1), this.dirty = !0, m }, createFromCallback: function (l, u, v, p) { for (var c = this.createMultiple(u, v, p), m = 0; m < c.length; m++) { const g = c[m]; l.call(this, g, m) } return c }, createMultiple: function (l, u, v) { u === void 0 && (u = this.frame.name), v === void 0 && (v = !0), Array.isArray(u) || (u = [u]); const p = []; const c = this; return u.forEach(function (m) { for (let g = 0; g < l; g++)p.push(c.create(0, 0, m, v)) }), p }, childCanRender: function (l) { return l.visible && l.alpha > 0 }, getRenderList: function () { return this.dirty && (this.renderList = this.children.list.filter(this.childCanRender, this), this.dirty = !1), this.renderList }, clear: function () { this.children.removeAll(), this.dirty = !0 }, preDestroy: function () { this.children.destroy(), this.renderList = [] } }); e.exports = f }, function (e, d, t) { const i = t(208); const h = t(35); const n = t(0); const o = t(11); const r = t(75); const s = t(15); const a = t(10); const f = t(1052); const l = t(441); const u = t(3); const v = new n({ Extends: s, Mixins: [o.AlphaSingle, o.BlendMode, o.ComputedSize, o.Depth, o.Mask, o.Pipeline, o.Transform, o.Visible, f], initialize: function (c, m, g, x) { s.call(this, c, 'Container'), this.list = [], this.exclusive = !0, this.maxSize = -1, this.position = 0, this.localTransform = new o.TransformMatrix(), this.tempTransformMatrix = new o.TransformMatrix(), this._sortKey = '', this._sysEvents = c.sys.events, this.scrollFactorX = 1, this.scrollFactorY = 1, this.initPipeline(), this.setPosition(m, g), this.clearAlpha(), this.setBlendMode(h.SKIP_CHECK), x && this.add(x) }, originX: { get: function () { return 0.5 } }, originY: { get: function () { return 0.5 } }, displayOriginX: { get: function () { return this.width * 0.5 } }, displayOriginY: { get: function () { return this.height * 0.5 } }, setExclusive: function (p) { return p === void 0 && (p = !0), this.exclusive = p, this }, getBounds: function (p) { if (p === void 0 && (p = new a()), p.setTo(this.x, this.y, 0, 0), this.parentContainer) { const c = this.parentContainer.getBoundsTransformMatrix(); const m = c.transformPoint(this.x, this.y); p.setTo(m.x, m.y, 0, 0) } if (this.list.length > 0) { const g = this.list; const x = new a(); let y = !1; p.setEmpty(); for (let T = 0; T < g.length; T++) { const S = g[T]; S.getBounds && (S.getBounds(x), y ? l(x, p, p) : (p.setTo(x.x, x.y, x.width, x.height), y = !0)) } } return p }, addHandler: function (p) { p.once(r.DESTROY, this.remove, this), this.exclusive && (p.parentContainer && p.parentContainer.remove(p), p.removeFromDisplayList(), p.parentContainer = this) }, removeHandler: function (p) { p.off(r.DESTROY, this.remove), this.exclusive && (p.parentContainer = null, p.addToDisplayList()) }, pointToContainer: function (p, c) { c === void 0 && (c = new u()), this.parentContainer ? this.parentContainer.pointToContainer(p, c) : c = new u(p.x, p.y); const m = this.tempTransformMatrix; return m.applyITRS(this.x, this.y, this.rotation, this.scaleX, this.scaleY), m.invert(), m.transformPoint(p.x, p.y, c), c }, getBoundsTransformMatrix: function () { return this.getWorldTransformMatrix(this.tempTransformMatrix, this.localTransform) }, add: function (p) { return i.Add(this.list, p, this.maxSize, this.addHandler, this), this }, addAt: function (p, c) { return i.AddAt(this.list, p, c, this.maxSize, this.addHandler, this), this }, getAt: function (p) { return this.list[p] }, getIndex: function (p) { return this.list.indexOf(p) }, sort: function (p, c) { return p ? (c === void 0 && (c = function (m, g) { return m[p] - g[p] }), i.StableSort(this.list, c), this) : this }, getByName: function (p) { return i.GetFirst(this.list, 'name', p) }, getRandom: function (p, c) { return i.GetRandom(this.list, p, c) }, getFirst: function (p, c, m, g) { return i.GetFirst(this.list, p, c, m, g) }, getAll: function (p, c, m, g) { return i.GetAll(this.list, p, c, m, g) }, count: function (p, c, m, g) { return i.CountAllMatching(this.list, p, c, m, g) }, swap: function (p, c) { return i.Swap(this.list, p, c), this }, moveTo: function (p, c) { return i.MoveTo(this.list, p, c), this }, moveAbove: function (p, c) { return i.MoveAbove(this.list, p, c), this }, moveBelow: function (p, c) { return i.MoveBelow(this.list, p, c), this }, remove: function (p, c) { let m = i.Remove(this.list, p, this.removeHandler, this); if (c && m) { Array.isArray(m) || (m = [m]); for (let g = 0; g < m.length; g++)m[g].destroy() } return this }, removeAt: function (p, c) { const m = i.RemoveAt(this.list, p, this.removeHandler, this); return c && m && m.destroy(), this }, removeBetween: function (p, c, m) { const g = i.RemoveBetween(this.list, p, c, this.removeHandler, this); if (m) for (let x = 0; x < g.length; x++)g[x].destroy(); return this }, removeAll: function (p) { const c = i.RemoveBetween(this.list, 0, this.list.length, this.removeHandler, this); if (p) for (let m = 0; m < c.length; m++)c[m].destroy(); return this }, bringToTop: function (p) { return i.BringToTop(this.list, p), this }, sendToBack: function (p) { return i.SendToBack(this.list, p), this }, moveUp: function (p) { return i.MoveUp(this.list, p), this }, moveDown: function (p) { return i.MoveDown(this.list, p), this }, reverse: function () { return this.list.reverse(), this }, shuffle: function () { return i.Shuffle(this.list), this }, replace: function (p, c, m) { const g = i.Replace(this.list, p, c); return g && (this.addHandler(c), this.removeHandler(p), m && p.destroy()), this }, exists: function (p) { return this.list.indexOf(p) > -1 }, setAll: function (p, c, m, g) { return i.SetAll(this.list, p, c, m, g), this }, each: function (p, c) { const m = [null]; let g; const x = this.list.slice(); const y = x.length; for (g = 2; g < arguments.length; g++)m.push(arguments[g]); for (g = 0; g < y; g++)m[0] = x[g], p.apply(c, m); return this }, iterate: function (p, c) { const m = [null]; let g; for (g = 2; g < arguments.length; g++)m.push(arguments[g]); for (g = 0; g < this.list.length; g++)m[0] = this.list[g], p.apply(c, m); return this }, setScrollFactor: function (p, c, m) { return c === void 0 && (c = p), m === void 0 && (m = !1), this.scrollFactorX = p, this.scrollFactorY = c, m && (i.SetAll(this.list, 'scrollFactorX', p), i.SetAll(this.list, 'scrollFactorY', c)), this }, length: { get: function () { return this.list.length } }, first: { get: function () { return this.position = 0, this.list.length > 0 ? this.list[0] : null } }, last: { get: function () { return this.list.length > 0 ? (this.position = this.list.length - 1, this.list[this.position]) : null } }, next: { get: function () { return this.position < this.list.length ? (this.position++, this.list[this.position]) : null } }, previous: { get: function () { return this.position > 0 ? (this.position--, this.list[this.position]) : null } }, preDestroy: function () { this.removeAll(!!this.exclusive), this.localTransform.destroy(), this.tempTransformMatrix.destroy(), this.list = [] } }); e.exports = v }, function (e, d, t) { const i = t(148); const h = t(0); const n = t(1057); const o = new h({ Extends: i, Mixins: [n], initialize: function (s, a, f, l, u, v, p) { i.call(this, s, a, f, l, u, v, p), this.type = 'DynamicBitmapText', this.scrollX = 0, this.scrollY = 0, this.cropWidth = 0, this.cropHeight = 0, this.displayCallback, this.callbackData = { parent: this, color: 0, tint: { topLeft: 0, topRight: 0, bottomLeft: 0, bottomRight: 0 }, index: 0, charCode: 0, x: 0, y: 0, scale: 0, rotation: 0, data: 0 } }, setSize: function (r, s) { return this.cropWidth = r, this.cropHeight = s, this }, setDisplayCallback: function (r) { return this.displayCallback = r, this }, setScrollX: function (r) { return this.scrollX = r, this }, setScrollY: function (r) { return this.scrollY = r, this } }); e.exports = o }, function (e, d, t) { const i = t(133); const h = t(0); const n = t(217); const o = t(303); const r = t(304); const s = t(305); const a = t(309); const f = t(167); const l = t(312); const u = t(313); const v = t(314); const p = t(111); const c = t(15); const m = t(2); const g = t(6); const x = t(14); const y = t(1063); var T = new h({ Extends: c, Mixins: [o, r, s, a, f, u, v, l, y], initialize: function (E, C) { const P = g(C, 'x', 0); const A = g(C, 'y', 0); c.call(this, E, 'Graphics'), this.setPosition(P, A), this.initPipeline(), this.displayOriginX = 0, this.displayOriginY = 0, this.commandBuffer = [], this.defaultFillColor = -1, this.defaultFillAlpha = 1, this.defaultStrokeWidth = 1, this.defaultStrokeColor = -1, this.defaultStrokeAlpha = 1, this._lineWidth = 1, this.setDefaultStyles(C) }, setDefaultStyles: function (S) { return g(S, 'lineStyle', null) && (this.defaultStrokeWidth = g(S, 'lineStyle.width', 1), this.defaultStrokeColor = g(S, 'lineStyle.color', 16777215), this.defaultStrokeAlpha = g(S, 'lineStyle.alpha', 1), this.lineStyle(this.defaultStrokeWidth, this.defaultStrokeColor, this.defaultStrokeAlpha)), g(S, 'fillStyle', null) && (this.defaultFillColor = g(S, 'fillStyle.color', 16777215), this.defaultFillAlpha = g(S, 'fillStyle.alpha', 1), this.fillStyle(this.defaultFillColor, this.defaultFillAlpha)), this }, lineStyle: function (S, E, C) { return C === void 0 && (C = 1), this.commandBuffer.push(n.LINE_STYLE, S, E, C), this._lineWidth = S, this }, fillStyle: function (S, E) { return E === void 0 && (E = 1), this.commandBuffer.push(n.FILL_STYLE, S, E), this }, fillGradientStyle: function (S, E, C, P, A, M, L, F) { return A === void 0 && (A = 1), M === void 0 && (M = A), L === void 0 && (L = A), F === void 0 && (F = A), this.commandBuffer.push(n.GRADIENT_FILL_STYLE, A, M, L, F, S, E, C, P), this }, lineGradientStyle: function (S, E, C, P, A, M) { return M === void 0 && (M = 1), this.commandBuffer.push(n.GRADIENT_LINE_STYLE, S, M, E, C, P, A), this }, beginPath: function () { return this.commandBuffer.push(n.BEGIN_PATH), this }, closePath: function () { return this.commandBuffer.push(n.CLOSE_PATH), this }, fillPath: function () { return this.commandBuffer.push(n.FILL_PATH), this }, fill: function () { return this.commandBuffer.push(n.FILL_PATH), this }, strokePath: function () { return this.commandBuffer.push(n.STROKE_PATH), this }, stroke: function () { return this.commandBuffer.push(n.STROKE_PATH), this }, fillCircleShape: function (S) { return this.fillCircle(S.x, S.y, S.radius) }, strokeCircleShape: function (S) { return this.strokeCircle(S.x, S.y, S.radius) }, fillCircle: function (S, E, C) { return this.beginPath(), this.arc(S, E, C, 0, x.PI2), this.fillPath(), this }, strokeCircle: function (S, E, C) { return this.beginPath(), this.arc(S, E, C, 0, x.PI2), this.strokePath(), this }, fillRectShape: function (S) { return this.fillRect(S.x, S.y, S.width, S.height) }, strokeRectShape: function (S) { return this.strokeRect(S.x, S.y, S.width, S.height) }, fillRect: function (S, E, C, P) { return this.commandBuffer.push(n.FILL_RECT, S, E, C, P), this }, strokeRect: function (S, E, C, P) { const A = this._lineWidth / 2; const M = S - A; const L = S + A; return this.beginPath(), this.moveTo(S, E), this.lineTo(S, E + P), this.strokePath(), this.beginPath(), this.moveTo(S + C, E), this.lineTo(S + C, E + P), this.strokePath(), this.beginPath(), this.moveTo(M, E), this.lineTo(L + C, E), this.strokePath(), this.beginPath(), this.moveTo(M, E + P), this.lineTo(L + C, E + P), this.strokePath(), this }, fillRoundedRect: function (S, E, C, P, A) { A === void 0 && (A = 20); let M = A; let L = A; let F = A; let I = A; return typeof A !== 'number' && (M = m(A, 'tl', 20), L = m(A, 'tr', 20), F = m(A, 'bl', 20), I = m(A, 'br', 20)), this.beginPath(), this.moveTo(S + M, E), this.lineTo(S + C - L, E), this.arc(S + C - L, E + L, L, -x.TAU, 0), this.lineTo(S + C, E + P - I), this.arc(S + C - I, E + P - I, I, 0, x.TAU), this.lineTo(S + F, E + P), this.arc(S + F, E + P - F, F, x.TAU, Math.PI), this.lineTo(S, E + M), this.arc(S + M, E + M, M, -Math.PI, -x.TAU), this.fillPath(), this }, strokeRoundedRect: function (S, E, C, P, A) { A === void 0 && (A = 20); let M = A; let L = A; let F = A; let I = A; return typeof A !== 'number' && (M = m(A, 'tl', 20), L = m(A, 'tr', 20), F = m(A, 'bl', 20), I = m(A, 'br', 20)), this.beginPath(), this.moveTo(S + M, E), this.lineTo(S + C - L, E), this.moveTo(S + C - L, E), this.arc(S + C - L, E + L, L, -x.TAU, 0), this.lineTo(S + C, E + P - I), this.moveTo(S + C, E + P - I), this.arc(S + C - I, E + P - I, I, 0, x.TAU), this.lineTo(S + F, E + P), this.moveTo(S + F, E + P), this.arc(S + F, E + P - F, F, x.TAU, Math.PI), this.lineTo(S, E + M), this.moveTo(S, E + M), this.arc(S + M, E + M, M, -Math.PI, -x.TAU), this.strokePath(), this }, fillPointShape: function (S, E) { return this.fillPoint(S.x, S.y, E) }, fillPoint: function (S, E, C) { return !C || C < 1 ? C = 1 : (S -= C / 2, E -= C / 2), this.commandBuffer.push(n.FILL_RECT, S, E, C, C), this }, fillTriangleShape: function (S) { return this.fillTriangle(S.x1, S.y1, S.x2, S.y2, S.x3, S.y3) }, strokeTriangleShape: function (S) { return this.strokeTriangle(S.x1, S.y1, S.x2, S.y2, S.x3, S.y3) }, fillTriangle: function (S, E, C, P, A, M) { return this.commandBuffer.push(n.FILL_TRIANGLE, S, E, C, P, A, M), this }, strokeTriangle: function (S, E, C, P, A, M) { return this.commandBuffer.push(n.STROKE_TRIANGLE, S, E, C, P, A, M), this }, strokeLineShape: function (S) { return this.lineBetween(S.x1, S.y1, S.x2, S.y2) }, lineBetween: function (S, E, C, P) { return this.beginPath(), this.moveTo(S, E), this.lineTo(C, P), this.strokePath(), this }, lineTo: function (S, E) { return this.commandBuffer.push(n.LINE_TO, S, E), this }, moveTo: function (S, E) { return this.commandBuffer.push(n.MOVE_TO, S, E), this }, strokePoints: function (S, E, C, P) { E === void 0 && (E = !1), C === void 0 && (C = !1), P === void 0 && (P = S.length), this.beginPath(), this.moveTo(S[0].x, S[0].y); for (let A = 1; A < P; A++) this.lineTo(S[A].x, S[A].y); return E && this.lineTo(S[0].x, S[0].y), C && this.closePath(), this.strokePath(), this }, fillPoints: function (S, E, C, P) { E === void 0 && (E = !1), C === void 0 && (C = !1), P === void 0 && (P = S.length), this.beginPath(), this.moveTo(S[0].x, S[0].y); for (let A = 1; A < P; A++) this.lineTo(S[A].x, S[A].y); return E && this.lineTo(S[0].x, S[0].y), C && this.closePath(), this.fillPath(), this }, strokeEllipseShape: function (S, E) { E === void 0 && (E = 32); const C = S.getPoints(E); return this.strokePoints(C, !0) }, strokeEllipse: function (S, E, C, P, A) { A === void 0 && (A = 32); const M = new p(S, E, C, P); const L = M.getPoints(A); return this.strokePoints(L, !0) }, fillEllipseShape: function (S, E) { E === void 0 && (E = 32); const C = S.getPoints(E); return this.fillPoints(C, !0) }, fillEllipse: function (S, E, C, P, A) { A === void 0 && (A = 32); const M = new p(S, E, C, P); const L = M.getPoints(A); return this.fillPoints(L, !0) }, arc: function (S, E, C, P, A, M, L) { return M === void 0 && (M = !1), L === void 0 && (L = 0), this.commandBuffer.push(n.ARC, S, E, C, P, A, M, L), this }, slice: function (S, E, C, P, A, M, L) { return M === void 0 && (M = !1), L === void 0 && (L = 0), this.commandBuffer.push(n.BEGIN_PATH), this.commandBuffer.push(n.MOVE_TO, S, E), this.commandBuffer.push(n.ARC, S, E, C, P, A, M, L), this.commandBuffer.push(n.CLOSE_PATH), this }, save: function () { return this.commandBuffer.push(n.SAVE), this }, restore: function () { return this.commandBuffer.push(n.RESTORE), this }, translateCanvas: function (S, E) { return this.commandBuffer.push(n.TRANSLATE, S, E), this }, scaleCanvas: function (S, E) { return this.commandBuffer.push(n.SCALE, S, E), this }, rotateCanvas: function (S) { return this.commandBuffer.push(n.ROTATE, S), this }, clear: function () { return this.commandBuffer.length = 0, this.defaultFillColor > -1 && this.fillStyle(this.defaultFillColor, this.defaultFillAlpha), this.defaultStrokeColor > -1 && this.lineStyle(this.defaultStrokeWidth, this.defaultStrokeColor, this.defaultStrokeAlpha), this }, generateTexture: function (S, E, C) { const P = this.scene.sys; const A = P.game.renderer; E === void 0 && (E = P.scale.width), C === void 0 && (C = P.scale.height), T.TargetCamera.setScene(this.scene), T.TargetCamera.setViewport(0, 0, E, C), T.TargetCamera.scrollX = this.x, T.TargetCamera.scrollY = this.y; let M, L; if (typeof S === 'string') if (P.textures.exists(S)) { M = P.textures.get(S); const F = M.getSourceImage(); F instanceof HTMLCanvasElement && (L = F.getContext('2d')) } else M = P.textures.createCanvas(S, E, C), L = M.getSourceImage().getContext('2d'); else S instanceof HTMLCanvasElement && (L = S.getContext('2d')); return L && (this.renderCanvas(A, this, T.TargetCamera, null, L, !1), M && M.refresh()), this }, preDestroy: function () { this.commandBuffer = [] } }); T.TargetCamera = new i(), e.exports = T }, function (e, d) { e.exports = { ARC: 0, BEGIN_PATH: 1, CLOSE_PATH: 2, FILL_RECT: 3, LINE_TO: 4, MOVE_TO: 5, LINE_STYLE: 6, FILL_STYLE: 7, FILL_PATH: 8, STROKE_PATH: 9, FILL_TRIANGLE: 10, STROKE_TRIANGLE: 11, SAVE: 14, RESTORE: 15, TRANSLATE: 16, SCALE: 17, ROTATE: 18, GRADIENT_FILL_STYLE: 21, GRADIENT_LINE_STYLE: 22 } }, function (e, d, t) { const i = t(4); const h = function (n, o, r) { r === void 0 && (r = new i()); const s = n.width / 2; const a = n.height / 2; return r.x = n.x + s * Math.cos(o), r.y = n.y + a * Math.sin(o), r }; e.exports = h }, function (e, d, t) { const i = t(35); const h = t(0); const n = t(11); const o = t(176); const r = t(101); const s = t(9); const a = t(75); const f = t(110); const l = t(1071); const u = t(20); const v = t(79); const p = new h({ Extends: f, Mixins: [n.AlphaSingle, n.BlendMode, n.Depth, n.Mask, n.Pipeline, n.Visible, s, l], initialize: function (m, g) { f.call(this, m), s.call(this), this.scene = m, this.displayList = null, this.type = 'Layer', this.state = 0, this.parentContainer = null, this.name = '', this.active = !0, this.tabIndex = -1, this.data = null, this.renderFlags = 15, this.cameraFilter = 0, this.input = null, this.body = null, this.ignoreDestroy = !1, this.systems = m.sys, this.events = m.sys.events, this.sortChildrenFlag = !1, this.addCallback = this.addChildCallback, this.removeCallback = this.removeChildCallback, this.initPipeline(), this.clearAlpha(), this.setBlendMode(i.SKIP_CHECK), g && this.add(g), m.sys.queueDepthSort() }, setActive: function (c) { return this.active = c, this }, setName: function (c) { return this.name = c, this }, setState: function (c) { return this.state = c, this }, setDataEnabled: function () { return this.data || (this.data = new r(this)), this }, setData: function (c, m) { return this.data || (this.data = new r(this)), this.data.set(c, m), this }, incData: function (c, m) { return this.data || (this.data = new r(this)), this.data.inc(c, m), this }, toggleData: function (c) { return this.data || (this.data = new r(this)), this.data.toggle(c), this }, getData: function (c) { return this.data || (this.data = new r(this)), this.data.get(c) }, setInteractive: function () { return this }, disableInteractive: function () { return this }, removeInteractive: function () { return this }, addedToScene: function () {}, removedFromScene: function () {}, update: function () {}, toJSON: function () { return o(this) }, willRender: function (c) { return !(this.renderFlags !== 15 || this.list.length === 0 || this.cameraFilter !== 0 && this.cameraFilter & c.id) }, getIndexList: function () { for (var c = this, m = this.parentContainer, g = []; m && (g.unshift(m.getIndex(c)), c = m, m.parentContainer);)m = m.parentContainer; return g.unshift(this.displayList.getIndex(c)), g }, addChildCallback: function (c) { c.displayList && c.displayList !== this && c.removeFromDisplayList(), c.displayList || (this.queueDepthSort(), c.displayList = this, c.emit(a.ADDED_TO_SCENE, c, this.scene), this.events.emit(u.ADDED_TO_SCENE, c, this.scene)) }, removeChildCallback: function (c) { this.queueDepthSort(), c.displayList = null, c.emit(a.REMOVED_FROM_SCENE, c, this.scene), this.events.emit(u.REMOVED_FROM_SCENE, c, this.scene) }, queueDepthSort: function () { this.sortChildrenFlag = !0 }, depthSort: function () { this.sortChildrenFlag && (v(this.list, this.sortByDepth), this.sortChildrenFlag = !1) }, sortByDepth: function (c, m) { return c._depth - m._depth }, getChildren: function () { return this.list }, destroy: function () { if (!(!this.scene || this.ignoreDestroy)) { this.emit(a.DESTROY, this); for (let c = this.list.length; c--;) this.list[c].destroy(); this.removeAllListeners(), this.resetPostPipeline(!0), this.displayList && (this.displayList.remove(this, !0), this.displayList.queueDepthSort()), this.data && (this.data.destroy(), this.data = void 0), this.active = !1, this.visible = !1, this.list = void 0, this.scene = void 0, this.displayList = void 0, this.systems = void 0, this.events = void 0 } } }); e.exports = p }, function (e, d, t) { const i = t(0); const h = t(11); const n = t(15); const o = t(450); const r = t(110); const s = t(452); const a = t(1075); const f = new i({ Extends: n, Mixins: [h.Depth, h.Mask, h.Pipeline, h.Transform, h.Visible, a], initialize: function (u, v, p, c) { if (n.call(this, u, 'ParticleEmitterManager'), this.blendMode = -1, this.timeScale = 1, this.texture = null, this.frame = null, this.frameNames = [], p !== null && (typeof p === 'object' || Array.isArray(p)) && (c = p, p = null), this.setTexture(v, p), this.initPipeline(), this.emitters = new r(this), this.wells = new r(this), c) { Array.isArray(c) || (c = [c]); for (let m = 0; m < c.length; m++) this.createEmitter(c[m]) } }, addedToScene: function () { this.scene.sys.updateList.add(this) }, removedFromScene: function () { this.scene.sys.updateList.remove(this) }, setTexture: function (l, u) { return this.texture = this.scene.sys.textures.get(l), this.setFrame(u) }, setFrame: function (l) { this.frame = this.texture.get(l); const u = this.texture.getFramesFromTextureSource(this.frame.sourceIndex); const v = []; return u.forEach(function (p) { v.push(p.name) }), this.frameNames = v, this.defaultFrame = this.frame, this }, setEmitterFrames: function (l, u) { Array.isArray(l) || (l = [l]); const v = u.frames; v.length = 0; for (let p = 0; p < l.length; p++) { const c = l[p]; this.frameNames.indexOf(c) !== -1 && v.push(this.texture.get(c)) } return v.length > 0 ? u.defaultFrame = v[0] : u.defaultFrame = this.defaultFrame, this }, addEmitter: function (l) { return this.emitters.add(l) }, createEmitter: function (l) { return this.addEmitter(new s(this, l)) }, removeEmitter: function (l) { return this.emitters.remove(l, !0) }, addGravityWell: function (l) { return this.wells.add(l) }, createGravityWell: function (l) { return this.addGravityWell(new o(l)) }, emitParticle: function (l, u, v) { for (let p = this.emitters.list, c = 0; c < p.length; c++) { const m = p[c]; m.active && m.emitParticle(l, u, v) } return this }, emitParticleAt: function (l, u, v) { return this.emitParticle(v, l, u) }, pause: function () { return this.active = !1, this }, resume: function () { return this.active = !0, this }, getProcessors: function () { return this.wells.getAll('active', !0) }, preUpdate: function (l, u) { u *= this.timeScale; for (let v = this.emitters.list, p = 0; p < v.length; p++) { const c = v[p]; c.active && c.preUpdate(l, u) } }, setAlpha: function () {}, setScrollFactor: function () {}, setBlendMode: function () {} }); e.exports = f }, function (e, d, t) { const i = t(35); const h = t(133); const n = t(31); const o = t(0); const r = t(11); const s = t(33); const a = t(109); const f = t(15); const l = t(1); const u = t(92); const v = t(1079); const p = t(141); const c = t(12); const m = t(222); const g = new o({ Extends: f, Mixins: [r.Alpha, r.BlendMode, r.ComputedSize, r.Crop, r.Depth, r.Flip, r.GetBounds, r.Mask, r.Origin, r.Pipeline, r.ScrollFactor, r.Tint, r.Transform, r.Visible, v], initialize: function (y, T, S, E, C, P, A) { T === void 0 && (T = 0), S === void 0 && (S = 0), E === void 0 && (E = 32), C === void 0 && (C = 32), f.call(this, y, 'RenderTexture'), this.renderer = y.sys.renderer, this.textureManager = y.sys.textures, this.globalTint = 16777215, this.globalAlpha = 1, this.canvas = null, this.dirty = !1, this._crop = this.resetCropObject(), this.texture = null, this.frame = null, this._saved = !1, P === void 0 ? (this.canvas = n.create2D(this, E, C), this.texture = y.sys.textures.addCanvas(m(), this.canvas), this.frame = this.texture.get()) : (this.texture = y.sys.textures.get(P), this.frame = this.texture.get(A), this.canvas = this.frame.source.image, this._saved = !0, this.dirty = !0, this.width = this.frame.cutWidth, this.height = this.frame.cutHeight), this.context = this.canvas.getContext('2d'), this._eraseMode = !1, this.camera = new h(0, 0, E, C), this.renderTarget = null; const M = this.renderer; M ? M.type === s.WEBGL ? (this.drawGameObject = this.batchGameObjectWebGL, this.renderTarget = new p(M, E, C, 1, 0, !1)) : M.type === s.CANVAS && (this.drawGameObject = this.batchGameObjectCanvas) : this.drawGameObject = l, this.camera.setScene(y), this.setPosition(T, S), P === void 0 && this.setSize(E, C), this.setOrigin(0, 0), this.initPipeline(u.SINGLE_PIPELINE) }, setSize: function (x, y) { return this.resize(x, y) }, resize: function (x, y) { y === void 0 && (y = x); const T = this.frame; if (x !== this.width || y !== this.height) { if (T.name === '__BASE') { this.canvas.width = x, this.canvas.height = y, this.texture.width = x, this.texture.height = y; const S = this.renderTarget; S && (S.resize(x, y), T.glTexture = S.texture, T.source.isRenderTexture = !0, T.source.isGLTexture = !0, T.source.glTexture = S.texture), this.camera.setSize(x, y), T.source.width = x, T.source.height = y, T.setSize(x, y), this.width = x, this.height = y } } else { const E = this.texture.getSourceImage(); T.cutX + x > E.width && (x = E.width - T.cutX), T.cutY + y > E.height && (y = E.height - T.cutY), T.setSize(x, y, T.cutX, T.cutY) } this.updateDisplayOrigin(); const C = this.input; return C && !C.customHitArea && (C.hitArea.width = x, C.hitArea.height = y), this }, setGlobalTint: function (x) { return this.globalTint = x, this }, setGlobalAlpha: function (x) { return this.globalAlpha = x, this }, saveTexture: function (x) { return this.textureManager.renameTexture(this.texture.key, x), this._saved = !0, this.texture }, fill: function (x, y, T, S, E, C) { const P = this.frame; const A = this.camera; const M = this.renderer; y === void 0 && (y = 1), T === void 0 && (T = 0), S === void 0 && (S = 0), E === void 0 && (E = P.cutWidth), C === void 0 && (C = P.cutHeight); const L = (x >> 16 & 255) / 255; const F = (x >> 8 & 255) / 255; const I = (x & 255) / 255; const G = this.renderTarget; if (A.preRender(), G) { G.bind(!0); const U = this.pipeline; U.manager.set(U); const Y = G.width; const X = G.height; const O = M.width; const R = M.height; const D = O / Y; const B = R / X; U.drawFillRect(T * D, S * B, E * D, C * B, c.getTintFromFloats(I, F, L, 1), y), G.unbind(!0) } else { const N = this.context; M.setContext(N), N.fillStyle = 'rgba(' + L + ',' + F + ',' + I + ',' + y + ')', N.fillRect(T + P.cutX, S + P.cutY, E, C), M.setContext() } return this.dirty = !0, this }, clear: function () { if (this.dirty) { const x = this.renderTarget; if (x)x.clear(); else { const y = this.context; y.save(), y.setTransform(1, 0, 0, 1, 0, 0), y.clearRect(this.frame.cutX, this.frame.cutY, this.frame.cutWidth, this.frame.cutHeight), y.restore() } this.dirty = !1 } return this }, erase: function (x, y, T) { return this._eraseMode = !0, this.draw(x, y, T, 1, 16777215), this._eraseMode = !1, this }, draw: function (x, y, T, S, E) { return this.beginDraw(), this.batchDraw(x, y, T, S, E), this.endDraw(), this }, drawFrame: function (x, y, T, S, E, C) { return this.beginDraw(), this.batchDrawFrame(x, y, T, S, E, C), this.endDraw(), this }, beginDraw: function () { const x = this.camera; const y = this.renderer; const T = this.renderTarget; return x.preRender(), T ? y.beginCapture(T.width, T.height) : y.setContext(this.context), this }, batchDraw: function (x, y, T, S, E) { return S === void 0 && (S = this.globalAlpha), E === void 0 ? E = (this.globalTint >> 16) + (this.globalTint & 65280) + ((this.globalTint & 255) << 16) : E = (E >> 16) + (E & 65280) + ((E & 255) << 16), Array.isArray(x) || (x = [x]), this.batchList(x, y, T, S, E), this }, batchDrawFrame: function (x, y, T, S, E, C) { T === void 0 && (T = 0), S === void 0 && (S = 0), E === void 0 && (E = this.globalAlpha), C === void 0 ? C = (this.globalTint >> 16) + (this.globalTint & 65280) + ((this.globalTint & 255) << 16) : C = (C >> 16) + (C & 65280) + ((C & 255) << 16); const P = this.textureManager.getFrame(x, y); return P && (this.renderTarget ? this.pipeline.batchTextureFrame(P, T, S, C, E, this.camera.matrix, null) : this.batchTextureFrame(P, T + this.frame.cutX, S + this.frame.cutY, E, C)), this }, endDraw: function (x) { x === void 0 && (x = this._eraseMode); const y = this.renderer; const T = this.renderTarget; if (T) { const S = y.endCapture(); const E = y.pipelines.setUtility(); E.blitFrame(S, T, 1, !1, !1, x), y.resetScissor(), y.resetViewport() } else y.setContext(); return this.dirty = !0, this }, batchList: function (x, y, T, S, E) { for (let C = 0; C < x.length; C++) { const P = x[C]; !P || P === this || (P.renderWebGL || P.renderCanvas ? this.drawGameObject(P, y, T) : P.isParent || P.list ? this.batchGroup(P.getChildren(), y, T) : typeof P === 'string' ? this.batchTextureFrameKey(P, null, y, T, S, E) : P instanceof a ? this.batchTextureFrame(P, y, T, S, E) : Array.isArray(P) && this.batchList(P, y, T, S, E)) } }, batchGroup: function (x, y, T) { y === void 0 && (y = 0), T === void 0 && (T = 0), y += this.frame.cutX, T += this.frame.cutY; for (let S = 0; S < x.length; S++) { const E = x[S]; if (E.willRender(this.camera)) { const C = E.x + y; const P = E.y + T; this.drawGameObject(E, C, P) } } }, batchGameObjectWebGL: function (x, y, T) { y === void 0 && (y = x.x), T === void 0 && (T = x.y); const S = x.x; const E = x.y; x.setPosition(y + this.frame.cutX, T + this.frame.cutY), x.renderDirect ? x.renderDirect(this.renderer, x, this.camera) : x.renderWebGL(this.renderer, x, this.camera), x.setPosition(S, E) }, batchGameObjectCanvas: function (x, y, T) { y === void 0 && (y = x.x), T === void 0 && (T = x.y); const S = x.x; const E = x.y; if (this._eraseMode) { var C = x.blendMode; x.blendMode = i.ERASE }x.setPosition(y + this.frame.cutX, T + this.frame.cutY), x.renderCanvas(this.renderer, x, this.camera, null), x.setPosition(S, E), this._eraseMode && (x.blendMode = C) }, batchTextureFrameKey: function (x, y, T, S, E, C) { const P = this.textureManager.getFrame(x, y); P && this.batchTextureFrame(P, T, S, E, C) }, batchTextureFrame: function (x, y, T, S, E) { y === void 0 && (y = 0), T === void 0 && (T = 0), y += this.frame.cutX, T += this.frame.cutY; const C = this.renderTarget; if (C) this.pipeline.batchTextureFrame(x, y, T, E, S, this.camera.matrix, null); else { const P = this.context; const A = x.canvasData; const M = x.source.image; const L = this.camera.matrix; P.save(), P.globalCompositeOperation = this._eraseMode ? 'destination-out' : 'source-over', P.globalAlpha = S, L.setToContext(P), P.drawImage(M, A.x, A.y, A.width, A.height, y, T, A.width, A.height), P.restore() } }, snapshotArea: function (x, y, T, S, E, C, P) { return this.renderTarget ? this.renderer.snapshotFramebuffer(this.renderTarget.framebuffer, this.width, this.height, E, !1, x, y, T, S, C, P) : this.renderer.snapshotCanvas(this.canvas, E, !1, x, y, T, S, C, P), this }, snapshot: function (x, y, T) { return this.renderTarget ? this.renderer.snapshotFramebuffer(this.renderTarget.framebuffer, this.width, this.height, x, !1, 0, 0, this.width, this.height, y, T) : this.renderer.snapshotCanvas(this.canvas, x, !1, 0, 0, this.width, this.height, y, T), this }, snapshotPixel: function (x, y, T) { return this.renderTarget ? this.renderer.snapshotFramebuffer(this.renderTarget.framebuffer, this.width, this.height, T, !0, x, y) : this.renderer.snapshotCanvas(this.canvas, T, !0, x, y), this }, preDestroy: function () { this._saved || (n.remove(this.canvas), this.renderTarget && this.renderTarget.destroy(), this.texture.destroy(), this.camera.destroy(), this.canvas = null, this.context = null, this.texture = null) } }); e.exports = g }, function (e, d) { const t = function () { return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (i) { const h = Math.random() * 16 | 0; const n = i === 'x' ? h : h & 3 | 8; return n.toString(16) }) }; e.exports = t }, function (e, d, t) { const i = t(164); const h = t(0); const n = t(11); const o = t(15); const r = t(92); const s = t(1085); const a = t(3); const f = new h({ Extends: o, Mixins: [n.AlphaSingle, n.BlendMode, n.Depth, n.Flip, n.Mask, n.Pipeline, n.Size, n.Texture, n.Transform, n.Visible, n.ScrollFactor, s], initialize: function (u, v, p, c, m, g, x, y, T) { c === void 0 && (c = '__DEFAULT'), g === void 0 && (g = 2), x === void 0 && (x = !0), o.call(this, u, 'Rope'), this.anims = new i(this), this.points = g, this.vertices, this.uv, this.colors, this.alphas, this.tintFill = c === '__DEFAULT', this.dirty = !1, this.horizontal = x, this._flipX = !1, this._flipY = !1, this._perp = new a(), this.debugCallback = null, this.debugGraphic = null, this.setTexture(c, m), this.setPosition(v, p), this.setSizeToFrame(), this.initPipeline(r.ROPE_PIPELINE), Array.isArray(g) && this.resizeArrays(g.length), this.setPoints(g, y, T), this.updateVertices() }, addedToScene: function () { this.scene.sys.updateList.add(this) }, removedFromScene: function () { this.scene.sys.updateList.remove(this) }, preUpdate: function (l, u) { const v = this.anims.currentFrame; this.anims.update(l, u), this.anims.currentFrame !== v && (this.updateUVs(), this.updateVertices()) }, play: function (l, u, v) { return this.anims.play(l, u, v), this }, setDirty: function () { return this.dirty = !0, this }, setHorizontal: function (l, u, v) { return l === void 0 && (l = this.points.length), this.horizontal ? this : (this.horizontal = !0, this.setPoints(l, u, v)) }, setVertical: function (l, u, v) { return l === void 0 && (l = this.points.length), this.horizontal ? (this.horizontal = !1, this.setPoints(l, u, v)) : this }, setTintFill: function (l) { return l === void 0 && (l = !1), this.tintFill = l, this }, setAlphas: function (l, u) { const v = this.points.length; if (v < 1) return this; const p = this.alphas; l === void 0 ? l = [1] : !Array.isArray(l) && u === void 0 && (l = [l]); let c; let m = 0; if (u !== void 0) for (c = 0; c < v; c++)m = c * 2, p[m] = l, p[m + 1] = u; else if (l.length === v) for (c = 0; c < v; c++)m = c * 2, p[m] = l[c], p[m + 1] = l[c]; else { let g = l[0]; for (c = 0; c < v; c++)m = c * 2, l.length > m && (g = l[m]), p[m] = g, l.length > m + 1 && (g = l[m + 1]), p[m + 1] = g } return this }, setColors: function (l) { const u = this.points.length; if (u < 1) return this; const v = this.colors; l === void 0 ? l = [16777215] : Array.isArray(l) || (l = [l]); let p; let c = 0; if (l.length === u) for (p = 0; p < u; p++)c = p * 2, v[c] = l[p], v[c + 1] = l[p]; else { let m = l[0]; for (p = 0; p < u; p++)c = p * 2, l.length > c && (m = l[c]), v[c] = m, l.length > c + 1 && (m = l[c + 1]), v[c + 1] = m } return this }, setPoints: function (l, u, v) { if (l === void 0 && (l = 2), typeof l === 'number') { let p = l; p < 2 && (p = 2), l = []; let c, m, g; if (this.horizontal) for (g = -this.frame.halfWidth, m = this.frame.width / (p - 1), c = 0; c < p; c++)l.push({ x: g + c * m, y: 0 }); else for (g = -this.frame.halfHeight, m = this.frame.height / (p - 1), c = 0; c < p; c++)l.push({ x: 0, y: g + c * m }) } let x = l.length; const y = this.points.length; return x < 1 ? (console.warn('Rope: Not enough points given'), this) : (x === 1 && (l.unshift({ x: 0, y: 0 }), x++), y !== x && this.resizeArrays(x), this.points = l, this.updateUVs(), u != null && this.setColors(u), v != null && this.setAlphas(v), this) }, updateUVs: function () { for (let l = this.uv, u = this.points.length, v = this.frame.u0, p = this.frame.v0, c = this.frame.u1, m = this.frame.v1, g = (c - v) / (u - 1), x = (m - p) / (u - 1), y = 0; y < u; y++) { const T = y * 4; var S; var E; var C; var P; this.horizontal ? (this._flipX ? (S = c - y * g, C = c - y * g) : (S = v + y * g, C = v + y * g), this._flipY ? (E = m, P = p) : (E = p, P = m)) : (this._flipX ? (S = v, C = c) : (S = c, C = v), this._flipY ? (E = m - y * x, P = m - y * x) : (E = p + y * x, P = p + y * x)), l[T + 0] = S, l[T + 1] = E, l[T + 2] = C, l[T + 3] = P } return this }, resizeArrays: function (l) { let u = this.colors; let v = this.alphas; this.vertices = new Float32Array(l * 4), this.uv = new Float32Array(l * 4), u = new Uint32Array(l * 2), v = new Float32Array(l * 2); for (let p = 0; p < l * 2; p++)u[p] = 16777215, v[p] = 1; return this.colors = u, this.alphas = v, this.dirty = !0, this }, updateVertices: function () { const l = this._perp; const u = this.points; const v = this.vertices; const p = u.length; if (this.dirty = !1, !(p < 1)) { for (var c, m = u[0], g = this.horizontal ? this.frame.halfHeight : this.frame.halfWidth, x = 0; x < p; x++) { const y = u[x]; const T = x * 4; x < p - 1 ? c = u[x + 1] : c = y, l.x = c.y - m.y, l.y = -(c.x - m.x); const S = l.length(); l.x /= S, l.y /= S, l.x *= g, l.y *= g, v[T] = y.x + l.x, v[T + 1] = y.y + l.y, v[T + 2] = y.x - l.x, v[T + 3] = y.y - l.y, m = y } return this } }, setDebug: function (l, u) { return this.debugGraphic = l, !l && !u ? this.debugCallback = null : u ? this.debugCallback = u : this.debugCallback = this.renderDebugVerts, this }, renderDebugVerts: function (l, u, v) { const p = l.debugGraphic; let c = v[0]; let m = v[1]; let g = v[2]; let x = v[3]; p.lineBetween(c, m, g, x); for (let y = 4; y < u; y += 4) { const T = v[y + 0]; const S = v[y + 1]; const E = v[y + 2]; const C = v[y + 3]; p.lineBetween(c, m, T, S), p.lineBetween(g, x, E, C), p.lineBetween(g, x, T, S), p.lineBetween(T, S, E, C), c = T, m = S, g = E, x = C } }, preDestroy: function () { this.anims.destroy(), this.anims = void 0, this.points = null, this.vertices = null, this.uv = null, this.colors = null, this.alphas = null, this.debugCallback = null, this.debugGraphic = null }, flipX: { get: function () { return this._flipX }, set: function (l) { return this._flipX = l, this.updateUVs() } }, flipY: { get: function () { return this._flipY }, set: function (l) { return this._flipY = l, this.updateUVs() } } }); e.exports = f }, function (e, d, t) {
        const i = t(142); const h = t(31); const n = t(0); const o = t(11); const r = t(22); const s = t(15); const a = t(458); const f = t(6); const l = t(202); const u = t(1088); const v = t(459); const p = new n({
          Extends: s,
          Mixins: [o.Alpha, o.BlendMode, o.ComputedSize, o.Crop, o.Depth, o.Flip, o.GetBounds, o.Mask, o.Origin, o.Pipeline, o.ScrollFactor, o.Tint, o.Transform, o.Visible, u],
          initialize: function (m, g, x, y, T) { g === void 0 && (g = 0), x === void 0 && (x = 0), s.call(this, m, 'Text'), this.renderer = m.sys.renderer, this.setPosition(g, x), this.setOrigin(0, 0), this.initPipeline(), this.canvas = h.create(this), this.context = this.canvas.getContext('2d'), this.style = new v(this, T), this.autoRound = !0, this.splitRegExp = /(?:\r\n|\r|\n)/, this._text = void 0, this.padding = { left: 0, right: 0, top: 0, bottom: 0 }, this.width = 1, this.height = 1, this.lineSpacing = 0, this.dirty = !1, this.style.resolution === 0 && (this.style.resolution = 1), this._crop = this.resetCropObject(), this.texture = m.sys.textures.addCanvas(null, this.canvas, !0), this.frame = this.texture.get(), this.frame.source.resolution = this.style.resolution, this.renderer && this.renderer.gl && (this.renderer.deleteTexture(this.frame.source.glTexture), this.frame.source.glTexture = null), this.initRTL(), this.setText(y), T && T.padding && this.setPadding(T.padding), T && T.lineSpacing && this.setLineSpacing(T.lineSpacing), m.sys.game.events.on(r.CONTEXT_RESTORED, function () { this.dirty = !0 }, this) },
          initRTL: function () { !this.style.rtl || (this.canvas.dir = 'rtl', this.context.direction = 'rtl', this.canvas.style.display = 'none', i(this.canvas, this.scene.sys.canvas), this.originX = 1) },
          runWordWrap: function (c) {
            const m = this.style; if (m.wordWrapCallback) {
              let g = m.wordWrapCallback.call(m.wordWrapCallbackScope, c, this); return Array.isArray(g) && (g = g.join(`
`)), g
            } else return m.wordWrapWidth ? m.wordWrapUseAdvanced ? this.advancedWordWrap(c, this.context, this.style.wordWrapWidth) : this.basicWordWrap(c, this.context, this.style.wordWrapWidth) : c
          },
          advancedWordWrap: function (c, m, g) {
            for (var x = '', y = c.replace(/ +/gi, ' ').split(this.splitRegExp), T = y.length, S = 0; S < T; S++) {
              let E = y[S]; let C = ''; E = E.replace(/^ *|\s*$/gi, ''); const P = m.measureText(E).width; if (P < g) {
                x += E + `
`;continue
              } for (let A = g, M = E.split(' '), L = 0; L < M.length; L++) { const F = M[L]; const I = F + ' '; let G = m.measureText(I).width; if (G > A) { if (L === 0) { for (var U = I; U.length && (U = U.slice(0, -1), G = m.measureText(U).width, !(G <= A)););if (!U.length) throw new Error("This text's wordWrapWidth setting is less than a single character!"); const Y = F.substr(U.length); M[L] = Y, C += U } const X = M[L].length ? L : L + 1; const O = M.slice(X).join(' ').replace(/[ \n]*$/gi, ''); y[S + 1] = O + ' ' + (y[S + 1] || ''), T = y.length; break } else C += I, A -= G }x += C.replace(/[ \n]*$/gi, '') + `
`
            } return x = x.replace(/[\s|\n]*$/gi, ''), x
          },
          basicWordWrap: function (c, m, g) {
            for (var x = '', y = c.split(this.splitRegExp), T = y.length - 1, S = m.measureText(' ').width, E = 0; E <= T; E++) {
              for (let C = g, P = y[E].split(' '), A = P.length - 1, M = 0; M <= A; M++) {
                const L = P[M]; const F = m.measureText(L).width; let I = F; M < A && (I += S), I > C && M > 0 && (x += `
`, C = g), x += L, M < A ? (x += ' ', C -= I) : C -= F
              }E < T && (x += `
`)
            } return x
          },
          getWrappedText: function (c) { c === void 0 && (c = this._text), this.style.syncFont(this.canvas, this.context); const m = this.runWordWrap(c); return m.split(this.splitRegExp) },
          setText: function (c) {
            return !c && c !== 0 && (c = ''), Array.isArray(c) && (c = c.join(`
`)), c !== this._text && (this._text = c.toString(), this.updateText()), this
          },
          setStyle: function (c) { return this.style.setStyle(c) },
          setFont: function (c) { return this.style.setFont(c) },
          setFontFamily: function (c) { return this.style.setFontFamily(c) },
          setFontSize: function (c) { return this.style.setFontSize(c) },
          setFontStyle: function (c) { return this.style.setFontStyle(c) },
          setFixedSize: function (c, m) { return this.style.setFixedSize(c, m) },
          setBackgroundColor: function (c) { return this.style.setBackgroundColor(c) },
          setFill: function (c) { return this.style.setFill(c) },
          setColor: function (c) { return this.style.setColor(c) },
          setStroke: function (c, m) { return this.style.setStroke(c, m) },
          setShadow: function (c, m, g, x, y, T) { return this.style.setShadow(c, m, g, x, y, T) },
          setShadowOffset: function (c, m) { return this.style.setShadowOffset(c, m) },
          setShadowColor: function (c) { return this.style.setShadowColor(c) },
          setShadowBlur: function (c) { return this.style.setShadowBlur(c) },
          setShadowStroke: function (c) { return this.style.setShadowStroke(c) },
          setShadowFill: function (c) { return this.style.setShadowFill(c) },
          setWordWrapWidth: function (c, m) { return this.style.setWordWrapWidth(c, m) },
          setWordWrapCallback: function (c, m) { return this.style.setWordWrapCallback(c, m) },
          setAlign: function (c) { return this.style.setAlign(c) },
          setResolution: function (c) { return this.style.setResolution(c) },
          setLineSpacing: function (c) { return this.lineSpacing = c, this.updateText() },
          setPadding: function (c, m, g, x) { if (typeof c === 'object') { const y = c; const T = f(y, 'x', null); T !== null ? (c = T, g = T) : (c = f(y, 'left', 0), g = f(y, 'right', c)); const S = f(y, 'y', null); S !== null ? (m = S, x = S) : (m = f(y, 'top', 0), x = f(y, 'bottom', m)) } else c === void 0 && (c = 0), m === void 0 && (m = c), g === void 0 && (g = c), x === void 0 && (x = m); return this.padding.left = c, this.padding.top = m, this.padding.right = g, this.padding.bottom = x, this.updateText() },
          setMaxLines: function (c) { return this.style.setMaxLines(c) },
          updateText: function () { const c = this.canvas; const m = this.context; const g = this.style; const x = g.resolution; const y = g.metrics; g.syncFont(c, m); let T = this._text; (g.wordWrapWidth || g.wordWrapCallback) && (T = this.runWordWrap(this._text)); const S = T.split(this.splitRegExp); const E = a(this, y, S); const C = this.padding; let P; g.fixedWidth === 0 ? (this.width = E.width + C.left + C.right, P = E.width) : (this.width = g.fixedWidth, P = this.width - C.left - C.right, P < E.width && (P = E.width)), g.fixedHeight === 0 ? this.height = E.height + C.top + C.bottom : this.height = g.fixedHeight; let A = this.width; let M = this.height; this.updateDisplayOrigin(), A *= x, M *= x, A = Math.max(A, 1), M = Math.max(M, 1), c.width !== A || c.height !== M ? (c.width = A, c.height = M, this.frame.setSize(A, M), g.syncFont(c, m)) : m.clearRect(0, 0, A, M), m.save(), m.scale(x, x), g.backgroundColor && (m.fillStyle = g.backgroundColor, m.fillRect(0, 0, A, M)), g.syncStyle(c, m), m.textBaseline = 'alphabetic', m.translate(C.left, C.top); for (var L, F, I = 0; I < E.lines; I++) { if (L = g.strokeThickness / 2, F = g.strokeThickness / 2 + I * E.lineHeight + y.ascent, I > 0 && (F += E.lineSpacing * I), g.rtl)L = A - L; else if (g.align === 'right')L += P - E.lineWidths[I]; else if (g.align === 'center')L += (P - E.lineWidths[I]) / 2; else if (g.align === 'justify') { const G = 0.85; if (E.lineWidths[I] / E.width >= G) { let U = E.width - E.lineWidths[I]; const Y = m.measureText(' ').width; const X = S[I].trim(); const O = X.split(' '); U += (S[I].length - X.length) * Y; for (let R = Math.floor(U / Y), D = 0; R > 0;)O[D] += ' ', D = (D + 1) % (O.length - 1 || 1), --R; S[I] = O.join(' ') } } this.autoRound && (L = Math.round(L), F = Math.round(F)), g.strokeThickness && (this.style.syncShadow(m, g.shadowStroke), m.strokeText(S[I], L, F)), g.color && (this.style.syncShadow(m, g.shadowFill), m.fillText(S[I], L, F)) }m.restore(), this.renderer && this.renderer.gl && (this.frame.source.glTexture = this.renderer.canvasToTexture(c, this.frame.source.glTexture, !0), this.frame.glTexture = this.frame.source.glTexture), this.dirty = !0; const B = this.input; return B && !B.customHitArea && (B.hitArea.width = this.width, B.hitArea.height = this.height), this },
          getTextMetrics: function () { return this.style.getTextMetrics() },
          text: { get: function () { return this._text }, set: function (c) { this.setText(c) } },
          toJSON: function () { const c = o.ToJSON(this); const m = { autoRound: this.autoRound, text: this._text, style: this.style.toJSON(), padding: { left: this.padding.left, right: this.padding.right, top: this.padding.top, bottom: this.padding.bottom } }; return c.data = m, c },
          preDestroy: function () { this.style.rtl && l(this.canvas), h.remove(this.canvas), this.texture.destroy() }
        }); e.exports = p
      }, function (e, d, t) { const i = t(31); const h = t(0); const n = t(11); const o = t(22); const r = t(15); const s = t(361); const a = t(192); const f = t(1091); const l = t(3); const u = 8; const v = new h({ Extends: r, Mixins: [n.Alpha, n.BlendMode, n.ComputedSize, n.Crop, n.Depth, n.Flip, n.GetBounds, n.Mask, n.Origin, n.Pipeline, n.ScrollFactor, n.Tint, n.Transform, n.Visible, f], initialize: function (c, m, g, x, y, T, S) { const E = c.sys.renderer; r.call(this, c, 'TileSprite'); const C = c.sys.textures.get(T); const P = C.get(S); !x || !y ? (x = P.width, y = P.height) : (x = Math.floor(x), y = Math.floor(y)), this._tilePosition = new l(), this._tileScale = new l(1, 1), this.dirty = !1, this.renderer = E, this.canvas = i.create(this, x, y), this.context = this.canvas.getContext('2d'), this.displayTexture = C, this.displayFrame = P, this._crop = this.resetCropObject(), this.texture = c.sys.textures.addCanvas(null, this.canvas, !0), this.frame = this.texture.get(), this.potWidth = s(P.width), this.potHeight = s(P.height), this.fillCanvas = i.create2D(this, this.potWidth, this.potHeight), this.fillContext = this.fillCanvas.getContext('2d'), this.fillPattern = null, this.setPosition(m, g), this.setSize(x, y), this.setFrame(S), this.setOriginFromFrame(), this.initPipeline(), c.sys.game.events.on(o.CONTEXT_RESTORED, function (A) { if (A) { const M = A.gl; this.dirty = !0, this.fillPattern = null, this.fillPattern = A.createTexture2D(0, M.LINEAR, M.LINEAR, M.REPEAT, M.REPEAT, M.RGBA, this.fillCanvas, this.potWidth, this.potHeight) } }, this) }, setTexture: function (p, c) { return this.displayTexture = this.scene.sys.textures.get(p), this.setFrame(c) }, setFrame: function (p) { const c = this.displayTexture.get(p); return this.potWidth = s(c.width), this.potHeight = s(c.height), this.canvas.width = 0, !c.cutWidth || !c.cutHeight ? this.renderFlags &= ~u : this.renderFlags |= u, this.displayFrame = c, this.dirty = !0, this.updateTileTexture(), this }, setTilePosition: function (p, c) { return p !== void 0 && (this.tilePositionX = p), c !== void 0 && (this.tilePositionY = c), this }, setTileScale: function (p, c) { return p === void 0 && (p = this.tileScaleX), c === void 0 && (c = p), this.tileScaleX = p, this.tileScaleY = c, this }, updateTileTexture: function () { if (!(!this.dirty || !this.renderer)) { const p = this.displayFrame; if (p.source.isRenderTexture || p.source.isGLTexture) { console.warn('TileSprites can only use Image or Canvas based textures'), this.dirty = !1; return } const c = this.fillContext; const m = this.fillCanvas; let g = this.potWidth; let x = this.potHeight; (!this.renderer || !this.renderer.gl) && (g = p.cutWidth, x = p.cutHeight), c.clearRect(0, 0, g, x), m.width = g, m.height = x, c.drawImage(p.source.image, p.cutX, p.cutY, p.cutWidth, p.cutHeight, 0, 0, g, x), this.renderer && this.renderer.gl ? this.fillPattern = this.renderer.canvasToTexture(m, this.fillPattern) : this.fillPattern = c.createPattern(m, 'repeat'), this.updateCanvas(), this.dirty = !1 } }, updateCanvas: function () { const p = this.canvas; if ((p.width !== this.width || p.height !== this.height) && (p.width = this.width, p.height = this.height, this.frame.setSize(this.width, this.height), this.updateDisplayOrigin(), this.dirty = !0), !this.dirty || this.renderer && this.renderer.gl) { this.dirty = !1; return } const c = this.context; this.scene.sys.game.config.antialias || a.disable(c); const m = this._tileScale.x; const g = this._tileScale.y; const x = this._tilePosition.x; const y = this._tilePosition.y; c.clearRect(0, 0, this.width, this.height), c.save(), c.scale(m, g), c.translate(-x, -y), c.fillStyle = this.fillPattern, c.fillRect(x, y, this.width / m, this.height / g), c.restore(), this.dirty = !1 }, preDestroy: function () { this.renderer && this.renderer.gl && this.renderer.deleteTexture(this.fillPattern), i.remove(this.canvas), i.remove(this.fillCanvas), this.fillPattern = null, this.fillContext = null, this.fillCanvas = null, this.displayTexture = null, this.displayFrame = null, this.texture.destroy(), this.renderer = null }, tilePositionX: { get: function () { return this._tilePosition.x }, set: function (p) { this._tilePosition.x = p, this.dirty = !0 } }, tilePositionY: { get: function () { return this._tilePosition.y }, set: function (p) { this._tilePosition.y = p, this.dirty = !0 } }, tileScaleX: { get: function () { return this._tileScale.x }, set: function (p) { this._tileScale.x = p, this.dirty = !0 } }, tileScaleY: { get: function () { return this._tileScale.y }, set: function (p) { this._tileScale.y = p, this.dirty = !0 } } }); e.exports = v }, function (e, d, t) { const i = t(0); const h = t(18); const n = t(11); const o = t(75); const r = t(22); const s = t(51); const a = t(15); const f = t(70); const l = t(222); const u = t(1094); const v = t(14); const p = new i({ Extends: a, Mixins: [n.Alpha, n.BlendMode, n.Depth, n.Flip, n.GetBounds, n.Mask, n.Origin, n.Pipeline, n.ScrollFactor, n.Size, n.TextureCrop, n.Tint, n.Transform, n.Visible, u], initialize: function (m, g, x, y) { a.call(this, m, 'Video'), this.video = null, this.videoTexture = null, this.videoTextureSource = null, this.snapshotTexture = null, this.flipY = !1, this._key = l(), this.touchLocked = !0, this.playWhenUnlocked = !1, this.retryLimit = 20, this.retry = 0, this.retryInterval = 500, this._retryID = null, this._systemMuted = !1, this._codeMuted = !1, this._systemPaused = !1, this._codePaused = !1, this._callbacks = { play: this.playHandler.bind(this), error: this.loadErrorHandler.bind(this), end: this.completeHandler.bind(this), time: this.timeUpdateHandler.bind(this), seeking: this.seekingHandler.bind(this), seeked: this.seekedHandler.bind(this) }, this._crop = this.resetCropObject(), this.markers = {}, this._markerIn = -1, this._markerOut = v.MAX_SAFE_INTEGER, this._lastUpdate = 0, this._cacheKey = '', this._isSeeking = !1, this.removeVideoElementOnDestroy = !1, this.setPosition(g, x), this.initPipeline(), y && this.changeSource(y, !1); const T = m.sys.game.events; T.on(r.PAUSE, this.globalPause, this), T.on(r.RESUME, this.globalResume, this); const S = m.sys.sound; S && S.on(f.GLOBAL_MUTE, this.globalMute, this) }, addedToScene: function () { this.scene.sys.updateList.add(this) }, removedFromScene: function () { this.scene.sys.updateList.remove(this) }, play: function (c, m, g) { if (this.touchLocked && this.playWhenUnlocked || this.isPlaying()) return this; const x = this.video; if (!x) return console.warn('Video not loaded'), this; c === void 0 && (c = x.loop); const y = this.scene.sys.sound; y && y.mute && this.setMute(!0), isNaN(m) || (this._markerIn = m), !isNaN(g) && g > m && (this._markerOut = g), x.loop = c; const T = this._callbacks; const S = x.play(); return S !== void 0 ? S.then(this.playPromiseSuccessHandler.bind(this)).catch(this.playPromiseErrorHandler.bind(this)) : (x.addEventListener('playing', T.play, !0), x.readyState < 2 && (this.retry = this.retryLimit, this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval))), x.addEventListener('ended', T.end, !0), x.addEventListener('timeupdate', T.time, !0), x.addEventListener('seeking', T.seeking, !0), x.addEventListener('seeked', T.seeked, !0), this }, changeSource: function (c, m, g, x, y) { m === void 0 && (m = !0); const T = this.video; T && this.stop(); const S = this.scene.sys.cache.video.get(c); return S ? (this.video = S, this._cacheKey = c, this._codePaused = S.paused, this._codeMuted = S.muted, this.videoTexture ? (this.scene.sys.textures.remove(this._key), this.videoTexture = this.scene.sys.textures.create(this._key, S, S.videoWidth, S.videoHeight), this.videoTextureSource = this.videoTexture.source[0], this.videoTexture.add('__BASE', 0, 0, 0, S.videoWidth, S.videoHeight), this.setTexture(this.videoTexture), this.setSizeToFrame(), this.updateDisplayOrigin(), this.emit(o.VIDEO_CREATED, this, S.videoWidth, S.videoHeight)) : this.updateTexture(), S.currentTime = 0, this._lastUpdate = 0, m && this.play(g, x, y)) : this.video = null, this }, addMarker: function (c, m, g) { return !isNaN(m) && m >= 0 && !isNaN(g) && (this.markers[c] = [m, g]), this }, playMarker: function (c, m) { const g = this.markers[c]; return g && this.play(m, g[0], g[1]), this }, removeMarker: function (c) { return delete this.markers[c], this }, snapshot: function (c, m) { return c === void 0 && (c = this.width), m === void 0 && (m = this.height), this.snapshotArea(0, 0, this.width, this.height, c, m) }, snapshotArea: function (c, m, g, x, y, T) { c === void 0 && (c = 0), m === void 0 && (m = 0), g === void 0 && (g = this.width), x === void 0 && (x = this.height), y === void 0 && (y = g), T === void 0 && (T = x); const S = this.video; let E = this.snapshotTexture; return E ? (E.setSize(y, T), S && E.context.drawImage(S, c, m, g, x, 0, 0, y, T)) : (E = this.scene.sys.textures.createCanvas(l(), y, T), this.snapshotTexture = E, S && E.context.drawImage(S, c, m, g, x, 0, 0, y, T)), E.update() }, saveSnapshotTexture: function (c) { return this.snapshotTexture ? this.scene.sys.textures.renameTexture(this.snapshotTexture.key, c) : this.snapshotTexture = this.scene.sys.textures.createCanvas(c, this.width, this.height), this.snapshotTexture }, loadURL: function (c, m, g) { m === void 0 && (m = 'loadeddata'), g === void 0 && (g = !1), this.video && this.stop(), this.videoTexture && this.scene.sys.textures.remove(this._key); const x = document.createElement('video'); return x.controls = !1, g && (x.muted = !0, x.defaultMuted = !0, x.setAttribute('autoplay', 'autoplay')), x.setAttribute('playsinline', 'playsinline'), x.setAttribute('preload', 'auto'), x.addEventListener('error', this._callbacks.error, !0), x.src = c, x.load(), this.video = x, this }, loadMediaStream: function (c, m, g) { m === void 0 && (m = 'loadeddata'), g === void 0 && (g = !1), this.video && this.stop(), this.videoTexture && this.scene.sys.textures.remove(this._key); const x = document.createElement('video'); x.controls = !1, g && (x.muted = !0, x.defaultMuted = !0, x.setAttribute('autoplay', 'autoplay')), x.setAttribute('playsinline', 'playsinline'), x.setAttribute('preload', 'auto'), x.addEventListener('error', this._callbacks.error, !0); try { x.srcObject = c } catch (y) { x.src = window.URL.createObjectURL(c) } return x.load(), this.video = x, this }, playPromiseSuccessHandler: function () { this._codePaused = !1, this.touchLocked = !1, this.emit(o.VIDEO_PLAY, this), this._markerIn > -1 && (this.video.currentTime = this._markerIn) }, playPromiseErrorHandler: function (c) { this.scene.sys.input.once(s.POINTER_DOWN, this.unlockHandler, this), this.touchLocked = !0, this.playWhenUnlocked = !0, this.emit(o.VIDEO_ERROR, this, c) }, playHandler: function () { this._codePaused = !1, this.touchLocked = !1, this.emit(o.VIDEO_PLAY, this), this.video.removeEventListener('playing', this._callbacks.play, !0) }, loadErrorHandler: function (c) { this.stop(), this.emit(o.VIDEO_ERROR, this, c) }, unlockHandler: function () { this.touchLocked = !1, this.playWhenUnlocked = !1, this.emit(o.VIDEO_UNLOCKED, this), this._markerIn > -1 && (this.video.currentTime = this._markerIn), this.video.play(), this.emit(o.VIDEO_PLAY, this) }, completeHandler: function () { this.emit(o.VIDEO_COMPLETE, this) }, timeUpdateHandler: function () { this.video && this.video.currentTime < this._lastUpdate && (this.emit(o.VIDEO_LOOP, this), this._lastUpdate = 0) }, preUpdate: function () { const c = this.video; if (c) { const m = c.currentTime; m !== this._lastUpdate && (this._lastUpdate = m, this.updateTexture(), m >= this._markerOut && (c.loop ? (c.currentTime = this._markerIn, this.updateTexture(), this._lastUpdate = m, this.emit(o.VIDEO_LOOP, this)) : (this.emit(o.VIDEO_COMPLETE, this), this.stop()))) } }, checkVideoProgress: function () { this.video.readyState >= 2 ? this.updateTexture() : (this.retry--, this.retry > 0 ? this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval) : this.emit(o.VIDEO_TIMEOUT, this)) }, updateTexture: function () { const c = this.video; const m = c.videoWidth; const g = c.videoHeight; if (!this.videoTexture) this.videoTexture = this.scene.sys.textures.create(this._key, c, m, g), this.videoTextureSource = this.videoTexture.source[0], this.videoTexture.add('__BASE', 0, 0, 0, m, g), this.setTexture(this.videoTexture), this.setSizeToFrame(), this.updateDisplayOrigin(), this.emit(o.VIDEO_CREATED, this, m, g); else { const x = this.videoTextureSource; x.source !== c && (x.source = c, x.width = m, x.height = g), x.update() } }, getVideoKey: function () { return this._cacheKey }, seekTo: function (c) { const m = this.video; if (m) { const g = m.duration; if (g !== 1 / 0 && !isNaN(g)) { const x = g * c; this.setCurrentTime(x) } } return this }, getCurrentTime: function () { return this.video ? this.video.currentTime : 0 }, setCurrentTime: function (c) { const m = this.video; if (m) { if (typeof c === 'string') { const g = c[0]; const x = parseFloat(c.substr(1)); g === '+' ? c = m.currentTime + x : g === '-' && (c = m.currentTime - x) }m.currentTime = c, this._lastUpdate = c } return this }, isSeeking: function () { return this._isSeeking }, seekingHandler: function () { this._isSeeking = !0, this.emit(o.VIDEO_SEEKING, this) }, seekedHandler: function () { this._isSeeking = !1, this.emit(o.VIDEO_SEEKED, this); const c = this.video; c && this.updateTexture() }, getProgress: function () { const c = this.video; if (c) { const m = c.currentTime; const g = c.duration; if (g !== 1 / 0 && !isNaN(g)) return m / g } return 0 }, getDuration: function () { return this.video ? this.video.duration : 0 }, setMute: function (c) { c === void 0 && (c = !0), this._codeMuted = c; const m = this.video; return m && (m.muted = this._systemMuted ? !0 : c), this }, isMuted: function () { return this._codeMuted }, globalMute: function (c, m) { this._systemMuted = m; const g = this.video; g && (g.muted = this._codeMuted ? !0 : m) }, globalPause: function () { this._systemPaused = !0, this.video && this.video.pause() }, globalResume: function () { this._systemPaused = !1, this.video && !this._codePaused && this.video.play() }, setPaused: function (c) { c === void 0 && (c = !0); const m = this.video; return this._codePaused = c, m && (c ? m.paused || m.pause() : c || m.paused && !this._systemPaused && m.play()), this }, getVolume: function () { return this.video ? this.video.volume : 1 }, setVolume: function (c) { return c === void 0 && (c = 1), this.video && (this.video.volume = h(c, 0, 1)), this }, getPlaybackRate: function () { return this.video ? this.video.playbackRate : 1 }, setPlaybackRate: function (c) { return this.video && (this.video.playbackRate = c), this }, getLoop: function () { return this.video ? this.video.loop : !1 }, setLoop: function (c) { return c === void 0 && (c = !0), this.video && (this.video.loop = c), this }, isPlaying: function () { return this.video ? !(this.video.paused || this.video.ended) : !1 }, isPaused: function () { return this.video && this.video.paused || this._codePaused || this._systemPaused }, saveTexture: function (c, m) { return m === void 0 && (m = !1), this.videoTexture && this.scene.sys.textures.renameTexture(this._key, c), this._key = c, this.flipY = m, this.videoTextureSource && this.videoTextureSource.setFlipY(m), this.videoTexture }, stop: function () { const c = this.video; if (c) { const m = this._callbacks; for (const g in m)c.removeEventListener(g, m[g], !0); c.pause() } return this._retryID && window.clearTimeout(this._retryID), this.emit(o.VIDEO_STOP, this), this }, removeVideoElement: function () { const c = this.video; if (c) { for (c.parentNode && c.parentNode.removeChild(c); c.hasChildNodes();)c.removeChild(c.firstChild); c.removeAttribute('autoplay'), c.removeAttribute('src'), this.video = null } }, preDestroy: function () { this.stop(), this.removeVideoElementOnDestroy && this.removeVideoElement(); const c = this.scene.sys.game.events; c.off(r.PAUSE, this.globalPause, this), c.off(r.RESUME, this.globalResume, this); const m = this.scene.sys.sound; m && m.off(f.GLOBAL_MUTE, this.globalMute, this), this._retryID && window.clearTimeout(this._retryID) } }); e.exports = p }, function (e, d, t) { const i = t(0); const h = t(228); const n = t(470); const o = t(56); const r = new i({ initialize: function (a) { this.type = o.POLYGON, this.area = 0, this.points = [], a && this.setTo(a) }, contains: function (s, a) { return h(this, s, a) }, setTo: function (s) { if (this.area = 0, this.points = [], typeof s === 'string' && (s = s.split(' ')), !Array.isArray(s)) return this; for (var a, f = Number.MAX_VALUE, l = 0; l < s.length; l++)a = { x: 0, y: 0 }, typeof s[l] === 'number' || typeof s[l] === 'string' ? (a.x = parseFloat(s[l]), a.y = parseFloat(s[l + 1]), l++) : Array.isArray(s[l]) ? (a.x = s[l][0], a.y = s[l][1]) : (a.x = s[l].x, a.y = s[l].y), this.points.push(a), a.y < f && (f = a.y); return this.calculateArea(f), this }, calculateArea: function () { if (this.points.length < 3) return this.area = 0, this.area; for (var s = 0, a, f, l = 0; l < this.points.length - 1; l++)a = this.points[l], f = this.points[l + 1], s += (f.x - a.x) * (a.y + f.y); return a = this.points[0], f = this.points[this.points.length - 1], s += (a.x - f.x) * (f.y + a.y), this.area = -s * 0.5, this.area }, getPoints: function (s, a, f) { return n(this, s, a, f) } }); e.exports = r }, function (e, d) { const t = function (i, h, n) { for (var o = !1, r = -1, s = i.points.length - 1; ++r < i.points.length; s = r) { const a = i.points[r].x; const f = i.points[r].y; const l = i.points[s].x; const u = i.points[s].y; (f <= n && n < u || u <= n && n < f) && h < (l - a) * (n - f) / (u - f) + a && (o = !o) } return o }; e.exports = t }, function (e, d, t) { const i = t(0); const h = t(11); const n = t(15); const o = t(2); const r = t(17); const s = t(478); const a = t(1176); const f = t(25); const l = new i({ Extends: n, Mixins: [h.ComputedSize, h.Depth, h.GetBounds, h.Mask, h.Origin, h.ScrollFactor, h.Transform, h.Visible, a], initialize: function (v, p, c, m, g, x, y, T) { c === void 0 && (c = 0), m === void 0 && (m = 0), g === void 0 && (g = 128), x === void 0 && (x = 128), n.call(this, v, 'Shader'), this.blendMode = -1, this.shader; const S = v.sys.renderer; this.renderer = S, this.gl = S.gl, this.vertexData = new ArrayBuffer(6 * (Float32Array.BYTES_PER_ELEMENT * 2)), this.vertexBuffer = S.createVertexBuffer(this.vertexData.byteLength, this.gl.STREAM_DRAW), this.program = null, this.bytes = new Uint8Array(this.vertexData), this.vertexViewF32 = new Float32Array(this.vertexData), this._tempMatrix1 = new f(), this._tempMatrix2 = new f(), this._tempMatrix3 = new f(), this.viewMatrix = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]), this.projectionMatrix = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]), this.uniforms = {}, this.pointer = null, this._rendererWidth = S.width, this._rendererHeight = S.height, this._textureCount = 0, this.framebuffer = null, this.glTexture = null, this.renderToTexture = !1, this.texture = null, this.setPosition(c, m), this.setSize(g, x), this.setOrigin(0.5, 0.5), this.setShader(p, y, T) }, willRender: function (u) { return this.renderToTexture ? !0 : !(n.RENDER_MASK !== this.renderFlags || this.cameraFilter !== 0 && this.cameraFilter & u.id) }, setRenderToTexture: function (u, v) { if (v === void 0 && (v = !1), !this.renderToTexture) { const p = this.width; const c = this.height; var m = this.renderer; this.glTexture = m.createTextureFromSource(null, p, c, 0), this.glTexture.flipY = v, this.framebuffer = m.createFramebuffer(p, c, this.glTexture, !1), this._rendererWidth = p, this._rendererHeight = c, this.renderToTexture = !0, this.projOrtho(0, this.width, this.height, 0), u && (this.texture = this.scene.sys.textures.addGLTexture(u, this.glTexture, p, c)) } return this.shader && (m.pipelines.clear(), this.load(), this.flush(), m.pipelines.rebind()), this }, setShader: function (u, v, p) { if (v === void 0 && (v = []), typeof u === 'string') { const c = this.scene.sys.cache.shader; if (!c.has(u)) return console.warn('Shader missing: ' + u), this; this.shader = c.get(u) } else this.shader = u; const m = this.gl; const g = this.renderer; this.program && m.deleteProgram(this.program); const x = g.createProgram(this.shader.vertexSrc, this.shader.fragmentSrc); m.uniformMatrix4fv(m.getUniformLocation(x, 'uViewMatrix'), !1, this.viewMatrix), m.uniformMatrix4fv(m.getUniformLocation(x, 'uProjectionMatrix'), !1, this.projectionMatrix), m.uniform2f(m.getUniformLocation(x, 'uResolution'), this.width, this.height), this.program = x; const y = new Date(); const T = { resolution: { type: '2f', value: { x: this.width, y: this.height } }, time: { type: '1f', value: 0 }, mouse: { type: '2f', value: { x: this.width / 2, y: this.height / 2 } }, date: { type: '4fv', value: [y.getFullYear(), y.getMonth(), y.getDate(), y.getHours() * 60 * 60 + y.getMinutes() * 60 + y.getSeconds()] }, sampleRate: { type: '1f', value: 44100 }, iChannel0: { type: 'sampler2D', value: null, textureData: { repeat: !0 } }, iChannel1: { type: 'sampler2D', value: null, textureData: { repeat: !0 } }, iChannel2: { type: 'sampler2D', value: null, textureData: { repeat: !0 } }, iChannel3: { type: 'sampler2D', value: null, textureData: { repeat: !0 } } }; this.shader.uniforms ? this.uniforms = r(!0, {}, this.shader.uniforms, T) : this.uniforms = T; for (let S = 0; S < 4; S++)v[S] && this.setSampler2D('iChannel' + S, v[S], S, p); return this.initUniforms(), this.projOrtho(0, this._rendererWidth, this._rendererHeight, 0), this }, setPointer: function (u) { return this.pointer = u, this }, projOrtho: function (u, v, p, c) { const m = -1e3; const g = 1e3; const x = 1 / (u - v); const y = 1 / (p - c); const T = 1 / (m - g); const S = this.projectionMatrix; S[0] = -2 * x, S[5] = -2 * y, S[10] = 2 * T, S[12] = (u + v) * x, S[13] = (c + p) * y, S[14] = (g + m) * T; const E = this.program; const C = this.gl; const P = this.renderer; P.setProgram(E), C.uniformMatrix4fv(C.getUniformLocation(E, 'uProjectionMatrix'), !1, this.projectionMatrix), this._rendererWidth = v, this._rendererHeight = p }, initUniforms: function () { const u = this.gl; const v = this.renderer.glFuncMap; const p = this.program; this._textureCount = 0; for (const c in this.uniforms) { const m = this.uniforms[c]; const g = m.type; const x = v[g]; m.uniformLocation = u.getUniformLocation(p, c), g !== 'sampler2D' && (m.glMatrix = x.matrix, m.glValueLength = x.length, m.glFunc = x.func) } }, setSampler2DBuffer: function (u, v, p, c, m, g) { m === void 0 && (m = 0), g === void 0 && (g = {}); const x = this.uniforms[u]; return x.value = v, g.width = p, g.height = c, x.textureData = g, this._textureCount = m, this.initSampler2D(x), this }, setSampler2D: function (u, v, p, c) { p === void 0 && (p = 0); const m = this.scene.sys.textures; if (m.exists(v)) { const g = m.getFrame(v); if (g.glTexture && g.glTexture.isRenderTexture) return this.setSampler2DBuffer(u, g.glTexture, g.width, g.height, p, c); const x = this.uniforms[u]; const y = g.source; x.textureKey = v, x.source = y.image, x.value = g.glTexture, y.isGLTexture && (c || (c = {}), c.width = y.width, c.height = y.height), c && (x.textureData = c), this._textureCount = p, this.initSampler2D(x) } return this }, setUniform: function (u, v) { return s(this.uniforms, u, v), this }, getUniform: function (u) { return o(this.uniforms, u, null) }, setChannel0: function (u, v) { return this.setSampler2D('iChannel0', u, 0, v) }, setChannel1: function (u, v) { return this.setSampler2D('iChannel1', u, 1, v) }, setChannel2: function (u, v) { return this.setSampler2D('iChannel2', u, 2, v) }, setChannel3: function (u, v) { return this.setSampler2D('iChannel3', u, 3, v) }, initSampler2D: function (u) { if (u.value) { const v = this.gl; v.activeTexture(v.TEXTURE0 + this._textureCount), v.bindTexture(v.TEXTURE_2D, u.value); const p = u.textureData; if (p && !u.value.isRenderTexture) { const c = v[o(p, 'magFilter', 'linear').toUpperCase()]; const m = v[o(p, 'minFilter', 'linear').toUpperCase()]; let g = v[o(p, 'wrapS', 'repeat').toUpperCase()]; let x = v[o(p, 'wrapT', 'repeat').toUpperCase()]; const y = v[o(p, 'format', 'rgba').toUpperCase()]; if (p.repeat && (g = v.REPEAT, x = v.REPEAT), v.pixelStorei(v.UNPACK_FLIP_Y_WEBGL, !!p.flipY), p.width) { const T = o(p, 'width', 512); const S = o(p, 'height', 2); const E = o(p, 'border', 0); v.texImage2D(v.TEXTURE_2D, 0, y, T, S, E, y, v.UNSIGNED_BYTE, null) } else v.texImage2D(v.TEXTURE_2D, 0, y, v.RGBA, v.UNSIGNED_BYTE, u.source); v.texParameteri(v.TEXTURE_2D, v.TEXTURE_MAG_FILTER, c), v.texParameteri(v.TEXTURE_2D, v.TEXTURE_MIN_FILTER, m), v.texParameteri(v.TEXTURE_2D, v.TEXTURE_WRAP_S, g), v.texParameteri(v.TEXTURE_2D, v.TEXTURE_WRAP_T, x) } this.renderer.setProgram(this.program), v.uniform1i(u.uniformLocation, this._textureCount), this._textureCount++ } }, syncUniforms: function () { const u = this.gl; const v = this.uniforms; let p; let c; let m; let g; let x; let y = 0; for (const T in v)p = v[T], m = p.glFunc, c = p.glValueLength, g = p.uniformLocation, x = p.value, x !== null && (c === 1 ? p.glMatrix ? m.call(u, g, p.transpose, x) : m.call(u, g, x) : c === 2 ? m.call(u, g, x.x, x.y) : c === 3 ? m.call(u, g, x.x, x.y, x.z) : c === 4 ? m.call(u, g, x.x, x.y, x.z, x.w) : p.type === 'sampler2D' && (u.activeTexture(u.TEXTURE0 + y), u.bindTexture(u.TEXTURE_2D, x), u.uniform1i(g, y), y++)) }, load: function (u) { const v = this.gl; const p = this.width; const c = this.height; const m = this.renderer; const g = this.program; const x = this.viewMatrix; if (!this.renderToTexture) { const y = -this._displayOriginX; const T = -this._displayOriginY; x[0] = u[0], x[1] = u[1], x[4] = u[2], x[5] = u[3], x[8] = u[4], x[9] = u[5], x[12] = x[0] * y + x[4] * T, x[13] = x[1] * y + x[5] * T }v.useProgram(g), v.uniformMatrix4fv(v.getUniformLocation(g, 'uViewMatrix'), !1, x), v.uniform2f(v.getUniformLocation(g, 'uResolution'), this.width, this.height); const S = this.uniforms; const E = S.resolution; E.value.x = p, E.value.y = c, S.time.value = m.game.loop.getDuration(); const C = this.pointer; if (C) { const P = S.mouse; const A = C.x / p; const M = 1 - C.y / c; P.value.x = A.toFixed(2), P.value.y = M.toFixed(2) } this.syncUniforms() }, flush: function () { const u = this.width; const v = this.height; const p = this.program; const c = this.gl; const m = this.vertexBuffer; const g = this.renderer; const x = Float32Array.BYTES_PER_ELEMENT * 2; this.renderToTexture && (g.setFramebuffer(this.framebuffer), c.clearColor(0, 0, 0, 0), c.clear(c.COLOR_BUFFER_BIT)), c.bindBuffer(c.ARRAY_BUFFER, m); const y = c.getAttribLocation(p, 'inPosition'); y !== -1 && (c.enableVertexAttribArray(y), c.vertexAttribPointer(y, 2, c.FLOAT, !1, x, 0)); const T = this.vertexViewF32; T[3] = v, T[4] = u, T[5] = v, T[8] = u, T[9] = v, T[10] = u; const S = 6; c.bufferSubData(c.ARRAY_BUFFER, 0, this.bytes.subarray(0, S * x)), c.drawArrays(c.TRIANGLES, 0, S), this.renderToTexture && g.setFramebuffer(null, !1) }, setAlpha: function () {}, setBlendMode: function () {}, preDestroy: function () { const u = this.gl; u.deleteProgram(this.program), u.deleteBuffer(this.vertexBuffer), this.renderToTexture && (this.renderer.deleteFramebuffer(this.framebuffer), this.texture.destroy(), this.framebuffer = null, this.glTexture = null, this.texture = null) } }); e.exports = l }, function (e, d, t) { const i = t(0); const h = t(11); const n = t(36); const o = t(116); const r = t(15); const s = t(479); const a = t(480); const f = t(19); const l = t(69); const u = t(1179); const v = t(79); const p = t(39); const c = t(117); const m = new i({ Extends: r, Mixins: [h.AlphaSingle, h.BlendMode, h.Depth, h.Mask, h.Pipeline, h.Size, h.Texture, h.Transform, h.Visible, h.ScrollFactor, u], initialize: function (x, y, T, S, E, C, P, A, M, L, F, I) { y === void 0 && (y = 0), T === void 0 && (T = 0), S === void 0 && (S = '__WHITE'), r.call(this, x, 'Mesh'), this.faces = [], this.vertices = [], this.tintFill = !1, this.debugCallback = null, this.debugGraphic = null, this.hideCCW = !0, this.modelPosition = new p(), this.modelScale = new p(1, 1, 1), this.modelRotation = new p(), this.dirtyCache = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], this.transformMatrix = new l(), this.viewPosition = new p(), this.viewMatrix = new l(), this.projectionMatrix = new l(), this.totalRendered = 0, this.totalFrame = 0, this.ignoreDirtyCache = !1; const G = x.sys.renderer; this.setPosition(y, T), this.setTexture(S, E), this.setSize(G.width, G.height), this.initPipeline(), this.setPerspective(G.width, G.height), C && this.addVertices(C, P, A, M, L, F, I) }, addedToScene: function () { this.scene.sys.updateList.add(this) }, removedFromScene: function () { this.scene.sys.updateList.remove(this) }, panX: function (g) { return this.viewPosition.addScale(p.LEFT, g), this.dirtyCache[10] = 1, this }, panY: function (g) { return this.viewPosition.y += p.DOWN.y * g, this.dirtyCache[10] = 1, this }, panZ: function (g) { return this.viewPosition.z += g, this.dirtyCache[10] = 1, this }, setPerspective: function (g, x, y, T, S) { return y === void 0 && (y = 45), T === void 0 && (T = 0.01), S === void 0 && (S = 1e3), this.projectionMatrix.perspective(n(y), g / x, T, S), this.dirtyCache[10] = 1, this.dirtyCache[11] = 0, this }, setOrtho: function (g, x, y, T) { return g === void 0 && (g = this.scene.sys.renderer.getAspectRatio()), x === void 0 && (x = 1), y === void 0 && (y = -1e3), T === void 0 && (T = 1e3), this.projectionMatrix.ortho(-g, g, -x, x, y, T), this.dirtyCache[10] = 1, this.dirtyCache[11] = 1, this }, clear: function () { return this.faces.forEach(function (g) { g.destroy() }), this.faces = [], this.vertices = [], this }, addVerticesFromObj: function (g, x, y, T, S, E, C, P, A) { const M = this.scene.sys.cache.obj.get(g); return M && a(M, this, x, y, T, S, E, C, P, A), this }, sortByDepth: function (g, x) { return g.depth - x.depth }, depthSort: function () { return v(this.faces, this.sortByDepth), this }, addVertex: function (g, x, y, T, S, E, C) { const P = new c(g, x, y, T, S, E, C); return this.vertices.push(P), P }, addFace: function (g, x, y) { const T = new o(g, x, y); return this.faces.push(T), this.dirtyCache[9] = -1, T }, addVertices: function (g, x, y, T, S, E, C) { const P = s(g, x, y, T, S, E, C); return P && (this.faces = this.faces.concat(P.faces), this.vertices = this.vertices.concat(P.vertices)), this.dirtyCache[9] = -1, this }, getFaceCount: function () { return this.faces.length }, getVertexCount: function () { return this.vertices.length }, getFace: function (g) { return this.faces[g] }, getFaceAt: function (g, x, y) { y === void 0 && (y = this.scene.sys.cameras.main); for (var T = f(this, y).calc, S = this.faces, E = [], C = 0; C < S.length; C++) { const P = S[C]; P.contains(g, x, T) && E.push(P) } return v(E, this.sortByDepth) }, setDebug: function (g, x) { return this.debugGraphic = g, !g && !x ? this.debugCallback = null : x ? this.debugCallback = x : this.debugCallback = this.renderDebug, this }, isDirty: function () { const g = this.modelPosition; const x = this.modelRotation; const y = this.modelScale; const T = this.dirtyCache; const S = g.x; const E = g.y; const C = g.z; const P = x.x; const A = x.y; const M = x.z; const L = y.x; const F = y.y; const I = y.z; const G = this.getFaceCount(); const U = T[0]; const Y = T[1]; const X = T[2]; const O = T[3]; const R = T[4]; const D = T[5]; const B = T[6]; const N = T[7]; const w = T[8]; const z = T[9]; return T[0] = S, T[1] = E, T[2] = C, T[3] = P, T[4] = A, T[5] = M, T[6] = L, T[7] = F, T[8] = I, T[9] = G, U !== S || Y !== E || X !== C || O !== P || R !== A || D !== M || B !== L || N !== F || w !== I || z !== G }, preUpdate: function () { this.totalRendered = this.totalFrame, this.totalFrame = 0; const g = this.dirtyCache; if (!(!this.ignoreDirtyCache && !g[10] && !this.isDirty())) { const x = this.width; const y = this.height; const T = this.viewMatrix; const S = this.viewPosition; g[10] && (T.identity(), T.translate(S), T.invert(), g[10] = 0); const E = this.transformMatrix; E.setWorldMatrix(this.modelRotation, this.modelPosition, this.modelScale, this.viewMatrix, this.projectionMatrix); for (let C = S.z, P = this.faces, A = 0; A < P.length; A++)P[A].transformCoordinatesLocal(E, x, y, C); this.depthSort() } }, renderDebug: function (g, x) { for (let y = g.debugGraphic, T = 0; T < x.length; T++) { const S = x[T]; const E = S.vertex1.tx; const C = S.vertex1.ty; const P = S.vertex2.tx; const A = S.vertex2.ty; const M = S.vertex3.tx; const L = S.vertex3.ty; y.strokeTriangle(E, C, P, A, M, L) } }, preDestroy: function () { this.clear(), this.debugCallback = null, this.debugGraphic = null } }); e.exports = m }, function (e, d, t) { const i = t(50); const h = function (n, o) { return i(n.x, n.y, o.x, o.y) <= n.radius + o.radius }; e.exports = h }, function (e, d, t) { const i = t(4); const h = t(233); const n = function (o, r, s) { if (s === void 0 && (s = []), h(o, r)) { const a = o.x1; const f = o.y1; const l = o.x2; const u = o.y2; const v = r.x; const p = r.y; const c = r.radius; const m = l - a; const g = u - f; const x = a - v; const y = f - p; const T = m * m + g * g; const S = 2 * (m * x + g * y); const E = x * x + y * y - c * c; const C = S * S - 4 * T * E; let P; let A; if (C === 0) { const M = -S / (2 * T); P = a + M * m, A = f + M * g, M >= 0 && M <= 1 && s.push(new i(P, A)) } else if (C > 0) { const L = (-S - Math.sqrt(C)) / (2 * T); P = a + L * m, A = f + L * g, L >= 0 && L <= 1 && s.push(new i(P, A)); const F = (-S + Math.sqrt(C)) / (2 * T); P = a + F * m, A = f + F * g, F >= 0 && F <= 1 && s.push(new i(P, A)) } } return s }; e.exports = n }, function (e, d, t) { const i = t(66); const h = t(4); const n = new h(); const o = function (r, s, a) { if (a === void 0 && (a = n), i(s, r.x1, r.y1)) return a.x = r.x1, a.y = r.y1, !0; if (i(s, r.x2, r.y2)) return a.x = r.x2, a.y = r.y2, !0; const f = r.x2 - r.x1; const l = r.y2 - r.y1; const u = s.x - r.x1; const v = s.y - r.y1; const p = f * f + l * l; let c = f; let m = l; if (p > 0) { const g = (u * f + v * l) / p; c *= g, m *= g }a.x = r.x1 + c, a.y = r.y1 + m; const x = c * c + m * m; return x <= p && c * f + m * l >= 0 && i(s, a.x, a.y) }; e.exports = o }, function (e, d, t) { const i = t(4); const h = t(96); const n = t(488); const o = function (r, s, a) { if (a === void 0 && (a = []), n(r, s)) for (let f = s.getLineA(), l = s.getLineB(), u = s.getLineC(), v = s.getLineD(), p = [new i(), new i(), new i(), new i()], c = [h(f, r, p[0]), h(l, r, p[1]), h(u, r, p[2]), h(v, r, p[3])], m = 0; m < 4; m++)c[m] && a.push(p[m]); return a }; e.exports = o }, function (e, d) { const t = function (i, h, n, o) { n === void 0 && (n = !1), o === void 0 && (o = []); for (var r = i.x3 - i.x1, s = i.y3 - i.y1, a = i.x2 - i.x1, f = i.y2 - i.y1, l = r * r + s * s, u = r * a + s * f, v = a * a + f * f, p = l * v - u * u, c = p === 0 ? 0 : 1 / p, m, g, x, y, T, S, E = i.x1, C = i.y1, P = 0; P < h.length && (x = h[P].x - E, y = h[P].y - C, T = r * x + s * y, S = a * x + f * y, m = (v * T - u * S) * c, g = (l * S - u * T) * c, !(m >= 0 && g >= 0 && m + g < 1 && (o.push({ x: h[P].x, y: h[P].y }), n))); P++);return o }; e.exports = t }, function (e, d) { const t = function (i, h, n, o) { const r = Math.cos(o); const s = Math.sin(o); let a = i.x1 - h; let f = i.y1 - n; return i.x1 = a * r - f * s + h, i.y1 = a * s + f * r + n, a = i.x2 - h, f = i.y2 - n, i.x2 = a * r - f * s + h, i.y2 = a * s + f * r + n, i }; e.exports = t }, function (e, d) { const t = function (i) { return i.height === 0 ? NaN : i.width / i.height }; e.exports = t }, function (e, d) { const t = function (i, h, n, o) { const r = Math.cos(o); const s = Math.sin(o); let a = i.x1 - h; let f = i.y1 - n; return i.x1 = a * r - f * s + h, i.y1 = a * s + f * r + n, a = i.x2 - h, f = i.y2 - n, i.x2 = a * r - f * s + h, i.y2 = a * s + f * r + n, a = i.x3 - h, f = i.y3 - n, i.x3 = a * r - f * s + h, i.y3 = a * s + f * r + n, i }; e.exports = t }, function (e, d, t) { e.exports = { BUTTON_DOWN: t(1310), BUTTON_UP: t(1311), CONNECTED: t(1312), DISCONNECTED: t(1313), GAMEPAD_BUTTON_DOWN: t(1314), GAMEPAD_BUTTON_UP: t(1315) } }, function (e, d, t) { const i = t(17); const h = t(156); const n = function (o, r) { const s = o === void 0 ? h() : i({}, o); if (r) for (const a in r)r[a] !== void 0 && (s[a] = r[a]); return s }; e.exports = n }, function (e, d, t) { const i = t(0); const h = t(21); const n = t(23); const o = t(8); const r = t(2); const s = t(7); const a = t(408); const f = new i({ Extends: n, initialize: function (u, v, p, c) { let m = 'xml'; if (s(v)) { const g = v; v = r(g, 'key'), p = r(g, 'url'), c = r(g, 'xhrSettings'), m = r(g, 'extension', m) } const x = { type: 'xml', cache: u.cacheManager.xml, extension: m, responseType: 'text', key: v, url: p, xhrSettings: c }; n.call(this, u, x) }, onProcess: function () { this.state = h.FILE_PROCESSING, this.data = a(this.xhrLoader.responseText), this.data ? this.onProcessComplete() : (console.warn('Invalid XMLFile: ' + this.key), this.onProcessError()) } }); o.register('xml', function (l, u, v) { if (Array.isArray(l)) for (let p = 0; p < l.length; p++) this.addFile(new f(this, l[p])); else this.addFile(new f(this, l, u, v)); return this }), e.exports = f }, function (e, d, t) { const i = t(0); const h = t(21); const n = t(23); const o = t(8); const r = t(2); const s = t(7); const a = new i({ Extends: n, initialize: function (l, u, v, p) { let c = 'text'; let m = 'txt'; let g = l.cacheManager.text; if (s(u)) { const x = u; u = r(x, 'key'), v = r(x, 'url'), p = r(x, 'xhrSettings'), m = r(x, 'extension', m), c = r(x, 'type', c), g = r(x, 'cache', g) } const y = { type: c, cache: g, extension: m, responseType: 'text', key: u, url: v, xhrSettings: p }; n.call(this, l, y) }, onProcess: function () { this.state = h.FILE_PROCESSING, this.data = this.xhrLoader.responseText, this.onProcessComplete() } }); o.register('text', function (f, l, u) { if (Array.isArray(f)) for (let v = 0; v < f.length; v++) this.addFile(new a(this, f[v])); else this.addFile(new a(this, f, l, u)); return this }), e.exports = a }, function (e, d, t) { e.exports = { Acceleration: t(1368), Angular: t(1369), Bounce: t(1370), Debug: t(1371), Drag: t(1372), Enable: t(1373), Friction: t(1374), Gravity: t(1375), Immovable: t(1376), Mass: t(1377), OverlapCirc: t(523), OverlapRect: t(244), Pushable: t(1378), Size: t(1379), Velocity: t(1380) } }, function (e, d) { const t = function (i, h, n, o, r, s, a) { s === void 0 && (s = !0), a === void 0 && (a = !1); let f = []; let l = []; const u = i.treeMinMax; if (u.minX = h, u.minY = n, u.maxX = h + o, u.maxY = n + r, a && (l = i.staticTree.search(u)), s && i.useTree)f = i.tree.search(u); else if (s) { const v = i.bodies; const p = { position: { x: h, y: n }, left: h, top: n, right: h + o, bottom: n + r, isCircle: !1 }; const c = i.intersects; v.iterate(function (m) { c(m, p) && f.push(m) }) } return l.concat(f) }; e.exports = t }, function (e, d, t) { e.exports = { COLLIDE: t(1381), OVERLAP: t(1382), PAUSE: t(1383), RESUME: t(1384), TILE_COLLIDE: t(1385), TILE_OVERLAP: t(1386), WORLD_BOUNDS: t(1387), WORLD_STEP: t(1388) } }, function (e, d, t) { const i = t(62); const h = function (n, o, r, s) { let a = 0; const f = n.deltaAbsX() + o.deltaAbsX() + s; return n._dx === 0 && o._dx === 0 ? (n.embedded = !0, o.embedded = !0) : n._dx > o._dx ? (a = n.right - o.x, a > f && !r || n.checkCollision.right === !1 || o.checkCollision.left === !1 ? a = 0 : (n.touching.none = !1, n.touching.right = !0, o.touching.none = !1, o.touching.left = !0, o.physicsType === i.STATIC_BODY && !r && (n.blocked.none = !1, n.blocked.right = !0), n.physicsType === i.STATIC_BODY && !r && (o.blocked.none = !1, o.blocked.left = !0))) : n._dx < o._dx && (a = n.x - o.width - o.x, -a > f && !r || n.checkCollision.left === !1 || o.checkCollision.right === !1 ? a = 0 : (n.touching.none = !1, n.touching.left = !0, o.touching.none = !1, o.touching.right = !0, o.physicsType === i.STATIC_BODY && !r && (n.blocked.none = !1, n.blocked.left = !0), n.physicsType === i.STATIC_BODY && !r && (o.blocked.none = !1, o.blocked.right = !0))), n.overlapX = a, o.overlapX = a, a }; e.exports = h }, function (e, d, t) { const i = t(62); const h = function (n, o, r, s) { let a = 0; const f = n.deltaAbsY() + o.deltaAbsY() + s; return n._dy === 0 && o._dy === 0 ? (n.embedded = !0, o.embedded = !0) : n._dy > o._dy ? (a = n.bottom - o.y, a > f && !r || n.checkCollision.down === !1 || o.checkCollision.up === !1 ? a = 0 : (n.touching.none = !1, n.touching.down = !0, o.touching.none = !1, o.touching.up = !0, o.physicsType === i.STATIC_BODY && !r && (n.blocked.none = !1, n.blocked.down = !0), n.physicsType === i.STATIC_BODY && !r && (o.blocked.none = !1, o.blocked.up = !0))) : n._dy < o._dy && (a = n.y - o.bottom, -a > f && !r || n.checkCollision.up === !1 || o.checkCollision.down === !1 ? a = 0 : (n.touching.none = !1, n.touching.up = !0, o.touching.none = !1, o.touching.down = !0, o.physicsType === i.STATIC_BODY && !r && (n.blocked.none = !1, n.blocked.up = !0), n.physicsType === i.STATIC_BODY && !r && (o.blocked.none = !1, o.blocked.down = !0))), n.overlapY = a, o.overlapY = a, a }; e.exports = h }, function (e, d) { const t = function (i, h) { return !(h.right <= i.left || h.bottom <= i.top || h.position.x >= i.right || h.position.y >= i.bottom) }; e.exports = t }, function (e, d, t) { e.exports = { Bounce: t(1495), Collision: t(1496), Force: t(1497), Friction: t(1498), Gravity: t(1499), Mass: t(1500), Sensor: t(1501), SetBody: t(1502), Sleep: t(1503), Static: t(1520), Transform: t(1521), Velocity: t(1522) } }, function (e, d) { const t = {}; e.exports = t, (function () { t.create = function (i, h) { const n = i.bodyA; const o = i.bodyB; const r = { id: t.id(n, o), bodyA: n, bodyB: o, activeContacts: [], separation: 0, isActive: !0, confirmedActive: !0, isSensor: n.isSensor || o.isSensor, timeCreated: h, timeUpdated: h, collision: null, inverseMass: 0, friction: 0, frictionStatic: 0, restitution: 0, slop: 0 }; return t.update(r, i, h), r }, t.update = function (i, h, n) { if (i.collision = h, h.collided) { const o = h.supports; const r = i.activeContacts; const s = h.parentA; const a = h.parentB; i.inverseMass = s.inverseMass + a.inverseMass, i.friction = Math.min(s.friction, a.friction), i.frictionStatic = Math.max(s.frictionStatic, a.frictionStatic), i.restitution = Math.max(s.restitution, a.restitution), i.slop = Math.max(s.slop, a.slop); for (let f = 0; f < o.length; f++)r[f] = o[f].contact; const l = o.length; l < r.length && (r.length = l), i.separation = h.depth, t.setActive(i, !0, n) } else i.isActive === !0 && t.setActive(i, !1, n) }, t.setActive = function (i, h, n) { h ? (i.isActive = !0, i.timeUpdated = n) : (i.isActive = !1, i.activeContacts.length = 0) }, t.id = function (i, h) { return i.id < h.id ? 'A' + i.id + 'B' + h.id : 'A' + h.id + 'B' + i.id } }()) }, function (e, d, t) { e.exports = { CalculateFacesAt: t(252), CalculateFacesWithin: t(63), CheckIsoBounds: t(541), Copy: t(1420), CreateFromTiles: t(1421), CullBounds: t(543), CullTiles: t(544), Fill: t(1422), FilterTiles: t(1423), FindByIndex: t(1424), FindTile: t(1425), ForEachTile: t(1426), GetCullTilesFunction: t(1427), GetTileAt: t(158), GetTileAtWorldXY: t(1428), GetTilesWithin: t(26), GetTilesWithinShape: t(1429), GetTilesWithinWorldXY: t(529), GetTileToWorldXFunction: t(1430), GetTileToWorldXYFunction: t(1431), GetTileToWorldYFunction: t(1432), GetWorldToTileXFunction: t(1433), GetWorldToTileXYFunction: t(1434), GetWorldToTileYFunction: t(1435), HasTileAt: t(562), HasTileAtWorldXY: t(1436), HexagonalCullBounds: t(546), HexagonalCullTiles: t(545), HexagonalTileToWorldXY: t(550), HexagonalTileToWorldY: t(554), HexagonalWorldToTileXY: t(556), HexagonalWorldToTileY: t(560), IsInLayerBounds: t(119), IsometricCullTiles: t(547), IsometricTileToWorldXY: t(551), IsometricWorldToTileXY: t(557), PutTileAt: t(257), PutTileAtWorldXY: t(1437), PutTilesAt: t(1438), Randomize: t(1439), RemoveTileAt: t(563), RemoveTileAtWorldXY: t(1440), RenderDebug: t(1441), ReplaceByIndex: t(542), RunCull: t(159), SetCollision: t(1442), SetCollisionBetween: t(1443), SetCollisionByExclusion: t(1444), SetCollisionByProperty: t(1445), SetCollisionFromCollisionGroup: t(1446), SetLayerCollisionIndex: t(160), SetTileCollision: t(72), SetTileIndexCallback: t(1447), SetTileLocationCallback: t(1448), Shuffle: t(1449), StaggeredCullBounds: t(549), StaggeredCullTiles: t(548), StaggeredTileToWorldXY: t(552), StaggeredTileToWorldY: t(555), StaggeredWorldToTileXY: t(558), StaggeredWorldToTileY: t(561), SwapByIndex: t(1450), TileToWorldX: t(253), TileToWorldXY: t(553), TileToWorldY: t(254), WeightedRandomize: t(1451), WorldToTileX: t(255), WorldToTileXY: t(559), WorldToTileY: t(256) } }, function (e, d, t) { const i = t(158); const h = function (n, o, r) { const s = i(n, o, !0, r); const a = i(n, o - 1, !0, r); const f = i(n, o + 1, !0, r); const l = i(n - 1, o, !0, r); const u = i(n + 1, o, !0, r); const v = s && s.collides; return v && (s.faceTop = !0, s.faceBottom = !0, s.faceLeft = !0, s.faceRight = !0), a && a.collides && (v && (s.faceTop = !1), a.faceBottom = !v), f && f.collides && (v && (s.faceBottom = !1), f.faceTop = !v), l && l.collides && (v && (s.faceLeft = !1), l.faceRight = !v), u && u.collides && (v && (s.faceRight = !1), u.faceLeft = !v), s && !s.collides && s.resetFaces(), s }; e.exports = h }, function (e, d) { const t = function (i, h, n) { let o = n.baseTileWidth; const r = n.tilemapLayer; let s = 0; return r && (h || (h = r.scene.cameras.main), s = r.x + h.scrollX * (1 - r.scrollFactorX), o *= r.scaleX), s + i * o }; e.exports = t }, function (e, d) { const t = function (i, h, n) { let o = n.baseTileHeight; const r = n.tilemapLayer; let s = 0; return r && (h || (h = r.scene.cameras.main), s = r.y + h.scrollY * (1 - r.scrollFactorY), o *= r.scaleY), s + i * o }; e.exports = t }, function (e, d) { const t = function (i, h, n, o) { h === void 0 && (h = !0); let r = o.baseTileWidth; const s = o.tilemapLayer; return s && (n || (n = s.scene.cameras.main), i = i - (s.x + n.scrollX * (1 - s.scrollFactorX)), r *= s.scaleX), h ? Math.floor(i / r) : i / r }; e.exports = t }, function (e, d) { const t = function (i, h, n, o) { h === void 0 && (h = !0); let r = o.baseTileHeight; const s = o.tilemapLayer; return s && (n || (n = s.scene.cameras.main), i = i - (s.y + n.scrollY * (1 - s.scrollFactorY)), r *= s.scaleY), h ? Math.floor(i / r) : i / r }; e.exports = t }, function (e, d, t) { const i = t(85); const h = t(119); const n = t(252); const o = t(72); const r = function (s, a, f, l, u) { if (l === void 0 && (l = !0), !h(a, f, u)) return null; const v = u.data[f][a]; const p = v && v.collides; if (s instanceof i)u.data[f][a] === null && (u.data[f][a] = new i(u, s.index, a, f, u.tileWidth, u.tileHeight)), u.data[f][a].copy(s); else { const c = s; u.data[f][a] === null ? u.data[f][a] = new i(u, c, a, f, u.tileWidth, u.tileHeight) : u.data[f][a].index = c } const m = u.data[f][a]; const g = u.collideIndexes.indexOf(m.index) !== -1; return o(m, g), l && p !== m.collides && n(a, f, u), m }; e.exports = r }, function (e, d, t) { const i = t(29); const h = function (n) { return n = n.toLowerCase(), n === 'isometric' ? i.ISOMETRIC : n === 'staggered' ? i.STAGGERED : n === 'hexagonal' ? i.HEXAGONAL : i.ORTHOGONAL }; e.exports = h }, function (e, d, t) { const i = t(40); const h = t(120); const n = t(121); const o = t(85); const r = function (s, a, f, l, u) { for (var v = new h({ tileWidth: f, tileHeight: l }), p = new n({ name: s, tileWidth: f, tileHeight: l, format: i.ARRAY_2D, layers: [v] }), c = [], m = a.length, g = 0, x = 0; x < a.length; x++) { c[x] = []; for (var y = a[x], T = 0; T < y.length; T++) { const S = parseInt(y[T], 10); isNaN(S) || S === -1 ? c[x][T] = u ? null : new o(v, -1, T, x, f, l) : c[x][T] = new o(v, S, T, x, f, l) }g === 0 && (g = y.length) } return p.width = v.width = g, p.height = v.height = m, p.widthInPixels = v.widthInPixels = g * f, p.heightInPixels = v.heightInPixels = m * l, v.data = c, p }; e.exports = r }, function (e, d, t) { const i = t(571); const h = t(261); const n = function (s) { return { x: s.x, y: s.y } }; const o = ['id', 'name', 'type', 'rotation', 'properties', 'visible', 'x', 'y', 'width', 'height']; const r = function (s, a, f) { a === void 0 && (a = 0), f === void 0 && (f = 0); const l = i(s, o); if (l.x += a, l.y += f, s.gid) { const u = h(s.gid); l.gid = u.gid, l.flippedHorizontal = u.flippedHorizontal, l.flippedVertical = u.flippedVertical, l.flippedAntiDiagonal = u.flippedAntiDiagonal } else s.polyline ? l.polyline = s.polyline.map(n) : s.polygon ? l.polygon = s.polygon.map(n) : s.ellipse ? l.ellipse = s.ellipse : s.text ? l.text = s.text : s.point ? l.point = !0 : l.rectangle = !0; return l }; e.exports = r }, function (e, d) { const t = 2147483648; const i = 1073741824; const h = 536870912; const n = function (o) { const r = Boolean(o & t); const s = Boolean(o & i); const a = Boolean(o & h); o = o & ~(t | i | h); let f = 0; let l = !1; return r && s && a ? (f = Math.PI / 2, l = !0) : r && s && !a ? (f = Math.PI, l = !1) : r && !s && a ? (f = Math.PI / 2, l = !1) : r && !s && !a ? (f = 0, l = !0) : !r && s && a ? (f = 3 * Math.PI / 2, l = !1) : !r && s && !a ? (f = Math.PI, l = !0) : !r && !s && a ? (f = 3 * Math.PI / 2, l = !0) : !r && !s && !a && (f = 0, l = !1), { gid: o, flippedHorizontal: r, flippedVertical: s, flippedAntiDiagonal: a, rotation: f, flipped: l } }; e.exports = n }, function (e, d, t) { const i = t(40); const h = t(121); const n = t(564); const o = t(580); const r = function (s, a, f, l, u, v, p, c) { f === void 0 && (f = 32), l === void 0 && (l = 32), u === void 0 && (u = 10), v === void 0 && (v = 10), c === void 0 && (c = !1); let m = null; if (Array.isArray(p)) { const g = a !== void 0 ? a : 'map'; m = n(g, i.ARRAY_2D, p, f, l, c) } else if (a !== void 0) { const x = s.cache.tilemap.get(a); x ? m = n(a, x.format, x.data, f, l, c) : console.warn('No map data found for key ' + a) } return m === null && (m = new h({ tileWidth: f, tileHeight: l, width: u, height: v })), new o(s, m) }; e.exports = r }, function (e, d, t) { const i = t(6); const h = function (n) { let o = i(n, 'targets', null); return o === null || (typeof o === 'function' && (o = o.call()), Array.isArray(o) || (o = [o])), o }; e.exports = h }, function (e, d) { function t (r) { return !!r.getActive && typeof r.getActive === 'function' } function i (r) { return !!r.getStart && typeof r.getStart === 'function' } function h (r) { return !!r.getEnd && typeof r.getEnd === 'function' } function n (r) { return i(r) || h(r) || t(r) } var o = function (r, s) { let a; let f = function (S, E, C) { return C }; let l = function (S, E, C) { return C }; let u = null; const v = typeof s; if (v === 'number')f = function () { return s }; else if (v === 'string') { const p = s[0]; const c = parseFloat(s.substr(2)); switch (p) { case '+':f = function (S, E, C) { return C + c }; break; case '-':f = function (S, E, C) { return C - c }; break; case '*':f = function (S, E, C) { return C * c }; break; case '/':f = function (S, E, C) { return C / c }; break; default:f = function () { return parseFloat(s) } } } else if (v === 'function')f = s; else if (v === 'object') if (n(s))t(s) && (u = s.getActive), h(s) && (f = s.getEnd), i(s) && (l = s.getStart); else if (s.hasOwnProperty('value'))a = o(r, s.value); else { const m = s.hasOwnProperty('to'); const g = s.hasOwnProperty('from'); const x = s.hasOwnProperty('start'); if (m && (g || x)) { if (a = o(r, s.to), x) { const y = o(r, s.start); a.getActive = y.getEnd } if (g) { const T = o(r, s.from); a.getStart = T.getEnd } } } return a || (a = { getActive: u, getEnd: f, getStart: l }), a }; e.exports = o }, function (e, d) { const t = { targets: null, delay: 0, duration: 1e3, ease: 'Power0', easeParams: null, hold: 0, repeat: 0, repeatDelay: 0, yoyo: !1, flipX: !1, flipY: !1 }; e.exports = t }, function (e, d, t) { const i = t(0); const h = t(9); const n = t(267); const o = t(16); const r = t(5); const s = t(100); const a = t(14); const f = new i({ Extends: h, initialize: function (u, v, p) { h.call(this), this.parent = u, this.parentIsTimeline = u.hasOwnProperty('isTimeline'), this.data = v, this.totalData = v.length, this.targets = p, this.totalTargets = p.length, this.useFrames = !1, this.timeScale = 1, this.loop = 0, this.loopDelay = 0, this.loopCounter = 0, this.startDelay = 0, this.hasStarted = !1, this.isSeeking = !1, this.completeDelay = 0, this.countdown = 0, this.offset = 0, this.calculatedOffset = 0, this.state = s.PENDING_ADD, this._pausedState = s.INIT, this.paused = !1, this.elapsed = 0, this.totalElapsed = 0, this.duration = 0, this.progress = 0, this.totalDuration = 0, this.totalProgress = 0, this.callbacks = { onActive: null, onComplete: null, onLoop: null, onRepeat: null, onStart: null, onStop: null, onUpdate: null, onYoyo: null }, this.callbackScope }, getValue: function (l) { return l === void 0 && (l = 0), this.data[l].current }, setTimeScale: function (l) { return this.timeScale = l, this }, getTimeScale: function () { return this.timeScale }, isPlaying: function () { return this.state === s.ACTIVE }, isPaused: function () { return this.state === s.PAUSED }, hasTarget: function (l) { return this.targets.indexOf(l) !== -1 }, updateTo: function (l, u, v) { v === void 0 && (v = !1); for (let p = 0; p < this.totalData; p++) { const c = this.data[p]; c.key === l && (c.end = u, v && (c.start = c.current)) } return this }, restart: function () { return this.elapsed = 0, this.progress = 0, this.totalElapsed = 0, this.totalProgress = 0, this.state === s.ACTIVE ? this.seek(0) : this.state === s.REMOVED ? (this.seek(0), this.parent.makeActive(this), this) : this.state === s.PENDING_ADD ? this : this.play() }, calcDuration: function () { for (var l = 0, u = a.MAX_SAFE_INTEGER, v = this.data, p = 0; p < this.totalData; p++) { const c = v[p]; c.t1 = c.duration + c.hold, c.yoyo && (c.t1 += c.duration), c.t2 = c.t1 + c.repeatDelay, c.totalDuration = c.delay + c.t1, c.repeat === -1 ? c.totalDuration += c.t2 * 999999999999 : c.repeat > 0 && (c.totalDuration += c.t2 * c.repeat), c.totalDuration > l && (l = c.totalDuration), c.delay < u && (u = c.delay) } this.duration = Math.max(l, 0.001), this.loopCounter = this.loop === -1 ? 999999999999 : this.loop, this.loopCounter > 0 ? this.totalDuration = this.duration + this.completeDelay + (this.duration + this.loopDelay) * this.loopCounter : this.totalDuration = this.duration + this.completeDelay, this.startDelay = u }, init: function () { if (this.paused && !this.parentIsTimeline) return this.state = s.PENDING_ADD, this._pausedState = s.INIT, !1; for (let l = this.data, u = this.totalTargets, v = 0; v < this.totalData; v++) { const p = l[v]; const c = p.target; const m = p.gen; const g = p.key; const x = p.index; p.delay = m.delay(c, g, 0, x, u, this), p.duration = Math.max(m.duration(c, g, 0, x, u, this), 0.001), p.hold = m.hold(c, g, 0, x, u, this), p.repeat = m.repeat(c, g, 0, x, u, this), p.repeatDelay = m.repeatDelay(c, g, 0, x, u, this) } return this.calcDuration(), this.progress = 0, this.totalProgress = 0, this.elapsed = 0, this.totalElapsed = 0, this.state = s.INIT, !0 }, makeActive: function () { this.parent.makeActive(this), this.dispatchTweenEvent(n.TWEEN_ACTIVE, this.callbacks.onActive) }, nextState: function () { this.loopCounter > 0 ? (this.elapsed = 0, this.progress = 0, this.loopCounter--, this.resetTweenData(!0), this.loopDelay > 0 ? (this.countdown = this.loopDelay, this.state = s.LOOP_DELAY) : (this.state = s.ACTIVE, this.dispatchTweenEvent(n.TWEEN_LOOP, this.callbacks.onLoop))) : this.completeDelay > 0 ? (this.state = s.COMPLETE_DELAY, this.countdown = this.completeDelay) : (this.state = s.PENDING_REMOVE, this.dispatchTweenEvent(n.TWEEN_COMPLETE, this.callbacks.onComplete)) }, pause: function () { return this.state === s.PAUSED ? this : (this.paused = !0, this._pausedState = this.state, this.state = s.PAUSED, this) }, play: function (l) { l === void 0 && (l = !1); const u = this.state; return u === s.INIT && !this.parentIsTimeline ? (this.resetTweenData(!1), this.state = s.ACTIVE, this) : u === s.ACTIVE || u === s.PENDING_ADD && this._pausedState === s.PENDING_ADD ? this : !this.parentIsTimeline && (u === s.PENDING_REMOVE || u === s.REMOVED) ? (this.seek(0), this.parent.makeActive(this), this) : (this.parentIsTimeline ? (this.resetTweenData(l), this.calculatedOffset === 0 ? this.state = s.ACTIVE : (this.countdown = this.calculatedOffset, this.state = s.OFFSET_DELAY)) : this.paused ? (this.paused = !1, this.makeActive()) : (this.resetTweenData(l), this.state = s.ACTIVE, this.makeActive()), this) }, resetTweenData: function (l) { for (let u = this.data, v = this.totalData, p = this.totalTargets, c = 0; c < v; c++) { const m = u[c]; const g = m.target; const x = m.key; const y = m.index; m.progress = 0, m.elapsed = 0, m.repeatCounter = m.repeat === -1 ? 999999999999 : m.repeat, l ? (m.start = m.getStartValue(g, x, m.start, y, p, this), m.end = m.getEndValue(g, x, m.end, y, p, this), m.current = m.start, m.state = s.PLAYING_FORWARD) : m.state = s.PENDING_RENDER, m.delay > 0 && (m.elapsed = m.delay, m.state = s.DELAY), m.getActiveValue && (g[x] = m.getActiveValue(m.target, m.key, m.start)) } }, resume: function () { return this.state === s.PAUSED ? (this.paused = !1, this.state = this._pausedState) : this.play(), this }, seek: function (l, u) { u === void 0 && (u = 16.6), this.state === s.REMOVED && this.makeActive(), this.elapsed = 0, this.progress = 0, this.totalElapsed = 0, this.totalProgress = 0; for (let v = this.data, p = this.totalTargets, c = 0; c < this.totalData; c++) { const m = v[c]; const g = m.target; const x = m.gen; const y = m.key; const T = m.index; m.progress = 0, m.elapsed = 0, m.repeatCounter = m.repeat === -1 ? 999999999999 : m.repeat, m.delay = x.delay(g, y, 0, T, p, this), m.duration = Math.max(x.duration(g, y, 0, T, p, this), 0.001), m.hold = x.hold(g, y, 0, T, p, this), m.repeat = x.repeat(g, y, 0, T, p, this), m.repeatDelay = x.repeatDelay(g, y, 0, T, p, this), m.current = m.start, m.state = s.PLAYING_FORWARD, this.updateTweenData(this, m, 0, T, p), m.delay > 0 && (m.elapsed = m.delay, m.state = s.DELAY) } this.calcDuration(); let S = !1; this.state === s.PAUSED && (S = !0, this.state = s.ACTIVE), this.isSeeking = !0; do this.update(0, u); while (this.totalProgress < l); return this.isSeeking = !1, S && (this.state = s.PAUSED), this }, setCallback: function (l, u, v, p) { return this.callbacks[l] = { func: u, scope: p, params: v }, this }, complete: function (l) { return l === void 0 && (l = 0), l ? (this.state = s.COMPLETE_DELAY, this.countdown = l) : (this.state = s.PENDING_REMOVE, this.dispatchTweenEvent(n.TWEEN_COMPLETE, this.callbacks.onComplete)), this }, remove: function () { return this.parent.remove(this), this }, stop: function (l) { return this.state === s.ACTIVE && l !== void 0 && this.seek(l), this.state !== s.REMOVED && ((this.state === s.PAUSED || this.state === s.PENDING_ADD) && (this.parentIsTimeline ? (this.parent.manager._destroy.push(this), this.parent.manager._toProcess++) : (this.parent._destroy.push(this), this.parent._toProcess++)), this.dispatchTweenEvent(n.TWEEN_STOP, this.callbacks.onStop), this.removeAllListeners(), this.state = s.PENDING_REMOVE), this }, update: function (l, u) { if (this.state === s.PAUSED) return !1; switch (this.useFrames && (u = 1 * this.parent.timeScale), u *= this.timeScale, this.elapsed += u, this.progress = Math.min(this.elapsed / this.duration, 1), this.totalElapsed += u, this.totalProgress = Math.min(this.totalElapsed / this.totalDuration, 1), this.state) { case s.ACTIVE:!this.hasStarted && !this.isSeeking && (this.startDelay -= u, this.startDelay <= 0 && (this.hasStarted = !0, this.dispatchTweenEvent(n.TWEEN_START, this.callbacks.onStart))); for (var v = !1, p = 0; p < this.totalData; p++) { const c = this.data[p]; this.updateTweenData(this, c, u) && (v = !0) }v || this.nextState(); break; case s.LOOP_DELAY:this.countdown -= u, this.countdown <= 0 && (this.state = s.ACTIVE, this.dispatchTweenEvent(n.TWEEN_LOOP, this.callbacks.onLoop)); break; case s.OFFSET_DELAY:this.countdown -= u, this.countdown <= 0 && (this.state = s.ACTIVE); break; case s.COMPLETE_DELAY:this.countdown -= u, this.countdown <= 0 && (this.state = s.PENDING_REMOVE, this.dispatchTweenEvent(n.TWEEN_COMPLETE, this.callbacks.onComplete)); break } return this.state === s.PENDING_REMOVE }, dispatchTweenDataEvent: function (l, u, v) { this.isSeeking || (this.emit(l, this, v.key, v.target, v.current, v.previous), u && (u.params[1] = v.target, u.func.apply(u.scope, u.params))) }, dispatchTweenEvent: function (l, u) { this.isSeeking || (this.emit(l, this, this.targets), u && (u.params[1] = this.targets, u.func.apply(u.scope, u.params))) }, setStateFromEnd: function (l, u, v) { return u.yoyo ? (u.elapsed = v, u.progress = v / u.duration, u.flipX && u.target.toggleFlipX(), u.flipY && u.target.toggleFlipY(), this.dispatchTweenDataEvent(n.TWEEN_YOYO, l.callbacks.onYoyo, u), u.start = u.getStartValue(u.target, u.key, u.start, u.index, l.totalTargets, l), s.PLAYING_BACKWARD) : u.repeatCounter > 0 ? (u.repeatCounter--, u.elapsed = v, u.progress = v / u.duration, u.flipX && u.target.toggleFlipX(), u.flipY && u.target.toggleFlipY(), u.start = u.getStartValue(u.target, u.key, u.start, u.index, l.totalTargets, l), u.end = u.getEndValue(u.target, u.key, u.start, u.index, l.totalTargets, l), u.repeatDelay > 0 ? (u.elapsed = u.repeatDelay - v, u.current = u.start, u.target[u.key] = u.current, s.REPEAT_DELAY) : (this.dispatchTweenDataEvent(n.TWEEN_REPEAT, l.callbacks.onRepeat, u), s.PLAYING_FORWARD)) : s.COMPLETE }, setStateFromStart: function (l, u, v) { return u.repeatCounter > 0 ? (u.repeatCounter--, u.elapsed = v, u.progress = v / u.duration, u.flipX && u.target.toggleFlipX(), u.flipY && u.target.toggleFlipY(), u.end = u.getEndValue(u.target, u.key, u.start, u.index, l.totalTargets, l), u.repeatDelay > 0 ? (u.elapsed = u.repeatDelay - v, u.current = u.start, u.target[u.key] = u.current, s.REPEAT_DELAY) : (this.dispatchTweenDataEvent(n.TWEEN_REPEAT, l.callbacks.onRepeat, u), s.PLAYING_FORWARD)) : s.COMPLETE }, updateTweenData: function (l, u, v) { const p = u.target; switch (u.state) { case s.PLAYING_FORWARD:case s.PLAYING_BACKWARD:if (!p) { u.state = s.COMPLETE; break } var c = u.elapsed; var m = u.duration; var g = 0; c += v, c > m && (g = c - m, c = m); var x = u.state === s.PLAYING_FORWARD; var y = c / m; if (u.elapsed = c, u.progress = y, u.previous = u.current, y === 1)x ? (u.current = u.end, p[u.key] = u.end, u.hold > 0 ? (u.elapsed = u.hold - g, u.state = s.HOLD_DELAY) : u.state = this.setStateFromEnd(l, u, g)) : (u.current = u.start, p[u.key] = u.start, u.state = this.setStateFromStart(l, u, g)); else { const T = x ? u.ease(y) : u.ease(1 - y); u.current = u.start + (u.end - u.start) * T, p[u.key] = u.current } this.dispatchTweenDataEvent(n.TWEEN_UPDATE, l.callbacks.onUpdate, u); break; case s.DELAY:u.elapsed -= v, u.elapsed <= 0 && (u.elapsed = Math.abs(u.elapsed), u.state = s.PENDING_RENDER); break; case s.REPEAT_DELAY:u.elapsed -= v, u.elapsed <= 0 && (u.elapsed = Math.abs(u.elapsed), u.state = s.PLAYING_FORWARD, this.dispatchTweenDataEvent(n.TWEEN_REPEAT, l.callbacks.onRepeat, u)); break; case s.HOLD_DELAY:u.elapsed -= v, u.elapsed <= 0 && (u.state = this.setStateFromEnd(l, u, Math.abs(u.elapsed))); break; case s.PENDING_RENDER:p ? (u.start = u.getStartValue(p, u.key, p[u.key], u.index, l.totalTargets, l), u.end = u.getEndValue(p, u.key, u.start, u.index, l.totalTargets, l), u.current = u.start, p[u.key] = u.start, u.state = s.PLAYING_FORWARD) : u.state = s.COMPLETE; break } return u.state !== s.COMPLETE } }); f.TYPES = ['onActive', 'onComplete', 'onLoop', 'onRepeat', 'onStart', 'onStop', 'onUpdate', 'onYoyo'], r.register('tween', function (l) { return this.scene.sys.tweens.add(l) }), o.register('tween', function (l) { return this.scene.sys.tweens.create(l) }), e.exports = f }, function (e, d, t) { e.exports = { TIMELINE_COMPLETE: t(1466), TIMELINE_LOOP: t(1467), TIMELINE_PAUSE: t(1468), TIMELINE_RESUME: t(1469), TIMELINE_START: t(1470), TIMELINE_UPDATE: t(1471), TWEEN_ACTIVE: t(1472), TWEEN_COMPLETE: t(1473), TWEEN_LOOP: t(1474), TWEEN_REPEAT: t(1475), TWEEN_START: t(1476), TWEEN_STOP: t(1477), TWEEN_UPDATE: t(1478), TWEEN_YOYO: t(1479) } }, function (e, d) { const t = function (i, h, n, o, r, s, a, f, l, u, v, p, c, m, g) { return { target: i, index: h, key: n, getActiveValue: s, getEndValue: o, getStartValue: r, ease: a, duration: 0, totalDuration: 0, delay: 0, yoyo: u, hold: 0, repeat: 0, repeatDelay: 0, flipX: m, flipY: g, progress: 0, elapsed: 0, repeatCounter: 0, start: 0, previous: 0, current: 0, end: 0, t1: 0, t2: 0, gen: { delay: f, duration: l, hold: v, repeat: p, repeatDelay: c }, state: 0 } }; e.exports = t }, function (e, d, t) { const i = t(68); const h = function (n) { return i(n, -Math.PI, Math.PI) }; e.exports = h }, function (e, d, t) { const i = t(68); const h = function (n) { return i(n, -180, 180) }; e.exports = h }, function (e, d, t) { const i = {}; e.exports = i; const h = t(83); const n = t(32); (function () { i.fromVertices = function (o) { for (var r = {}, s = 0; s < o.length; s++) { const a = (s + 1) % o.length; const f = h.normalise({ x: o[a].y - o[s].y, y: o[s].x - o[a].x }); let l = f.y === 0 ? 1 / 0 : f.x / f.y; l = l.toFixed(3).toString(), r[l] = f } return n.values(r) }, i.rotate = function (o, r) { if (r !== 0) for (let s = Math.cos(r), a = Math.sin(r), f = 0; f < o.length; f++) { const l = o[f]; var u; u = l.x * s - l.y * a, l.y = l.x * a + l.y * s, l.x = u } } })() }, function (e, d, t) { e.exports = { AFTER_ADD: t(1504), AFTER_REMOVE: t(1505), AFTER_UPDATE: t(1506), BEFORE_ADD: t(1507), BEFORE_REMOVE: t(1508), BEFORE_UPDATE: t(1509), COLLISION_ACTIVE: t(1510), COLLISION_END: t(1511), COLLISION_START: t(1512), DRAG_END: t(1513), DRAG: t(1514), DRAG_START: t(1515), PAUSE: t(1516), RESUME: t(1517), SLEEP_END: t(1518), SLEEP_START: t(1519) } }, function (e, d, t) { const i = {}; e.exports = i; const h = t(274); const n = t(250); const o = t(84); (function () { i.collisions = function (r, s) { for (var a = [], f = s.pairs.table, l = s.metrics, u = 0; u < r.length; u++) { const v = r[u][0]; const p = r[u][1]; if (!((v.isStatic || v.isSleeping) && (p.isStatic || p.isSleeping)) && !!i.canCollide(v.collisionFilter, p.collisionFilter) && (l.midphaseTests += 1, o.overlaps(v.bounds, p.bounds))) for (let c = v.parts.length > 1 ? 1 : 0; c < v.parts.length; c++) for (let m = v.parts[c], g = p.parts.length > 1 ? 1 : 0; g < p.parts.length; g++) { const x = p.parts[g]; if (m === v && x === p || o.overlaps(m.bounds, x.bounds)) { const y = n.id(m, x); const T = f[y]; var S; T && T.isActive ? S = T.collision : S = null; const E = h.collides(m, x, S); l.narrowphaseTests += 1, E.reused && (l.narrowReuseCount += 1), E.collided && (a.push(E), l.narrowDetections += 1) } } } return a }, i.canCollide = function (r, s) { return r.group === s.group && r.group !== 0 ? r.group > 0 : (r.mask & s.category) != 0 && (s.mask & r.category) != 0 } })() }, function (e, d, t) { const i = {}; e.exports = i; const h = t(64); const n = t(83); (function () { i.collides = function (o, r, s) { let a; let f; let l; let u; let v = !1; if (s) { const p = o.parent; const c = r.parent; const m = p.speed * p.speed + p.angularSpeed * p.angularSpeed + c.speed * c.speed + c.angularSpeed * c.angularSpeed; v = s && s.collided && m < 0.2, u = s } else u = { collided: !1, bodyA: o, bodyB: r }; if (s && v) { const g = u.axisBody; const x = g === o ? r : o; const y = [g.axes[s.axisNumber]]; if (l = i._overlapAxes(g.vertices, x.vertices, y), u.reused = !0, l.overlap <= 0) return u.collided = !1, u } else { if (a = i._overlapAxes(o.vertices, r.vertices, o.axes), a.overlap <= 0 || (f = i._overlapAxes(r.vertices, o.vertices, r.axes), f.overlap <= 0)) return u.collided = !1, u; a.overlap < f.overlap ? (l = a, u.axisBody = o) : (l = f, u.axisBody = r), u.axisNumber = l.axisNumber }u.bodyA = o.id < r.id ? o : r, u.bodyB = o.id < r.id ? r : o, u.collided = !0, u.depth = l.overlap, u.parentA = u.bodyA.parent, u.parentB = u.bodyB.parent, o = u.bodyA, r = u.bodyB, n.dot(l.axis, n.sub(r.position, o.position)) < 0 ? u.normal = { x: l.axis.x, y: l.axis.y } : u.normal = { x: -l.axis.x, y: -l.axis.y }, u.tangent = n.perp(u.normal), u.penetration = u.penetration || {}, u.penetration.x = u.normal.x * u.depth, u.penetration.y = u.normal.y * u.depth; const T = i._findSupports(o, r, u.normal); let S = []; if (h.contains(o.vertices, T[0]) && S.push(T[0]), h.contains(o.vertices, T[1]) && S.push(T[1]), S.length < 2) { const E = i._findSupports(r, o, n.neg(u.normal)); h.contains(r.vertices, E[0]) && S.push(E[0]), S.length < 2 && h.contains(r.vertices, E[1]) && S.push(E[1]) } return S.length < 1 && (S = [T[0]]), u.supports = S, u }, i._overlapAxes = function (o, r, s) { for (var a = n._temp[0], f = n._temp[1], l = { overlap: Number.MAX_VALUE }, u, v, p = 0; p < s.length; p++) { if (v = s[p], i._projectToAxis(a, o, v), i._projectToAxis(f, r, v), u = Math.min(a.max - f.min, f.max - a.min), u <= 0) return l.overlap = u, l; u < l.overlap && (l.overlap = u, l.axis = v, l.axisNumber = p) } return l }, i._projectToAxis = function (o, r, s) { for (var a = n.dot(r[0], s), f = a, l = 1; l < r.length; l += 1) { const u = n.dot(r[l], s); u > f ? f = u : u < a && (a = u) }o.min = a, o.max = f }, i._findSupports = function (o, r, s) { for (var a = Number.MAX_VALUE, f = n._temp[0], l = r.vertices, u = o.position, v, p, c, m, g = 0; g < l.length; g++)p = l[g], f.x = p.x - u.x, f.y = p.y - u.y, v = -n.dot(s, f), v < a && (a = v, c = p); const x = c.index - 1 >= 0 ? c.index - 1 : l.length - 1; p = l[x], f.x = p.x - u.x, f.y = p.y - u.y, a = -n.dot(s, f), m = p; const y = (c.index + 1) % l.length; return p = l[y], f.x = p.x - u.x, f.y = p.y - u.y, v = -n.dot(s, f), v < a && (m = p), [c, m] } })() }, function (e, d, t) { e.exports = { AlignTo: t(601), Angle: t(602), Call: t(603), GetFirst: t(604), GetLast: t(605), GridAlign: t(606), IncAlpha: t(678), IncX: t(679), IncXY: t(680), IncY: t(681), PlaceOnCircle: t(682), PlaceOnEllipse: t(683), PlaceOnLine: t(684), PlaceOnRectangle: t(685), PlaceOnTriangle: t(686), PlayAnimation: t(687), PropertyValueInc: t(46), PropertyValueSet: t(27), RandomCircle: t(688), RandomEllipse: t(689), RandomLine: t(690), RandomRectangle: t(691), RandomTriangle: t(692), Rotate: t(693), RotateAround: t(694), RotateAroundDistance: t(695), ScaleX: t(696), ScaleXY: t(697), ScaleY: t(698), SetAlpha: t(699), SetBlendMode: t(700), SetDepth: t(701), SetHitArea: t(702), SetOrigin: t(703), SetRotation: t(704), SetScale: t(705), SetScaleX: t(706), SetScaleY: t(707), SetScrollFactor: t(708), SetScrollFactorX: t(709), SetScrollFactorY: t(710), SetTint: t(711), SetVisible: t(712), SetX: t(713), SetXY: t(714), SetY: t(715), ShiftPosition: t(716), Shuffle: t(717), SmootherStep: t(718), SmoothStep: t(719), Spread: t(720), ToggleVisible: t(721), WrapInRectangle: t(722) } }, function (e, d, t) { const i = t(123); const h = []; h[i.BOTTOM_CENTER] = t(277), h[i.BOTTOM_LEFT] = t(278), h[i.BOTTOM_RIGHT] = t(279), h[i.LEFT_BOTTOM] = t(280), h[i.LEFT_CENTER] = t(281), h[i.LEFT_TOP] = t(282), h[i.RIGHT_BOTTOM] = t(283), h[i.RIGHT_CENTER] = t(284), h[i.RIGHT_TOP] = t(285), h[i.TOP_CENTER] = t(286), h[i.TOP_LEFT] = t(287), h[i.TOP_RIGHT] = t(288); const n = function (o, r, s, a, f) { return h[s](o, r, a, f) }; e.exports = n }, function (e, d, t) { const i = t(42); const h = t(87); const n = t(88); const o = t(52); const r = function (s, a, f, l) { return f === void 0 && (f = 0), l === void 0 && (l = 0), n(s, h(a) + f), o(s, i(a) + l), s }; e.exports = r }, function (e, d, t) { const i = t(42); const h = t(43); const n = t(53); const o = t(52); const r = function (s, a, f, l) { return f === void 0 && (f = 0), l === void 0 && (l = 0), n(s, h(a) - f), o(s, i(a) + l), s }; e.exports = r }, function (e, d, t) { const i = t(42); const h = t(44); const n = t(54); const o = t(52); const r = function (s, a, f, l) { return f === void 0 && (f = 0), l === void 0 && (l = 0), n(s, h(a) + f), o(s, i(a) + l), s }; e.exports = r }, function (e, d, t) { const i = t(42); const h = t(43); const n = t(55); const o = t(54); const r = function (s, a, f, l) { return f === void 0 && (f = 0), l === void 0 && (l = 0), o(s, h(a) - f), n(s, i(a) + l), s }; e.exports = r }, function (e, d, t) { const i = t(89); const h = t(43); const n = t(90); const o = t(54); const r = function (s, a, f, l) { return f === void 0 && (f = 0), l === void 0 && (l = 0), o(s, h(a) - f), n(s, i(a) + l), s }; e.exports = r }, function (e, d, t) { const i = t(43); const h = t(45); const n = t(54); const o = t(52); const r = function (s, a, f, l) { return f === void 0 && (f = 0), l === void 0 && (l = 0), n(s, i(a) - f), o(s, h(a) - l), s }; e.exports = r }, function (e, d, t) { const i = t(42); const h = t(44); const n = t(55); const o = t(53); const r = function (s, a, f, l) { return f === void 0 && (f = 0), l === void 0 && (l = 0), o(s, h(a) + f), n(s, i(a) + l), s }; e.exports = r }, function (e, d, t) { const i = t(89); const h = t(44); const n = t(90); const o = t(53); const r = function (s, a, f, l) { return f === void 0 && (f = 0), l === void 0 && (l = 0), o(s, h(a) + f), n(s, i(a) + l), s }; e.exports = r }, function (e, d, t) { const i = t(44); const h = t(45); const n = t(53); const o = t(52); const r = function (s, a, f, l) { return f === void 0 && (f = 0), l === void 0 && (l = 0), n(s, i(a) + f), o(s, h(a) - l), s }; e.exports = r }, function (e, d, t) { const i = t(87); const h = t(45); const n = t(55); const o = t(88); const r = function (s, a, f, l) { return f === void 0 && (f = 0), l === void 0 && (l = 0), o(s, i(a) + f), n(s, h(a) - l), s }; e.exports = r }, function (e, d, t) { const i = t(43); const h = t(45); const n = t(55); const o = t(53); const r = function (s, a, f, l) { return f === void 0 && (f = 0), l === void 0 && (l = 0), o(s, i(a) - f), n(s, h(a) - l), s }; e.exports = r }, function (e, d, t) { const i = t(44); const h = t(45); const n = t(55); const o = t(54); const r = function (s, a, f, l) { return f === void 0 && (f = 0), l === void 0 && (l = 0), o(s, i(a) + f), n(s, h(a) - l), s }; e.exports = r }, function (e, d, t) { const i = t(123); const h = []; h[i.BOTTOM_CENTER] = t(290), h[i.BOTTOM_LEFT] = t(291), h[i.BOTTOM_RIGHT] = t(292), h[i.CENTER] = t(293), h[i.LEFT_CENTER] = t(295), h[i.RIGHT_CENTER] = t(296), h[i.TOP_CENTER] = t(297), h[i.TOP_LEFT] = t(298), h[i.TOP_RIGHT] = t(299), h[i.LEFT_BOTTOM] = h[i.BOTTOM_LEFT], h[i.LEFT_TOP] = h[i.TOP_LEFT], h[i.RIGHT_BOTTOM] = h[i.BOTTOM_RIGHT], h[i.RIGHT_TOP] = h[i.TOP_RIGHT]; const n = function (o, r, s, a, f) { return h[s](o, r, a, f) }; e.exports = n }, function (e, d, t) { const i = t(42); const h = t(87); const n = t(55); const o = t(88); const r = function (s, a, f, l) { return f === void 0 && (f = 0), l === void 0 && (l = 0), o(s, h(a) + f), n(s, i(a) + l), s }; e.exports = r }, function (e, d, t) { const i = t(42); const h = t(43); const n = t(55); const o = t(53); const r = function (s, a, f, l) { return f === void 0 && (f = 0), l === void 0 && (l = 0), o(s, h(a) - f), n(s, i(a) + l), s }; e.exports = r }, function (e, d, t) { const i = t(42); const h = t(44); const n = t(55); const o = t(54); const r = function (s, a, f, l) { return f === void 0 && (f = 0), l === void 0 && (l = 0), o(s, h(a) + f), n(s, i(a) + l), s }; e.exports = r }, function (e, d, t) { const i = t(294); const h = t(87); const n = t(89); const o = function (r, s, a, f) { return a === void 0 && (a = 0), f === void 0 && (f = 0), i(r, h(s) + a, n(s) + f), r }; e.exports = o }, function (e, d, t) { const i = t(88); const h = t(90); const n = function (o, r, s) { return i(o, r), h(o, s) }; e.exports = n }, function (e, d, t) { const i = t(89); const h = t(43); const n = t(90); const o = t(53); const r = function (s, a, f, l) { return f === void 0 && (f = 0), l === void 0 && (l = 0), o(s, h(a) - f), n(s, i(a) + l), s }; e.exports = r }, function (e, d, t) { const i = t(89); const h = t(44); const n = t(90); const o = t(54); const r = function (s, a, f, l) { return f === void 0 && (f = 0), l === void 0 && (l = 0), o(s, h(a) + f), n(s, i(a) + l), s }; e.exports = r }, function (e, d, t) { const i = t(87); const h = t(45); const n = t(88); const o = t(52); const r = function (s, a, f, l) { return f === void 0 && (f = 0), l === void 0 && (l = 0), n(s, i(a) + f), o(s, h(a) - l), s }; e.exports = r }, function (e, d, t) { const i = t(43); const h = t(45); const n = t(53); const o = t(52); const r = function (s, a, f, l) { return f === void 0 && (f = 0), l === void 0 && (l = 0), n(s, i(a) - f), o(s, h(a) - l), s }; e.exports = r }, function (e, d, t) { const i = t(44); const h = t(45); const n = t(54); const o = t(52); const r = function (s, a, f, l) { return f === void 0 && (f = 0), l === void 0 && (l = 0), n(s, i(a) + f), o(s, h(a) - l), s }; e.exports = r }, function (e, d, t) { const i = t(169); const h = t(98); const n = t(14); const o = t(4); const r = function (s, a, f) { f === void 0 && (f = new o()); const l = h(a, 0, n.PI2); return i(s, l, f) }; e.exports = r }, function (e, d, t) { const i = t(302); const h = t(169); const n = t(98); const o = t(14); const r = function (s, a, f, l) { l === void 0 && (l = []), !a && f > 0 && (a = i(s) / f); for (let u = 0; u < a; u++) { const v = n(u / a, 0, o.PI2); l.push(h(s, v)) } return l }; e.exports = r }, function (e, d) { const t = function (i) { return 2 * (Math.PI * i.radius) }; e.exports = t }, function (e, d, t) { const i = t(18); const h = 2; const n = { _alpha: 1, clearAlpha: function () { return this.setAlpha(1) }, setAlpha: function (o) { return o === void 0 && (o = 1), this.alpha = o, this }, alpha: { get: function () { return this._alpha }, set: function (o) { const r = i(o, 0, 1); this._alpha = r, r === 0 ? this.renderFlags &= ~h : this.renderFlags |= h } } }; e.exports = n }, function (e, d, t) { const i = t(35); const h = { _blendMode: i.NORMAL, blendMode: { get: function () { return this._blendMode }, set: function (n) { typeof n === 'string' && (n = i[n]), n |= 0, n >= -1 && (this._blendMode = n) } }, setBlendMode: function (n) { return this.blendMode = n, this } }; e.exports = h }, function (e, d) { const t = { _depth: 0, depth: { get: function () { return this._depth }, set: function (i) { this.displayList && this.displayList.queueDepthSort(), this._depth = i } }, setDepth: function (i) { return i === void 0 && (i = 0), this.depth = i, this } }; e.exports = t }, function (e, d, t) { const i = t(171); const h = t(130); const n = function (o, r, s, a) { a === void 0 && (a = []), !r && s > 0 && (r = h(o) / s); for (let f = 0; f < r; f++) { const l = f / r; a.push(i(o, l)) } return a }; e.exports = n }, function (e, d, t) { const i = t(4); const h = function (n, o, r) { return r === void 0 && (r = new i()), r.x = n.x1 + (n.x2 - n.x1) * o, r.y = n.y1 + (n.y2 - n.y1) * o, r }; e.exports = h }, function (e, d) { const t = function (i, h, n, o) { const r = Math.cos(o); const s = Math.sin(o); const a = i.x - h; const f = i.y - n; return i.x = a * r - f * s + h, i.y = a * s + f * r + n, i }; e.exports = t }, function (e, d, t) { const i = t(310); const h = t(311); const n = { mask: null, setMask: function (o) { return this.mask = o, this }, clearMask: function (o) { return o === void 0 && (o = !1), o && this.mask && this.mask.destroy(), this.mask = null, this }, createBitmapMask: function (o) { return o === void 0 && (this.texture || this.shader) && (o = this), new i(this.scene, o) }, createGeometryMask: function (o) { return o === void 0 && this.type === 'Graphics' && (o = this), new h(this.scene, o) } }; e.exports = n }, function (e, d, t) { const i = t(0); const h = t(22); const n = t(91); const o = new i({ initialize: function (s, a) { const f = s.sys.renderer; this.renderer = f, this.bitmapMask = a, this.maskTexture = null, this.mainTexture = null, this.dirty = !0, this.mainFramebuffer = null, this.maskFramebuffer = null, this.invertAlpha = !1, this.isStencil = !1, this.createMask(), s.sys.game.events.on(h.CONTEXT_RESTORED, this.createMask, this), f && f.on(n.RESIZE, this.createMask, this) }, createMask: function () { const r = this.renderer; if (!(!r || !r.gl)) { this.mainTexture && this.clearMask(); const s = r.width; const a = r.height; const f = (s & s - 1) == 0 && (a & a - 1) == 0; const l = r.gl; const u = f ? l.REPEAT : l.CLAMP_TO_EDGE; const v = l.LINEAR; this.mainTexture = r.createTexture2D(0, v, v, u, u, l.RGBA, null, s, a), this.maskTexture = r.createTexture2D(0, v, v, u, u, l.RGBA, null, s, a), this.mainFramebuffer = r.createFramebuffer(s, a, this.mainTexture, !0), this.maskFramebuffer = r.createFramebuffer(s, a, this.maskTexture, !0) } }, clearMask: function () { const r = this.renderer; !r || !r.gl || !this.mainTexture || (r.deleteTexture(this.mainTexture), r.deleteTexture(this.maskTexture), r.deleteFramebuffer(this.mainFramebuffer), r.deleteFramebuffer(this.maskFramebuffer), this.mainTexture = null, this.maskTexture = null, this.mainFramebuffer = null, this.maskFramebuffer = null) }, setBitmap: function (r) { this.bitmapMask = r }, preRenderWebGL: function (r, s, a) { r.pipelines.BITMAPMASK_PIPELINE.beginMask(this, s, a) }, postRenderWebGL: function (r, s) { r.pipelines.BITMAPMASK_PIPELINE.endMask(this, s) }, preRenderCanvas: function () {}, postRenderCanvas: function () {}, destroy: function () { this.clearMask(), this.renderer && this.renderer.off(n.RESIZE, this.createMask, this), this.bitmapMask = null, this.prevFramebuffer = null, this.renderer = null } }); e.exports = o }, function (e, d, t) { const i = t(0); const h = new i({ initialize: function (o, r) { this.geometryMask = r, this.invertAlpha = !1, this.isStencil = !0, this.level = 0 }, setShape: function (n) { return this.geometryMask = n, this }, setInvertAlpha: function (n) { return n === void 0 && (n = !0), this.invertAlpha = n, this }, preRenderWebGL: function (n, o, r) { const s = n.gl; n.flush(), n.maskStack.length === 0 && (s.enable(s.STENCIL_TEST), s.clear(s.STENCIL_BUFFER_BIT), n.maskCount = 0), n.currentCameraMask.mask !== this && (n.currentMask.mask = this), n.maskStack.push({ mask: this, camera: r }), this.applyStencil(n, r, !0), n.maskCount++ }, applyStencil: function (n, o, r) { const s = n.gl; const a = this.geometryMask; const f = n.maskCount; s.colorMask(!1, !1, !1, !1), r ? (s.stencilFunc(s.EQUAL, f, 255), s.stencilOp(s.KEEP, s.KEEP, s.INCR)) : (s.stencilFunc(s.EQUAL, f + 1, 255), s.stencilOp(s.KEEP, s.KEEP, s.DECR)), a.renderWebGL(n, a, o), n.flush(), s.colorMask(!0, !0, !0, !0), s.stencilOp(s.KEEP, s.KEEP, s.KEEP), r ? this.invertAlpha ? s.stencilFunc(s.NOTEQUAL, f + 1, 255) : s.stencilFunc(s.EQUAL, f + 1, 255) : this.invertAlpha ? s.stencilFunc(s.NOTEQUAL, f, 255) : s.stencilFunc(s.EQUAL, f, 255) }, postRenderWebGL: function (n) { const o = n.gl; n.maskStack.pop(), n.maskCount--, n.flush(); const r = n.currentMask; if (n.maskStack.length === 0)r.mask = null, o.disable(o.STENCIL_TEST); else { const s = n.maskStack[n.maskStack.length - 1]; s.mask.applyStencil(n, s.camera, !1), n.currentCameraMask.mask !== s.mask ? (r.mask = s.mask, r.camera = s.camera) : r.mask = null } }, preRenderCanvas: function (n, o, r) { const s = this.geometryMask; n.currentContext.save(), s.renderCanvas(n, s, r, null, null, !0), n.currentContext.clip() }, postRenderCanvas: function (n) { n.currentContext.restore() }, destroy: function () { this.geometryMask = null } }); e.exports = h }, function (e, d) { const t = { scrollFactorX: 1, scrollFactorY: 1, setScrollFactor: function (i, h) { return h === void 0 && (h = i), this.scrollFactorX = i, this.scrollFactorY = h, this } }; e.exports = t }, function (e, d, t) { const i = t(14); const h = t(25); const n = t(177); const o = t(269); const r = t(270); const s = t(3); const a = 4; const f = { _scaleX: 1, _scaleY: 1, _rotation: 0, x: 0, y: 0, z: 0, w: 0, scale: { get: function () { return (this._scaleX + this._scaleY) / 2 }, set: function (l) { this._scaleX = l, this._scaleY = l, l === 0 ? this.renderFlags &= ~a : this.renderFlags |= a } }, scaleX: { get: function () { return this._scaleX }, set: function (l) { this._scaleX = l, l === 0 ? this.renderFlags &= ~a : this.renderFlags |= a } }, scaleY: { get: function () { return this._scaleY }, set: function (l) { this._scaleY = l, l === 0 ? this.renderFlags &= ~a : this.renderFlags |= a } }, angle: { get: function () { return r(this._rotation * i.RAD_TO_DEG) }, set: function (l) { this.rotation = r(l) * i.DEG_TO_RAD } }, rotation: { get: function () { return this._rotation }, set: function (l) { this._rotation = o(l) } }, setPosition: function (l, u, v, p) { return l === void 0 && (l = 0), u === void 0 && (u = l), v === void 0 && (v = 0), p === void 0 && (p = 0), this.x = l, this.y = u, this.z = v, this.w = p, this }, copyPosition: function (l) { return l.x !== void 0 && (this.x = l.x), l.y !== void 0 && (this.y = l.y), l.z !== void 0 && (this.z = l.z), l.w !== void 0 && (this.w = l.w), this }, setRandomPosition: function (l, u, v, p) { return l === void 0 && (l = 0), u === void 0 && (u = 0), v === void 0 && (v = this.scene.sys.scale.width), p === void 0 && (p = this.scene.sys.scale.height), this.x = l + Math.random() * v, this.y = u + Math.random() * p, this }, setRotation: function (l) { return l === void 0 && (l = 0), this.rotation = l, this }, setAngle: function (l) { return l === void 0 && (l = 0), this.angle = l, this }, setScale: function (l, u) { return l === void 0 && (l = 1), u === void 0 && (u = l), this.scaleX = l, this.scaleY = u, this }, setX: function (l) { return l === void 0 && (l = 0), this.x = l, this }, setY: function (l) { return l === void 0 && (l = 0), this.y = l, this }, setZ: function (l) { return l === void 0 && (l = 0), this.z = l, this }, setW: function (l) { return l === void 0 && (l = 0), this.w = l, this }, getLocalTransformMatrix: function (l) { return l === void 0 && (l = new h()), l.applyITRS(this.x, this.y, this._rotation, this._scaleX, this._scaleY) }, getWorldTransformMatrix: function (l, u) { l === void 0 && (l = new h()), u === void 0 && (u = new h()); let v = this.parentContainer; if (!v) return this.getLocalTransformMatrix(l); for (l.applyITRS(this.x, this.y, this._rotation, this._scaleX, this._scaleY); v;)u.applyITRS(v.x, v.y, v._rotation, v._scaleX, v._scaleY), u.multiply(l, l), v = v.parentContainer; return l }, getLocalPoint: function (l, u, v, p) { v || (v = new s()), p || (p = this.scene.sys.cameras.main); const c = p.scrollX; const m = p.scrollY; const g = l + c * this.scrollFactorX - c; const x = u + m * this.scrollFactorY - m; return this.parentContainer ? this.getWorldTransformMatrix().applyInverse(g, x, v) : n(g, x, this.x, this.y, this.rotation, this.scaleX, this.scaleY, v), this._originComponent && (v.x += this._displayOriginX, v.y += this._displayOriginY), v }, getParentRotation: function () { for (var l = 0, u = this.parentContainer; u;)l += u.rotation, u = u.parentContainer; return l } }; e.exports = f }, function (e, d) { const t = 1; const i = { _visible: !0, visible: { get: function () { return this._visible }, set: function (h) { h ? (this._visible = !0, this.renderFlags |= t) : (this._visible = !1, this.renderFlags &= ~t) } }, setVisible: function (h) { return this.visible = h, this } }; e.exports = i }, function (e, d, t) { e.exports = { CHANGE_DATA: t(638), CHANGE_DATA_KEY: t(639), DESTROY: t(640), REMOVE_DATA: t(641), SET_DATA: t(642) } }, function (e, d, t) { const i = t(130); const h = t(4); const n = function (o, r, s, a) { if (a === void 0 && (a = []), !r && !s) return a; r ? s = Math.round(i(o) / r) : r = i(o) / s; for (let f = o.x, l = o.y, u = 0, v = 0; v < s; v++) switch (a.push(new h(f, l)), u) { case 0:f += r, f >= o.right && (u = 1, l += f - o.right, f = o.right); break; case 1:l += r, l >= o.bottom && (u = 2, f -= l - o.bottom, l = o.bottom); break; case 2:f -= r, f <= o.left && (u = 3, l -= o.left - f, f = o.left); break; case 3:l -= r, l <= o.top && (u = 0, l = o.top); break } return a }; e.exports = n }, function (e, d) { const t = function (i, h, n) { h === void 0 && (h = 1), n === void 0 && (n = []); let o = Math.round(i.x1); let r = Math.round(i.y1); const s = Math.round(i.x2); const a = Math.round(i.y2); const f = Math.abs(s - o); const l = Math.abs(a - r); const u = o < s ? 1 : -1; const v = r < a ? 1 : -1; let p = f - l; n.push({ x: o, y: r }); for (let c = 1; !(o === s && r === a);) { const m = p << 1; m > -l && (p -= l, o += u), m < f && (p += f, r += v), c % h == 0 && n.push({ x: o, y: r }), c++ } return n }; e.exports = t }, function (e, d) { const t = function (i, h, n) { if (h.length) { if (h.length === 1) return h[0] } else return NaN; let o = 1; let r; let s; if (n) { if (i < h[0][n]) return h[0]; for (;h[o][n] < i;)o++ } else for (;h[o] < i;)o++; return o > h.length && (o = h.length), n ? (r = h[o - 1][n], s = h[o][n], s - i <= i - r ? h[o] : h[o - 1]) : (r = h[o - 1], s = h[o], s - i <= i - r ? s : r) }; e.exports = t }, function (e, d, t) { const i = t(0); const h = new i({ initialize: function (o, r, s, a, f) { f === void 0 && (f = !1), this.textureKey = o, this.textureFrame = r, this.index = s, this.frame = a, this.isFirst = !1, this.isLast = !1, this.prevFrame = null, this.nextFrame = null, this.duration = 0, this.progress = 0, this.isKeyFrame = f }, toJSON: function () { return { key: this.textureKey, frame: this.textureFrame, duration: this.duration, keyframe: this.isKeyFrame } }, destroy: function () { this.frame = void 0 } }); e.exports = h }, function (e, d) { const t = function (i) { const h = /\D/g; return i.sort(function (n, o) { return parseInt(n.replace(h, ''), 10) - parseInt(o.replace(h, ''), 10) }), i }; e.exports = t }, function (e, d, t) { const i = t(185); const h = t(0); const n = t(102); const o = t(9); const r = t(132); const s = t(22); const a = t(2); const f = t(6); const l = t(186); const u = t(322); const v = new h({ Extends: o, initialize: function (c) { o.call(this), this.game = c, this.textureManager = null, this.globalTimeScale = 1, this.anims = new n(), this.mixes = new n(), this.paused = !1, this.name = 'AnimationManager', c.events.once(s.BOOT, this.boot, this) }, boot: function () { this.textureManager = this.game.textures, this.game.events.once(s.DESTROY, this.destroy, this) }, addMix: function (p, c, m) { const g = this.anims; const x = this.mixes; const y = typeof p === 'string' ? p : p.key; const T = typeof c === 'string' ? c : c.key; if (g.has(y) && g.has(T)) { let S = x.get(y); S || (S = {}), S[T] = m, x.set(y, S) } return this }, removeMix: function (p, c) { const m = this.mixes; const g = typeof p === 'string' ? p : p.key; const x = m.get(g); if (x) if (c) { const y = typeof c === 'string' ? c : c.key; x.hasOwnProperty(y) && delete x[y] } else c || m.delete(g); return this }, getMix: function (p, c) { const m = this.mixes; const g = typeof p === 'string' ? p : p.key; const x = typeof c === 'string' ? c : c.key; const y = m.get(g); return y && y.hasOwnProperty(x) ? y[x] : 0 }, add: function (p, c) { return this.anims.has(p) ? (console.warn('Animation key exists: ' + p), this) : (c.key = p, this.anims.set(p, c), this.emit(r.ADD_ANIMATION, p, c), this) }, exists: function (p) { return this.anims.has(p) }, createFromAseprite: function (p, c) { const m = []; const g = this.game.cache.json.get(p); if (!g) return m; const x = this; const y = f(g, 'meta', null); const T = f(g, 'frames', null); if (y && T) { const S = f(y, 'frameTags', []); S.forEach(function (E) { let C = []; const P = a(E, 'name', null); const A = a(E, 'from', 0); const M = a(E, 'to', 0); const L = a(E, 'direction', 'forward'); if (!!P && (!c || c && c.indexOf(P) > -1)) { for (var F = [], I = Number.MAX_SAFE_INTEGER, G = A; G <= M; G++) { const U = G.toString(); const Y = T[U]; if (Y) { const X = a(Y, 'duration', Number.MAX_SAFE_INTEGER); X < I && (I = X), F.push({ frame: U, duration: X }) } }F.forEach(function (B) { C.push({ key: p, frame: B.frame, duration: I - B.duration }) }); const O = I * C.length; L === 'reverse' && (C = C.reverse()); const R = { key: P, frames: C, duration: O, yoyo: L === 'pingpong' }; const D = x.create(R); D && m.push(D) } }) } return m }, create: function (p) { const c = p.key; let m = !1; return c && (m = this.get(c), m || (m = new i(this, c, p), this.anims.set(c, m), this.emit(r.ADD_ANIMATION, c, m))), m }, fromJSON: function (p, c) { c === void 0 && (c = !1), c && this.anims.clear(), typeof p === 'string' && (p = JSON.parse(p)); const m = []; if (p.hasOwnProperty('anims') && Array.isArray(p.anims)) { for (let g = 0; g < p.anims.length; g++)m.push(this.create(p.anims[g])); p.hasOwnProperty('globalTimeScale') && (this.globalTimeScale = p.globalTimeScale) } else p.hasOwnProperty('key') && p.type === 'frame' && m.push(this.create(p)); return m }, generateFrameNames: function (p, c) { const m = f(c, 'prefix', ''); const g = f(c, 'start', 0); const x = f(c, 'end', 0); const y = f(c, 'suffix', ''); const T = f(c, 'zeroPad', 0); const S = f(c, 'outputArray', []); let E = f(c, 'frames', !1); const C = this.textureManager.get(p); if (!C) return S; let P; if (c) for (E || (E = u(g, x)), P = 0; P < E.length; P++) { const A = m + l(E[P], T, '0', 1) + y; C.has(A) ? S.push({ key: p, frame: A }) : console.warn('generateFrameNames: Frame missing: ' + A + ' from texture: ' + p) } else for (E = C.getFrameNames(), P = 0; P < E.length; P++)S.push({ key: p, frame: E[P] }); return S }, generateFrameNumbers: function (p, c) { const m = f(c, 'start', 0); let g = f(c, 'end', -1); const x = f(c, 'first', !1); const y = f(c, 'outputArray', []); let T = f(c, 'frames', !1); const S = this.textureManager.get(p); if (!S) return y; x && S.has(x) && y.push({ key: p, frame: x }), T || (g === -1 && (g = S.frameTotal - 2), T = u(m, g)); for (let E = 0; E < T.length; E++)S.has(T[E]) ? y.push({ key: p, frame: T[E] }) : console.warn('generateFrameNumbers: Frame ' + E + ' missing from texture: ' + p); return y }, get: function (p) { return this.anims.get(p) }, pauseAll: function () { return this.paused || (this.paused = !0, this.emit(r.PAUSE_ALL)), this }, play: function (p, c) { Array.isArray(c) || (c = [c]); for (let m = 0; m < c.length; m++)c[m].anims.play(p); return this }, staggerPlay: function (p, c, m, g) { m === void 0 && (m = 0), g === void 0 && (g = !0), Array.isArray(c) || (c = [c]); let x = c.length; g || x--; for (let y = 0; y < c.length; y++) { const T = m < 0 ? Math.abs(m) * (x - y) : m * y; c[y].anims.playAfterDelay(p, T) } return this }, remove: function (p) { const c = this.get(p); return c && (this.emit(r.REMOVE_ANIMATION, p, c), this.anims.delete(p), this.removeMix(p)), c }, resumeAll: function () { return this.paused && (this.paused = !1, this.emit(r.RESUME_ALL)), this }, toJSON: function (p) { const c = { anims: [], globalTimeScale: this.globalTimeScale }; return p !== void 0 && p !== '' ? c.anims.push(this.anims.get(p).toJSON()) : this.anims.each(function (m, g) { c.anims.push(g.toJSON()) }), c }, destroy: function () { this.anims.clear(), this.mixes.clear(), this.textureManager = null, this.game = null } }); e.exports = v }, function (e, d) { const t = function (i, h, n, o) { const r = []; let s; let a = !1; if ((n || o) && (a = !0, n || (n = ''), o || (o = '')), h < i) for (s = i; s >= h; s--)a ? r.push(n + s.toString() + o) : r.push(s); else for (s = i; s <= h; s++)a ? r.push(n + s.toString() + o) : r.push(s); return r }; e.exports = t }, function (e, d, t) { const i = t(0); const h = t(102); const n = t(9); const o = t(324); const r = new i({ initialize: function () { this.entries = new h(), this.events = new n() }, add: function (s, a) { return this.entries.set(s, a), this.events.emit(o.ADD, this, s, a), this }, has: function (s) { return this.entries.has(s) }, exists: function (s) { return this.entries.has(s) }, get: function (s) { return this.entries.get(s) }, remove: function (s) { const a = this.get(s); return a && (this.entries.delete(s), this.events.emit(o.REMOVE, this, s, a.data)), this }, getKeys: function () { return this.entries.keys() }, destroy: function () { this.entries.clear(), this.events.removeAllListeners(), this.entries = null, this.events = null } }); e.exports = r }, function (e, d, t) { e.exports = { ADD: t(736), REMOVE: t(737) } }, function (e, d, t) { const i = t(323); const h = t(0); const n = t(22); const o = new h({ initialize: function (s) { this.game = s, this.binary = new i(), this.bitmapFont = new i(), this.json = new i(), this.physics = new i(), this.shader = new i(), this.audio = new i(), this.video = new i(), this.text = new i(), this.html = new i(), this.obj = new i(), this.tilemap = new i(), this.xml = new i(), this.custom = {}, this.game.events.once(n.DESTROY, this.destroy, this) }, addCustom: function (r) { return this.custom.hasOwnProperty(r) || (this.custom[r] = new i()), this.custom[r] }, destroy: function () { for (let r = ['binary', 'bitmapFont', 'json', 'physics', 'shader', 'audio', 'video', 'text', 'html', 'obj', 'tilemap', 'xml'], s = 0; s < r.length; s++) this[r[s]].destroy(), this[r[s]] = null; for (const a in this.custom) this.custom[a].destroy(); this.custom = null, this.game = null } }); e.exports = o }, function (e, d, t) { const i = t(133); const h = t(190); const n = t(18); const o = t(0); const r = t(11); const s = t(333); const a = t(37); const f = t(135); const l = t(10); const u = t(3); const v = new o({ Extends: i, Mixins: [r.Flip, r.Tint, r.Pipeline], initialize: function (c, m, g, x) { i.call(this, c, m, g, x), this.postPipelines = [], this.pipelineData = {}, this.inputEnabled = !0, this.fadeEffect = new s.Fade(this), this.flashEffect = new s.Flash(this), this.shakeEffect = new s.Shake(this), this.panEffect = new s.Pan(this), this.rotateToEffect = new s.RotateTo(this), this.zoomEffect = new s.Zoom(this), this.lerp = new u(1, 1), this.followOffset = new u(), this.deadzone = null, this._follow = null }, setDeadzone: function (p, c) { if (p === void 0) this.deadzone = null; else { if (this.deadzone ? (this.deadzone.width = p, this.deadzone.height = c) : this.deadzone = new l(0, 0, p, c), this._follow) { const m = this.width / 2; const g = this.height / 2; const x = this._follow.x - this.followOffset.x; const y = this._follow.y - this.followOffset.y; this.midPoint.set(x, y), this.scrollX = x - m, this.scrollY = y - g }h(this.deadzone, this.midPoint.x, this.midPoint.y) } return this }, fadeIn: function (p, c, m, g, x, y) { return this.fadeEffect.start(!1, p, c, m, g, !0, x, y) }, fadeOut: function (p, c, m, g, x, y) { return this.fadeEffect.start(!0, p, c, m, g, !0, x, y) }, fadeFrom: function (p, c, m, g, x, y, T) { return this.fadeEffect.start(!1, p, c, m, g, x, y, T) }, fade: function (p, c, m, g, x, y, T) { return this.fadeEffect.start(!0, p, c, m, g, x, y, T) }, flash: function (p, c, m, g, x, y, T) { return this.flashEffect.start(p, c, m, g, x, y, T) }, shake: function (p, c, m, g, x) { return this.shakeEffect.start(p, c, m, g, x) }, pan: function (p, c, m, g, x, y, T) { return this.panEffect.start(p, c, m, g, x, y, T) }, rotateTo: function (p, c, m, g, x, y, T) { return this.rotateToEffect.start(p, c, m, g, x, y, T) }, zoomTo: function (p, c, m, g, x, y) { return this.zoomEffect.start(p, c, m, g, x, y) }, preRender: function () { this.renderList.length = 0; const p = this.width; const c = this.height; const m = p * 0.5; const g = c * 0.5; const x = this.zoom; const y = this.matrix; let T = p * this.originX; let S = c * this.originY; const E = this._follow; const C = this.deadzone; let P = this.scrollX; let A = this.scrollY; C && h(C, this.midPoint.x, this.midPoint.y); let M = !1; if (E && !this.panEffect.isRunning) { const L = E.x - this.followOffset.x; const F = E.y - this.followOffset.y; C ? (L < C.x ? P = f(P, P - (C.x - L), this.lerp.x) : L > C.right && (P = f(P, P + (L - C.right), this.lerp.x)), F < C.y ? A = f(A, A - (C.y - F), this.lerp.y) : F > C.bottom && (A = f(A, A + (F - C.bottom), this.lerp.y))) : (P = f(P, L - T, this.lerp.x), A = f(A, F - S, this.lerp.y)), M = !0 } this.useBounds && (P = this.clampX(P), A = this.clampY(A)), this.roundPixels && (T = Math.round(T), S = Math.round(S), P = Math.round(P), A = Math.round(A)), this.scrollX = P, this.scrollY = A; const I = P + m; const G = A + g; this.midPoint.set(I, G); const U = p / x; const Y = c / x; let X = I - U / 2; let O = G - Y / 2; this.roundPixels && (X = Math.round(X), O = Math.round(O)), this.worldView.setTo(X, O, U, Y), y.applyITRS(this.x + T, this.y + S, this.rotation, x, x), y.translate(-T, -S), this.shakeEffect.preRender(), M && this.emit(a.FOLLOW_UPDATE, this, E) }, setLerp: function (p, c) { return p === void 0 && (p = 1), c === void 0 && (c = p), this.lerp.set(p, c), this }, setFollowOffset: function (p, c) { return p === void 0 && (p = 0), c === void 0 && (c = 0), this.followOffset.set(p, c), this }, startFollow: function (p, c, m, g, x, y) { c === void 0 && (c = !1), m === void 0 && (m = 1), g === void 0 && (g = m), x === void 0 && (x = 0), y === void 0 && (y = x), this._follow = p, this.roundPixels = c, m = n(m, 0, 1), g = n(g, 0, 1), this.lerp.set(m, g), this.followOffset.set(x, y); const T = this.width / 2; const S = this.height / 2; const E = p.x - x; const C = p.y - y; return this.midPoint.set(E, C), this.scrollX = E - T, this.scrollY = C - S, this.useBounds && (this.scrollX = this.clampX(this.scrollX), this.scrollY = this.clampY(this.scrollY)), this }, stopFollow: function () { return this._follow = null, this }, resetFX: function () { return this.rotateToEffect.reset(), this.panEffect.reset(), this.shakeEffect.reset(), this.flashEffect.reset(), this.fadeEffect.reset(), this }, update: function (p, c) { this.visible && (this.rotateToEffect.update(p, c), this.panEffect.update(p, c), this.zoomEffect.update(p, c), this.shakeEffect.update(p, c), this.flashEffect.update(p, c), this.fadeEffect.update(p, c)) }, destroy: function () { this.resetFX(), i.prototype.destroy.call(this), this._follow = null, this.deadzone = null } }); e.exports = v }, function (e, d, t) { const i = t(38); const h = function (n) { const o = new i(); n = n.replace(/^(?:#|0x)?([a-f\d])([a-f\d])([a-f\d])$/i, function (l, u, v, p) { return u + u + v + v + p + p }); const r = /^(?:#|0x)?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(n); if (r) { const s = parseInt(r[1], 16); const a = parseInt(r[2], 16); const f = parseInt(r[3], 16); o.setTo(s, a, f) } return o }; e.exports = h }, function (e, d) { const t = function (i, h, n, o) { return o << 24 | i << 16 | h << 8 | n }; e.exports = t }, function (e, d) { const t = function (i, h, n, o) { o === void 0 && (o = { h: 0, s: 0, v: 0 }), i /= 255, h /= 255, n /= 255; const r = Math.min(i, h, n); const s = Math.max(i, h, n); const a = s - r; let f = 0; const l = s === 0 ? 0 : a / s; const u = s; return s !== r && (s === i ? f = (h - n) / a + (h < n ? 6 : 0) : s === h ? f = (n - i) / a + 2 : s === n && (f = (i - h) / a + 4), f /= 6), o.hasOwnProperty('_h') ? (o._h = f, o._s = l, o._v = u) : (o.h = f, o.s = l, o.v = u), o }; e.exports = t }, function (e, d) { const t = function (i) { return i > 16777215 ? { a: i >>> 24, r: i >> 16 & 255, g: i >> 8 & 255, b: i & 255 } : { a: 255, r: i >> 16 & 255, g: i >> 8 & 255, b: i & 255 } }; e.exports = t }, function (e, d, t) { const i = t(38); const h = function (n) { return new i(n.r, n.g, n.b, n.a) }; e.exports = h }, function (e, d, t) { const i = t(38); const h = function (n) { const o = new i(); const r = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d+(?:\.\d+)?))?\s*\)$/.exec(n.toLowerCase()); if (r) { const s = parseInt(r[1], 10); const a = parseInt(r[2], 10); const f = parseInt(r[3], 10); const l = r[4] !== void 0 ? parseFloat(r[4]) : 1; o.setTo(s, a, f, l * 255) } return o }; e.exports = h }, function (e, d, t) { e.exports = { Fade: t(761), Flash: t(762), Pan: t(763), Shake: t(796), RotateTo: t(797), Zoom: t(798) } }, function (e, d, t) { e.exports = { In: t(764), Out: t(765), InOut: t(766) } }, function (e, d, t) { e.exports = { In: t(767), Out: t(768), InOut: t(769) } }, function (e, d, t) { e.exports = { In: t(770), Out: t(771), InOut: t(772) } }, function (e, d, t) { e.exports = { In: t(773), Out: t(774), InOut: t(775) } }, function (e, d, t) { e.exports = { In: t(776), Out: t(777), InOut: t(778) } }, function (e, d, t) { e.exports = { In: t(779), Out: t(780), InOut: t(781) } }, function (e, d, t) { e.exports = t(782) }, function (e, d, t) { e.exports = { In: t(783), Out: t(784), InOut: t(785) } }, function (e, d, t) { e.exports = { In: t(786), Out: t(787), InOut: t(788) } }, function (e, d, t) { e.exports = { In: t(789), Out: t(790), InOut: t(791) } }, function (e, d, t) { e.exports = { In: t(792), Out: t(793), InOut: t(794) } }, function (e, d, t) { e.exports = t(795) }, function (e, d, t) { const i = t(0); const h = t(33); const n = t(347); const o = t(2); const r = t(6); const s = t(7); const a = t(193); const f = t(1); const l = t(197); const u = t(187); const v = new i({ initialize: function (c) { c === void 0 && (c = {}); const m = ['#ff0000', '#ffff00', '#00ff00', '#00ffff', '#000000']; const g = '#ffffff'; this.width = r(c, 'width', 1024), this.height = r(c, 'height', 768), this.zoom = r(c, 'zoom', 1), this.parent = r(c, 'parent', void 0), this.scaleMode = r(c, 'scaleMode', 0), this.expandParent = r(c, 'expandParent', !0), this.autoRound = r(c, 'autoRound', !1), this.autoCenter = r(c, 'autoCenter', 0), this.resizeInterval = r(c, 'resizeInterval', 500), this.fullscreenTarget = r(c, 'fullscreenTarget', null), this.minWidth = r(c, 'minWidth', 0), this.maxWidth = r(c, 'maxWidth', 0), this.minHeight = r(c, 'minHeight', 0), this.maxHeight = r(c, 'maxHeight', 0); const x = r(c, 'scale', null); x && (this.width = r(x, 'width', this.width), this.height = r(x, 'height', this.height), this.zoom = r(x, 'zoom', this.zoom), this.parent = r(x, 'parent', this.parent), this.scaleMode = r(x, 'mode', this.scaleMode), this.expandParent = r(x, 'expandParent', this.expandParent), this.autoRound = r(x, 'autoRound', this.autoRound), this.autoCenter = r(x, 'autoCenter', this.autoCenter), this.resizeInterval = r(x, 'resizeInterval', this.resizeInterval), this.fullscreenTarget = r(x, 'fullscreenTarget', this.fullscreenTarget), this.minWidth = r(x, 'min.width', this.minWidth), this.maxWidth = r(x, 'max.width', this.maxWidth), this.minHeight = r(x, 'min.height', this.minHeight), this.maxHeight = r(x, 'max.height', this.maxHeight)), this.renderType = r(c, 'type', h.AUTO), this.canvas = r(c, 'canvas', null), this.context = r(c, 'context', null), this.canvasStyle = r(c, 'canvasStyle', null), this.customEnvironment = r(c, 'customEnvironment', !1), this.sceneConfig = r(c, 'scene', null), this.seed = r(c, 'seed', [(Date.now() * Math.random()).toString()]), a.RND = new a.RandomDataGenerator(this.seed), this.gameTitle = r(c, 'title', ''), this.gameURL = r(c, 'url', 'https://phaser.io'), this.gameVersion = r(c, 'version', ''), this.autoFocus = r(c, 'autoFocus', !0), this.domCreateContainer = r(c, 'dom.createContainer', !1), this.domBehindCanvas = r(c, 'dom.behindCanvas', !1), this.domPointerEvents = r(c, 'dom.pointerEvents', 'none'), this.inputKeyboard = r(c, 'input.keyboard', !0), this.inputKeyboardEventTarget = r(c, 'input.keyboard.target', window), this.inputKeyboardCapture = r(c, 'input.keyboard.capture', []), this.inputMouse = r(c, 'input.mouse', !0), this.inputMouseEventTarget = r(c, 'input.mouse.target', null), this.inputMousePreventDefaultDown = r(c, 'input.mouse.preventDefaultDown', !0), this.inputMousePreventDefaultUp = r(c, 'input.mouse.preventDefaultUp', !0), this.inputMousePreventDefaultMove = r(c, 'input.mouse.preventDefaultMove', !0), this.inputMousePreventDefaultWheel = r(c, 'input.mouse.preventDefaultWheel', !0), this.inputTouch = r(c, 'input.touch', n.input.touch), this.inputTouchEventTarget = r(c, 'input.touch.target', null), this.inputTouchCapture = r(c, 'input.touch.capture', !0), this.inputActivePointers = r(c, 'input.activePointers', 1), this.inputSmoothFactor = r(c, 'input.smoothFactor', 0), this.inputWindowEvents = r(c, 'input.windowEvents', !0), this.inputGamepad = r(c, 'input.gamepad', !1), this.inputGamepadEventTarget = r(c, 'input.gamepad.target', window), this.disableContextMenu = r(c, 'disableContextMenu', !1), this.audio = r(c, 'audio', {}), this.hideBanner = r(c, 'banner', null) === !1, this.hidePhaser = r(c, 'banner.hidePhaser', !1), this.bannerTextColor = r(c, 'banner.text', g), this.bannerBackgroundColor = r(c, 'banner.background', m), this.gameTitle === '' && this.hidePhaser && (this.hideBanner = !0), this.fps = r(c, 'fps', null); const y = r(c, 'render', c); this.pipeline = r(y, 'pipeline', null), this.antialias = r(y, 'antialias', !0), this.antialiasGL = r(y, 'antialiasGL', !0), this.mipmapFilter = r(y, 'mipmapFilter', 'LINEAR'), this.desynchronized = r(y, 'desynchronized', !1), this.roundPixels = r(y, 'roundPixels', !1), this.pixelArt = r(y, 'pixelArt', this.zoom !== 1), this.pixelArt && (this.antialias = !1, this.antialiasGL = !1, this.roundPixels = !0), this.transparent = r(y, 'transparent', !1), this.clearBeforeRender = r(y, 'clearBeforeRender', !0), this.preserveDrawingBuffer = r(y, 'preserveDrawingBuffer', !1), this.premultipliedAlpha = r(y, 'premultipliedAlpha', !0), this.failIfMajorPerformanceCaveat = r(y, 'failIfMajorPerformanceCaveat', !1), this.powerPreference = r(y, 'powerPreference', 'default'), this.batchSize = r(y, 'batchSize', 4096), this.maxTextures = r(y, 'maxTextures', -1), this.maxLights = r(y, 'maxLights', 10); const T = r(c, 'backgroundColor', 0); this.backgroundColor = u(T), this.transparent && (this.backgroundColor = u(0), this.backgroundColor.alpha = 0), this.preBoot = r(c, 'callbacks.preBoot', f), this.postBoot = r(c, 'callbacks.postBoot', f), this.physics = r(c, 'physics', {}), this.defaultPhysicsSystem = r(this.physics, 'default', !1), this.loaderBaseURL = r(c, 'loader.baseURL', ''), this.loaderPath = r(c, 'loader.path', ''); const S = n.os.android ? 6 : 32; this.loaderMaxParallelDownloads = r(c, 'loader.maxParallelDownloads', S), this.loaderCrossOrigin = r(c, 'loader.crossOrigin', void 0), this.loaderResponseType = r(c, 'loader.responseType', ''), this.loaderAsync = r(c, 'loader.async', !0), this.loaderUser = r(c, 'loader.user', ''), this.loaderPassword = r(c, 'loader.password', ''), this.loaderTimeout = r(c, 'loader.timeout', 0), this.loaderWithCredentials = r(c, 'loader.withCredentials', !1), this.installGlobalPlugins = [], this.installScenePlugins = []; const E = r(c, 'plugins', null); let C = l.DefaultScene; E && (Array.isArray(E) ? this.defaultPlugins = E : s(E) && (this.installGlobalPlugins = o(E, 'global', []), this.installScenePlugins = o(E, 'scene', []), Array.isArray(E.default) ? C = E.default : Array.isArray(E.defaultMerge) && (C = C.concat(E.defaultMerge)))), this.defaultPlugins = C; const P = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAg'; this.defaultImage = r(c, 'images.default', P + 'AQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg=='), this.missingImage = r(c, 'images.missing', P + 'CAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg=='), this.whiteImage = r(c, 'images.white', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAIAAAAmkwkpAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAABdJREFUeNpi/P//PwMMMDEgAdwcgAADAJZuAwXJYZOzAAAAAElFTkSuQmCC'), window && (window.FORCE_WEBGL ? this.renderType = h.WEBGL : window.FORCE_CANVAS && (this.renderType = h.CANVAS)) } }); e.exports = v }, function (e, d, t) { e.exports = { os: t(105), browser: t(136), features: t(191), input: t(808), audio: t(809), video: t(810), fullscreen: t(811), canvasFeatures: t(348) } }, function (e, d, t) { const i = t(31); const h = { supportInverseAlpha: !1, supportNewBlendModes: !1 }; function n () { const s = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/'; const a = 'AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg=='; const f = new Image(); return f.onload = function () { const l = new Image(); l.onload = function () { const u = i.create(l, 6, 1); const v = u.getContext('2d'); if (v.globalCompositeOperation = 'multiply', v.drawImage(f, 0, 0), v.drawImage(l, 2, 0), !v.getImageData(2, 0, 1, 1)) return !1; const p = v.getImageData(2, 0, 1, 1).data; i.remove(l), h.supportNewBlendModes = p[0] === 255 && p[1] === 0 && p[2] === 0 }, l.src = s + '/wCKxvRF' + a }, f.src = s + 'AP804Oa6' + a, !1 } function o () { const s = i.create(this, 2, 1); const a = s.getContext('2d'); a.fillStyle = 'rgba(10, 20, 30, 0.5)', a.fillRect(0, 0, 1, 1); const f = a.getImageData(0, 0, 1, 1); if (f === null) return !1; a.putImageData(f, 1, 0); const l = a.getImageData(1, 0, 1, 1); return l.data[0] === f.data[0] && l.data[1] === f.data[1] && l.data[2] === f.data[2] && l.data[3] === f.data[3] } function r () { return typeof importScripts !== 'function' && document !== void 0 && (h.supportNewBlendModes = n(), h.supportInverseAlpha = o()), h }e.exports = r() }, function (e, d) { const t = function (i, h, n, o) { return Math.atan2(o - h, n - i) }; e.exports = t }, function (e, d) { const t = function (i, h) { return Math.atan2(h.y - i.y, h.x - i.x) }; e.exports = t }, function (e, d) { const t = function (i) { return i = i % (2 * Math.PI), i >= 0 ? i : i + 2 * Math.PI }; e.exports = t }, function (e, d) { const t = function (i, h) { const n = i.x - h.x; const o = i.y - h.y; return Math.sqrt(n * n + o * o) }; e.exports = t }, function (e, d) { const t = function (i, h, n, o) { const r = i - n; const s = h - o; return r * r + s * s }; e.exports = t }, function (e, d) { const t = function (i, h, n) { return n === void 0 && (n = 1e-4), i > h - n }; e.exports = t }, function (e, d) { const t = function (i, h, n) { return n === void 0 && (n = 1e-4), i < h + n }; e.exports = t }, function (e, d, t) { const i = t(357); const h = function (n, o) { return i(n) / i(o) / i(n - o) }; e.exports = h }, function (e, d) { const t = function (i) { if (i === 0) return 1; for (var h = i; --i;)h *= i; return h }; e.exports = t }, function (e, d) { function t (r, s) { const a = 1 - r; return a * a * a * s } function i (r, s) { const a = 1 - r; return 3 * a * a * r * s } function h (r, s) { return 3 * (1 - r) * r * r * s } function n (r, s) { return r * r * r * s } const o = function (r, s, a, f, l) { return t(r, s) + i(r, a) + h(r, f) + n(r, l) }; e.exports = o }, function (e, d) { function t (o, r) { const s = 1 - o; return s * s * r } function i (o, r) { return 2 * (1 - o) * o * r } function h (o, r) { return o * o * r } const n = function (o, r, s, a) { return t(o, r) + i(o, s) + h(o, a) }; e.exports = n }, function (e, d, t) { const i = t(184); const h = function (n, o, r) { return o + (r - o) * i(n, 0, 1) }; e.exports = h }, function (e, d) { const t = function (i) { const h = Math.log(i) / 0.6931471805599453; return 1 << Math.ceil(h) }; e.exports = t }, function (e, d) { const t = function (i, h) { const n = i.x; const o = i.y; return i.x = n * Math.cos(h) - o * Math.sin(h), i.y = n * Math.sin(h) + o * Math.cos(h), i }; e.exports = t }, function (e, d) { const t = function (i) { return i > 0 ? Math.ceil(i) : Math.floor(i) }; e.exports = t }, function (e, d, t) { const i = t(0); var h = new i({ initialize: function (o) { this.val = new Float32Array(9), o ? this.copy(o) : this.identity() }, clone: function () { return new h(this) }, set: function (n) { return this.copy(n) }, copy: function (n) { const o = this.val; const r = n.val; return o[0] = r[0], o[1] = r[1], o[2] = r[2], o[3] = r[3], o[4] = r[4], o[5] = r[5], o[6] = r[6], o[7] = r[7], o[8] = r[8], this }, fromMat4: function (n) { const o = n.val; const r = this.val; return r[0] = o[0], r[1] = o[1], r[2] = o[2], r[3] = o[4], r[4] = o[5], r[5] = o[6], r[6] = o[8], r[7] = o[9], r[8] = o[10], this }, fromArray: function (n) { const o = this.val; return o[0] = n[0], o[1] = n[1], o[2] = n[2], o[3] = n[3], o[4] = n[4], o[5] = n[5], o[6] = n[6], o[7] = n[7], o[8] = n[8], this }, identity: function () { const n = this.val; return n[0] = 1, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 1, n[5] = 0, n[6] = 0, n[7] = 0, n[8] = 1, this }, transpose: function () { const n = this.val; const o = n[1]; const r = n[2]; const s = n[5]; return n[1] = n[3], n[2] = n[6], n[3] = o, n[5] = n[7], n[6] = r, n[7] = s, this }, invert: function () { const n = this.val; const o = n[0]; const r = n[1]; const s = n[2]; const a = n[3]; const f = n[4]; const l = n[5]; const u = n[6]; const v = n[7]; const p = n[8]; const c = p * f - l * v; const m = -p * a + l * u; const g = v * a - f * u; let x = o * c + r * m + s * g; return x ? (x = 1 / x, n[0] = c * x, n[1] = (-p * r + s * v) * x, n[2] = (l * r - s * f) * x, n[3] = m * x, n[4] = (p * o - s * u) * x, n[5] = (-l * o + s * a) * x, n[6] = g * x, n[7] = (-v * o + r * u) * x, n[8] = (f * o - r * a) * x, this) : null }, adjoint: function () { const n = this.val; const o = n[0]; const r = n[1]; const s = n[2]; const a = n[3]; const f = n[4]; const l = n[5]; const u = n[6]; const v = n[7]; const p = n[8]; return n[0] = f * p - l * v, n[1] = s * v - r * p, n[2] = r * l - s * f, n[3] = l * u - a * p, n[4] = o * p - s * u, n[5] = s * a - o * l, n[6] = a * v - f * u, n[7] = r * u - o * v, n[8] = o * f - r * a, this }, determinant: function () { const n = this.val; const o = n[0]; const r = n[1]; const s = n[2]; const a = n[3]; const f = n[4]; const l = n[5]; const u = n[6]; const v = n[7]; const p = n[8]; return o * (p * f - l * v) + r * (-p * a + l * u) + s * (v * a - f * u) }, multiply: function (n) { const o = this.val; const r = o[0]; const s = o[1]; const a = o[2]; const f = o[3]; const l = o[4]; const u = o[5]; const v = o[6]; const p = o[7]; const c = o[8]; const m = n.val; const g = m[0]; const x = m[1]; const y = m[2]; const T = m[3]; const S = m[4]; const E = m[5]; const C = m[6]; const P = m[7]; const A = m[8]; return o[0] = g * r + x * f + y * v, o[1] = g * s + x * l + y * p, o[2] = g * a + x * u + y * c, o[3] = T * r + S * f + E * v, o[4] = T * s + S * l + E * p, o[5] = T * a + S * u + E * c, o[6] = C * r + P * f + A * v, o[7] = C * s + P * l + A * p, o[8] = C * a + P * u + A * c, this }, translate: function (n) { const o = this.val; const r = n.x; const s = n.y; return o[6] = r * o[0] + s * o[3] + o[6], o[7] = r * o[1] + s * o[4] + o[7], o[8] = r * o[2] + s * o[5] + o[8], this }, rotate: function (n) { const o = this.val; const r = o[0]; const s = o[1]; const a = o[2]; const f = o[3]; const l = o[4]; const u = o[5]; const v = Math.sin(n); const p = Math.cos(n); return o[0] = p * r + v * f, o[1] = p * s + v * l, o[2] = p * a + v * u, o[3] = p * f - v * r, o[4] = p * l - v * s, o[5] = p * u - v * a, this }, scale: function (n) { const o = this.val; const r = n.x; const s = n.y; return o[0] = r * o[0], o[1] = r * o[1], o[2] = r * o[2], o[3] = s * o[3], o[4] = s * o[4], o[5] = s * o[5], this }, fromQuat: function (n) { const o = n.x; const r = n.y; const s = n.z; const a = n.w; const f = o + o; const l = r + r; const u = s + s; const v = o * f; const p = o * l; const c = o * u; const m = r * l; const g = r * u; const x = s * u; const y = a * f; const T = a * l; const S = a * u; const E = this.val; return E[0] = 1 - (m + x), E[3] = p + S, E[6] = c - T, E[1] = p - S, E[4] = 1 - (v + x), E[7] = g + y, E[2] = c + T, E[5] = g - y, E[8] = 1 - (v + m), this }, normalFromMat4: function (n) { const o = n.val; const r = this.val; const s = o[0]; const a = o[1]; const f = o[2]; const l = o[3]; const u = o[4]; const v = o[5]; const p = o[6]; const c = o[7]; const m = o[8]; const g = o[9]; const x = o[10]; const y = o[11]; const T = o[12]; const S = o[13]; const E = o[14]; const C = o[15]; const P = s * v - a * u; const A = s * p - f * u; const M = s * c - l * u; const L = a * p - f * v; const F = a * c - l * v; const I = f * c - l * p; const G = m * S - g * T; const U = m * E - x * T; const Y = m * C - y * T; const X = g * E - x * S; const O = g * C - y * S; const R = x * C - y * E; let D = P * R - A * O + M * X + L * Y - F * U + I * G; return D ? (D = 1 / D, r[0] = (v * R - p * O + c * X) * D, r[1] = (p * Y - u * R - c * U) * D, r[2] = (u * O - v * Y + c * G) * D, r[3] = (f * O - a * R - l * X) * D, r[4] = (s * R - f * Y + l * U) * D, r[5] = (a * Y - s * O - l * G) * D, r[6] = (S * I - E * F + C * L) * D, r[7] = (E * M - T * I - C * A) * D, r[8] = (T * F - S * M + C * P) * D, this) : null } }); e.exports = h }, function (e, d, t) { const i = t(0); const h = t(364); const n = t(1); const o = t(39); const r = 1e-6; const s = new Int8Array([1, 2, 0]); const a = new Float32Array([0, 0, 0]); const f = new o(1, 0, 0); const l = new o(0, 1, 0); const u = new o(); const v = new h(); const p = new i({ initialize: function (m, g, x, y) { this.onChangeCallback = n, this.set(m, g, x, y) }, x: { get: function () { return this._x }, set: function (c) { this._x = c, this.onChangeCallback(this) } }, y: { get: function () { return this._y }, set: function (c) { this._y = c, this.onChangeCallback(this) } }, z: { get: function () { return this._z }, set: function (c) { this._z = c, this.onChangeCallback(this) } }, w: { get: function () { return this._w }, set: function (c) { this._w = c, this.onChangeCallback(this) } }, copy: function (c) { return this.set(c) }, set: function (c, m, g, x, y) { return y === void 0 && (y = !0), typeof c === 'object' ? (this._x = c.x || 0, this._y = c.y || 0, this._z = c.z || 0, this._w = c.w || 0) : (this._x = c || 0, this._y = m || 0, this._z = g || 0, this._w = x || 0), y && this.onChangeCallback(this), this }, add: function (c) { return this._x += c.x, this._y += c.y, this._z += c.z, this._w += c.w, this.onChangeCallback(this), this }, subtract: function (c) { return this._x -= c.x, this._y -= c.y, this._z -= c.z, this._w -= c.w, this.onChangeCallback(this), this }, scale: function (c) { return this._x *= c, this._y *= c, this._z *= c, this._w *= c, this.onChangeCallback(this), this }, length: function () { const c = this.x; const m = this.y; const g = this.z; const x = this.w; return Math.sqrt(c * c + m * m + g * g + x * x) }, lengthSq: function () { const c = this.x; const m = this.y; const g = this.z; const x = this.w; return c * c + m * m + g * g + x * x }, normalize: function () { const c = this.x; const m = this.y; const g = this.z; const x = this.w; let y = c * c + m * m + g * g + x * x; return y > 0 && (y = 1 / Math.sqrt(y), this._x = c * y, this._y = m * y, this._z = g * y, this._w = x * y), this.onChangeCallback(this), this }, dot: function (c) { return this.x * c.x + this.y * c.y + this.z * c.z + this.w * c.w }, lerp: function (c, m) { m === void 0 && (m = 0); const g = this.x; const x = this.y; const y = this.z; const T = this.w; return this.set(g + m * (c.x - g), x + m * (c.y - x), y + m * (c.z - y), T + m * (c.w - T)) }, rotationTo: function (c, m) { const g = c.x * m.x + c.y * m.y + c.z * m.z; return g < -0.999999 ? (u.copy(f).cross(c).length() < r && u.copy(l).cross(c), u.normalize(), this.setAxisAngle(u, Math.PI)) : g > 0.999999 ? this.set(0, 0, 0, 1) : (u.copy(c).cross(m), this._x = u.x, this._y = u.y, this._z = u.z, this._w = 1 + g, this.normalize()) }, setAxes: function (c, m, g) { const x = v.val; return x[0] = m.x, x[3] = m.y, x[6] = m.z, x[1] = g.x, x[4] = g.y, x[7] = g.z, x[2] = -c.x, x[5] = -c.y, x[8] = -c.z, this.fromMat3(v).normalize() }, identity: function () { return this.set(0, 0, 0, 1) }, setAxisAngle: function (c, m) { m = m * 0.5; const g = Math.sin(m); return this.set(g * c.x, g * c.y, g * c.z, Math.cos(m)) }, multiply: function (c) { const m = this.x; const g = this.y; const x = this.z; const y = this.w; const T = c.x; const S = c.y; const E = c.z; const C = c.w; return this.set(m * C + y * T + g * E - x * S, g * C + y * S + x * T - m * E, x * C + y * E + m * S - g * T, y * C - m * T - g * S - x * E) }, slerp: function (c, m) { const g = this.x; const x = this.y; const y = this.z; const T = this.w; let S = c.x; let E = c.y; let C = c.z; let P = c.w; let A = g * S + x * E + y * C + T * P; A < 0 && (A = -A, S = -S, E = -E, C = -C, P = -P); let M = 1 - m; let L = m; if (1 - A > r) { const F = Math.acos(A); const I = Math.sin(F); M = Math.sin((1 - m) * F) / I, L = Math.sin(m * F) / I } return this.set(M * g + L * S, M * x + L * E, M * y + L * C, M * T + L * P) }, invert: function () { const c = this.x; const m = this.y; const g = this.z; const x = this.w; const y = c * c + m * m + g * g + x * x; const T = y ? 1 / y : 0; return this.set(-c * T, -m * T, -g * T, x * T) }, conjugate: function () { return this._x = -this.x, this._y = -this.y, this._z = -this.z, this.onChangeCallback(this), this }, rotateX: function (c) { c *= 0.5; const m = this.x; const g = this.y; const x = this.z; const y = this.w; const T = Math.sin(c); const S = Math.cos(c); return this.set(m * S + y * T, g * S + x * T, x * S - g * T, y * S - m * T) }, rotateY: function (c) { c *= 0.5; const m = this.x; const g = this.y; const x = this.z; const y = this.w; const T = Math.sin(c); const S = Math.cos(c); return this.set(m * S - x * T, g * S + y * T, x * S + m * T, y * S - g * T) }, rotateZ: function (c) { c *= 0.5; const m = this.x; const g = this.y; const x = this.z; const y = this.w; const T = Math.sin(c); const S = Math.cos(c); return this.set(m * S + g * T, g * S - m * T, x * S + y * T, y * S - x * T) }, calculateW: function () { const c = this.x; const m = this.y; const g = this.z; return this.w = -Math.sqrt(1 - c * c - m * m - g * g), this }, setFromEuler: function (c, m) { const g = c.x / 2; const x = c.y / 2; const y = c.z / 2; const T = Math.cos(g); const S = Math.cos(x); const E = Math.cos(y); const C = Math.sin(g); const P = Math.sin(x); const A = Math.sin(y); switch (c.order) { case 'XYZ': { this.set(C * S * E + T * P * A, T * P * E - C * S * A, T * S * A + C * P * E, T * S * E - C * P * A, m); break } case 'YXZ': { this.set(C * S * E + T * P * A, T * P * E - C * S * A, T * S * A - C * P * E, T * S * E + C * P * A, m); break } case 'ZXY': { this.set(C * S * E - T * P * A, T * P * E + C * S * A, T * S * A + C * P * E, T * S * E - C * P * A, m); break } case 'ZYX': { this.set(C * S * E - T * P * A, T * P * E + C * S * A, T * S * A - C * P * E, T * S * E + C * P * A, m); break } case 'YZX': { this.set(C * S * E + T * P * A, T * P * E + C * S * A, T * S * A - C * P * E, T * S * E - C * P * A, m); break } case 'XZY': { this.set(C * S * E - T * P * A, T * P * E - C * S * A, T * S * A + C * P * E, T * S * E + C * P * A, m); break } } return this }, setFromRotationMatrix: function (c) { const m = c.val; const g = m[0]; const x = m[4]; const y = m[8]; const T = m[1]; const S = m[5]; const E = m[9]; const C = m[2]; const P = m[6]; const A = m[10]; const M = g + S + A; let L; return M > 0 ? (L = 0.5 / Math.sqrt(M + 1), this.set((P - E) * L, (y - C) * L, (T - x) * L, 0.25 / L)) : g > S && g > A ? (L = 2 * Math.sqrt(1 + g - S - A), this.set(0.25 * L, (x + T) / L, (y + C) / L, (P - E) / L)) : S > A ? (L = 2 * Math.sqrt(1 + S - g - A), this.set((x + T) / L, 0.25 * L, (E + P) / L, (y - C) / L)) : (L = 2 * Math.sqrt(1 + A - g - S), this.set((y + C) / L, (E + P) / L, 0.25 * L, (T - x) / L)), this }, fromMat3: function (c) { const m = c.val; const g = m[0] + m[4] + m[8]; let x; if (g > 0)x = Math.sqrt(g + 1), this.w = 0.5 * x, x = 0.5 / x, this._x = (m[7] - m[5]) * x, this._y = (m[2] - m[6]) * x, this._z = (m[3] - m[1]) * x; else { let y = 0; m[4] > m[0] && (y = 1), m[8] > m[y * 3 + y] && (y = 2); const T = s[y]; const S = s[T]; x = Math.sqrt(m[y * 3 + y] - m[T * 3 + T] - m[S * 3 + S] + 1), a[y] = 0.5 * x, x = 0.5 / x, a[T] = (m[T * 3 + y] + m[y * 3 + T]) * x, a[S] = (m[S * 3 + y] + m[y * 3 + S]) * x, this._x = a[0], this._y = a[1], this._z = a[2], this._w = (m[S * 3 + T] - m[T * 3 + S]) * x } return this.onChangeCallback(this), this } }); e.exports = p }, function (e, d, t) { const i = t(367); const h = t(31); const n = t(33); const o = t(191); const r = function (s) { const a = s.config; if ((a.customEnvironment || a.canvas) && a.renderType === n.AUTO) throw new Error('Must set explicit renderType in custom environment'); if (!a.customEnvironment && !a.canvas && a.renderType !== n.HEADLESS) if (a.renderType === n.CANVAS || a.renderType !== n.CANVAS && !o.webGL) if (o.canvas)a.renderType = n.CANVAS; else throw new Error('Cannot create Canvas or WebGL context, aborting.'); else a.renderType = n.WEBGL; a.antialias || h.disableSmoothing(); const f = s.scale.baseSize; const l = f.width; const u = f.height; if (a.canvas ? (s.canvas = a.canvas, s.canvas.width = l, s.canvas.height = u) : s.canvas = h.create(s, l, u, a.renderType), a.canvasStyle && (s.canvas.style = a.canvasStyle), a.antialias || i.setCrisp(s.canvas), a.renderType !== n.HEADLESS) { let v, p; v = t(368), p = t(371), a.renderType === n.WEBGL ? s.renderer = new p(s) : (s.renderer = new v(s), s.context = s.renderer.gameContext) } }; e.exports = r }, function (e, d) { const t = { setCrisp: function (i) { const h = ['optimizeSpeed', '-moz-crisp-edges', '-o-crisp-edges', '-webkit-optimize-contrast', 'optimize-contrast', 'crisp-edges', 'pixelated']; return h.forEach(function (n) { i.style['image-rendering'] = n }), i.style.msInterpolationMode = 'nearest-neighbor', i }, setBicubic: function (i) { return i.style['image-rendering'] = 'auto', i.style.msInterpolationMode = 'bicubic', i } }; e.exports = t }, function (e, d, t) { const i = t(37); const h = t(369); const n = t(0); const o = t(33); const r = t(9); const s = t(91); const a = t(370); const f = t(104); const l = t(106); const u = t(25); const v = new n({ Extends: r, initialize: function (c) { r.call(this); const m = c.config; this.config = { clearBeforeRender: m.clearBeforeRender, backgroundColor: m.backgroundColor, antialias: m.antialias, roundPixels: m.roundPixels }, this.game = c, this.type = o.CANVAS, this.drawCount = 0, this.width = 0, this.height = 0, this.gameCanvas = c.canvas; const g = { alpha: c.config.transparent, desynchronized: c.config.desynchronized }; this.gameContext = m.context ? m.context : this.gameCanvas.getContext('2d', g), this.currentContext = this.gameContext, this.antialias = c.config.antialias, this.blendModes = a(), this.snapshotState = { x: 0, y: 0, width: 1, height: 1, getPixel: !1, callback: null, type: 'image/png', encoder: 0.92 }, this._tempMatrix1 = new u(), this._tempMatrix2 = new u(), this._tempMatrix3 = new u(), this.isBooted = !1, this.init() }, init: function () { this.game.textures.once(l.READY, this.boot, this) }, boot: function () { const p = this.game; const c = p.scale.baseSize; this.width = c.width, this.height = c.height, this.isBooted = !0, p.scale.on(f.RESIZE, this.onResize, this), this.resize(c.width, c.height) }, onResize: function (p, c) { (c.width !== this.width || c.height !== this.height) && this.resize(c.width, c.height) }, resize: function (p, c) { this.width = p, this.height = c, this.emit(s.RESIZE, p, c) }, resetTransform: function () { this.currentContext.setTransform(1, 0, 0, 1, 0, 0) }, setBlendMode: function (p) { return this.currentContext.globalCompositeOperation = p, this }, setContext: function (p) { return this.currentContext = p || this.gameContext, this }, setAlpha: function (p) { return this.currentContext.globalAlpha = p, this }, preRender: function () { const p = this.gameContext; const c = this.config; const m = this.width; const g = this.height; p.globalAlpha = 1, p.globalCompositeOperation = 'source-over', p.setTransform(1, 0, 0, 1, 0, 0), c.clearBeforeRender && (p.clearRect(0, 0, m, g), c.transparent || (p.fillStyle = c.backgroundColor.rgba, p.fillRect(0, 0, m, g))), p.save(), this.drawCount = 0, this.emit(s.PRE_RENDER) }, render: function (p, c, m) { const g = c.length; this.emit(s.RENDER, p, m); const x = m.x; const y = m.y; const T = m.width; const S = m.height; const E = m.renderToTexture ? m.context : p.sys.context; E.save(), this.game.scene.customViewports && (E.beginPath(), E.rect(x, y, T, S), E.clip()), this.currentContext = E; const C = m.mask; C && C.preRenderCanvas(this, null, m._maskCamera), m.transparent || (E.fillStyle = m.backgroundColor.rgba, E.fillRect(x, y, T, S)), E.globalAlpha = m.alpha, E.globalCompositeOperation = 'source-over', this.drawCount += g, m.renderToTexture && m.emit(i.PRE_RENDER, m), m.matrix.copyToContext(E); for (let P = 0; P < g; P++) { const A = c[P]; A.mask && A.mask.preRenderCanvas(this, A, m), A.renderCanvas(this, A, m), A.mask && A.mask.postRenderCanvas(this, A, m) }E.setTransform(1, 0, 0, 1, 0, 0), E.globalCompositeOperation = 'source-over', E.globalAlpha = 1, m.flashEffect.postRenderCanvas(E), m.fadeEffect.postRenderCanvas(E), m.dirty = !1, C && C.postRenderCanvas(this), E.restore(), m.renderToTexture && (m.emit(i.POST_RENDER, m), m.renderToGame && p.sys.context.drawImage(m.canvas, x, y)) }, postRender: function () { const p = this.gameContext; p.restore(), this.emit(s.POST_RENDER); const c = this.snapshotState; c.callback && (h(this.gameCanvas, c), c.callback = null) }, snapshotCanvas: function (p, c, m, g, x, y, T, S, E) { m === void 0 && (m = !1), this.snapshotArea(g, x, y, T, c, S, E); const C = this.snapshotState; return C.getPixel = m, h(this.canvas, C), C.callback = null, this }, snapshot: function (p, c, m) { return this.snapshotArea(0, 0, this.gameCanvas.width, this.gameCanvas.height, p, c, m) }, snapshotArea: function (p, c, m, g, x, y, T) { const S = this.snapshotState; return S.callback = x, S.type = y, S.encoder = T, S.getPixel = !1, S.x = p, S.y = c, S.width = Math.min(m, this.gameCanvas.width), S.height = Math.min(g, this.gameCanvas.height), this }, snapshotPixel: function (p, c, m) { return this.snapshotArea(p, c, 1, 1, m), this.snapshotState.getPixel = !0, this }, batchSprite: function (p, c, m, g) { const x = m.alpha * p.alpha; if (x !== 0) { const y = this.currentContext; const T = this._tempMatrix1; const S = this._tempMatrix2; const E = c.canvasData; let C = E.x; let P = E.y; let A = c.cutWidth; let M = c.cutHeight; const L = c.customPivot; const F = c.source.resolution; const I = p.displayOriginX; const G = p.displayOriginY; let U = -I + c.x; let Y = -G + c.y; if (p.isCropped) { const X = p._crop; (X.flipX !== p.flipX || X.flipY !== p.flipY) && c.updateCropUVs(X, p.flipX, p.flipY), A = X.cw, M = X.ch, C = X.cx, P = X.cy, U = -I + X.x, Y = -G + X.y, p.flipX && (U >= 0 ? U = -(U + A) : U < 0 && (U = Math.abs(U) - A)), p.flipY && (Y >= 0 ? Y = -(Y + M) : Y < 0 && (Y = Math.abs(Y) - M)) } let O = 1; let R = 1; p.flipX && (L || (U += -c.realWidth + I * 2), O = -1), p.flipY && (L || (Y += -c.realHeight + G * 2), R = -1), S.applyITRS(p.x, p.y, p.rotation, p.scaleX * O, p.scaleY * R), T.copyFrom(m.matrix), g ? (T.multiplyWithOffset(g, -m.scrollX * p.scrollFactorX, -m.scrollY * p.scrollFactorY), S.e = p.x, S.f = p.y) : (S.e -= m.scrollX * p.scrollFactorX, S.f -= m.scrollY * p.scrollFactorY), T.multiply(S), y.save(), T.setToContext(y), y.globalCompositeOperation = this.blendModes[p.blendMode], y.globalAlpha = x, y.imageSmoothingEnabled = !(!this.antialias || c.source.scaleMode), p.mask && p.mask.preRenderCanvas(this, p, m), y.drawImage(c.source.image, C, P, A, M, U, Y, A / F, M / F), p.mask && p.mask.postRenderCanvas(this, p, m), y.restore() } }, destroy: function () { this.removeAllListeners(), this.game = null, this.gameCanvas = null, this.gameContext = null } }); e.exports = v }, function (e, d, t) { const i = t(31); const h = t(38); const n = t(2); const o = function (r, s) { const a = n(s, 'callback'); const f = n(s, 'type', 'image/png'); const l = n(s, 'encoder', 0.92); const u = Math.abs(Math.round(n(s, 'x', 0))); const v = Math.abs(Math.round(n(s, 'y', 0))); const p = n(s, 'width', r.width); const c = n(s, 'height', r.height); const m = n(s, 'getPixel', !1); if (m) { const g = r.getContext('2d'); const x = g.getImageData(u, v, 1, 1); const y = x.data; a.call(null, new h(y[0], y[1], y[2], y[3] / 255)) } else if (u !== 0 || v !== 0 || p !== r.width || c !== r.height) { const T = i.createWebGL(this, p, c); const S = T.getContext('2d'); S.drawImage(r, u, v, p, c, 0, 0, p, c); const E = new Image(); E.onerror = function () { a.call(null), i.remove(T) }, E.onload = function () { a.call(null, E), i.remove(T) }, E.src = T.toDataURL(f, l) } else { const C = new Image(); C.onerror = function () { a.call(null) }, C.onload = function () { a.call(null, C) }, C.src = r.toDataURL(f, l) } }; e.exports = o }, function (e, d, t) { const i = t(35); const h = t(348); const n = function () { const o = []; const r = h.supportNewBlendModes; const s = 'source-over'; return o[i.NORMAL] = s, o[i.ADD] = 'lighter', o[i.MULTIPLY] = r ? 'multiply' : s, o[i.SCREEN] = r ? 'screen' : s, o[i.OVERLAY] = r ? 'overlay' : s, o[i.DARKEN] = r ? 'darken' : s, o[i.LIGHTEN] = r ? 'lighten' : s, o[i.COLOR_DODGE] = r ? 'color-dodge' : s, o[i.COLOR_BURN] = r ? 'color-burn' : s, o[i.HARD_LIGHT] = r ? 'hard-light' : s, o[i.SOFT_LIGHT] = r ? 'soft-light' : s, o[i.DIFFERENCE] = r ? 'difference' : s, o[i.EXCLUSION] = r ? 'exclusion' : s, o[i.HUE] = r ? 'hue' : s, o[i.SATURATION] = r ? 'saturation' : s, o[i.COLOR] = r ? 'color' : s, o[i.LUMINOSITY] = r ? 'luminosity' : s, o[i.ERASE] = 'destination-out', o[i.SOURCE_IN] = 'source-in', o[i.SOURCE_OUT] = 'source-out', o[i.SOURCE_ATOP] = 'source-atop', o[i.DESTINATION_OVER] = 'destination-over', o[i.DESTINATION_IN] = 'destination-in', o[i.DESTINATION_OUT] = 'destination-out', o[i.DESTINATION_ATOP] = 'destination-atop', o[i.LIGHTER] = 'lighter', o[i.COPY] = 'copy', o[i.XOR] = 'xor', o }; e.exports = n }, function (e, d, t) {
        const i = t(93); const h = t(37); const n = t(0); const o = t(33); const r = t(9); const s = t(91); const a = t(22); const f = t(138); const l = t(69); const u = t(1); const v = t(372); const p = t(141); const c = t(104); const m = t(106); const g = t(12); const x = t(383); const y = new n({
          Extends: r,
          initialize: function (S) { r.call(this); const E = S.config; const C = { alpha: E.transparent, desynchronized: E.desynchronized, depth: !1, antialias: E.antialiasGL, premultipliedAlpha: E.premultipliedAlpha, stencil: !0, failIfMajorPerformanceCaveat: E.failIfMajorPerformanceCaveat, powerPreference: E.powerPreference, preserveDrawingBuffer: E.preserveDrawingBuffer }; this.config = { clearBeforeRender: E.clearBeforeRender, antialias: E.antialias, backgroundColor: E.backgroundColor, contextCreation: C, roundPixels: E.roundPixels, maxTextures: E.maxTextures, maxTextureSize: E.maxTextureSize, batchSize: E.batchSize, maxLights: E.maxLights, mipmapFilter: E.mipmapFilter }, this.game = S, this.type = o.WEBGL, this.pipelines = null, this.width = 0, this.height = 0, this.canvas = S.canvas, this.blendModes = [], this.contextLost = !1, this.snapshotState = { x: 0, y: 0, width: 1, height: 1, getPixel: !1, callback: null, type: 'image/png', encoder: 0.92, isFramebuffer: !1, bufferWidth: 0, bufferHeight: 0 }, this.currentActiveTexture = 0, this.startActiveTexture = 0, this.maxTextures = 0, this.textureIndexes, this.tempTextures, this.textureZero, this.normalTexture, this.currentFramebuffer = null, this.fboStack = [], this.currentProgram = null, this.currentBlendMode = 1 / 0, this.currentScissorEnabled = !1, this.currentScissor = null, this.scissorStack = [], this.contextLostHandler = u, this.contextRestoredHandler = u, this.gl = null, this.supportedExtensions = null, this.instancedArraysExtension = null, this.vaoExtension = null, this.extensions = {}, this.glFormats = [], this.compression = { ETC1: !1, PVRTC: !1, S3TC: !1 }, this.drawingBufferHeight = 0, this.blankTexture = null, this.whiteTexture = null, this.maskCount = 0, this.maskStack = [], this.currentMask = { mask: null, camera: null }, this.currentCameraMask = { mask: null, camera: null }, this.glFuncMap = null, this.currentType = '', this.newType = !1, this.nextTypeMatch = !1, this.finalType = !1, this.mipmapFilter = null, this.textureFlush = 0, this.isTextureClean = !1, this.defaultScissor = [0, 0, 0, 0], this.isBooted = !1, this.renderTarget = null, this.projectionMatrix, this.projectionWidth = 0, this.projectionHeight = 0, this.init(this.config) },
          init: function (T) { let S; const E = this.game; const C = this.canvas; const P = T.backgroundColor; if (E.config.context ? S = E.config.context : S = C.getContext('webgl', T.contextCreation) || C.getContext('experimental-webgl', T.contextCreation), !S || S.isContextLost()) throw this.contextLost = !0, new Error('WebGL unsupported'); this.gl = S; const A = this; this.contextLostHandler = function (D) { A.contextLost = !0, A.game.events.emit(a.CONTEXT_LOST, A), D.preventDefault() }, this.contextRestoredHandler = function () { A.contextLost = !1, A.init(A.config), A.game.events.emit(a.CONTEXT_RESTORED, A) }, C.addEventListener('webglcontextlost', this.contextLostHandler, !1), C.addEventListener('webglcontextrestored', this.contextRestoredHandler, !1), E.context = S; for (var M = 0; M <= 27; M++) this.blendModes.push({ func: [S.ONE, S.ONE_MINUS_SRC_ALPHA], equation: S.FUNC_ADD }); this.blendModes[1].func = [S.ONE, S.DST_ALPHA], this.blendModes[2].func = [S.DST_COLOR, S.ONE_MINUS_SRC_ALPHA], this.blendModes[3].func = [S.ONE, S.ONE_MINUS_SRC_COLOR], this.blendModes[17] = { func: [S.ZERO, S.ONE_MINUS_SRC_ALPHA], equation: S.FUNC_REVERSE_SUBTRACT }, this.glFormats[0] = S.BYTE, this.glFormats[1] = S.SHORT, this.glFormats[2] = S.UNSIGNED_BYTE, this.glFormats[3] = S.UNSIGNED_SHORT, this.glFormats[4] = S.FLOAT, this.glFuncMap = { mat2: { func: S.uniformMatrix2fv, length: 1, matrix: !0 }, mat3: { func: S.uniformMatrix3fv, length: 1, matrix: !0 }, mat4: { func: S.uniformMatrix4fv, length: 1, matrix: !0 }, '1f': { func: S.uniform1f, length: 1 }, '1fv': { func: S.uniform1fv, length: 1 }, '1i': { func: S.uniform1i, length: 1 }, '1iv': { func: S.uniform1iv, length: 1 }, '2f': { func: S.uniform2f, length: 2 }, '2fv': { func: S.uniform2fv, length: 1 }, '2i': { func: S.uniform2i, length: 2 }, '2iv': { func: S.uniform2iv, length: 1 }, '3f': { func: S.uniform3f, length: 3 }, '3fv': { func: S.uniform3fv, length: 1 }, '3i': { func: S.uniform3i, length: 3 }, '3iv': { func: S.uniform3iv, length: 1 }, '4f': { func: S.uniform4f, length: 4 }, '4fv': { func: S.uniform4fv, length: 1 }, '4i': { func: S.uniform4i, length: 4 }, '4iv': { func: S.uniform4iv, length: 1 } }; const L = S.getSupportedExtensions(); (!T.maxTextures || T.maxTextures === -1) && (T.maxTextures = S.getParameter(S.MAX_TEXTURE_IMAGE_UNITS)), T.maxTextureSize || (T.maxTextureSize = S.getParameter(S.MAX_TEXTURE_SIZE)); const F = 'WEBGL_compressed_texture_'; const I = 'WEBKIT_' + F; this.compression.ETC1 = S.getExtension(F + 'etc1') || S.getExtension(I + 'etc1'), this.compression.PVRTC = S.getExtension(F + 'pvrtc') || S.getExtension(I + 'pvrtc'), this.compression.S3TC = S.getExtension(F + 's3tc') || S.getExtension(I + 's3tc'), this.supportedExtensions = L; const G = 'ANGLE_instanced_arrays'; this.instancedArraysExtension = L.indexOf(G) > -1 ? S.getExtension(G) : null; const U = 'OES_vertex_array_object'; this.vaoExtension = L.indexOf(U) > -1 ? S.getExtension(U) : null, S.disable(S.DEPTH_TEST), S.disable(S.CULL_FACE), S.enable(S.BLEND), S.clearColor(P.redGL, P.greenGL, P.blueGL, P.alphaGL), this.mipmapFilter = S[T.mipmapFilter], this.maxTextures = g.checkShaderMax(S, T.maxTextures), this.textureIndexes = []; let Y = this.tempTextures; if (Array.isArray(Y)) for (let X = 0; M < this.maxTextures; X++)S.deleteTexture(Y[X]); else Y = new Array(this.maxTextures); for (let O = 0; O < this.maxTextures; O++) { const R = S.createTexture(); S.activeTexture(S.TEXTURE0 + O), S.bindTexture(S.TEXTURE_2D, R), S.texImage2D(S.TEXTURE_2D, 0, S.RGBA, 1, 1, 0, S.RGBA, S.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 255])), Y[O] = R, this.textureIndexes.push(O) } return this.tempTextures = Y, this.currentActiveTexture = 1, this.startActiveTexture++, S.activeTexture(S.TEXTURE1), this.pipelines = new v(this), this.setBlendMode(o.BlendModes.NORMAL), this.projectionMatrix = new l().identity(), E.textures.once(m.READY, this.boot, this), this },
          boot: function () { const T = this.game; const S = this.pipelines; const E = T.scale.baseSize; this.width = E.width, this.height = E.height, this.isBooted = !0, this.renderTarget = new p(this, this.width, this.height, 1, 0, !0, !0), S.boot(T.config.pipeline), this.blankTexture = T.textures.getFrame('__DEFAULT'), this.whiteTexture = T.textures.getFrame('__WHITE'); const C = this.gl; C.bindFramebuffer(C.FRAMEBUFFER, null), C.enable(C.SCISSOR_TEST), T.scale.on(c.RESIZE, this.onResize, this), this.resize(E.width, E.height) },
          onResize: function (T, S) { (S.width !== this.width || S.height !== this.height) && this.resize(S.width, S.height) },
          beginCapture: function (T, S) { T === void 0 && (T = this.width), S === void 0 && (S = this.height), this.renderTarget.bind(!0, T, S), this.setProjectionMatrix(T, S), this.resetTextures() },
          endCapture: function () { return this.renderTarget.unbind(!0), this.resetProjectionMatrix(), this.renderTarget },
          resize: function (T, S) { const E = this.gl; return this.width = T, this.height = S, this.setProjectionMatrix(T, S), E.viewport(0, 0, T, S), this.drawingBufferHeight = E.drawingBufferHeight, E.scissor(0, E.drawingBufferHeight - S, T, S), this.defaultScissor[2] = T, this.defaultScissor[3] = S, this.emit(s.RESIZE, T, S), this },
          getAspectRatio: function () { return this.width / this.height },
          setProjectionMatrix: function (T, S) { return (T !== this.projectionWidth || S !== this.projectionHeight) && (this.projectionWidth = T, this.projectionHeight = S, this.projectionMatrix.ortho(0, T, S, 0, -1e3, 1e3)), this },
          resetProjectionMatrix: function () { this.projectionWidth = this.width, this.projectionHeight = this.height, this.projectionMatrix.ortho(0, this.width, this.height, 0, -1e3, 1e3) },
          hasExtension: function (T) { return this.supportedExtensions ? this.supportedExtensions.indexOf(T) : !1 },
          getExtension: function (T) { return this.hasExtension(T) ? (T in this.extensions || (this.extensions[T] = this.gl.getExtension(T)), this.extensions[T]) : null },
          flush: function () { this.pipelines.flush() },
          pushScissor: function (T, S, E, C, P) { P === void 0 && (P = this.drawingBufferHeight); const A = this.scissorStack; const M = [T, S, E, C]; return A.push(M), this.setScissor(T, S, E, C, P), this.currentScissor = M, M },
          setScissor: function (T, S, E, C, P) { P === void 0 && (P = this.drawingBufferHeight); const A = this.gl; const M = this.currentScissor; let L = E > 0 && C > 0; if (M && L) { const F = M[0]; const I = M[1]; const G = M[2]; const U = M[3]; L = F !== T || I !== S || G !== E || U !== C }L && (this.flush(), A.scissor(T, P - S - C, E, C)) },
          resetScissor: function () { const T = this.gl; T.enable(T.SCISSOR_TEST); const S = this.currentScissor; if (S) { const E = S[0]; const C = S[1]; const P = S[2]; const A = S[3]; P > 0 && A > 0 && T.scissor(E, this.drawingBufferHeight - C - A, P, A) } },
          popScissor: function () { const T = this.scissorStack; T.pop(); const S = T[T.length - 1]; S && this.setScissor(S[0], S[1], S[2], S[3]), this.currentScissor = S },
          hasActiveStencilMask: function () { const T = this.currentMask.mask; const S = this.currentCameraMask.mask; return T && T.isStencil || S && S.isStencil },
          resetViewport: function () { const T = this.gl; T.viewport(0, 0, this.width, this.height), this.drawingBufferHeight = T.drawingBufferHeight },
          setBlendMode: function (T, S) { S === void 0 && (S = !1); const E = this.gl; const C = this.blendModes[T]; return S || T !== o.BlendModes.SKIP_CHECK && this.currentBlendMode !== T ? (this.flush(), E.enable(E.BLEND), E.blendEquation(C.equation), C.func.length > 2 ? E.blendFuncSeparate(C.func[0], C.func[1], C.func[2], C.func[3]) : E.blendFunc(C.func[0], C.func[1]), this.currentBlendMode = T, !0) : !1 },
          addBlendMode: function (T, S) { const E = this.blendModes.push({ func: T, equation: S }); return E - 1 },
          updateBlendMode: function (T, S, E) { return this.blendModes[T] && (this.blendModes[T].func = S, E && (this.blendModes[T].equation = E)), this },
          removeBlendMode: function (T) { return T > 17 && this.blendModes[T] && this.blendModes.splice(T, 1), this },
          setBlankTexture: function () { this.setTexture2D(this.blankTexture.glTexture) },
          setTextureSource: function (T) { if (this.pipelines.forceZero()) return this.setTextureZero(T.glTexture, !0), 0; const S = this.gl; const E = this.currentActiveTexture; return T.glIndexCounter < this.startActiveTexture && (T.glIndexCounter = this.startActiveTexture, E < this.maxTextures ? (T.glIndex = E, S.activeTexture(S.TEXTURE0 + E), S.bindTexture(S.TEXTURE_2D, T.glTexture), this.currentActiveTexture++) : (this.flush(), this.startActiveTexture++, this.textureFlush++, T.glIndexCounter = this.startActiveTexture, T.glIndex = 1, S.activeTexture(S.TEXTURE1), S.bindTexture(S.TEXTURE_2D, T.glTexture), this.currentActiveTexture = 2)), this.isTextureClean = !1, T.glIndex },
          isNewNormalMap: function (T, S) { return this.textureZero !== T || this.normalTexture !== S },
          setTextureZero: function (T, S) { if (this.textureZero !== T) { S && this.flush(); const E = this.gl; E.activeTexture(E.TEXTURE0), E.bindTexture(E.TEXTURE_2D, T), this.textureZero = T } },
          clearTextureZero: function () { this.textureZero = null },
          setNormalMap: function (T) { if (this.normalTexture !== T) { const S = this.gl; S.activeTexture(S.TEXTURE1), S.bindTexture(S.TEXTURE_2D, T), this.normalTexture = T, this.currentActiveTexture === 1 && (this.currentActiveTexture = 2) } },
          clearNormalMap: function () { this.normalTexture = null, this.startActiveTexture++, this.currentActiveTexture = 1, this.textureFlush++ },
          unbindTextures: function () { for (let T = this.gl, S = this.tempTextures, E = 0; E < S.length; E++)T.activeTexture(T.TEXTURE0 + E), T.bindTexture(T.TEXTURE_2D, null); this.normalTexture = null, this.textureZero = null, this.currentActiveTexture = 1, this.startActiveTexture++, this.textureFlush++ },
          resetTextures: function (T) { if (T === void 0 && (T = !1), !this.isTextureClean) { this.flush(); const S = this.gl; const E = this.tempTextures; if (T) { for (let C = 0; C < E.length; C++)S.activeTexture(S.TEXTURE0 + C), S.bindTexture(S.TEXTURE_2D, E[C]); S.activeTexture(S.TEXTURE1), S.bindTexture(S.TEXTURE_2D, E[1]), this.isTextureClean = !0 } else S.activeTexture(S.TEXTURE0), S.bindTexture(S.TEXTURE_2D, E[0]), S.activeTexture(S.TEXTURE1), S.bindTexture(S.TEXTURE_2D, E[1]); this.normalTexture = null, this.textureZero = null, this.currentActiveTexture = 1, this.startActiveTexture++, this.textureFlush++ } },
          setTexture2D: function (T) { if (this.pipelines.forceZero()) return this.setTextureZero(T, !0), 0; const S = this.gl; const E = this.currentActiveTexture; return T.glIndexCounter < this.startActiveTexture && (T.glIndexCounter = this.startActiveTexture, E < this.maxTextures ? (T.glIndex = E, S.activeTexture(S.TEXTURE0 + E), S.bindTexture(S.TEXTURE_2D, T), this.currentActiveTexture++) : (this.flush(), this.startActiveTexture++, this.textureFlush++, T.glIndexCounter = this.startActiveTexture, T.glIndex = 1, S.activeTexture(S.TEXTURE1), S.bindTexture(S.TEXTURE_2D, T), this.currentActiveTexture = 2)), this.isTextureClean = !1, T.glIndex },
          pushFramebuffer: function (T, S, E, C) { return T === this.currentFramebuffer ? this : (this.fboStack.push(T), this.setFramebuffer(T, S, E, C)) },
          setFramebuffer: function (T, S, E, C) { if (S === void 0 && (S = !1), E === void 0 && (E = !1), C === void 0 && (C = !0), T === this.currentFramebuffer) return this; const P = this.gl; let A = this.width; let M = this.height; return T && T.renderTexture && C ? (A = T.renderTexture.width, M = T.renderTexture.height) : this.flush(), P.bindFramebuffer(P.FRAMEBUFFER, T), C && P.viewport(0, 0, A, M), S && (T ? (this.drawingBufferHeight = M, this.pushScissor(0, 0, A, M)) : (this.drawingBufferHeight = this.height, this.popScissor())), this.currentFramebuffer = T, E && this.resetTextures(), this },
          popFramebuffer: function (T, S, E) { T === void 0 && (T = !1), S === void 0 && (S = !1), E === void 0 && (E = !0); const C = this.fboStack; C.pop(); let P = C[C.length - 1]; return P || (P = null), this.setFramebuffer(P, T, S, E), P },
          setProgram: function (T) { return T !== this.currentProgram ? (this.flush(), this.gl.useProgram(T), this.currentProgram = T, !0) : !1 },
          resetProgram: function () { return this.gl.useProgram(this.currentProgram), this },
          createTextureFromSource: function (T, S, E, C) { const P = this.gl; let A = P.NEAREST; let M = P.NEAREST; let L = P.CLAMP_TO_EDGE; let F = null; S = T ? T.width : S, E = T ? T.height : E; const I = f(S, E); return I && (L = P.REPEAT), C === o.ScaleModes.LINEAR && this.config.antialias && (A = I ? this.mipmapFilter : P.LINEAR, M = P.LINEAR), !T && typeof S === 'number' && typeof E === 'number' ? F = this.createTexture2D(0, A, M, L, L, P.RGBA, null, S, E) : F = this.createTexture2D(0, A, M, L, L, P.RGBA, T), F },
          createTexture2D: function (T, S, E, C, P, A, M, L, F, I, G, U) { I = I == null ? !0 : I, G === void 0 && (G = !1), U === void 0 && (U = !1); const Y = this.gl; const X = Y.createTexture(); Y.activeTexture(Y.TEXTURE0); const O = Y.getParameter(Y.TEXTURE_BINDING_2D); return Y.bindTexture(Y.TEXTURE_2D, X), Y.texParameteri(Y.TEXTURE_2D, Y.TEXTURE_MIN_FILTER, S), Y.texParameteri(Y.TEXTURE_2D, Y.TEXTURE_MAG_FILTER, E), Y.texParameteri(Y.TEXTURE_2D, Y.TEXTURE_WRAP_S, P), Y.texParameteri(Y.TEXTURE_2D, Y.TEXTURE_WRAP_T, C), Y.pixelStorei(Y.UNPACK_PREMULTIPLY_ALPHA_WEBGL, I), Y.pixelStorei(Y.UNPACK_FLIP_Y_WEBGL, U), M == null ? Y.texImage2D(Y.TEXTURE_2D, T, A, L, F, 0, A, Y.UNSIGNED_BYTE, null) : (G || (L = M.width, F = M.height), Y.texImage2D(Y.TEXTURE_2D, T, A, A, Y.UNSIGNED_BYTE, M)), f(L, F) && Y.generateMipmap(Y.TEXTURE_2D), O && Y.bindTexture(Y.TEXTURE_2D, O), X.isAlphaPremultiplied = I, X.isRenderTexture = !1, X.width = L, X.height = F, X.glIndex = 0, X.glIndexCounter = -1, X },
          createFramebuffer: function (T, S, E, C) { const P = this.gl; const A = P.createFramebuffer(); let M = 0; if (this.setFramebuffer(A), C) { const L = P.createRenderbuffer(); P.bindRenderbuffer(P.RENDERBUFFER, L), P.renderbufferStorage(P.RENDERBUFFER, P.DEPTH_STENCIL, T, S), P.framebufferRenderbuffer(P.FRAMEBUFFER, P.DEPTH_STENCIL_ATTACHMENT, P.RENDERBUFFER, L) } if (E.isRenderTexture = !0, E.isAlphaPremultiplied = !1, P.framebufferTexture2D(P.FRAMEBUFFER, P.COLOR_ATTACHMENT0, P.TEXTURE_2D, E, 0), M = P.checkFramebufferStatus(P.FRAMEBUFFER), M !== P.FRAMEBUFFER_COMPLETE) { const F = { 36054: 'Incomplete Attachment', 36055: 'Missing Attachment', 36057: 'Incomplete Dimensions', 36061: 'Framebuffer Unsupported' }; throw new Error('Framebuffer status: ' + F[M]) } return A.renderTexture = E, this.setFramebuffer(null), this.resetTextures(), A },
          createProgram: function (T, S) {
            const E = this.gl; const C = E.createProgram(); const P = E.createShader(E.VERTEX_SHADER); const A = E.createShader(E.FRAGMENT_SHADER); if (E.shaderSource(P, T), E.shaderSource(A, S), E.compileShader(P), E.compileShader(A), !E.getShaderParameter(P, E.COMPILE_STATUS)) {
              throw new Error(`Vertex Shader failed:
` + E.getShaderInfoLog(P))
            } if (!E.getShaderParameter(A, E.COMPILE_STATUS)) {
              throw new Error(`Fragment Shader failed:
` + E.getShaderInfoLog(A))
            } if (E.attachShader(C, P), E.attachShader(C, A), E.linkProgram(C), !E.getProgramParameter(C, E.LINK_STATUS)) {
              throw new Error(`Link Program failed:
` + E.getProgramInfoLog(C))
            } return E.useProgram(C), C
          },
          createVertexBuffer: function (T, S) { const E = this.gl; const C = E.createBuffer(); return E.bindBuffer(E.ARRAY_BUFFER, C), E.bufferData(E.ARRAY_BUFFER, T, S), E.bindBuffer(E.ARRAY_BUFFER, null), C },
          createIndexBuffer: function (T, S) { const E = this.gl; const C = E.createBuffer(); return E.bindBuffer(E.ELEMENT_ARRAY_BUFFER, C), E.bufferData(E.ELEMENT_ARRAY_BUFFER, T, S), E.bindBuffer(E.ELEMENT_ARRAY_BUFFER, null), C },
          deleteTexture: function (T, S) { return S && this.resetTextures(!0), T && this.gl.deleteTexture(T), this },
          deleteFramebuffer: function (T) { return T && (this.gl.deleteFramebuffer(T), i(this.fboStack, T), this.currentFramebuffer === T && (this.currentFramebuffer = null)), this },
          deleteProgram: function (T) { return T && this.gl.deleteProgram(T), this },
          deleteBuffer: function (T) { return this.gl.deleteBuffer(T), this },
          preRenderCamera: function (T) { const S = T.x; const E = T.y; const C = T.width; const P = T.height; const A = T.backgroundColor; if (T.emit(h.PRE_RENDER, T), this.pipelines.preBatchCamera(T), this.pushScissor(S, E, C, P), T.mask && (this.currentCameraMask.mask = T.mask, this.currentCameraMask.camera = T._maskCamera, T.mask.preRenderWebGL(this, T, T._maskCamera)), A.alphaGL > 0) { const M = this.pipelines.setMulti(); M.drawFillRect(S, E, C, P, g.getTintFromFloats(A.blueGL, A.greenGL, A.redGL, 1), A.alphaGL) } },
          getCurrentStencilMask: function () { let T = null; const S = this.maskStack; const E = this.currentCameraMask; return S.length > 0 ? T = S[S.length - 1] : E.mask && E.mask.isStencil && (T = E), T },
          postRenderCamera: function (T) { const S = T.flashEffect; const E = T.fadeEffect; if (S.isRunning || E.isRunning || E.isComplete) { const C = this.pipelines.setMulti(); S.postRenderWebGL(C, g.getTintFromFloats), E.postRenderWebGL(C, g.getTintFromFloats) }T.dirty = !1, this.popScissor(), T.mask && (this.currentCameraMask.mask = null, T.mask.postRenderWebGL(this, T._maskCamera)), this.pipelines.postBatchCamera(T), T.emit(h.POST_RENDER, T) },
          preRender: function () { if (!this.contextLost) { const T = this.gl; if (T.bindFramebuffer(T.FRAMEBUFFER, null), this.config.clearBeforeRender) { const S = this.config.backgroundColor; T.clearColor(S.redGL, S.greenGL, S.blueGL, S.alphaGL), T.clear(T.COLOR_BUFFER_BIT | T.DEPTH_BUFFER_BIT | T.STENCIL_BUFFER_BIT) }T.enable(T.SCISSOR_TEST), this.currentScissor = this.defaultScissor, this.scissorStack.length = 0, this.scissorStack.push(this.currentScissor), this.game.scene.customViewports && T.scissor(0, this.drawingBufferHeight - this.height, this.width, this.height), this.currentMask.mask = null, this.currentCameraMask.mask = null, this.maskStack.length = 0, this.textureFlush = 0, this.emit(s.PRE_RENDER) } },
          render: function (T, S, E) { if (!this.contextLost) { const C = S.length; if (this.emit(s.RENDER, T, E), this.preRenderCamera(E), C === 0) { this.setBlendMode(o.BlendModes.NORMAL), this.postRenderCamera(E); return } this.currentType = ''; for (var P = this.currentMask, A = 0; A < C; A++) { this.finalType = A === C - 1; const M = S[A]; const L = M.mask; P = this.currentMask, P.mask && P.mask !== L && P.mask.postRenderWebGL(this, P.camera), L && P.mask !== L && L.preRenderWebGL(this, M, E), M.blendMode !== this.currentBlendMode && this.setBlendMode(M.blendMode); const F = M.type; F !== this.currentType && (this.newType = !0, this.currentType = F), this.finalType ? this.nextTypeMatch = !1 : this.nextTypeMatch = S[A + 1].type === this.currentType, M.renderWebGL(this, M, E), this.newType = !1 }P = this.currentMask, P.mask && P.mask.postRenderWebGL(this, P.camera), this.setBlendMode(o.BlendModes.NORMAL), this.postRenderCamera(E) } },
          postRender: function () { if (!this.contextLost) { this.flush(), this.emit(s.POST_RENDER); const T = this.snapshotState; T.callback && (x(this.canvas, T), T.callback = null), this.textureFlush > 0 && (this.startActiveTexture++, this.currentActiveTexture = 1) } },
          snapshot: function (T, S, E) { return this.snapshotArea(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight, T, S, E) },
          snapshotArea: function (T, S, E, C, P, A, M) { const L = this.snapshotState; return L.callback = P, L.type = A, L.encoder = M, L.getPixel = !1, L.x = T, L.y = S, L.width = Math.min(E, this.gl.drawingBufferWidth), L.height = Math.min(C, this.gl.drawingBufferHeight), this },
          snapshotPixel: function (T, S, E) { return this.snapshotArea(T, S, 1, 1, E), this.snapshotState.getPixel = !0, this },
          snapshotFramebuffer: function (T, S, E, C, P, A, M, L, F, I, G) { P === void 0 && (P = !1), A === void 0 && (A = 0), M === void 0 && (M = 0), L === void 0 && (L = S), F === void 0 && (F = E); const U = this.currentFramebuffer; this.snapshotArea(A, M, L, F, C, I, G); const Y = this.snapshotState; return Y.getPixel = P, Y.isFramebuffer = !0, Y.bufferWidth = S, Y.bufferHeight = E, this.setFramebuffer(T), x(this.canvas, Y), this.setFramebuffer(U), Y.callback = null, Y.isFramebuffer = !1, this },
          canvasToTexture: function (T, S, E, C) { return E === void 0 && (E = !1), C === void 0 && (C = !1), S ? this.updateCanvasTexture(T, S, C) : this.createCanvasTexture(T, E, C) },
          createCanvasTexture: function (T, S, E) { S === void 0 && (S = !1), E === void 0 && (E = !1); const C = this.gl; let P = C.NEAREST; let A = C.NEAREST; const M = T.width; const L = T.height; let F = C.CLAMP_TO_EDGE; const I = f(M, L); return !S && I && (F = C.REPEAT), this.config.antialias && (P = I ? this.mipmapFilter : C.LINEAR, A = C.LINEAR), this.createTexture2D(0, P, A, F, F, C.RGBA, T, M, L, !0, !1, E) },
          updateCanvasTexture: function (T, S, E) { E === void 0 && (E = !1); const C = this.gl; const P = T.width; const A = T.height; if (P > 0 && A > 0) { C.activeTexture(C.TEXTURE0); const M = C.getParameter(C.TEXTURE_BINDING_2D); C.bindTexture(C.TEXTURE_2D, S), C.pixelStorei(C.UNPACK_FLIP_Y_WEBGL, E), C.pixelStorei(C.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !0), C.texImage2D(C.TEXTURE_2D, 0, C.RGBA, C.RGBA, C.UNSIGNED_BYTE, T), S.width = P, S.height = A, M && C.bindTexture(C.TEXTURE_2D, M) } return S },
          createVideoTexture: function (T, S, E) { S === void 0 && (S = !1), E === void 0 && (E = !1); const C = this.gl; let P = C.NEAREST; let A = C.NEAREST; const M = T.videoWidth; const L = T.videoHeight; let F = C.CLAMP_TO_EDGE; const I = f(M, L); return !S && I && (F = C.REPEAT), this.config.antialias && (P = I ? this.mipmapFilter : C.LINEAR, A = C.LINEAR), this.createTexture2D(0, P, A, F, F, C.RGBA, T, M, L, !0, !0, E) },
          updateVideoTexture: function (T, S, E) { E === void 0 && (E = !1); const C = this.gl; const P = T.videoWidth; const A = T.videoHeight; if (P > 0 && A > 0) { C.activeTexture(C.TEXTURE0); const M = C.getParameter(C.TEXTURE_BINDING_2D); C.bindTexture(C.TEXTURE_2D, S), C.pixelStorei(C.UNPACK_FLIP_Y_WEBGL, E), C.texImage2D(C.TEXTURE_2D, 0, C.RGBA, C.RGBA, C.UNSIGNED_BYTE, T), S.width = P, S.height = A, M && C.bindTexture(C.TEXTURE_2D, M) } return S },
          setTextureFilter: function (T, S) { const E = this.gl; const C = [E.LINEAR, E.NEAREST][S]; E.activeTexture(E.TEXTURE0); const P = E.getParameter(E.TEXTURE_BINDING_2D); return E.bindTexture(E.TEXTURE_2D, T), E.texParameteri(E.TEXTURE_2D, E.TEXTURE_MIN_FILTER, C), E.texParameteri(E.TEXTURE_2D, E.TEXTURE_MAG_FILTER, C), P && E.bindTexture(E.TEXTURE_2D, P), this },
          getMaxTextureSize: function () { return this.config.maxTextureSize },
          destroy: function () { this.canvas.removeEventListener('webglcontextlost', this.contextLostHandler, !1), this.canvas.removeEventListener('webglcontextrestored', this.contextRestoredHandler, !1); for (let T = this.gl, S = this.tempTextures, E = 0; E < S.length; E++)T.deleteTexture(S[E]); this.pipelines.destroy(), this.removeAllListeners(), this.fboStack = [], this.maskStack = [], this.extensions = {}, this.textureIndexes = [], this.gl = null, this.game = null, this.canvas = null, this.contextLost = !0, this.currentMask = null, this.currentCameraMask = null }
        }); e.exports = y
      }, function (e, d, t) { const i = t(0); const h = t(92); const n = t(102); const o = t(373); const r = t(376); const s = t(377); const a = t(108); const f = t(378); const l = t(379); const u = t(380); const v = t(381); const p = new i({ initialize: function (m) { this.game = m.game, this.renderer = m, this.classes = new n([[h.UTILITY_PIPELINE, v], [h.MULTI_PIPELINE, a], [h.BITMAPMASK_PIPELINE, o], [h.SINGLE_PIPELINE, u], [h.ROPE_PIPELINE, l], [h.LIGHT_PIPELINE, s], [h.POINTLIGHT_PIPELINE, f], [h.GRAPHICS_PIPELINE, r]]), this.postPipelineClasses = new n(), this.pipelines = new n(), this.current = null, this.previous = null, this.MULTI_PIPELINE = null, this.BITMAPMASK_PIPELINE = null, this.UTILITY_PIPELINE = null, this.fullFrame1, this.fullFrame2, this.halfFrame1, this.halfFrame2 }, boot: function (c) { let m; let g; const x = this; const y = this.game; if (this.classes.each(function (S, E) { m = x.add(S, new E({ game: y })), S === h.UTILITY_PIPELINE && (x.UTILITY_PIPELINE = m, x.fullFrame1 = m.fullFrame1, x.fullFrame2 = m.fullFrame2, x.halfFrame1 = m.halfFrame1, x.halfFrame2 = m.halfFrame2) }), this.MULTI_PIPELINE = this.get(h.MULTI_PIPELINE), this.BITMAPMASK_PIPELINE = this.get(h.BITMAPMASK_PIPELINE), c) for (g in c) { const T = c[g]; m = new T(y), m.isPostFX ? this.postPipelineClasses.set(g, T) : this.has(g) || (this.classes.set(g, T), this.add(g, m)) } }, add: function (c, m) { if (m.isPostFX) { console.warn(c + ' is a Post Pipeline. Use `addPostPipeline` instead'); return } const g = this.pipelines; const x = this.renderer; return g.has(c) ? console.warn('Pipeline exists: ' + c) : (m.name = c, m.manager = this, g.set(c, m)), m.hasBooted || m.boot(), x.width !== 0 && x.height !== 0 && m.resize(x.width, x.height), m }, addPostPipeline: function (c, m) { this.postPipelineClasses.has(c) || this.postPipelineClasses.set(c, m) }, flush: function () { this.current && this.current.flush() }, has: function (c) { const m = this.pipelines; return typeof c === 'string' ? m.has(c) : !!m.contains(c) }, get: function (c) { const m = this.pipelines; if (typeof c === 'string') return m.get(c); if (m.contains(c)) return c }, getPostPipeline: function (c, m) { const g = this.postPipelineClasses; let x; if (typeof c === 'string' ? x = g.get(c) : typeof c === 'function' ? g.contains(c) && (x = c) : typeof c === 'object' && (x = g.get(c.name)), x) { const y = new x(this.game); return m && (y.gameObject = m), y } }, remove: function (c, m, g) { m === void 0 && (m = !0), g === void 0 && (g = !0), this.pipelines.delete(c), m && this.classes.delete(c), g && this.postPipelineClasses.delete(c) }, set: function (c, m, g) { if (!c.isPostFX) return this.isCurrent(c, g) || (this.flush(), this.current && this.current.unbind(), this.current = c, c.bind(g)), c.updateProjectionMatrix(), c.onBind(m), c }, preBatch: function (c) { if (c.hasPostPipeline) { this.flush(); for (let m = c.postPipelines, g = m.length - 1; g >= 0; g--) { const x = m[g]; x.active && x.preBatch(c) } } }, postBatch: function (c) { if (c.hasPostPipeline) { this.flush(); for (let m = c.postPipelines, g = 0; g < m.length; g++) { const x = m[g]; x.active && x.postBatch(c) } } }, preBatchCamera: function (c) { if (c.hasPostPipeline) { this.flush(); for (let m = c.postPipelines, g = m.length - 1; g >= 0; g--) { const x = m[g]; x.active && x.preBatch(c) } } }, postBatchCamera: function (c) { if (c.hasPostPipeline) { this.flush(); for (let m = c.postPipelines, g = 0; g < m.length; g++) { const x = m[g]; x.active && x.postBatch(c) } } }, isCurrent: function (c, m) { const g = this.renderer; const x = this.current; return x && !m && (m = x.currentShader), !(x !== c || m.program !== g.currentProgram) }, copyFrame: function (c, m, g, x, y) { return this.setUtility(this.UTILITY_PIPELINE.copyShader).copyFrame(c, m, g, x, y), this }, copyToGame: function (c) { return this.setUtility(this.UTILITY_PIPELINE.copyShader).copyToGame(c), this }, drawFrame: function (c, m, g, x) { return this.setUtility(this.UTILITY_PIPELINE.colorMatrixShader).drawFrame(c, m, g, x), this }, blendFrames: function (c, m, g, x, y) { return this.setUtility(this.UTILITY_PIPELINE.linearShader).blendFrames(c, m, g, x, y), this }, blendFramesAdditive: function (c, m, g, x, y) { return this.setUtility(this.UTILITY_PIPELINE.addShader).blendFramesAdditive(c, m, g, x, y), this }, clearFrame: function (c, m) { return this.UTILITY_PIPELINE.clearFrame(c, m), this }, blitFrame: function (c, m, g, x, y, T) { return this.setUtility(this.UTILITY_PIPELINE.copyShader).blitFrame(c, m, g, x, y, T), this }, copyFrameRect: function (c, m, g, x, y, T, S, E) { return this.UTILITY_PIPELINE.copyFrameRect(c, m, g, x, y, T, S, E), this }, forceZero: function () { return this.current && this.current.forceZero }, setMulti: function () { return this.set(this.MULTI_PIPELINE) }, setUtility: function (c) { return this.UTILITY_PIPELINE.bind(c) }, rebind: function (c) { c === void 0 && this.previous && (c = this.previous); const m = this.renderer; const g = m.gl; g.disable(g.DEPTH_TEST), g.disable(g.CULL_FACE), m.hasActiveStencilMask() ? g.clear(g.DEPTH_BUFFER_BIT) : (g.disable(g.STENCIL_TEST), g.clear(g.DEPTH_BUFFER_BIT | g.STENCIL_BUFFER_BIT)), g.viewport(0, 0, m.width, m.height), m.currentProgram = null, m.setBlendMode(0, !0); const x = this.pipelines.entries; for (const y in x)x[y].glReset = !0; c && (this.current = c, c.rebind()), m.resetTextures() }, clear: function () { const c = this.renderer; this.flush(), this.current ? (this.current.unbind(), this.previous = this.current, this.current = null) : this.previous = null, c.currentProgram = null, c.setBlendMode(0, !0) }, destroy: function () { this.flush(), this.classes.clear(), this.postPipelineClasses.clear(), this.pipelines.clear(), this.renderer = null, this.game = null, this.classes = null, this.postPipelineClasses = null, this.pipelines = null, this.current = null, this.previous = null } }); e.exports = p }, function (e, d, t) { const i = t(0); const h = t(2); const n = t(866); const o = t(867); const r = t(107); const s = t(58); const a = new i({ Extends: s, initialize: function (l) { l.fragShader = h(l, 'fragShader', n), l.vertShader = h(l, 'vertShader', o), l.batchSize = h(l, 'batchSize', 1), l.vertices = h(l, 'vertices', [-1, 1, -1, -7, 7, 1]), l.attributes = h(l, 'attributes', [{ name: 'inPosition', size: 2, type: r.FLOAT }]), s.call(this, l) }, boot: function () { s.prototype.boot.call(this), this.set1i('uMainSampler', 0), this.set1i('uMaskSampler', 1) }, resize: function (f, l) { s.prototype.resize.call(this, f, l), this.set2f('uResolution', f, l) }, beginMask: function (f, l, u) { const v = this.gl; if (f.bitmapMask && v) { const p = this.renderer; p.flush(), p.pushFramebuffer(f.mainFramebuffer), v.disable(v.STENCIL_TEST), v.clearColor(0, 0, 0, 0), v.clear(v.COLOR_BUFFER_BIT), p.currentCameraMask.mask !== f && (p.currentMask.mask = f, p.currentMask.camera = u) } }, endMask: function (f, l) { const u = this.gl; const v = this.renderer; const p = f.bitmapMask; if (p && u) { v.flush(), v.pushFramebuffer(f.maskFramebuffer), u.clearColor(0, 0, 0, 0), u.clear(u.COLOR_BUFFER_BIT), v.setBlendMode(0, !0), p.renderWebGL(v, p, l), v.flush(), v.popFramebuffer(), v.popFramebuffer(); const c = v.getCurrentStencilMask(); c ? (u.enable(u.STENCIL_TEST), c.mask.applyStencil(v, c.camera, !0)) : v.currentMask.mask = null, v.pipelines.set(this), u.activeTexture(u.TEXTURE1), u.bindTexture(u.TEXTURE_2D, f.maskTexture), u.activeTexture(u.TEXTURE0), u.bindTexture(u.TEXTURE_2D, f.mainTexture), this.set1i('uInvertMaskAlpha', f.invertAlpha), u.drawArrays(this.topology, 0, 3), v.resetTextures() } } }); e.exports = a }, function (e, d, t) { e.exports = { AFTER_FLUSH: t(868), BEFORE_FLUSH: t(869), BIND: t(870), BOOT: t(871), DESTROY: t(872), REBIND: t(873), RESIZE: t(874) } }, function (e, d, t) { const i = t(0); const h = t(2); const n = t(107); const o = new i({ initialize: function (s, a, f, l, u) { this.pipeline = s, this.name = a, this.renderer = s.renderer, this.gl = this.renderer.gl, this.program = this.renderer.createProgram(f, l), this.attributes, this.vertexComponentCount = 0, this.vertexSize = 0, this.uniforms = {}, this.createAttributes(u), this.createUniforms() }, createAttributes: function (r) { let s = 0; let a = 0; const f = []; this.vertexComponentCount = 0; for (let l = 0; l < r.length; l++) { const u = r[l]; const v = u.name; const p = h(u, 'size', 1); const c = h(u, 'type', n.FLOAT); const m = c.enum; const g = c.size; const x = !!u.normalized; f.push({ name: v, size: p, type: m, normalized: x, offset: a, enabled: !1, location: -1 }), g === 4 ? s += p : s++, a += p * g } this.vertexSize = a, this.vertexComponentCount = s, this.attributes = f }, bind: function (r, s) { return r === void 0 && (r = !1), s === void 0 && (s = !1), s && this.pipeline.flush(), this.renderer.setProgram(this.program), r && this.setAttribPointers(), this }, rebind: function () { return this.renderer.setProgram(this.program), this.setAttribPointers(!0), this }, setAttribPointers: function (r) { r === void 0 && (r = !1); for (let s = this.gl, a = this.vertexSize, f = this.attributes, l = this.program, u = 0; u < f.length; u++) { const v = f[u]; const p = v.size; const c = v.type; const m = v.offset; const g = v.enabled; const x = v.location; const y = !!v.normalized; if (r) { const T = s.getAttribLocation(l, v.name); T >= 0 ? (s.enableVertexAttribArray(T), s.vertexAttribPointer(T, p, c, y, a, m), v.enabled = !0, v.location = T) : T !== -1 && s.disableVertexAttribArray(T) } else g ? s.vertexAttribPointer(x, p, c, y, a, m) : !g && x > -1 && (s.disableVertexAttribArray(x), v.location = -1) } return this }, createUniforms: function () { const r = this.gl; const s = this.program; const a = this.uniforms; let f; let l; let u; const v = r.getProgramParameter(s, r.ACTIVE_UNIFORMS); for (f = 0; f < v; f++) { const p = r.getActiveUniform(s, f); if (p) { l = p.name, u = r.getUniformLocation(s, l), u !== null && (a[l] = { name: l, location: u, value1: null, value2: null, value3: null, value4: null }); const c = l.indexOf('['); c > 0 && (l = l.substr(0, c), a.hasOwnProperty(l) || (u = r.getUniformLocation(s, l), u !== null && (a[l] = { name: l, location: u, value1: null, value2: null, value3: null, value4: null }))) } } return this }, hasUniform: function (r) { return this.uniforms.hasOwnProperty(r) }, resetUniform: function (r) { const s = this.uniforms[r]; return s && (s.value1 = null, s.value2 = null, s.value3 = null, s.value4 = null), this }, setUniform1: function (r, s, a, f) { const l = this.uniforms[s]; return l ? ((f || l.value1 !== a) && (l.value1 = a, this.renderer.setProgram(this.program), r.call(this.gl, l.location, a), this.pipeline.currentShader = this), this) : this }, setUniform2: function (r, s, a, f, l) { const u = this.uniforms[s]; return u ? ((l || u.value1 !== a || u.value2 !== f) && (u.value1 = a, u.value2 = f, this.renderer.setProgram(this.program), r.call(this.gl, u.location, a, f), this.pipeline.currentShader = this), this) : this }, setUniform3: function (r, s, a, f, l, u) { const v = this.uniforms[s]; return v ? ((u || v.value1 !== a || v.value2 !== f || v.value3 !== l) && (v.value1 = a, v.value2 = f, v.value3 = l, this.renderer.setProgram(this.program), r.call(this.gl, v.location, a, f, l), this.pipeline.currentShader = this), this) : this }, setUniform4: function (r, s, a, f, l, u, v) { const p = this.uniforms[s]; return p ? ((v || p.value1 !== a || p.value2 !== f || p.value3 !== l || p.value4 !== u) && (p.value1 = a, p.value2 = f, p.value3 = l, p.value4 = u, this.renderer.setProgram(this.program), r.call(this.gl, p.location, a, f, l, u), this.pipeline.currentShader = this), this) : this }, set1f: function (r, s) { return this.setUniform1(this.gl.uniform1f, r, s) }, set2f: function (r, s, a) { return this.setUniform2(this.gl.uniform2f, r, s, a) }, set3f: function (r, s, a, f) { return this.setUniform3(this.gl.uniform3f, r, s, a, f) }, set4f: function (r, s, a, f, l) { return this.setUniform4(this.gl.uniform4f, r, s, a, f, l) }, set1fv: function (r, s) { return this.setUniform1(this.gl.uniform1fv, r, s, !0) }, set2fv: function (r, s) { return this.setUniform1(this.gl.uniform2fv, r, s, !0) }, set3fv: function (r, s) { return this.setUniform1(this.gl.uniform3fv, r, s, !0) }, set4fv: function (r, s) { return this.setUniform1(this.gl.uniform4fv, r, s, !0) }, set1iv: function (r, s) { return this.setUniform1(this.gl.uniform1iv, r, s, !0) }, set2iv: function (r, s) { return this.setUniform1(this.gl.uniform2iv, r, s, !0) }, set3iv: function (r, s) { return this.setUniform1(this.gl.uniform3iv, r, s, !0) }, set4iv: function (r, s) { return this.setUniform1(this.gl.uniform4iv, r, s, !0) }, set1i: function (r, s) { return this.setUniform1(this.gl.uniform1i, r, s) }, set2i: function (r, s, a) { return this.setUniform2(this.gl.uniform2i, r, s, a) }, set3i: function (r, s, a, f) { return this.setUniform3(this.gl.uniform3i, r, s, a, f) }, set4i: function (r, s, a, f, l) { return this.setUniform4(this.gl.uniform4i, r, s, a, f, l) }, setMatrix2fv: function (r, s, a) { return this.setUniform2(this.gl.uniformMatrix2fv, r, s, a, !0) }, setMatrix3fv: function (r, s, a) { return this.setUniform2(this.gl.uniformMatrix3fv, r, s, a, !0) }, setMatrix4fv: function (r, s, a) { return this.setUniform2(this.gl.uniformMatrix4fv, r, s, a, !0) }, destroy: function () { this.gl.deleteProgram(this.program), this.pipeline = null, this.renderer = null, this.gl = null, this.program = null, this.attributes = null, this.uniforms = null } }); e.exports = o }, function (e, d, t) { const i = t(0); const h = t(59); const n = t(2); const o = t(875); const r = t(876); const s = t(25); const a = t(107); const f = t(58); const l = new i({ Extends: f, initialize: function (v) { v.fragShader = n(v, 'fragShader', o), v.vertShader = n(v, 'vertShader', r), v.attributes = n(v, 'attributes', [{ name: 'inPosition', size: 2 }, { name: 'inColor', size: 4, type: a.UNSIGNED_BYTE, normalized: !0 }]), f.call(this, v), this.calcMatrix = new s(), this.tempTriangle = [{ x: 0, y: 0, width: 0 }, { x: 0, y: 0, width: 0 }, { x: 0, y: 0, width: 0 }, { x: 0, y: 0, width: 0 }], this.strokeTint = { TL: 0, TR: 0, BL: 0, BR: 0 }, this.fillTint = { TL: 0, TR: 0, BL: 0, BR: 0 }, this.currentFrame = { u0: 0, v0: 0, u1: 1, v1: 1 }, this.firstQuad = [0, 0, 0, 0, 0], this.prevQuad = [0, 0, 0, 0, 0], this.polygonCache = [] }, batchFillRect: function (u, v, p, c, m, g) { this.renderer.pipelines.set(this); const x = this.calcMatrix; g && g.multiply(m, x); const y = u + p; const T = v + c; const S = x.getX(u, v); const E = x.getY(u, v); const C = x.getX(u, T); const P = x.getY(u, T); const A = x.getX(y, T); const M = x.getY(y, T); const L = x.getX(y, v); const F = x.getY(y, v); const I = this.fillTint; this.batchQuad(S, E, C, P, A, M, L, F, I.TL, I.TR, I.BL, I.BR) }, batchFillTriangle: function (u, v, p, c, m, g, x, y) { this.renderer.pipelines.set(this); const T = this.calcMatrix; y && y.multiply(x, T); const S = T.getX(u, v); const E = T.getY(u, v); const C = T.getX(p, c); const P = T.getY(p, c); const A = T.getX(m, g); const M = T.getY(m, g); const L = this.fillTint; this.batchTri(S, E, C, P, A, M, L.TL, L.TR, L.BL) }, batchStrokeTriangle: function (u, v, p, c, m, g, x, y, T) { const S = this.tempTriangle; S[0].x = u, S[0].y = v, S[0].width = x, S[1].x = p, S[1].y = c, S[1].width = x, S[2].x = m, S[2].y = g, S[2].width = x, S[3].x = u, S[3].y = v, S[3].width = x, this.batchStrokePath(S, x, !1, y, T) }, batchFillPath: function (u, v, p) { this.renderer.pipelines.set(this); const c = this.calcMatrix; p && p.multiply(v, c); for (var m = u.length, g = this.polygonCache, x, y, T = this.fillTint.TL, S = this.fillTint.TR, E = this.fillTint.BL, C = 0; C < m; ++C)y = u[C], g.push(y.x, y.y); x = h(g), m = x.length; for (let P = 0; P < m; P += 3) { const A = x[P + 0] * 2; const M = x[P + 1] * 2; const L = x[P + 2] * 2; const F = g[A + 0]; const I = g[A + 1]; const G = g[M + 0]; const U = g[M + 1]; const Y = g[L + 0]; const X = g[L + 1]; const O = c.getX(F, I); const R = c.getY(F, I); const D = c.getX(G, U); const B = c.getY(G, U); const N = c.getX(Y, X); const w = c.getY(Y, X); this.batchTri(O, R, D, B, N, w, T, S, E) }g.length = 0 }, batchStrokePath: function (u, v, p, c, m) { this.renderer.pipelines.set(this), this.prevQuad[4] = 0, this.firstQuad[4] = 0; for (let g = u.length - 1, x = 0; x < g; x++) { const y = u[x]; const T = u[x + 1]; this.batchLine(y.x, y.y, T.x, T.y, y.width / 2, T.width / 2, v, x, !p && x === g - 1, c, m) } }, batchLine: function (u, v, p, c, m, g, x, y, T, S, E) { this.renderer.pipelines.set(this); const C = this.calcMatrix; E && E.multiply(S, C); const P = p - u; const A = c - v; const M = Math.sqrt(P * P + A * A); const L = m * (c - v) / M; const F = m * (u - p) / M; const I = g * (c - v) / M; const G = g * (u - p) / M; const U = p - I; const Y = c - G; const X = u - L; const O = v - F; const R = p + I; const D = c + G; const B = u + L; const N = v + F; const w = C.getX(U, Y); const z = C.getY(U, Y); const V = C.getX(X, O); const W = C.getY(X, O); const H = C.getX(R, D); const K = C.getY(R, D); const Q = C.getX(B, N); const J = C.getY(B, N); const q = this.strokeTint; const j = q.TL; const _ = q.TR; const rt = q.BL; const nt = q.BR; if (this.batchQuad(Q, J, V, W, w, z, H, K, j, _, rt, nt), !(x <= 2)) { const et = this.prevQuad; const b = this.firstQuad; y > 0 && et[4] ? this.batchQuad(Q, J, V, W, et[0], et[1], et[2], et[3], j, _, rt, nt) : (b[0] = Q, b[1] = J, b[2] = V, b[3] = W, b[4] = 1), T && b[4] ? this.batchQuad(w, z, H, K, b[0], b[1], b[2], b[3], j, _, rt, nt) : (et[0] = w, et[1] = z, et[2] = H, et[3] = K, et[4] = 1) } }, batchVert: function (u, v, p) { const c = this.vertexViewF32; const m = this.vertexViewU32; let g = this.vertexCount * this.currentShader.vertexComponentCount - 1; c[++g] = u, c[++g] = v, m[++g] = p, this.vertexCount++ }, batchQuad: function (u, v, p, c, m, g, x, y, T, S, E, C) { let P = !1; return this.shouldFlush(6) && (this.flush(), P = !0), this.batchVert(u, v, T), this.batchVert(p, c, E), this.batchVert(m, g, C), this.batchVert(u, v, T), this.batchVert(m, g, C), this.batchVert(x, y, S), P }, batchTri: function (u, v, p, c, m, g, x, y, T) { let S = !1; return this.shouldFlush(3) && (this.flush(), S = !0), this.batchVert(u, v, x), this.batchVert(p, c, y), this.batchVert(m, g, T), S }, destroy: function () { return f.prototype.destroy.call(this), this.polygonCache = null, this } }); e.exports = l }, function (e, d, t) { const i = t(0); const h = t(2); const n = t(877); const o = t(108); const r = t(3); const s = t(58); let a = 10; const f = new r(); const l = new i({ Extends: o, initialize: function (v) { a = v.game.renderer.config.maxLights; for (var p = h(v, 'fragShader', n), c = [], m = 1; m <= a; m++)c.push({ name: 'lights' + m, fragShader: p.replace('%LIGHT_COUNT%', m.toString()) }); v.shaders = c, o.call(this, v), this.inverseRotationMatrix = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]), this.defaultNormalMap, this.lightsActive = !0 }, boot: function () { s.prototype.boot.call(this); const u = this.gl; const v = u.createTexture(); u.activeTexture(u.TEXTURE0), u.bindTexture(u.TEXTURE_2D, v), u.texImage2D(u.TEXTURE_2D, 0, u.RGBA, 1, 1, 0, u.RGBA, u.UNSIGNED_BYTE, new Uint8Array([127, 127, 255, 255])), this.defaultNormalMap = { glTexture: v }; for (let p = 0; p < this.shaders.length; p++) this['lightShader' + (p + 1)] = this.shaders[p] }, onRender: function (u, v) { const p = u.sys.lights; if (this.lightsActive = !1, !(!p || !p.active)) { const c = p.getLights(v); const m = c.length; if (m !== 0) { this.lightsActive = !0, this.setShader(this['lightShader' + m], !0); let g; const x = this.renderer; const y = x.height; const T = v.matrix; for (this.set1i('uMainSampler', 0), this.set1i('uNormSampler', 1), this.set2f('uResolution', this.width / 2, this.height / 2), this.set4f('uCamera', v.x, v.y, v.rotation, v.zoom), this.set3f('uAmbientLightColor', p.ambientColor.r, p.ambientColor.g, p.ambientColor.b), g = 0; g < m; g++) { const S = c[g].light; const E = S.color; const C = 'uLights[' + g + '].'; T.transformPoint(S.x, S.y, f), this.set2f(C + 'position', f.x - v.scrollX * S.scrollFactorX * v.zoom, y - (f.y - v.scrollY * S.scrollFactorY * v.zoom)), this.set3f(C + 'color', E.r, E.g, E.b), this.set1f(C + 'intensity', S.intensity), this.set1f(C + 'radius', S.radius) } this.currentNormalMapRotation = null } } }, setNormalMapRotation: function (u) { if (u !== this.currentNormalMapRotation || this.vertexCount === 0) { this.vertexCount > 0 && this.flush(); const v = this.inverseRotationMatrix; if (u) { const p = -u; const c = Math.cos(p); const m = Math.sin(p); v[1] = m, v[3] = -m, v[0] = v[4] = c } else v[0] = v[4] = 1, v[1] = v[3] = 0; this.setMatrix3fv('uInverseRotationMatrix', !1, v), this.currentNormalMapRotation = u } }, setTexture2D: function (u, v) { const p = this.renderer; u === void 0 && (u = p.tempTextures[0]); const c = this.getNormalMap(v); p.isNewNormalMap(u, c) && (this.flush(), p.setTextureZero(u), p.setNormalMap(c)); const m = v ? v.rotation : 0; return this.setNormalMapRotation(m), this.currentUnit = 0, 0 }, setGameObject: function (u, v) { v === void 0 && (v = u.frame); const p = this.renderer; const c = v.glTexture; const m = this.getNormalMap(u); return p.isNewNormalMap() && (this.flush(), p.setTextureZero(c), p.setNormalMap(m)), this.setNormalMapRotation(u.rotation), this.currentUnit = 0, 0 }, getNormalMap: function (u) { let v; return u ? u.displayTexture ? v = u.displayTexture.dataSource[u.displayFrame.sourceIndex] : u.texture ? v = u.texture.dataSource[u.frame.sourceIndex] : u.tileset && (Array.isArray(u.tileset) ? v = u.tileset[0].image.dataSource[0] : v = u.tileset.image.dataSource[0]) : v = this.defaultNormalMap, v || (v = this.defaultNormalMap), v.glTexture }, batchSprite: function (u, v, p) { this.lightsActive && o.prototype.batchSprite.call(this, u, v, p) }, batchTexture: function (u, v, p, c, m, g, x, y, T, S, E, C, P, A, M, L, F, I, G, U, Y, X, O, R, D, B, N, w, z, V, W, H) { this.lightsActive && o.prototype.batchTexture.call(this, u, v, p, c, m, g, x, y, T, S, E, C, P, A, M, L, F, I, G, U, Y, X, O, R, D, B, N, w, z, V, W, H) }, batchTextureFrame: function (u, v, p, c, m, g, x) { this.lightsActive && o.prototype.batchTextureFrame.call(this, u, v, p, c, m, g, x) } }); l.LIGHT_COUNT = a, e.exports = l }, function (e, d, t) { const i = t(0); const h = t(2); const n = t(880); const o = t(881); const r = t(58); const s = new i({ Extends: r, initialize: function (f) { f.vertShader = h(f, 'vertShader', o), f.fragShader = h(f, 'fragShader', n), f.attributes = h(f, 'attributes', [{ name: 'inPosition', size: 2 }, { name: 'inLightPosition', size: 2 }, { name: 'inLightRadius' }, { name: 'inLightAttenuation' }, { name: 'inLightColor', size: 4 }]), r.call(this, f) }, onRender: function (a, f) { this.set2f('uResolution', this.width, this.height), this.set1f('uCameraZoom', f.zoom) }, batchPointLight: function (a, f, l, u, v, p, c, m, g, x, y, T) { const S = a.color; const E = a.intensity; const C = a.radius; const P = a.attenuation; const A = S.r * E; const M = S.g * E; const L = S.b * E; const F = f.alpha * a.alpha; this.shouldFlush(6) && this.flush(), this.batchLightVert(l, u, y, T, C, P, A, M, L, F), this.batchLightVert(v, p, y, T, C, P, A, M, L, F), this.batchLightVert(c, m, y, T, C, P, A, M, L, F), this.batchLightVert(l, u, y, T, C, P, A, M, L, F), this.batchLightVert(c, m, y, T, C, P, A, M, L, F), this.batchLightVert(g, x, y, T, C, P, A, M, L, F) }, batchLightVert: function (a, f, l, u, v, p, c, m, g, x) { const y = this.vertexViewF32; let T = this.vertexCount * this.currentShader.vertexComponentCount - 1; y[++T] = a, y[++T] = f, y[++T] = l, y[++T] = u, y[++T] = v, y[++T] = p, y[++T] = c, y[++T] = m, y[++T] = g, y[++T] = x, this.vertexCount++ } }); e.exports = s }, function (e, d, t) { const i = t(0); const h = t(2); const n = t(108); const o = new i({ Extends: n, initialize: function (s) { s.topology = 5, s.batchSize = h(s, 'batchSize', 256), n.call(this, s) } }); e.exports = o }, function (e, d, t) { const i = t(0); const h = t(2); const n = t(108); const o = t(882); const r = t(883); const s = t(58); const a = new i({ Extends: n, initialize: function (l) { l.fragShader = h(l, 'fragShader', o), l.vertShader = h(l, 'vertShader', r), l.forceZero = !0, n.call(this, l) }, boot: function () { s.prototype.boot.call(this), this.set1i('uMainSampler', 0) } }); e.exports = a }, function (e, d, t) { const i = t(884); const h = t(35); const n = t(0); const o = t(198); const r = t(885); const s = t(886); const a = t(2); const f = t(887); const l = t(382); const u = t(58); const v = new n({ Extends: u, initialize: function (c) { c.renderTarget = a(c, 'renderTarget', [{ scale: 1 }, { scale: 1 }, { scale: 0.5 }, { scale: 0.5 }]), c.vertShader = a(c, 'vertShader', l), c.shaders = a(c, 'shaders', [{ name: 'Copy', fragShader: s }, { name: 'AddBlend', fragShader: i }, { name: 'LinearBlend', fragShader: f }, { name: 'ColorMatrix', fragShader: r }]), c.attributes = a(c, 'attributes', [{ name: 'inPosition', size: 2 }, { name: 'inTexCoord', size: 2 }]), c.vertices = [-1, -1, 0, 0, -1, 1, 0, 1, 1, 1, 1, 1, -1, -1, 0, 0, 1, 1, 1, 1, 1, -1, 1, 0], c.batchSize = 1, u.call(this, c), this.colorMatrix = new o(), this.copyShader, this.addShader, this.linearShader, this.colorMatrixShader, this.fullFrame1, this.fullFrame2, this.halfFrame1, this.halfFrame2 }, boot: function () { u.prototype.boot.call(this); const p = this.shaders; const c = this.renderTargets; this.copyShader = p[0], this.addShader = p[1], this.linearShader = p[2], this.colorMatrixShader = p[3], this.fullFrame1 = c[0], this.fullFrame2 = c[1], this.halfFrame1 = c[2], this.halfFrame2 = c[3] }, copyFrame: function (p, c, m, g, x) { m === void 0 && (m = 1), g === void 0 && (g = !0), x === void 0 && (x = !0); const y = this.gl; this.setShader(this.copyShader), this.set1i('uMainSampler', 0), this.set1f('uBrightness', m), y.activeTexture(y.TEXTURE0), y.bindTexture(y.TEXTURE_2D, p.texture), c ? (y.viewport(0, 0, c.width, c.height), y.bindFramebuffer(y.FRAMEBUFFER, c.framebuffer), y.framebufferTexture2D(y.FRAMEBUFFER, y.COLOR_ATTACHMENT0, y.TEXTURE_2D, c.texture, 0)) : y.viewport(0, 0, p.width, p.height), g && (x ? y.clearColor(0, 0, 0, 0) : y.clearColor(0, 0, 0, 1), y.clear(y.COLOR_BUFFER_BIT)), y.bufferData(y.ARRAY_BUFFER, this.vertexData, y.STATIC_DRAW), y.drawArrays(y.TRIANGLES, 0, 6), y.bindFramebuffer(y.FRAMEBUFFER, null), y.bindTexture(y.TEXTURE_2D, null) }, blitFrame: function (p, c, m, g, x, y) { m === void 0 && (m = 1), g === void 0 && (g = !0), x === void 0 && (x = !0), y === void 0 && (y = !1); const T = this.gl; if (this.setShader(this.copyShader), this.set1i('uMainSampler', 0), this.set1f('uBrightness', m), T.activeTexture(T.TEXTURE0), T.bindTexture(T.TEXTURE_2D, p.texture), p.height > c.height)T.viewport(0, 0, p.width, p.height), this.setTargetUVs(p, c); else { const S = c.height - p.height; T.viewport(0, S, p.width, p.height) } if (T.bindFramebuffer(T.FRAMEBUFFER, c.framebuffer), T.framebufferTexture2D(T.FRAMEBUFFER, T.COLOR_ATTACHMENT0, T.TEXTURE_2D, c.texture, 0), g && (x ? T.clearColor(0, 0, 0, 0) : T.clearColor(0, 0, 0, 1), T.clear(T.COLOR_BUFFER_BIT)), y) { var E = this.renderer.currentBlendMode; this.renderer.setBlendMode(h.ERASE) }T.bufferData(T.ARRAY_BUFFER, this.vertexData, T.STATIC_DRAW), T.drawArrays(T.TRIANGLES, 0, 6), y && this.renderer.setBlendMode(E), T.bindFramebuffer(T.FRAMEBUFFER, null), T.bindTexture(T.TEXTURE_2D, null), this.resetUVs() }, copyFrameRect: function (p, c, m, g, x, y, T, S) { T === void 0 && (T = !0), S === void 0 && (S = !0); const E = this.gl; E.bindFramebuffer(E.FRAMEBUFFER, p.framebuffer), E.framebufferTexture2D(E.FRAMEBUFFER, E.COLOR_ATTACHMENT0, E.TEXTURE_2D, p.texture, 0), T && (S ? E.clearColor(0, 0, 0, 0) : E.clearColor(0, 0, 0, 1), E.clear(E.COLOR_BUFFER_BIT)), E.activeTexture(E.TEXTURE0), E.bindTexture(E.TEXTURE_2D, c.texture), E.copyTexSubImage2D(E.TEXTURE_2D, 0, 0, 0, m, g, x, y), E.bindFramebuffer(E.FRAMEBUFFER, null), E.bindTexture(E.TEXTURE_2D, null) }, copyToGame: function (p) { const c = this.gl; this.setShader(this.copyShader), this.set1i('uMainSampler', 0), this.set1f('uBrightness', 1), this.renderer.popFramebuffer(), c.activeTexture(c.TEXTURE0), c.bindTexture(c.TEXTURE_2D, p.texture), c.bufferData(c.ARRAY_BUFFER, this.vertexData, c.STATIC_DRAW), c.drawArrays(c.TRIANGLES, 0, 6), this.renderer.resetTextures() }, drawFrame: function (p, c, m, g) { m === void 0 && (m = !0), g === void 0 && (g = this.colorMatrix); const x = this.gl; this.setShader(this.colorMatrixShader), this.set1i('uMainSampler', 0), this.set1fv('uColorMatrix', g.getData()), this.set1f('uAlpha', g.alpha), x.activeTexture(x.TEXTURE0), x.bindTexture(x.TEXTURE_2D, p.texture), c ? (x.viewport(0, 0, c.width, c.height), x.bindFramebuffer(x.FRAMEBUFFER, c.framebuffer), x.framebufferTexture2D(x.FRAMEBUFFER, x.COLOR_ATTACHMENT0, x.TEXTURE_2D, c.texture, 0)) : x.viewport(0, 0, p.width, p.height), m ? x.clearColor(0, 0, 0, 0) : x.clearColor(0, 0, 0, 1), x.clear(x.COLOR_BUFFER_BIT), x.bufferData(x.ARRAY_BUFFER, this.vertexData, x.STATIC_DRAW), x.drawArrays(x.TRIANGLES, 0, 6), x.bindFramebuffer(x.FRAMEBUFFER, null), x.bindTexture(x.TEXTURE_2D, null) }, blendFrames: function (p, c, m, g, x, y) { g === void 0 && (g = 1), x === void 0 && (x = !0), y === void 0 && (y = this.linearShader); const T = this.gl; this.setShader(y), this.set1i('uMainSampler1', 0), this.set1i('uMainSampler2', 1), this.set1f('uStrength', g), T.activeTexture(T.TEXTURE0), T.bindTexture(T.TEXTURE_2D, p.texture), T.activeTexture(T.TEXTURE1), T.bindTexture(T.TEXTURE_2D, c.texture), m ? (T.bindFramebuffer(T.FRAMEBUFFER, m.framebuffer), T.framebufferTexture2D(T.FRAMEBUFFER, T.COLOR_ATTACHMENT0, T.TEXTURE_2D, m.texture, 0), T.viewport(0, 0, m.width, m.height)) : T.viewport(0, 0, p.width, p.height), x ? T.clearColor(0, 0, 0, 0) : T.clearColor(0, 0, 0, 1), T.clear(T.COLOR_BUFFER_BIT), T.bufferData(T.ARRAY_BUFFER, this.vertexData, T.STATIC_DRAW), T.drawArrays(T.TRIANGLES, 0, 6), T.bindFramebuffer(T.FRAMEBUFFER, null), T.bindTexture(T.TEXTURE_2D, null) }, blendFramesAdditive: function (p, c, m, g, x) { this.blendFrames(p, c, m, g, x, this.addShader) }, clearFrame: function (p, c) { c === void 0 && (c = !0); const m = this.gl; m.viewport(0, 0, p.width, p.height), m.bindFramebuffer(m.FRAMEBUFFER, p.framebuffer), c ? m.clearColor(0, 0, 0, 0) : m.clearColor(0, 0, 0, 1), m.clear(m.COLOR_BUFFER_BIT); const g = this.renderer.currentFramebuffer; m.bindFramebuffer(m.FRAMEBUFFER, g) }, setUVs: function (p, c, m, g, x, y, T, S) { const E = this.vertexViewF32; E[2] = p, E[3] = c, E[6] = m, E[7] = g, E[10] = x, E[11] = y, E[14] = p, E[15] = c, E[18] = x, E[19] = y, E[22] = T, E[23] = S }, setTargetUVs: function (p, c) { let m = c.height / p.height; m > 0.5 ? m = 0.5 - (m - 0.5) : m = 0.5 + (0.5 - m), this.setUVs(0, m, 0, 1 + m, 1, 1 + m, 1, m) }, flipX: function () { this.setUVs(1, 0, 1, 1, 0, 1, 0, 0) }, flipY: function () { this.setUVs(0, 1, 0, 0, 1, 0, 1, 1) }, resetUVs: function () { this.setUVs(0, 0, 0, 1, 1, 1, 1, 0) } }); e.exports = v }, function (e, d) {
        e.exports = ['#define SHADER_NAME PHASER_QUAD_VS', '', 'precision mediump float;', '', 'attribute vec2 inPosition;', 'attribute vec2 inTexCoord;', '', 'varying vec2 outFragCoord;', 'varying vec2 outTexCoord;', '', 'void main ()', '{', '    outFragCoord = inPosition.xy * 0.5 + 0.5;', '    outTexCoord = inTexCoord;', '', '    gl_Position = vec4(inPosition, 0, 1);', '}', ''].join(`
`)
      }, function (e, d, t) { const i = t(31); const h = t(38); const n = t(2); const o = function (r, s) { const a = r.getContext('experimental-webgl'); const f = n(s, 'callback'); const l = n(s, 'type', 'image/png'); const u = n(s, 'encoder', 0.92); const v = n(s, 'x', 0); const p = n(s, 'y', 0); const c = n(s, 'getPixel', !1); const m = n(s, 'isFramebuffer', !1); const g = m ? n(s, 'bufferWidth', 1) : a.drawingBufferWidth; const x = m ? n(s, 'bufferHeight', 1) : a.drawingBufferHeight; if (c) { const y = new Uint8Array(4); const T = m ? p : x - p; a.readPixels(v, T, 1, 1, a.RGBA, a.UNSIGNED_BYTE, y), f.call(null, new h(y[0], y[1], y[2], y[3] / 255)) } else { const S = n(s, 'width', g); const E = n(s, 'height', x); const C = S * E * 4; const P = new Uint8Array(C); a.readPixels(v, x - p - E, S, E, a.RGBA, a.UNSIGNED_BYTE, P); for (var A = i.createWebGL(this, S, E), M = A.getContext('2d'), L = M.getImageData(0, 0, S, E), F = L.data, I = 0; I < E; I++) for (let G = 0; G < S; G++) { const U = ((E - I - 1) * S + G) * 4; const Y = (I * S + G) * 4; F[Y + 0] = P[U + 0], F[Y + 1] = P[U + 1], F[Y + 2] = P[U + 2], F[Y + 3] = P[U + 3] }M.putImageData(L, 0, 0); const X = new Image(); X.onerror = function () { f.call(null), i.remove(A) }, X.onload = function () { f.call(null, X), i.remove(A) }, X.src = A.toDataURL(l, u) } }; e.exports = o }, function (e, d, t) { const i = t(33); const h = function (n) { const o = n.config; if (!o.hideBanner) { let r = 'WebGL'; o.renderType === i.CANVAS ? r = 'Canvas' : o.renderType === i.HEADLESS && (r = 'Headless'); const s = o.audio; const a = n.device.audio; let f; if (a.webAudio && !s.disableWebAudio ? f = 'Web Audio' : s.noAudio || !a.webAudio && !a.audioData ? f = 'No Audio' : f = 'HTML5 Audio', n.device.browser.ie)window.console && console.log('Phaser v' + i.VERSION + ' / https://phaser.io'); else { let l = ''; const u = [l]; if (Array.isArray(o.bannerBackgroundColor)) { let v; o.bannerBackgroundColor.forEach(function (c) { l = l.concat('%c '), u.push('background: ' + c), v = c }), u[u.length - 1] = 'color: ' + o.bannerTextColor + '; background: ' + v } else l = l.concat('%c '), u.push('color: ' + o.bannerTextColor + '; background: ' + o.bannerBackgroundColor); u.push('background: transparent'), o.gameTitle && (l = l.concat(o.gameTitle), o.gameVersion && (l = l.concat(' v' + o.gameVersion)), o.hidePhaser || (l = l.concat(' / '))); const p = ''; o.hidePhaser || (l = l.concat('Phaser v' + i.VERSION + p + ' (' + r + ' | ' + f + ')')), l = l.concat(' %c ' + o.gameURL), u[0] = l, console.log.apply(console, u) } } }; e.exports = h }, function (e, d, t) { const i = t(0); const h = t(6); const n = t(1); const o = t(386); const r = new i({ initialize: function (a, f) { this.game = a, this.raf = new o(), this.started = !1, this.running = !1, this.minFps = h(f, 'min', 5), this.targetFps = h(f, 'target', 60), this._min = 1e3 / this.minFps, this._target = 1e3 / this.targetFps, this.actualFps = this.targetFps, this.nextFpsUpdate = 0, this.framesThisSecond = 0, this.callback = n, this.forceSetTimeOut = h(f, 'forceSetTimeOut', !1), this.time = 0, this.startTime = 0, this.lastTime = 0, this.frame = 0, this.inFocus = !0, this._pauseTime = 0, this._coolDown = 0, this.delta = 0, this.deltaIndex = 0, this.deltaHistory = [], this.deltaSmoothingMax = h(f, 'deltaHistory', 10), this.panicMax = h(f, 'panicMax', 120), this.rawDelta = 0, this.now = 0, this.smoothStep = h(f, 'smoothStep', !0) }, blur: function () { this.inFocus = !1 }, focus: function () { this.inFocus = !0, this.resetDelta() }, pause: function () { this._pauseTime = window.performance.now() }, resume: function () { this.resetDelta(), this.startTime += this.time - this._pauseTime }, resetDelta: function () { const s = window.performance.now(); this.time = s, this.lastTime = s, this.nextFpsUpdate = s + 1e3, this.framesThisSecond = 0; for (let a = 0; a < this.deltaSmoothingMax; a++) this.deltaHistory[a] = Math.min(this._target, this.deltaHistory[a]); this.delta = 0, this.deltaIndex = 0, this._coolDown = this.panicMax }, start: function (s) { if (this.started) return this; this.started = !0, this.running = !0; for (let a = 0; a < this.deltaSmoothingMax; a++) this.deltaHistory[a] = this._target; this.resetDelta(), this.startTime = window.performance.now(), this.callback = s, this.raf.start(this.step.bind(this), this.forceSetTimeOut, this._target) }, step: function () { const s = window.performance.now(); this.now = s; let a = s - this.lastTime; a < 0 && (a = 0), this.rawDelta = a; const f = this.deltaIndex; const l = this.deltaHistory; const u = this.deltaSmoothingMax; let v = a; let p = a; if (this.smoothStep) { (this._coolDown > 0 || !this.inFocus) && (this._coolDown--, v = Math.min(v, this._target)), v > this._min && (v = l[f], v = Math.min(v, this._min)), l[f] = v, this.deltaIndex++, this.deltaIndex > u && (this.deltaIndex = 0), p = 0; for (let c = 0; c < u; c++)p += l[c]; p /= u } this.delta = p, this.time += this.rawDelta, s > this.nextFpsUpdate && (this.actualFps = 0.25 * this.framesThisSecond + 0.75 * this.actualFps, this.nextFpsUpdate = s + 1e3, this.framesThisSecond = 0), this.framesThisSecond++; const m = p / this._target; this.callback(s, p, m), this.lastTime = s, this.frame++ }, tick: function () { this.step() }, sleep: function () { this.running && (this.raf.stop(), this.running = !1) }, wake: function (s) { this.running || (s && (this.startTime += -this.lastTime + (this.lastTime + window.performance.now())), this.raf.start(this.step.bind(this), this.useRAF), this.running = !0, this.step()) }, getDuration: function () { return Math.round(this.lastTime - this.startTime) / 1e3 }, getDurationMS: function () { return Math.round(this.lastTime - this.startTime) }, stop: function () { return this.running = !1, this.started = !1, this.raf.stop(), this }, destroy: function () { this.stop(), this.callback = n, this.raf = null, this.game = null } }); e.exports = r }, function (e, d, t) { const i = t(0); const h = t(1); const n = new i({ initialize: function () { this.isRunning = !1, this.callback = h, this.tick = 0, this.isSetTimeOut = !1, this.timeOutID = null, this.lastTime = 0, this.target = 0; const r = this; this.step = function s () { const a = window.performance.now(); r.lastTime = r.tick, r.tick = a, r.callback(a), r.timeOutID = window.requestAnimationFrame(s) }, this.stepTimeout = function s () { const a = Date.now(); const f = Math.min(Math.max(r.target * 2 + r.tick - a, 0), r.target); r.lastTime = r.tick, r.tick = a, r.callback(a), r.timeOutID = window.setTimeout(s, f) } }, start: function (o, r, s) { this.isRunning || (this.callback = o, this.isSetTimeOut = r, this.target = s, this.isRunning = !0, this.timeOutID = r ? window.setTimeout(this.stepTimeout, 0) : window.requestAnimationFrame(this.step)) }, stop: function () { this.isRunning = !1, this.isSetTimeOut ? clearTimeout(this.timeOutID) : window.cancelAnimationFrame(this.timeOutID) }, destroy: function () { this.stop(), this.callback = h } }); e.exports = n }, function (e, d, t) { const i = t(22); const h = function (n) { let o; const r = n.events; if (document.hidden !== void 0)o = 'visibilitychange'; else { const s = ['webkit', 'moz', 'ms']; s.forEach(function (f) { document[f + 'Hidden'] !== void 0 && (document.hidden = function () { return document[f + 'Hidden'] }, o = f + 'visibilitychange') }) } const a = function (f) { document.hidden || f.type === 'pause' ? r.emit(i.HIDDEN) : r.emit(i.VISIBLE) }; o && document.addEventListener(o, a, !1), window.onblur = function () { r.emit(i.BLUR) }, window.onfocus = function () { r.emit(i.FOCUS) }, window.focus && n.config.autoFocus && window.focus() }; e.exports = h }, function (e, d, t) { const i = t(389); const h = t(31); const n = t(6); const o = function (r) { const s = n(r, 'data', []); let a = n(r, 'canvas', null); const f = n(r, 'palette', i); const l = n(r, 'pixelWidth', 1); const u = n(r, 'pixelHeight', l); let v = n(r, 'resizeCanvas', !0); let p = n(r, 'clearCanvas', !0); const c = n(r, 'preRender', null); const m = n(r, 'postRender', null); const g = Math.floor(Math.abs(s[0].length * l)); const x = Math.floor(Math.abs(s.length * u)); a || (a = h.create2D(this, g, x), v = !1, p = !1), v && (a.width = g, a.height = x); const y = a.getContext('2d'); p && y.clearRect(0, 0, g, x), c && c(a, y); for (let T = 0; T < s.length; T++) for (let S = s[T], E = 0; E < S.length; E++) { const C = S[E]; C !== '.' && C !== ' ' && (y.fillStyle = f[C], y.fillRect(E * l, T * u, l, u)) } return m && m(a, y), a }; e.exports = o }, function (e, d) { e.exports = { 0: '#000', 1: '#9D9D9D', 2: '#FFF', 3: '#BE2633', 4: '#E06F8B', 5: '#493C2B', 6: '#A46422', 7: '#EB8931', 8: '#F7E26B', 9: '#2F484E', A: '#44891A', B: '#A3CE27', C: '#1B2632', D: '#005784', E: '#31A2F2', F: '#B2DCEF' } }, function (e, d, t) { const i = t(0); const h = t(358); const n = t(94); const o = t(3); const r = new i({ Extends: n, initialize: function (a, f, l, u) { n.call(this, 'CubicBezierCurve'), Array.isArray(a) && (u = new o(a[6], a[7]), l = new o(a[4], a[5]), f = new o(a[2], a[3]), a = new o(a[0], a[1])), this.p0 = a, this.p1 = f, this.p2 = l, this.p3 = u }, getStartPoint: function (s) { return s === void 0 && (s = new o()), s.copy(this.p0) }, getResolution: function (s) { return s }, getPoint: function (s, a) { a === void 0 && (a = new o()); const f = this.p0; const l = this.p1; const u = this.p2; const v = this.p3; return a.set(h(s, f.x, l.x, u.x, v.x), h(s, f.y, l.y, u.y, v.y)) }, draw: function (s, a) { a === void 0 && (a = 32); const f = this.getPoints(a); s.beginPath(), s.moveTo(this.p0.x, this.p0.y); for (let l = 1; l < f.length; l++)s.lineTo(f[l].x, f[l].y); return s.strokePath(), s }, toJSON: function () { return { type: this.type, points: [this.p0.x, this.p0.y, this.p1.x, this.p1.y, this.p2.x, this.p2.y, this.p3.x, this.p3.y] } } }); r.fromJSON = function (s) { const a = s.points; const f = new o(a[0], a[1]); const l = new o(a[2], a[3]); const u = new o(a[4], a[5]); const v = new o(a[6], a[7]); return new r(f, l, u, v) }, e.exports = r }, function (e, d, t) { const i = t(0); const h = t(94); const n = t(36); const o = t(6); const r = t(196); const s = t(3); const a = new i({ Extends: h, initialize: function (l, u, v, p, c, m, g, x) { if (typeof l === 'object') { const y = l; l = o(y, 'x', 0), u = o(y, 'y', 0), v = o(y, 'xRadius', 0), p = o(y, 'yRadius', v), c = o(y, 'startAngle', 0), m = o(y, 'endAngle', 360), g = o(y, 'clockwise', !1), x = o(y, 'rotation', 0) } else p === void 0 && (p = v), c === void 0 && (c = 0), m === void 0 && (m = 360), g === void 0 && (g = !1), x === void 0 && (x = 0); h.call(this, 'EllipseCurve'), this.p0 = new s(l, u), this._xRadius = v, this._yRadius = p, this._startAngle = n(c), this._endAngle = n(m), this._clockwise = g, this._rotation = n(x) }, getStartPoint: function (f) { return f === void 0 && (f = new s()), this.getPoint(0, f) }, getResolution: function (f) { return f * 2 }, getPoint: function (f, l) { l === void 0 && (l = new s()); for (var u = Math.PI * 2, v = this._endAngle - this._startAngle, p = Math.abs(v) < Number.EPSILON; v < 0;)v += u; for (;v > u;)v -= u; v < Number.EPSILON && (p ? v = 0 : v = u), this._clockwise && !p && (v === u ? v = -u : v = v - u); const c = this._startAngle + f * v; let m = this.p0.x + this._xRadius * Math.cos(c); let g = this.p0.y + this._yRadius * Math.sin(c); if (this._rotation !== 0) { const x = Math.cos(this._rotation); const y = Math.sin(this._rotation); const T = m - this.p0.x; const S = g - this.p0.y; m = T * x - S * y + this.p0.x, g = T * y + S * x + this.p0.y } return l.set(m, g) }, setXRadius: function (f) { return this.xRadius = f, this }, setYRadius: function (f) { return this.yRadius = f, this }, setWidth: function (f) { return this.xRadius = f / 2, this }, setHeight: function (f) { return this.yRadius = f / 2, this }, setStartAngle: function (f) { return this.startAngle = f, this }, setEndAngle: function (f) { return this.endAngle = f, this }, setClockwise: function (f) { return this.clockwise = f, this }, setRotation: function (f) { return this.rotation = f, this }, x: { get: function () { return this.p0.x }, set: function (f) { this.p0.x = f } }, y: { get: function () { return this.p0.y }, set: function (f) { this.p0.y = f } }, xRadius: { get: function () { return this._xRadius }, set: function (f) { this._xRadius = f } }, yRadius: { get: function () { return this._yRadius }, set: function (f) { this._yRadius = f } }, startAngle: { get: function () { return r(this._startAngle) }, set: function (f) { this._startAngle = n(f) } }, endAngle: { get: function () { return r(this._endAngle) }, set: function (f) { this._endAngle = n(f) } }, clockwise: { get: function () { return this._clockwise }, set: function (f) { this._clockwise = f } }, angle: { get: function () { return r(this._rotation) }, set: function (f) { this._rotation = n(f) } }, rotation: { get: function () { return this._rotation }, set: function (f) { this._rotation = f } }, toJSON: function () { return { type: this.type, x: this.p0.x, y: this.p0.y, xRadius: this._xRadius, yRadius: this._yRadius, startAngle: r(this._startAngle), endAngle: r(this._endAngle), clockwise: this._clockwise, rotation: r(this._rotation) } } }); a.fromJSON = function (f) { return new a(f) }, e.exports = a }, function (e, d, t) { const i = t(0); const h = t(94); const n = t(199); const o = t(10); const r = t(3); const s = new i({ Extends: h, initialize: function (f, l) { h.call(this, 'LineCurve'), Array.isArray(f) && (l = new r(f[2], f[3]), f = new r(f[0], f[1])), this.p0 = f, this.p1 = l, this.arcLengthDivisions = 1 }, getBounds: function (a) { return a === void 0 && (a = new o()), n([this.p0, this.p1], a) }, getStartPoint: function (a) { return a === void 0 && (a = new r()), a.copy(this.p0) }, getResolution: function (a) { return a === void 0 && (a = 1), a }, getPoint: function (a, f) { return f === void 0 && (f = new r()), a === 1 ? f.copy(this.p1) : (f.copy(this.p1).subtract(this.p0).scale(a).add(this.p0), f) }, getPointAt: function (a, f) { return this.getPoint(a, f) }, getTangent: function (a, f) { return f === void 0 && (f = new r()), f.copy(this.p1).subtract(this.p0).normalize(), f }, getUtoTmapping: function (a, f, l) { let u; if (f) { const v = this.getLengths(l); const p = v[v.length - 1]; const c = Math.min(f, p); u = c / p } else u = a; return u }, draw: function (a) { return a.lineBetween(this.p0.x, this.p0.y, this.p1.x, this.p1.y), a }, toJSON: function () { return { type: this.type, points: [this.p0.x, this.p0.y, this.p1.x, this.p1.y] } } }); s.fromJSON = function (a) { const f = a.points; const l = new r(f[0], f[1]); const u = new r(f[2], f[3]); return new s(l, u) }, e.exports = s }, function (e, d, t) { const i = t(0); const h = t(3); const n = new i({ initialize: function (r, s) { this.active = !1, this.p0 = new h(r, s) }, getPoint: function (o, r) { return r === void 0 && (r = new h()), r.copy(this.p0) }, getPointAt: function (o, r) { return this.getPoint(o, r) }, getResolution: function () { return 1 }, getLength: function () { return 0 }, toJSON: function () { return { type: 'MoveTo', points: [this.p0.x, this.p0.y] } } }); e.exports = n }, function (e, d, t) { const i = t(0); const h = t(94); const n = t(359); const o = t(3); const r = new i({ Extends: h, initialize: function (a, f, l) { h.call(this, 'QuadraticBezier'), Array.isArray(a) && (l = new o(a[4], a[5]), f = new o(a[2], a[3]), a = new o(a[0], a[1])), this.p0 = a, this.p1 = f, this.p2 = l }, getStartPoint: function (s) { return s === void 0 && (s = new o()), s.copy(this.p0) }, getResolution: function (s) { return s }, getPoint: function (s, a) { a === void 0 && (a = new o()); const f = this.p0; const l = this.p1; const u = this.p2; return a.set(n(s, f.x, l.x, u.x), n(s, f.y, l.y, u.y)) }, draw: function (s, a) { a === void 0 && (a = 32); const f = this.getPoints(a); s.beginPath(), s.moveTo(this.p0.x, this.p0.y); for (let l = 1; l < f.length; l++)s.lineTo(f[l].x, f[l].y); return s.strokePath(), s }, toJSON: function () { return { type: this.type, points: [this.p0.x, this.p0.y, this.p1.x, this.p1.y, this.p2.x, this.p2.y] } } }); r.fromJSON = function (s) { const a = s.points; const f = new o(a[0], a[1]); const l = new o(a[2], a[3]); const u = new o(a[4], a[5]); return new r(f, l, u) }, e.exports = r }, function (e, d, t) { const i = t(194); const h = t(0); const n = t(94); const o = t(3); const r = new h({ Extends: n, initialize: function (a) { a === void 0 && (a = []), n.call(this, 'SplineCurve'), this.points = [], this.addPoints(a) }, addPoints: function (s) { for (let a = 0; a < s.length; a++) { const f = new o(); typeof s[a] === 'number' ? (f.x = s[a], f.y = s[a + 1], a++) : Array.isArray(s[a]) ? (f.x = s[a][0], f.y = s[a][1]) : (f.x = s[a].x, f.y = s[a].y), this.points.push(f) } return this }, addPoint: function (s, a) { const f = new o(s, a); return this.points.push(f), f }, getStartPoint: function (s) { return s === void 0 && (s = new o()), s.copy(this.points[0]) }, getResolution: function (s) { return s * this.points.length }, getPoint: function (s, a) { a === void 0 && (a = new o()); const f = this.points; const l = (f.length - 1) * s; const u = Math.floor(l); const v = l - u; const p = f[u === 0 ? u : u - 1]; const c = f[u]; const m = f[u > f.length - 2 ? f.length - 1 : u + 1]; const g = f[u > f.length - 3 ? f.length - 1 : u + 2]; return a.set(i(v, p.x, c.x, m.x, g.x), i(v, p.y, c.y, m.y, g.y)) }, toJSON: function () { for (var s = [], a = 0; a < this.points.length; a++)s.push(this.points[a].x), s.push(this.points[a].y); return { type: this.type, points: s } } }); r.fromJSON = function (s) { return new r(s.points) }, e.exports = r }, function (e, d, t) {
        const i = t(0); const h = new i({
          initialize: function (o, r, s, a) {
            (!r || r === '') && (r = ['precision mediump float;', 'uniform vec2 resolution;', 'varying vec2 fragCoord;', 'void main () {', '    vec2 uv = fragCoord / resolution.xy;', '    gl_FragColor = vec4(uv.xyx, 1.0);', '}'].join(`
`)), (!s || s === '') && (s = ['precision mediump float;', 'uniform mat4 uProjectionMatrix;', 'uniform mat4 uViewMatrix;', 'uniform vec2 uResolution;', 'attribute vec2 inPosition;', 'varying vec2 fragCoord;', 'varying vec2 outTexCoord;', 'void main () {', '   gl_Position = uProjectionMatrix * uViewMatrix * vec4(inPosition, 1.0, 1.0);', '   fragCoord = vec2(inPosition.x, uResolution.y - inPosition.y);', '   outTexCoord = vec2(inPosition.x / uResolution.x, fragCoord.y / uResolution.y);', '}'].join(`
`)), a === void 0 && (a = null), this.key = o, this.fragmentSrc = r, this.vertexSrc = s, this.uniforms = a
          }
        }); e.exports = h
      }, function (e, d, t) { const i = t(38); i.ColorSpectrum = t(909), i.ColorToRGBA = t(910), i.ComponentToHex = t(398), i.GetColor = t(103), i.GetColor32 = t(328), i.HexStringToColor = t(327), i.HSLToColor = t(911), i.HSVColorWheel = t(912), i.HSVToRGB = t(188), i.HueToComponent = t(399), i.IntegerToColor = t(189), i.IntegerToRGB = t(330), i.Interpolate = t(913), i.ObjectToColor = t(331), i.RandomRGB = t(914), i.RGBStringToColor = t(332), i.RGBToHSV = t(329), i.RGBToString = t(915), i.ValueToColor = t(187), e.exports = i }, function (e, d) { const t = function (i) { const h = i.toString(16); return h.length === 1 ? '0' + h : h }; e.exports = t }, function (e, d) { const t = function (i, h, n) { return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? i + (h - i) * 6 * n : n < 1 / 2 ? h : n < 2 / 3 ? i + (h - i) * (2 / 3 - n) * 6 : i }; e.exports = t }, function (e, d, t) { const i = t(105); const h = function (n) { if (document.readyState === 'complete' || document.readyState === 'interactive') { n(); return } var o = function () { document.removeEventListener('deviceready', o, !0), document.removeEventListener('DOMContentLoaded', o, !0), window.removeEventListener('load', o, !0), n() }; document.body ? i.cordova ? document.addEventListener('deviceready', o, !1) : (document.addEventListener('DOMContentLoaded', o, !0), window.addEventListener('load', o, !0)) : window.setTimeout(o, 20) }; e.exports = h }, function (e, d) { const t = function (i) { if (!i) return window.innerHeight; const h = Math.abs(window.orientation); const n = { w: 0, h: 0 }; let o = document.createElement('div'); return o.setAttribute('style', 'position: fixed; height: 100vh; width: 0; top: 0'), document.documentElement.appendChild(o), n.w = h === 90 ? o.offsetHeight : window.innerWidth, n.h = h === 90 ? window.innerWidth : o.offsetHeight, document.documentElement.removeChild(o), o = null, Math.abs(window.orientation) !== 90 ? n.h : n.w }; e.exports = t }, function (e, d, t) { const i = t(201); const h = function (n, o) { const r = window.screen; const s = r ? r.orientation || r.mozOrientation || r.msOrientation : !1; if (s && typeof s.type === 'string') return s.type; if (typeof s === 'string') return s; if (typeof window.orientation === 'number') return window.orientation === 0 || window.orientation === 180 ? i.ORIENTATION.PORTRAIT : i.ORIENTATION.LANDSCAPE; if (window.matchMedia) { if (window.matchMedia('(orientation: portrait)').matches) return i.ORIENTATION.PORTRAIT; if (window.matchMedia('(orientation: landscape)').matches) return i.ORIENTATION.LANDSCAPE } else return o > n ? i.ORIENTATION.PORTRAIT : i.ORIENTATION.LANDSCAPE }; e.exports = h }, function (e, d) { e.exports = { NO_CENTER: 0, CENTER_BOTH: 1, CENTER_HORIZONTALLY: 2, CENTER_VERTICALLY: 3 } }, function (e, d) { e.exports = { LANDSCAPE: 'landscape-primary', PORTRAIT: 'portrait-primary' } }, function (e, d) { e.exports = { NONE: 0, WIDTH_CONTROLS_HEIGHT: 1, HEIGHT_CONTROLS_WIDTH: 2, FIT: 3, ENVELOP: 4, RESIZE: 5 } }, function (e, d) { e.exports = { NO_ZOOM: 1, ZOOM_2X: 2, ZOOM_4X: 4, MAX_ZOOM: -1 } }, function (e, d) { const t = function (i) { let h; return i !== '' && (typeof i === 'string' ? h = document.getElementById(i) : i && i.nodeType === 1 && (h = i)), h || (h = document.body), h }; e.exports = t }, function (e, d) { const t = function (i) { let h = ''; try { if (window.DOMParser) { const n = new DOMParser(); h = n.parseFromString(i, 'text/xml') } else h = new ActiveXObject('Microsoft.XMLDOM'), h.loadXML(i) } catch (o) { h = null } return !h || !h.documentElement || h.getElementsByTagName('parsererror').length ? null : h }; e.exports = t }, function (e, d, t) { const i = t(0); const h = t(203); const n = t(9); const o = t(51); const r = t(22); const s = t(410); const a = t(411); const f = t(412); const l = t(413); const u = t(25); const v = t(177); const p = new i({ initialize: function (m, g) { this.game = m, this.scaleManager, this.canvas, this.config = g, this.enabled = !0, this.events = new n(), this.isOver = !0, this.defaultCursor = '', this.keyboard = g.inputKeyboard ? new s(this) : null, this.mouse = g.inputMouse ? new a(this) : null, this.touch = g.inputTouch ? new l(this) : null, this.pointers = [], this.pointersTotal = g.inputActivePointers, g.inputTouch && this.pointersTotal === 1 && (this.pointersTotal = 2); for (let x = 0; x <= this.pointersTotal; x++) { const y = new f(this, x); y.smoothFactor = g.inputSmoothFactor, this.pointers.push(y) } this.mousePointer = g.inputMouse ? this.pointers[0] : null, this.activePointer = this.pointers[0], this.globalTopOnly = !0, this.time = 0, this._tempPoint = { x: 0, y: 0 }, this._tempHitTest = [], this._tempMatrix = new u(), this._tempMatrix2 = new u(), this._tempSkip = !1, this.mousePointerContainer = [this.mousePointer], m.events.once(r.BOOT, this.boot, this) }, boot: function () { this.canvas = this.game.canvas, this.scaleManager = this.game.scale, this.events.emit(o.MANAGER_BOOT), this.game.events.on(r.PRE_RENDER, this.preRender, this), this.game.events.once(r.DESTROY, this.destroy, this) }, setCanvasOver: function (c) { this.isOver = !0, this.events.emit(o.GAME_OVER, c) }, setCanvasOut: function (c) { this.isOver = !1, this.events.emit(o.GAME_OUT, c) }, preRender: function () { const c = this.game.loop.now; const m = this.game.loop.delta; const g = this.game.scene.getScenes(!0, !0); this.time = c, this.events.emit(o.MANAGER_UPDATE); for (let x = 0; x < g.length; x++) { const y = g[x]; if (y.sys.input && y.sys.input.updatePoll(c, m) && this.globalTopOnly) return } }, setDefaultCursor: function (c) { this.defaultCursor = c, this.canvas.style.cursor !== c && (this.canvas.style.cursor = c) }, setCursor: function (c) { c.cursor && (this.canvas.style.cursor = c.cursor) }, resetCursor: function (c) { c.cursor && this.canvas && (this.canvas.style.cursor = this.defaultCursor) }, addPointer: function (c) { c === void 0 && (c = 1); const m = []; this.pointersTotal + c > 10 && (c = 10 - this.pointersTotal); for (let g = 0; g < c; g++) { const x = this.pointers.length; const y = new f(this, x); y.smoothFactor = this.config.inputSmoothFactor, this.pointers.push(y), this.pointersTotal++, m.push(y) } return m }, updateInputPlugins: function (c, m) { const g = this.game.scene.getScenes(!0, !0); this._tempSkip = !1; for (let x = 0; x < g.length; x++) { const y = g[x]; if (y.sys.input) { const T = y.sys.input.update(c, m); if (T && this.globalTopOnly || this._tempSkip) return } } }, onTouchStart: function (c) { for (var m = this.pointers, g = [], x = 0; x < c.changedTouches.length; x++) for (let y = c.changedTouches[x], T = 1; T < this.pointersTotal; T++) { const S = m[T]; if (!S.active) { S.touchstart(y, c), this.activePointer = S, g.push(S); break } } this.updateInputPlugins(h.TOUCH_START, g) }, onTouchMove: function (c) { for (var m = this.pointers, g = [], x = 0; x < c.changedTouches.length; x++) for (let y = c.changedTouches[x], T = 1; T < this.pointersTotal; T++) { const S = m[T]; if (S.active && S.identifier === y.identifier) { S.touchmove(y, c), this.activePointer = S, g.push(S); break } } this.updateInputPlugins(h.TOUCH_MOVE, g) }, onTouchEnd: function (c) { for (var m = this.pointers, g = [], x = 0; x < c.changedTouches.length; x++) for (let y = c.changedTouches[x], T = 1; T < this.pointersTotal; T++) { const S = m[T]; if (S.active && S.identifier === y.identifier) { S.touchend(y, c), g.push(S); break } } this.updateInputPlugins(h.TOUCH_END, g) }, onTouchCancel: function (c) { for (var m = this.pointers, g = [], x = 0; x < c.changedTouches.length; x++) for (let y = c.changedTouches[x], T = 1; T < this.pointersTotal; T++) { const S = m[T]; if (S.active && S.identifier === y.identifier) { S.touchcancel(y, c), g.push(S); break } } this.updateInputPlugins(h.TOUCH_CANCEL, g) }, onMouseDown: function (c) { const m = this.mousePointer; m.down(c), m.updateMotion(), this.activePointer = m, this.updateInputPlugins(h.MOUSE_DOWN, this.mousePointerContainer) }, onMouseMove: function (c) { const m = this.mousePointer; m.move(c), m.updateMotion(), this.activePointer = m, this.updateInputPlugins(h.MOUSE_MOVE, this.mousePointerContainer) }, onMouseUp: function (c) { const m = this.mousePointer; m.up(c), m.updateMotion(), this.activePointer = m, this.updateInputPlugins(h.MOUSE_UP, this.mousePointerContainer) }, onMouseWheel: function (c) { const m = this.mousePointer; m.wheel(c), this.activePointer = m, this.updateInputPlugins(h.MOUSE_WHEEL, this.mousePointerContainer) }, onPointerLockChange: function (c) { const m = this.mouse.locked; this.mousePointer.locked = m, this.events.emit(o.POINTERLOCK_CHANGE, c, m) }, inputCandidate: function (c, m) { const g = c.input; if (!g || !g.enabled || !g.alwaysEnabled && !c.willRender(m)) return !1; let x = !0; let y = c.parentContainer; if (y) do { if (!y.willRender(m)) { x = !1; break }y = y.parentContainer } while (y); return x }, hitTest: function (c, m, g, x) { x === void 0 && (x = this._tempHitTest); const y = this._tempPoint; const T = g.scrollX; const S = g.scrollY; x.length = 0; const E = c.x; const C = c.y; g.getWorldPoint(E, C, y), c.worldX = y.x, c.worldY = y.y; for (let P = { x: 0, y: 0 }, A = this._tempMatrix, M = this._tempMatrix2, L = 0; L < m.length; L++) { const F = m[L]; if (this.inputCandidate(F, g)) { const I = y.x + T * F.scrollFactorX - T; const G = y.y + S * F.scrollFactorY - S; F.parentContainer ? (F.getWorldTransformMatrix(A, M), A.applyInverse(I, G, P)) : v(I, G, F.x, F.y, F.rotation, F.scaleX, F.scaleY, P), this.pointWithinHitArea(F, P.x, P.y) && x.push(F) } } return x }, pointWithinHitArea: function (c, m, g) { m += c.displayOriginX, g += c.displayOriginY; const x = c.input; return x && x.hitAreaCallback(x.hitArea, m, g, c) ? (x.localX = m, x.localY = g, !0) : !1 }, pointWithinInteractiveObject: function (c, m, g) { return c.hitArea ? (m += c.gameObject.displayOriginX, g += c.gameObject.displayOriginY, c.localX = m, c.localY = g, c.hitAreaCallback(c.hitArea, m, g, c)) : !1 }, transformPointer: function (c, m, g, x) { const y = c.position; const T = c.prevPosition; T.x = y.x, T.y = y.y; const S = this.scaleManager.transformX(m); const E = this.scaleManager.transformY(g); const C = c.smoothFactor; !x || C === 0 ? (y.x = S, y.y = E) : (y.x = S * C + T.x * (1 - C), y.y = E * C + T.y * (1 - C)) }, destroy: function () { this.events.removeAllListeners(), this.game.events.off(r.PRE_RENDER), this.keyboard && this.keyboard.destroy(), this.mouse && this.mouse.destroy(), this.touch && this.touch.destroy(); for (let c = 0; c < this.pointers.length; c++) this.pointers[c].destroy(); this.pointers = [], this._tempHitTest = [], this._tempMatrix.destroy(), this.canvas = null, this.game = null } }); e.exports = p }, function (e, d, t) { const i = t(93); const h = t(0); const n = t(22); const o = t(51); const r = t(143); const s = t(1); const a = new h({ initialize: function (l) { this.manager = l, this.queue = [], this.preventDefault = !0, this.captures = [], this.enabled = !1, this.target, this.onKeyDown = s, this.onKeyUp = s, l.events.once(o.MANAGER_BOOT, this.boot, this) }, boot: function () { const f = this.manager.config; this.enabled = f.inputKeyboard, this.target = f.inputKeyboardEventTarget, this.addCapture(f.inputKeyboardCapture), !this.target && window && (this.target = window), this.enabled && this.target && this.startListeners(), this.manager.game.events.on(n.POST_STEP, this.postUpdate, this) }, startListeners: function () { const f = this; this.onKeyDown = function (u) { if (!(u.defaultPrevented || !f.enabled || !f.manager)) { f.queue.push(u), f.manager.events.emit(o.MANAGER_PROCESS); const v = u.altKey || u.ctrlKey || u.shiftKey || u.metaKey; f.preventDefault && !v && f.captures.indexOf(u.keyCode) > -1 && u.preventDefault() } }, this.onKeyUp = function (u) { if (!(u.defaultPrevented || !f.enabled || !f.manager)) { f.queue.push(u), f.manager.events.emit(o.MANAGER_PROCESS); const v = u.altKey || u.ctrlKey || u.shiftKey || u.metaKey; f.preventDefault && !v && f.captures.indexOf(u.keyCode) > -1 && u.preventDefault() } }; const l = this.target; l && (l.addEventListener('keydown', this.onKeyDown, !1), l.addEventListener('keyup', this.onKeyUp, !1), this.enabled = !0) }, stopListeners: function () { const f = this.target; f.removeEventListener('keydown', this.onKeyDown, !1), f.removeEventListener('keyup', this.onKeyUp, !1), this.enabled = !1 }, postUpdate: function () { this.queue = [] }, addCapture: function (f) { typeof f === 'string' && (f = f.split(',')), Array.isArray(f) || (f = [f]); for (var l = this.captures, u = 0; u < f.length; u++) { let v = f[u]; typeof v === 'string' && (v = r[v.trim().toUpperCase()]), l.indexOf(v) === -1 && l.push(v) } this.preventDefault = l.length > 0 }, removeCapture: function (f) { typeof f === 'string' && (f = f.split(',')), Array.isArray(f) || (f = [f]); for (var l = this.captures, u = 0; u < f.length; u++) { let v = f[u]; typeof v === 'string' && (v = r[v.toUpperCase()]), i(l, v) } this.preventDefault = l.length > 0 }, clearCaptures: function () { this.captures = [], this.preventDefault = !1 }, destroy: function () { this.stopListeners(), this.clearCaptures(), this.queue = [], this.manager.game.events.off(n.POST_RENDER, this.postUpdate, this), this.target = null, this.enabled = !1, this.manager = null } }); e.exports = a }, function (e, d, t) { const i = t(0); const h = t(191); const n = t(51); const o = t(1); const r = new i({ initialize: function (a) { this.manager = a, this.preventDefaultDown = !0, this.preventDefaultUp = !0, this.preventDefaultMove = !0, this.preventDefaultWheel = !1, this.enabled = !1, this.target, this.locked = !1, this.onMouseMove = o, this.onMouseDown = o, this.onMouseUp = o, this.onMouseDownWindow = o, this.onMouseUpWindow = o, this.onMouseOver = o, this.onMouseOut = o, this.onMouseWheel = o, this.pointerLockChange = o, this.isTop = !0, a.events.once(n.MANAGER_BOOT, this.boot, this) }, boot: function () { const s = this.manager.config; this.enabled = s.inputMouse, this.target = s.inputMouseEventTarget, this.passive = s.inputMousePassive, this.preventDefaultDown = s.inputMousePreventDefaultDown, this.preventDefaultUp = s.inputMousePreventDefaultUp, this.preventDefaultMove = s.inputMousePreventDefaultMove, this.preventDefaultWheel = s.inputMousePreventDefaultWheel, this.target ? typeof this.target === 'string' && (this.target = document.getElementById(this.target)) : this.target = this.manager.game.canvas, s.disableContextMenu && this.disableContextMenu(), this.enabled && this.target && this.startListeners() }, disableContextMenu: function () { return document.body.addEventListener('contextmenu', function (s) { return s.preventDefault(), !1 }), this }, requestPointerLock: function () { if (h.pointerLock) { const s = this.target; s.requestPointerLock = s.requestPointerLock || s.mozRequestPointerLock || s.webkitRequestPointerLock, s.requestPointerLock() } }, releasePointerLock: function () { h.pointerLock && (document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock, document.exitPointerLock()) }, startListeners: function () { const s = this.target; if (s) { const a = this; const f = this.manager; const l = f.canvas; const u = window && window.focus && f.game.config.autoFocus; this.onMouseMove = function (p) { !p.defaultPrevented && a.enabled && f && f.enabled && (f.onMouseMove(p), a.preventDefaultMove && p.preventDefault()) }, this.onMouseDown = function (p) { u && window.focus(), !p.defaultPrevented && a.enabled && f && f.enabled && (f.onMouseDown(p), a.preventDefaultDown && p.target === l && p.preventDefault()) }, this.onMouseDownWindow = function (p) { !p.defaultPrevented && a.enabled && f && f.enabled && p.target !== l && f.onMouseDown(p) }, this.onMouseUp = function (p) { !p.defaultPrevented && a.enabled && f && f.enabled && (f.onMouseUp(p), a.preventDefaultUp && p.target === l && p.preventDefault()) }, this.onMouseUpWindow = function (p) { !p.defaultPrevented && a.enabled && f && f.enabled && p.target !== l && f.onMouseUp(p) }, this.onMouseOver = function (p) { !p.defaultPrevented && a.enabled && f && f.enabled && f.setCanvasOver(p) }, this.onMouseOut = function (p) { !p.defaultPrevented && a.enabled && f && f.enabled && f.setCanvasOut(p) }, this.onMouseWheel = function (p) { !p.defaultPrevented && a.enabled && f && f.enabled && f.onMouseWheel(p), a.preventDefaultWheel && p.target === l && p.preventDefault() }; const v = { passive: !0 }; if (s.addEventListener('mousemove', this.onMouseMove), s.addEventListener('mousedown', this.onMouseDown), s.addEventListener('mouseup', this.onMouseUp), s.addEventListener('mouseover', this.onMouseOver, v), s.addEventListener('mouseout', this.onMouseOut, v), this.preventDefaultWheel ? s.addEventListener('wheel', this.onMouseWheel, { passive: !1 }) : s.addEventListener('wheel', this.onMouseWheel, v), window && f.game.config.inputWindowEvents) try { window.top.addEventListener('mousedown', this.onMouseDownWindow, v), window.top.addEventListener('mouseup', this.onMouseUpWindow, v) } catch (p) { window.addEventListener('mousedown', this.onMouseDownWindow, v), window.addEventListener('mouseup', this.onMouseUpWindow, v), this.isTop = !1 }h.pointerLock && (this.pointerLockChange = function (p) { const c = a.target; a.locked = document.pointerLockElement === c || document.mozPointerLockElement === c || document.webkitPointerLockElement === c, f.onPointerLockChange(p) }, document.addEventListener('pointerlockchange', this.pointerLockChange, !0), document.addEventListener('mozpointerlockchange', this.pointerLockChange, !0), document.addEventListener('webkitpointerlockchange', this.pointerLockChange, !0)), this.enabled = !0 } }, stopListeners: function () { let s = this.target; s.removeEventListener('mousemove', this.onMouseMove), s.removeEventListener('mousedown', this.onMouseDown), s.removeEventListener('mouseup', this.onMouseUp), s.removeEventListener('mouseover', this.onMouseOver), s.removeEventListener('mouseout', this.onMouseOut), window && (s = this.isTop ? window.top : window, s.removeEventListener('mousedown', this.onMouseDownWindow), s.removeEventListener('mouseup', this.onMouseUpWindow)), h.pointerLock && (document.removeEventListener('pointerlockchange', this.pointerLockChange, !0), document.removeEventListener('mozpointerlockchange', this.pointerLockChange, !0), document.removeEventListener('webkitpointerlockchange', this.pointerLockChange, !0)) }, destroy: function () { this.stopListeners(), this.target = null, this.enabled = !1, this.manager = null } }); e.exports = r }, function (e, d, t) { const i = t(349); const h = t(0); const n = t(50); const o = t(124); const r = t(360); const s = t(3); const a = t(105); const f = new h({ initialize: function (u, v) { this.manager = u, this.id = v, this.event, this.downElement, this.upElement, this.camera = null, this.button = 0, this.buttons = 0, this.position = new s(), this.prevPosition = new s(), this.midPoint = new s(-1, -1), this.velocity = new s(), this.angle = 0, this.distance = 0, this.smoothFactor = 0, this.motionFactor = 0.2, this.worldX = 0, this.worldY = 0, this.moveTime = 0, this.downX = 0, this.downY = 0, this.downTime = 0, this.upX = 0, this.upY = 0, this.upTime = 0, this.primaryDown = !1, this.isDown = !1, this.wasTouch = !1, this.wasCanceled = !1, this.movementX = 0, this.movementY = 0, this.identifier = 0, this.pointerId = null, this.active = v === 0, this.locked = !1, this.deltaX = 0, this.deltaY = 0, this.deltaZ = 0 }, updateWorldPoint: function (l) { const u = l.getWorldPoint(this.x, this.y); return this.worldX = u.x, this.worldY = u.y, this }, positionToCamera: function (l, u) { return l.getWorldPoint(this.x, this.y, u) }, updateMotion: function () { const l = this.position.x; const u = this.position.y; const v = this.midPoint.x; const p = this.midPoint.y; if (!(l === v && u === p)) { let c = r(this.motionFactor, v, l); let m = r(this.motionFactor, p, u); o(c, l, 0.1) && (c = l), o(m, u, 0.1) && (m = u), this.midPoint.set(c, m); const g = l - c; const x = u - m; this.velocity.set(g, x), this.angle = i(c, m, l, u), this.distance = Math.sqrt(g * g + x * x) } }, up: function (l) { 'buttons' in l && (this.buttons = l.buttons), this.event = l, this.button = l.button, this.upElement = l.target, this.manager.transformPointer(this, l.pageX, l.pageY, !1), l.button === 0 && (this.primaryDown = !1, this.upX = this.x, this.upY = this.y), this.buttons === 0 && (this.isDown = !1, this.upTime = l.timeStamp, this.wasTouch = !1) }, down: function (l) { 'buttons' in l && (this.buttons = l.buttons), this.event = l, this.button = l.button, this.downElement = l.target, this.manager.transformPointer(this, l.pageX, l.pageY, !1), l.button === 0 && (this.primaryDown = !0, this.downX = this.x, this.downY = this.y), a.macOS && l.ctrlKey && (this.buttons = 2, this.primaryDown = !1), this.isDown || (this.isDown = !0, this.downTime = l.timeStamp), this.wasTouch = !1 }, move: function (l) { 'buttons' in l && (this.buttons = l.buttons), this.event = l, this.manager.transformPointer(this, l.pageX, l.pageY, !0), this.locked && (this.movementX = l.movementX || l.mozMovementX || l.webkitMovementX || 0, this.movementY = l.movementY || l.mozMovementY || l.webkitMovementY || 0), this.moveTime = l.timeStamp, this.wasTouch = !1 }, wheel: function (l) { 'buttons' in l && (this.buttons = l.buttons), this.event = l, this.manager.transformPointer(this, l.pageX, l.pageY, !1), this.deltaX = l.deltaX, this.deltaY = l.deltaY, this.deltaZ = l.deltaZ, this.wasTouch = !1 }, touchstart: function (l, u) { l.pointerId && (this.pointerId = l.pointerId), this.identifier = l.identifier, this.target = l.target, this.active = !0, this.buttons = 1, this.event = u, this.downElement = l.target, this.manager.transformPointer(this, l.pageX, l.pageY, !1), this.primaryDown = !0, this.downX = this.x, this.downY = this.y, this.downTime = u.timeStamp, this.isDown = !0, this.wasTouch = !0, this.wasCanceled = !1, this.updateMotion() }, touchmove: function (l, u) { this.event = u, this.manager.transformPointer(this, l.pageX, l.pageY, !0), this.moveTime = u.timeStamp, this.wasTouch = !0, this.updateMotion() }, touchend: function (l, u) { this.buttons = 0, this.event = u, this.upElement = l.target, this.manager.transformPointer(this, l.pageX, l.pageY, !1), this.primaryDown = !1, this.upX = this.x, this.upY = this.y, this.upTime = u.timeStamp, this.isDown = !1, this.wasTouch = !0, this.wasCanceled = !1, this.active = !1, this.updateMotion() }, touchcancel: function (l, u) { this.buttons = 0, this.event = u, this.upElement = l.target, this.manager.transformPointer(this, l.pageX, l.pageY, !1), this.primaryDown = !1, this.upX = this.x, this.upY = this.y, this.upTime = u.timeStamp, this.isDown = !1, this.wasTouch = !0, this.wasCanceled = !0, this.active = !1 }, noButtonDown: function () { return this.buttons === 0 }, leftButtonDown: function () { return !!(this.buttons & 1) }, rightButtonDown: function () { return !!(this.buttons & 2) }, middleButtonDown: function () { return !!(this.buttons & 4) }, backButtonDown: function () { return !!(this.buttons & 8) }, forwardButtonDown: function () { return !!(this.buttons & 16) }, leftButtonReleased: function () { return this.button === 0 && !this.isDown }, rightButtonReleased: function () { return this.button === 2 && !this.isDown }, middleButtonReleased: function () { return this.button === 1 && !this.isDown }, backButtonReleased: function () { return this.button === 3 && !this.isDown }, forwardButtonReleased: function () { return this.button === 4 && !this.isDown }, getDistance: function () { return this.isDown ? n(this.downX, this.downY, this.x, this.y) : n(this.downX, this.downY, this.upX, this.upY) }, getDistanceX: function () { return this.isDown ? Math.abs(this.downX - this.x) : Math.abs(this.downX - this.upX) }, getDistanceY: function () { return this.isDown ? Math.abs(this.downY - this.y) : Math.abs(this.downY - this.upY) }, getDuration: function () { return this.isDown ? this.manager.time - this.downTime : this.upTime - this.downTime }, getAngle: function () { return this.isDown ? i(this.downX, this.downY, this.x, this.y) : i(this.downX, this.downY, this.upX, this.upY) }, getInterpolatedPosition: function (l, u) { l === void 0 && (l = 10), u === void 0 && (u = []); for (let v = this.prevPosition.x, p = this.prevPosition.y, c = this.position.x, m = this.position.y, g = 0; g < l; g++) { const x = 1 / l * g; u[g] = { x: r(x, v, c), y: r(x, p, m) } } return u }, destroy: function () { this.camera = null, this.manager = null, this.position = null }, x: { get: function () { return this.position.x }, set: function (l) { this.position.x = l } }, y: { get: function () { return this.position.y }, set: function (l) { this.position.y = l } }, time: { get: function () { return this.event ? this.event.timeStamp : 0 } } }); e.exports = f }, function (e, d, t) { const i = t(0); const h = t(51); const n = t(1); const o = new i({ initialize: function (s) { this.manager = s, this.capture = !0, this.enabled = !1, this.target, this.onTouchStart = n, this.onTouchStartWindow = n, this.onTouchMove = n, this.onTouchEnd = n, this.onTouchEndWindow = n, this.onTouchCancel = n, this.onTouchCancelWindow = n, this.onTouchOver = n, this.onTouchOut = n, s.events.once(h.MANAGER_BOOT, this.boot, this) }, boot: function () { const r = this.manager.config; this.enabled = r.inputTouch, this.target = r.inputTouchEventTarget, this.capture = r.inputTouchCapture, this.target || (this.target = this.manager.game.canvas), r.disableContextMenu && this.disableContextMenu(), this.enabled && this.target && this.startListeners() }, disableContextMenu: function () { return document.body.addEventListener('contextmenu', function (r) { return r.preventDefault(), !1 }), this }, startListeners: function () { const r = this; const s = this.manager.canvas; const a = window && window.focus && this.manager.game.config.autoFocus; this.onTouchStart = function (v) { a && window.focus(), !v.defaultPrevented && r.enabled && r.manager && r.manager.enabled && (r.manager.onTouchStart(v), r.capture && v.cancelable && v.target === s && v.preventDefault()) }, this.onTouchStartWindow = function (v) { !v.defaultPrevented && r.enabled && r.manager && r.manager.enabled && v.target !== s && r.manager.onTouchStart(v) }, this.onTouchMove = function (v) { !v.defaultPrevented && r.enabled && r.manager && r.manager.enabled && (r.manager.onTouchMove(v), r.capture && v.cancelable && v.preventDefault()) }, this.onTouchEnd = function (v) { !v.defaultPrevented && r.enabled && r.manager && r.manager.enabled && (r.manager.onTouchEnd(v), r.capture && v.cancelable && v.target === s && v.preventDefault()) }, this.onTouchEndWindow = function (v) { !v.defaultPrevented && r.enabled && r.manager && r.manager.enabled && v.target !== s && r.manager.onTouchEnd(v) }, this.onTouchCancel = function (v) { !v.defaultPrevented && r.enabled && r.manager && r.manager.enabled && (r.manager.onTouchCancel(v), r.capture && v.preventDefault()) }, this.onTouchCancelWindow = function (v) { !v.defaultPrevented && r.enabled && r.manager && r.manager.enabled && r.manager.onTouchCancel(v) }, this.onTouchOver = function (v) { !v.defaultPrevented && r.enabled && r.manager && r.manager.enabled && r.manager.setCanvasOver(v) }, this.onTouchOut = function (v) { !v.defaultPrevented && r.enabled && r.manager && r.manager.enabled && r.manager.setCanvasOut(v) }; const f = this.target; if (f) { const l = { passive: !0 }; const u = { passive: !1 }; f.addEventListener('touchstart', this.onTouchStart, this.capture ? u : l), f.addEventListener('touchmove', this.onTouchMove, this.capture ? u : l), f.addEventListener('touchend', this.onTouchEnd, this.capture ? u : l), f.addEventListener('touchcancel', this.onTouchCancel, this.capture ? u : l), f.addEventListener('touchover', this.onTouchOver, this.capture ? u : l), f.addEventListener('touchout', this.onTouchOut, this.capture ? u : l), window && this.manager.game.config.inputWindowEvents && (window.addEventListener('touchstart', this.onTouchStartWindow, u), window.addEventListener('touchend', this.onTouchEndWindow, u), window.addEventListener('touchcancel', this.onTouchCancelWindow, u)), this.enabled = !0 } }, stopListeners: function () { const r = this.target; r.removeEventListener('touchstart', this.onTouchStart), r.removeEventListener('touchmove', this.onTouchMove), r.removeEventListener('touchend', this.onTouchEnd), r.removeEventListener('touchcancel', this.onTouchCancel), r.removeEventListener('touchover', this.onTouchOver), r.removeEventListener('touchout', this.onTouchOut), window && (window.removeEventListener('touchstart', this.onTouchStartWindow), window.removeEventListener('touchend', this.onTouchEndWindow)) }, destroy: function () { this.stopListeners(), this.target = null, this.enabled = !1, this.manager = null } }); e.exports = o }, function (e, d, t) { const i = t(0); const h = t(22); const n = t(9); const o = t(8); const r = t(16); const s = t(5); const a = t(2); const f = t(24); const l = t(93); const u = new i({ Extends: n, initialize: function (p) { n.call(this), this.game = p, this.plugins = [], this.scenePlugins = [], this._pendingGlobal = [], this._pendingScene = [], p.isBooted ? this.boot() : p.events.once(h.BOOT, this.boot, this) }, boot: function () { let v; let p; let c; let m; let g; let x; let y; const T = this.game.config; let S = T.installGlobalPlugins; for (S = S.concat(this._pendingGlobal), v = 0; v < S.length; v++)p = S[v], c = a(p, 'key', null), m = a(p, 'plugin', null), g = a(p, 'start', !1), x = a(p, 'mapping', null), y = a(p, 'data', null), c && (m ? this.install(c, m, g, x, y) : console.warn('Missing `plugin` for key: ' + c)); for (S = T.installScenePlugins, S = S.concat(this._pendingScene), v = 0; v < S.length; v++)p = S[v], c = a(p, 'key', null), m = a(p, 'plugin', null), x = a(p, 'mapping', null), c && (m ? this.installScenePlugin(c, m, x) : console.warn('Missing `plugin` for key: ' + c)); this._pendingGlobal = [], this._pendingScene = [], this.game.events.once(h.DESTROY, this.destroy, this) }, addToScene: function (v, p, c) { let m; let g; let x; const y = this.game; const T = v.scene; const S = v.settings.map; const E = v.settings.isBooted; for (m = 0; m < p.length; m++)g = p[m], y[g] ? (v[g] = y[g], S.hasOwnProperty(g) && (T[S[g]] = v[g])) : g === 'game' && S.hasOwnProperty(g) && (T[S[g]] = y); for (let C = 0; C < c.length; C++) for (x = c[C], m = 0; m < x.length; m++) if (g = x[m], !!f.hasCore(g)) { const P = f.getCore(g); const A = P.mapping; const M = new P.plugin(T, this, A); v[A] = M, P.custom ? T[A] = M : S.hasOwnProperty(A) && (T[S[A]] = M), E && M.boot() } for (x = this.plugins, m = 0; m < x.length; m++) { const L = x[m]; L.mapping && (T[L.mapping] = L.plugin) } }, getDefaultScenePlugins: function () { let v = this.game.config.defaultPlugins; return v = v.concat(this.scenePlugins), v }, installScenePlugin: function (v, p, c, m, g) { if (g === void 0 && (g = !1), typeof p !== 'function') { console.warn('Invalid Scene Plugin: ' + v); return } if (!f.hasCore(v))f.register(v, p, c, !0), this.scenePlugins.push(v); else if (!g && f.hasCore(v)) { console.warn('Scene Plugin key in use: ' + v); return } if (m) { const x = new p(m, this, v); m.sys[v] = x, c && c !== '' && (m[c] = x), x.boot() } }, install: function (v, p, c, m, g) { if (c === void 0 && (c = !1), m === void 0 && (m = null), g === void 0 && (g = null), typeof p !== 'function') return console.warn('Invalid Plugin: ' + v), null; if (f.hasCustom(v)) return console.warn('Plugin key in use: ' + v), null; if (m !== null && (c = !0), !this.game.isBooted) this._pendingGlobal.push({ key: v, plugin: p, start: c, mapping: m, data: g }); else if (f.registerCustom(v, p, m, g), c) return this.start(v); return null }, getIndex: function (v) { for (let p = this.plugins, c = 0; c < p.length; c++) { const m = p[c]; if (m.key === v) return c } return -1 }, getEntry: function (v) { const p = this.getIndex(v); if (p !== -1) return this.plugins[p] }, isActive: function (v) { const p = this.getEntry(v); return p && p.active }, start: function (v, p) { p === void 0 && (p = v); let c = this.getEntry(p); return c && !c.active ? (c.active = !0, c.plugin.start()) : c || (c = this.createEntry(v, p)), c ? c.plugin : null }, createEntry: function (v, p) { let c = f.getCustom(v); if (c) { const m = new c.plugin(this); c = { key: p, plugin: m, active: !0, mapping: c.mapping, data: c.data }, this.plugins.push(c), m.init(c.data), m.start() } return c }, stop: function (v) { const p = this.getEntry(v); return p && p.active && (p.active = !1, p.plugin.stop()), this }, get: function (v, p) { p === void 0 && (p = !0); let c = this.getEntry(v); if (c) return c.plugin; const m = this.getClass(v); return m && p ? (c = this.createEntry(v, v), c ? c.plugin : null) : m || null }, getClass: function (v) { return f.getCustomClass(v) }, removeGlobalPlugin: function (v) { const p = this.getEntry(v); p && l(this.plugins, p), f.removeCustom(v) }, removeScenePlugin: function (v) { l(this.scenePlugins, v), f.remove(v) }, registerGameObject: function (v, p, c) { return p && s.register(v, p), c && r.register(v, c), this }, removeGameObject: function (v, p, c) { return p === void 0 && (p = !0), c === void 0 && (c = !0), p && s.remove(v), c && r.remove(v), this }, registerFileType: function (v, p, c) { o.register(v, p), c && c.sys.load && (c.sys.load[v] = p) }, destroy: function () { for (let v = 0; v < this.plugins.length; v++) this.plugins[v].plugin.destroy(); f.destroyCustomPlugins(), this.game.noReturn && f.destroyCorePlugins(), this.game = null, this.plugins = [], this.scenePlugins = [] } }); e.exports = u }, function (e, d, t) { const i = t(201); const h = t(0); const n = t(9); const o = t(104); const r = t(22); const s = t(401); const a = t(407); const f = t(402); const l = t(1); const u = t(10); const v = t(416); const p = t(76); const c = t(3); const m = new h({ Extends: n, initialize: function (x) { n.call(this), this.game = x, this.canvas, this.canvasBounds = new u(), this.parent = null, this.parentIsWindow = !1, this.parentSize = new v(), this.gameSize = new v(), this.baseSize = new v(), this.displaySize = new v(), this.scaleMode = i.SCALE_MODE.NONE, this.zoom = 1, this._resetZoom = !1, this.displayScale = new c(1, 1), this.autoRound = !1, this.autoCenter = i.CENTER.NO_CENTER, this.orientation = i.ORIENTATION.LANDSCAPE, this.fullscreen, this.fullscreenTarget = null, this._createdFullscreenTarget = !1, this.dirty = !1, this.resizeInterval = 500, this._lastCheck = 0, this._checkOrientation = !1, this.listeners = { orientationChange: l, windowResize: l, fullScreenChange: l, fullScreenError: l } }, preBoot: function () { this.parseConfig(this.game.config), this.game.events.once(r.BOOT, this.boot, this) }, boot: function () { const g = this.game; this.canvas = g.canvas, this.fullscreen = g.device.fullscreen, this.scaleMode !== i.SCALE_MODE.RESIZE && this.displaySize.setAspectMode(this.scaleMode), this.scaleMode === i.SCALE_MODE.NONE ? this.resize(this.width, this.height) : (this.getParentBounds(), this.parentSize.width > 0 && this.parentSize.height > 0 && this.displaySize.setParent(this.parentSize), this.refresh()), g.events.on(r.PRE_STEP, this.step, this), g.events.once(r.READY, this.refresh, this), g.events.once(r.DESTROY, this.destroy, this), this.startListeners() }, parseConfig: function (g) { this.getParent(g), this.getParentBounds(); let x = g.width; let y = g.height; const T = g.scaleMode; let S = g.zoom; const E = g.autoRound; if (typeof x === 'string') { let C = this.parentSize.width; C === 0 && (C = window.innerWidth); const P = parseInt(x, 10) / 100; x = Math.floor(C * P) } if (typeof y === 'string') { let A = this.parentSize.height; A === 0 && (A = window.innerHeight); const M = parseInt(y, 10) / 100; y = Math.floor(A * M) } this.scaleMode = T, this.autoRound = E, this.autoCenter = g.autoCenter, this.resizeInterval = g.resizeInterval, E && (x = Math.floor(x), y = Math.floor(y)), this.gameSize.setSize(x, y), S === i.ZOOM.MAX_ZOOM && (S = this.getMaxZoom()), this.zoom = S, S !== 1 && (this._resetZoom = !0), this.baseSize.setSize(x, y), E && (this.baseSize.width = Math.floor(this.baseSize.width), this.baseSize.height = Math.floor(this.baseSize.height)), g.minWidth > 0 && this.displaySize.setMin(g.minWidth * S, g.minHeight * S), g.maxWidth > 0 && this.displaySize.setMax(g.maxWidth * S, g.maxHeight * S), this.displaySize.setSize(x, y), this.orientation = f(x, y) }, getParent: function (g) { const x = g.parent; if (x !== null) { if (this.parent = a(x), this.parentIsWindow = this.parent === document.body, g.expandParent && g.scaleMode !== i.SCALE_MODE.NONE) { let y = this.parent.getBoundingClientRect(); (this.parentIsWindow || y.height === 0) && (document.documentElement.style.height = '100%', document.body.style.height = '100%', y = this.parent.getBoundingClientRect(), !this.parentIsWindow && y.height === 0 && (this.parent.style.overflow = 'hidden', this.parent.style.width = '100%', this.parent.style.height = '100%')) }g.fullscreenTarget && !this.fullscreenTarget && (this.fullscreenTarget = a(g.fullscreenTarget)) } }, getParentBounds: function () { if (!this.parent) return !1; const g = this.parentSize; const x = this.parent.getBoundingClientRect(); this.parentIsWindow && this.game.device.os.iOS && (x.height = s(!0)); const y = x.width; const T = x.height; return g.width !== y || g.height !== T ? (g.setSize(y, T), !0) : !1 }, lockOrientation: function (g) { const x = screen.lockOrientation || screen.mozLockOrientation || screen.msLockOrientation; return x ? x.call(screen, g) : !1 }, setParentSize: function (g, x) { return this.parentSize.setSize(g, x), this.refresh() }, setGameSize: function (g, x) { const y = this.autoRound; y && (g = Math.floor(g), x = Math.floor(x)); const T = this.width; const S = this.height; return this.gameSize.resize(g, x), this.baseSize.resize(g, x), y && (this.baseSize.width = Math.floor(this.baseSize.width), this.baseSize.height = Math.floor(this.baseSize.height)), this.displaySize.setAspectRatio(g / x), this.canvas.width = this.baseSize.width, this.canvas.height = this.baseSize.height, this.refresh(T, S) }, resize: function (g, x) { const y = this.zoom; const T = this.autoRound; T && (g = Math.floor(g), x = Math.floor(x)); const S = this.width; const E = this.height; this.gameSize.resize(g, x), this.baseSize.resize(g, x), T && (this.baseSize.width = Math.floor(this.baseSize.width), this.baseSize.height = Math.floor(this.baseSize.height)), this.displaySize.setSize(g * y, x * y), this.canvas.width = this.baseSize.width, this.canvas.height = this.baseSize.height; const C = this.canvas.style; let P = g * y; let A = x * y; return T && (P = Math.floor(P), A = Math.floor(A)), (P !== g || A !== x) && (C.width = P + 'px', C.height = A + 'px'), this.refresh(S, E) }, setZoom: function (g) { return this.zoom = g, this._resetZoom = !0, this.refresh() }, setMaxZoom: function () { return this.zoom = this.getMaxZoom(), this._resetZoom = !0, this.refresh() }, refresh: function (g, x) { g === void 0 && (g = this.width), x === void 0 && (x = this.height), this.updateScale(), this.updateBounds(), this.updateOrientation(), this.displayScale.set(this.baseSize.width / this.canvasBounds.width, this.baseSize.height / this.canvasBounds.height); const y = this.game.domContainer; if (y) { this.baseSize.setCSS(y); const T = this.canvas.style; const S = y.style; S.transform = 'scale(' + this.displaySize.width / this.baseSize.width + ',' + this.displaySize.height / this.baseSize.height + ')', S.marginLeft = T.marginLeft, S.marginTop = T.marginTop } return this.emit(o.RESIZE, this.gameSize, this.baseSize, this.displaySize, g, x), this }, updateOrientation: function () { if (this._checkOrientation) { this._checkOrientation = !1; const g = f(this.width, this.height); g !== this.orientation && (this.orientation = g, this.emit(o.ORIENTATION_CHANGE, g)) } }, updateScale: function () { const g = this.canvas.style; const x = this.gameSize.width; const y = this.gameSize.height; let T; let S; const E = this.zoom; const C = this.autoRound; this.scaleMode === i.SCALE_MODE.NONE ? (this.displaySize.setSize(x * E, y * E), T = this.displaySize.width, S = this.displaySize.height, C && (T = Math.floor(T), S = Math.floor(S)), this._resetZoom && (g.width = T + 'px', g.height = S + 'px', this._resetZoom = !1)) : this.scaleMode === i.SCALE_MODE.RESIZE ? (this.displaySize.setSize(this.parentSize.width, this.parentSize.height), this.gameSize.setSize(this.displaySize.width, this.displaySize.height), this.baseSize.setSize(this.displaySize.width, this.displaySize.height), T = this.displaySize.width, S = this.displaySize.height, C && (T = Math.floor(T), S = Math.floor(S)), this.canvas.width = T, this.canvas.height = S) : (this.displaySize.setSize(this.parentSize.width, this.parentSize.height), T = this.displaySize.width, S = this.displaySize.height, C && (T = Math.floor(T), S = Math.floor(S)), g.width = T + 'px', g.height = S + 'px'), this.getParentBounds(), this.updateCenter() }, getMaxZoom: function () { const g = p(this.parentSize.width, this.gameSize.width, 0, !0); const x = p(this.parentSize.height, this.gameSize.height, 0, !0); return Math.max(Math.min(g, x), 1) }, updateCenter: function () { const g = this.autoCenter; if (g !== i.CENTER.NO_CENTER) { const x = this.canvas; const y = x.style; const T = x.getBoundingClientRect(); const S = T.width; const E = T.height; let C = Math.floor((this.parentSize.width - S) / 2); let P = Math.floor((this.parentSize.height - E) / 2); g === i.CENTER.CENTER_HORIZONTALLY ? P = 0 : g === i.CENTER.CENTER_VERTICALLY && (C = 0), y.marginLeft = C + 'px', y.marginTop = P + 'px' } }, updateBounds: function () { const g = this.canvasBounds; const x = this.canvas.getBoundingClientRect(); g.x = x.left + (window.pageXOffset || 0) - (document.documentElement.clientLeft || 0), g.y = x.top + (window.pageYOffset || 0) - (document.documentElement.clientTop || 0), g.width = x.width, g.height = x.height }, transformX: function (g) { return (g - this.canvasBounds.left) * this.displayScale.x }, transformY: function (g) { return (g - this.canvasBounds.top) * this.displayScale.y }, startFullscreen: function (g) { g === void 0 && (g = { navigationUI: 'hide' }); const x = this.fullscreen; if (!x.available) { this.emit(o.FULLSCREEN_UNSUPPORTED); return } if (!x.active) { const y = this.getFullscreenTarget(); x.keyboard ? y[x.request](Element.ALLOW_KEYBOARD_INPUT) : y[x.request](g) } }, fullscreenSuccessHandler: function () { this.getParentBounds(), this.refresh(), this.emit(o.ENTER_FULLSCREEN) }, fullscreenErrorHandler: function (g) { this.removeFullscreenTarget(), this.emit(o.FULLSCREEN_FAILED, g) }, getFullscreenTarget: function () { if (!this.fullscreenTarget) { const g = document.createElement('div'); g.style.margin = '0', g.style.padding = '0', g.style.width = '100%', g.style.height = '100%', this.fullscreenTarget = g, this._createdFullscreenTarget = !0 } if (this._createdFullscreenTarget) { const x = this.canvas.parentNode; x.insertBefore(this.fullscreenTarget, this.canvas), this.fullscreenTarget.appendChild(this.canvas) } return this.fullscreenTarget }, removeFullscreenTarget: function () { if (this._createdFullscreenTarget) { const g = this.fullscreenTarget; if (g && g.parentNode) { const x = g.parentNode; x.insertBefore(this.canvas, g), x.removeChild(g) } } }, stopFullscreen: function () { const g = this.fullscreen; if (!g.available) return this.emit(o.FULLSCREEN_UNSUPPORTED), !1; g.active && document[g.cancel](), this.removeFullscreenTarget(), this.getParentBounds(), this.emit(o.LEAVE_FULLSCREEN), this.refresh() }, toggleFullscreen: function (g) { this.fullscreen.active ? this.stopFullscreen() : this.startFullscreen(g) }, startListeners: function () { const g = this; const x = this.listeners; if (x.orientationChange = function () { g.updateBounds(), g._checkOrientation = !0, g.dirty = !0 }, x.windowResize = function () { g.updateBounds(), g.dirty = !0 }, window.addEventListener('orientationchange', x.orientationChange, !1), window.addEventListener('resize', x.windowResize, !1), this.fullscreen.available) { x.fullScreenChange = function (T) { return g.onFullScreenChange(T) }, x.fullScreenError = function (T) { return g.onFullScreenError(T) }; const y = ['webkit', 'moz', '']; y.forEach(function (T) { document.addEventListener(T + 'fullscreenchange', x.fullScreenChange, !1), document.addEventListener(T + 'fullscreenerror', x.fullScreenError, !1) }), document.addEventListener('MSFullscreenChange', x.fullScreenChange, !1), document.addEventListener('MSFullscreenError', x.fullScreenError, !1) } }, onFullScreenChange: function () { document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement || document.mozFullScreenElement ? this.fullscreenSuccessHandler() : this.stopFullscreen() }, onFullScreenError: function () { this.removeFullscreenTarget() }, step: function (g, x) { !this.parent || (this._lastCheck += x, (this.dirty || this._lastCheck > this.resizeInterval) && (this.getParentBounds() && this.refresh(), this.dirty = !1, this._lastCheck = 0)) }, stopListeners: function () { const g = this.listeners; window.removeEventListener('orientationchange', g.orientationChange, !1), window.removeEventListener('resize', g.windowResize, !1); const x = ['webkit', 'moz', '']; x.forEach(function (y) { document.removeEventListener(y + 'fullscreenchange', g.fullScreenChange, !1), document.removeEventListener(y + 'fullscreenerror', g.fullScreenError, !1) }), document.removeEventListener('MSFullscreenChange', g.fullScreenChange, !1), document.removeEventListener('MSFullscreenError', g.fullScreenError, !1) }, destroy: function () { this.removeAllListeners(), this.stopListeners(), this.game = null, this.canvas = null, this.canvasBounds = null, this.parent = null, this.fullscreenTarget = null, this.parentSize.destroy(), this.gameSize.destroy(), this.baseSize.destroy(), this.displaySize.destroy() }, isFullscreen: { get: function () { return this.fullscreen.active } }, width: { get: function () { return this.gameSize.width } }, height: { get: function () { return this.gameSize.height } }, isPortrait: { get: function () { return this.orientation === i.ORIENTATION.PORTRAIT } }, isLandscape: { get: function () { return this.orientation === i.ORIENTATION.LANDSCAPE } }, isGamePortrait: { get: function () { return this.height > this.width } }, isGameLandscape: { get: function () { return this.width > this.height } } }); e.exports = m }, function (e, d, t) { const i = t(18); const h = t(0); const n = t(76); const o = t(3); var r = new h({ initialize: function (a, f, l, u) { a === void 0 && (a = 0), f === void 0 && (f = a), l === void 0 && (l = 0), u === void 0 && (u = null), this._width = a, this._height = f, this._parent = u, this.aspectMode = l, this.aspectRatio = f === 0 ? 1 : a / f, this.minWidth = 0, this.minHeight = 0, this.maxWidth = Number.MAX_VALUE, this.maxHeight = Number.MAX_VALUE, this.snapTo = new o() }, setAspectMode: function (s) { return s === void 0 && (s = 0), this.aspectMode = s, this.setSize(this._width, this._height) }, setSnap: function (s, a) { return s === void 0 && (s = 0), a === void 0 && (a = s), this.snapTo.set(s, a), this.setSize(this._width, this._height) }, setParent: function (s) { return this._parent = s, this.setSize(this._width, this._height) }, setMin: function (s, a) { return s === void 0 && (s = 0), a === void 0 && (a = s), this.minWidth = i(s, 0, this.maxWidth), this.minHeight = i(a, 0, this.maxHeight), this.setSize(this._width, this._height) }, setMax: function (s, a) { return s === void 0 && (s = Number.MAX_VALUE), a === void 0 && (a = s), this.maxWidth = i(s, this.minWidth, Number.MAX_VALUE), this.maxHeight = i(a, this.minHeight, Number.MAX_VALUE), this.setSize(this._width, this._height) }, setSize: function (s, a) { switch (s === void 0 && (s = 0), a === void 0 && (a = s), this.aspectMode) { case r.NONE:this._width = this.getNewWidth(n(s, this.snapTo.x)), this._height = this.getNewHeight(n(a, this.snapTo.y)), this.aspectRatio = this._height === 0 ? 1 : this._width / this._height; break; case r.WIDTH_CONTROLS_HEIGHT:this._width = this.getNewWidth(n(s, this.snapTo.x)), this._height = this.getNewHeight(this._width * (1 / this.aspectRatio), !1); break; case r.HEIGHT_CONTROLS_WIDTH:this._height = this.getNewHeight(n(a, this.snapTo.y)), this._width = this.getNewWidth(this._height * this.aspectRatio, !1); break; case r.FIT:this.constrain(s, a, !0); break; case r.ENVELOP:this.constrain(s, a, !1); break } return this }, setAspectRatio: function (s) { return this.aspectRatio = s, this.setSize(this._width, this._height) }, resize: function (s, a) { return this._width = this.getNewWidth(n(s, this.snapTo.x)), this._height = this.getNewHeight(n(a, this.snapTo.y)), this.aspectRatio = this._height === 0 ? 1 : this._width / this._height, this }, getNewWidth: function (s, a) { return a === void 0 && (a = !0), s = i(s, this.minWidth, this.maxWidth), a && this._parent && s > this._parent.width && (s = Math.max(this.minWidth, this._parent.width)), s }, getNewHeight: function (s, a) { return a === void 0 && (a = !0), s = i(s, this.minHeight, this.maxHeight), a && this._parent && s > this._parent.height && (s = Math.max(this.minHeight, this._parent.height)), s }, constrain: function (s, a, f) { s === void 0 && (s = 0), a === void 0 && (a = s), f === void 0 && (f = !0), s = this.getNewWidth(s), a = this.getNewHeight(a); const l = this.snapTo; const u = a === 0 ? 1 : s / a; return f && this.aspectRatio > u || !f && this.aspectRatio < u ? (s = n(s, l.x), a = s / this.aspectRatio, l.y > 0 && (a = n(a, l.y), s = a * this.aspectRatio)) : (f && this.aspectRatio < u || !f && this.aspectRatio > u) && (a = n(a, l.y), s = a * this.aspectRatio, l.x > 0 && (s = n(s, l.x), a = s * (1 / this.aspectRatio))), this._width = s, this._height = a, this }, fitTo: function (s, a) { return this.constrain(s, a, !0) }, envelop: function (s, a) { return this.constrain(s, a, !1) }, setWidth: function (s) { return this.setSize(s, this._height) }, setHeight: function (s) { return this.setSize(this._width, s) }, toString: function () { return '[{ Size (width=' + this._width + ' height=' + this._height + ' aspectRatio=' + this.aspectRatio + ' aspectMode=' + this.aspectMode + ') }]' }, setCSS: function (s) { s && s.style && (s.style.width = this._width + 'px', s.style.height = this._height + 'px') }, copy: function (s) { return s.setAspectMode(this.aspectMode), s.aspectRatio = this.aspectRatio, s.setSize(this.width, this.height) }, destroy: function () { this._parent = null, this.snapTo = null }, width: { get: function () { return this._width }, set: function (s) { this.setSize(s, this._height) } }, height: { get: function () { return this._height }, set: function (s) { this.setSize(this._width, s) } } }); r.NONE = 0, r.WIDTH_CONTROLS_HEIGHT = 1, r.HEIGHT_CONTROLS_WIDTH = 2, r.FIT = 3, r.ENVELOP = 4, e.exports = r }, function (e, d, t) {
        const i = t(0); const h = t(144); const n = t(20); const o = t(22); const r = t(6); const s = t(95); const a = t(1); const f = t(418); const l = t(204); const u = new i({
          initialize: function (p, c) { if (this.game = p, this.keys = {}, this.scenes = [], this._pending = [], this._start = [], this._queue = [], this._data = {}, this.isProcessing = !1, this.isBooted = !1, this.customViewports = 0, c) { Array.isArray(c) || (c = [c]); for (let m = 0; m < c.length; m++) this._pending.push({ key: 'default', scene: c[m], autoStart: m === 0, data: {} }) }p.events.once(o.READY, this.bootQueue, this) },
          bootQueue: function () { if (!this.isBooted) { let v, p, c, m; for (v = 0; v < this._pending.length; v++) { p = this._pending[v], c = p.key, m = p.scene; var g; m instanceof f ? g = this.createSceneFromInstance(c, m) : typeof m === 'object' ? g = this.createSceneFromObject(c, m) : typeof m === 'function' && (g = this.createSceneFromFunction(c, m)), c = g.sys.settings.key, this.keys[c] = g, this.scenes.push(g), this._data[c] && (g.sys.settings.data = this._data[c].data, this._data[c].autoStart && (p.autoStart = !0)), (p.autoStart || g.sys.settings.active) && this._start.push(c) } for (this._pending.length = 0, this._data = {}, this.isBooted = !0, v = 0; v < this._start.length; v++)p = this._start[v], this.start(p); this._start.length = 0 } },
          processQueue: function () { const v = this._pending.length; const p = this._queue.length; if (!(v === 0 && p === 0)) { let c, m; if (v) { for (c = 0; c < v; c++)m = this._pending[c], this.add(m.key, m.scene, m.autoStart, m.data); for (c = 0; c < this._start.length; c++)m = this._start[c], this.start(m); this._start.length = 0, this._pending.length = 0; return } for (c = 0; c < this._queue.length; c++)m = this._queue[c], this[m.op](m.keyA, m.keyB); this._queue.length = 0 } },
          add: function (v, p, c, m) { if (c === void 0 && (c = !1), m === void 0 && (m = {}), this.isProcessing || !this.isBooted) return this._pending.push({ key: v, scene: p, autoStart: c, data: m }), this.isBooted || (this._data[v] = { data: m }), null; v = this.getKey(v, p); let g; return p instanceof f ? g = this.createSceneFromInstance(v, p) : typeof p === 'object' ? (p.key = v, g = this.createSceneFromObject(v, p)) : typeof p === 'function' && (g = this.createSceneFromFunction(v, p)), g.sys.settings.data = m, v = g.sys.settings.key, this.keys[v] = g, this.scenes.push(g), (c || g.sys.settings.active) && (this._pending.length ? this._start.push(v) : this.start(v)), g },
          remove: function (v) { if (this.isProcessing) this._queue.push({ op: 'remove', keyA: v, keyB: null }); else { const p = this.getScene(v); if (!p || p.sys.isTransitioning()) return this; let c = this.scenes.indexOf(p); const m = p.sys.settings.key; c > -1 && (delete this.keys[m], this.scenes.splice(c, 1), this._start.indexOf(m) > -1 && (c = this._start.indexOf(m), this._start.splice(c, 1)), p.sys.destroy()) } return this },
          bootScene: function (v) { const p = v.sys; const c = p.settings; p.sceneUpdate = a, v.init && (v.init.call(v, c.data), c.status = h.INIT, c.isTransition && p.events.emit(n.TRANSITION_INIT, c.transitionFrom, c.transitionDuration)); let m; p.load && (m = p.load, m.reset()), m && v.preload ? (v.preload.call(v), m.list.size === 0 ? this.create(v) : (c.status = h.LOADING, m.once(s.COMPLETE, this.loadComplete, this), m.start())) : this.create(v) },
          loadComplete: function (v) { this.create(v.scene) },
          payloadComplete: function (v) { this.bootScene(v.scene) },
          update: function (v, p) { this.processQueue(), this.isProcessing = !0; for (let c = this.scenes.length - 1; c >= 0; c--) { const m = this.scenes[c].sys; m.settings.status > h.START && m.settings.status <= h.RUNNING && m.step(v, p) } },
          render: function (v) { for (let p = 0; p < this.scenes.length; p++) { const c = this.scenes[p].sys; c.settings.visible && c.settings.status >= h.LOADING && c.settings.status < h.SLEEPING && c.render(v) } this.isProcessing = !1 },
          create: function (v) { const p = v.sys; const c = p.settings; v.create && (c.status = h.CREATING, v.create.call(v, c.data), c.status === h.DESTROYED) || (c.isTransition && p.events.emit(n.TRANSITION_START, c.transitionFrom, c.transitionDuration), v.update && (p.sceneUpdate = v.update), c.status = h.RUNNING, p.events.emit(n.CREATE, v)) },
          createSceneFromFunction: function (v, p) { const c = new p(); if (c instanceof f) { const m = c.sys.settings.key; if (m !== '' && (v = m), this.keys.hasOwnProperty(v)) throw new Error('Cannot add a Scene with duplicate key: ' + v); return this.createSceneFromInstance(v, c) } else return c.sys = new l(c), c.sys.settings.key = v, c.sys.init(this.game), c },
          createSceneFromInstance: function (v, p) { const c = p.sys.settings.key; return c === '' && (p.sys.settings.key = v), p.sys.init(this.game), p },
          createSceneFromObject: function (v, p) { const c = new f(p); const m = c.sys.settings.key; m !== '' ? v = m : c.sys.settings.key = v, c.sys.init(this.game); for (let g = ['init', 'preload', 'create', 'update', 'render'], x = 0; x < g.length; x++) { const y = r(p, g[x], null); y && (c[g[x]] = y) } if (p.hasOwnProperty('extend')) { for (const T in p.extend) if (p.extend.hasOwnProperty(T)) { const S = p.extend[T]; T === 'data' && c.hasOwnProperty('data') && typeof S === 'object' ? c.data.merge(S) : T !== 'sys' && (c[T] = S) } } return c },
          getKey: function (v, p) { if (v || (v = 'default'), typeof p === 'function') return v; if (p instanceof f ? v = p.sys.settings.key : typeof p === 'object' && p.hasOwnProperty('key') && (v = p.key), this.keys.hasOwnProperty(v)) throw new Error('Cannot add a Scene with duplicate key: ' + v); return v },
          getScenes: function (v, p) { v === void 0 && (v = !0), p === void 0 && (p = !1); for (var c = [], m = this.scenes, g = 0; g < m.length; g++) { const x = m[g]; x && (!v || v && x.sys.isActive()) && c.push(x) } return p ? c.reverse() : c },
          getScene: function (v) { if (typeof v === 'string') { if (this.keys[v]) return this.keys[v] } else for (let p = 0; p < this.scenes.length; p++) if (v === this.scenes[p]) return v; return null },
          isActive: function (v) { const p = this.getScene(v); return p ? p.sys.isActive() : null },
          isPaused: function (v) { const p = this.getScene(v); return p ? p.sys.isPaused() : null },
          isVisible: function (v) { const p = this.getScene(v); return p ? p.sys.isVisible() : null },
          isSleeping: function (v) { const p = this.getScene(v); return p ? p.sys.isSleeping() : null },
          pause: function (v, p) { const c = this.getScene(v); return c && c.sys.pause(p), this },
          resume: function (v, p) { const c = this.getScene(v); return c && c.sys.resume(p), this },
          sleep: function (v, p) { const c = this.getScene(v); return c && !c.sys.isTransitioning() && c.sys.sleep(p), this },
          wake: function (v, p) { const c = this.getScene(v); return c && c.sys.wake(p), this },
          run: function (v, p) { const c = this.getScene(v); if (!c) { for (let m = 0; m < this._pending.length; m++) if (this._pending[m].key === v) { this.queueOp('start', v, p); break } return this }c.sys.isSleeping() ? c.sys.wake(p) : c.sys.isPaused() ? c.sys.resume(p) : this.start(v, p) },
          start: function (v, p) { if (!this.isBooted) return this._data[v] = { autoStart: !0, data: p }, this; const c = this.getScene(v); if (c) { const m = c.sys; if (m.isActive() || m.isPaused())m.shutdown(), m.sceneUpdate = a, m.start(p); else { m.sceneUpdate = a, m.start(p); let g; if (m.load && (g = m.load), g && m.settings.hasOwnProperty('pack') && (g.reset(), g.addPack({ payload: m.settings.pack }))) return m.settings.status = h.LOADING, g.once(s.COMPLETE, this.payloadComplete, this), g.start(), this } this.bootScene(c) } return this },
          stop: function (v, p) { const c = this.getScene(v); return c && !c.sys.isTransitioning() && c.sys.shutdown(p), this },
          switch: function (v, p) { const c = this.getScene(v); const m = this.getScene(p); return c && m && c !== m && (this.sleep(v), this.isSleeping(p) ? this.wake(p) : this.start(p)), this },
          getAt: function (v) { return this.scenes[v] },
          getIndex: function (v) { const p = this.getScene(v); return this.scenes.indexOf(p) },
          bringToTop: function (v) { if (this.isProcessing) this._queue.push({ op: 'bringToTop', keyA: v, keyB: null }); else { const p = this.getIndex(v); if (p !== -1 && p < this.scenes.length) { const c = this.getScene(v); this.scenes.splice(p, 1), this.scenes.push(c) } } return this },
          sendToBack: function (v) { if (this.isProcessing) this._queue.push({ op: 'sendToBack', keyA: v, keyB: null }); else { const p = this.getIndex(v); if (p !== -1 && p > 0) { const c = this.getScene(v); this.scenes.splice(p, 1), this.scenes.unshift(c) } } return this },
          moveDown: function (v) { if (this.isProcessing) this._queue.push({ op: 'moveDown', keyA: v, keyB: null }); else { const p = this.getIndex(v); if (p > 0) { const c = p - 1; const m = this.getScene(v); const g = this.getAt(c); this.scenes[p] = g, this.scenes[c] = m } } return this },
          moveUp: function (v) { if (this.isProcessing) this._queue.push({ op: 'moveUp', keyA: v, keyB: null }); else { const p = this.getIndex(v); if (p < this.scenes.length - 1) { const c = p + 1; const m = this.getScene(v); const g = this.getAt(c); this.scenes[p] = g, this.scenes[c] = m } } return this },
          moveAbove: function (v, p) { if (v === p) return this; if (this.isProcessing) this._queue.push({ op: 'moveAbove', keyA: v, keyB: p }); else { const c = this.getIndex(v); const m = this.getIndex(p); if (c !== -1 && m !== -1) { const g = this.getAt(m); this.scenes.splice(m, 1), this.scenes.splice(c + 1, 0, g) } } return this },
          moveBelow: function (v, p) { if (v === p) return this; if (this.isProcessing) this._queue.push({ op: 'moveBelow', keyA: v, keyB: p }); else { const c = this.getIndex(v); const m = this.getIndex(p); if (c !== -1 && m !== -1) { const g = this.getAt(m); this.scenes.splice(m, 1), c === 0 ? this.scenes.unshift(g) : this.scenes.splice(c, 0, g) } } return this },
          queueOp: function (v, p, c) { return this._queue.push({ op: v, keyA: p, keyB: c }), this },
          swapPosition: function (v, p) { if (v === p) return this; if (this.isProcessing) this._queue.push({ op: 'swapPosition', keyA: v, keyB: p }); else { const c = this.getIndex(v); const m = this.getIndex(p); if (c !== m && c !== -1 && m !== -1) { const g = this.getAt(c); this.scenes[c] = this.scenes[m], this.scenes[m] = g } } return this },
          dump: function () {
            for (var v = [], p = ['pending', 'init', 'start', 'loading', 'creating', 'running', 'paused', 'sleeping', 'shutdown', 'destroyed'], c = 0; c < this.scenes.length; c++) { const m = this.scenes[c].sys; let g = m.settings.visible && (m.settings.status === h.RUNNING || m.settings.status === h.PAUSED) ? '[*] ' : '[-] '; g += m.settings.key + ' (' + p[m.settings.status] + ')', v.push(g) }console.log(v.join(`
`))
          },
          destroy: function () { for (let v = 0; v < this.scenes.length; v++) { const p = this.scenes[v].sys; p.destroy() } this.update = a, this.scenes = [], this._pending = [], this._start = [], this._queue = [], this.game = null }
        }); e.exports = u
      }, function (e, d, t) { const i = t(0); const h = t(204); const n = new i({ initialize: function (r) { this.sys = new h(this, r), this.game, this.anims, this.cache, this.registry, this.sound, this.textures, this.events, this.cameras, this.add, this.make, this.scene, this.children, this.lights, this.data, this.input, this.load, this.time, this.tweens, this.physics, this.matter, this.scale, this.plugins, this.renderer }, update: function () {} }); e.exports = n }, function (e, d, t) { const i = t(2); const h = t(205); const n = function (o) { const r = o.game.config.defaultPhysicsSystem; const s = i(o.settings, 'physics', !1); if (!(!r && !s)) { const a = []; if (r && a.push(h(r + 'Physics')), s) for (let f in s)f = h(f.concat('Physics')), a.indexOf(f) === -1 && a.push(f); return a } }; e.exports = n }, function (e, d, t) { const i = t(2); const h = function (n) { const o = n.plugins.getDefaultScenePlugins(); const r = i(n.settings, 'plugins', !1); return Array.isArray(r) ? r : o || [] }; e.exports = h }, function (e, d, t) { const i = t(144); const h = t(6); const n = t(127); const o = t(978); const r = { create: function (s) { return typeof s === 'string' ? s = { key: s } : s === void 0 && (s = {}), { status: i.PENDING, key: h(s, 'key', ''), active: h(s, 'active', !1), visible: h(s, 'visible', !0), isBooted: !1, isTransition: !1, transitionFrom: null, transitionDuration: 0, transitionAllowInput: !0, data: {}, pack: h(s, 'pack', !1), cameras: h(s, 'cameras', null), map: h(s, 'map', n(o, h(s, 'mapAdd', {}))), physics: h(s, 'physics', {}), loader: h(s, 'loader', {}), plugins: h(s, 'plugins', !1), input: h(s, 'input', {}) } } }; e.exports = r }, function (e, d, t) { const i = t(31); const h = t(423); const n = t(0); const o = t(38); const r = t(33); const s = t(9); const a = t(106); const f = t(22); const l = t(388); const u = t(6); const v = t(425); const p = t(206); const c = new n({ Extends: s, initialize: function (g) { s.call(this), this.game = g, this.name = 'TextureManager', this.list = {}, this._tempCanvas = i.create2D(this, 1, 1), this._tempContext = this._tempCanvas.getContext('2d'), this._pending = 0, g.events.once(f.BOOT, this.boot, this) }, boot: function () { this._pending = 3, this.on(a.LOAD, this.updatePending, this), this.on(a.ERROR, this.updatePending, this); const m = this.game.config; this.addBase64('__DEFAULT', m.defaultImage), this.addBase64('__MISSING', m.missingImage), this.addBase64('__WHITE', m.whiteImage), this.game.events.once(f.DESTROY, this.destroy, this) }, updatePending: function () { this._pending--, this._pending === 0 && (this.off(a.LOAD), this.off(a.ERROR), this.emit(a.READY)) }, checkKey: function (m) { return this.exists(m) ? (console.error('Texture key already in use: ' + m), !1) : !0 }, remove: function (m) { if (typeof m === 'string') if (this.exists(m))m = this.get(m); else return console.warn('No texture found matching key: ' + m), this; return this.list.hasOwnProperty(m.key) && (m.destroy(), this.emit(a.REMOVE, m.key)), this }, removeKey: function (m) { return this.list.hasOwnProperty(m) && delete this.list[m], this }, addBase64: function (m, g) { if (this.checkKey(m)) { const x = this; const y = new Image(); y.onerror = function () { x.emit(a.ERROR, m) }, y.onload = function () { const T = x.create(m, y); v.Image(T, 0), x.emit(a.ADD, m, T), x.emit(a.LOAD, m, T) }, y.src = g } return this }, getBase64: function (m, g, x, y) { x === void 0 && (x = 'image/png'), y === void 0 && (y = 0.92); let T = ''; const S = this.getFrame(m, g); if (S && (S.source.isRenderTexture || S.source.isGLTexture))console.warn('Cannot getBase64 from WebGL Texture'); else if (S) { const E = S.canvasData; const C = i.create2D(this, E.width, E.height); const P = C.getContext('2d'); P.drawImage(S.source.image, E.x, E.y, E.width, E.height, 0, 0, E.width, E.height), T = C.toDataURL(x, y), i.remove(C) } return T }, addImage: function (m, g, x) { let y = null; return this.checkKey(m) && (y = this.create(m, g), v.Image(y, 0), x && y.setDataSource(x), this.emit(a.ADD, m, y)), y }, addGLTexture: function (m, g, x, y) { let T = null; return this.checkKey(m) && (x === void 0 && (x = g.width), y === void 0 && (y = g.height), T = this.create(m, g, x, y), T.add('__BASE', 0, 0, 0, x, y), this.emit(a.ADD, m, T)), T }, addRenderTexture: function (m, g) { let x = null; return this.checkKey(m) && (x = this.create(m, g), x.add('__BASE', 0, 0, 0, g.width, g.height), this.emit(a.ADD, m, x)), x }, generate: function (m, g) { if (this.checkKey(m)) { const x = i.create(this, 1, 1); return g.canvas = x, l(g), this.addCanvas(m, x) } else return null }, createCanvas: function (m, g, x) { if (g === void 0 && (g = 256), x === void 0 && (x = 256), this.checkKey(m)) { const y = i.create(this, g, x, r.CANVAS, !0); return this.addCanvas(m, y) } return null }, addCanvas: function (m, g, x) { x === void 0 && (x = !1); let y = null; return x ? y = new h(this, m, g, g.width, g.height) : this.checkKey(m) && (y = new h(this, m, g, g.width, g.height), this.list[m] = y, this.emit(a.ADD, m, y)), y }, addAtlas: function (m, g, x, y) { return Array.isArray(x.textures) || Array.isArray(x.frames) ? this.addAtlasJSONArray(m, g, x, y) : this.addAtlasJSONHash(m, g, x, y) }, addAtlasJSONArray: function (m, g, x, y) { let T = null; if (this.checkKey(m)) { if (T = this.create(m, g), Array.isArray(x)) for (let S = x.length === 1, E = 0; E < T.source.length; E++) { const C = S ? x[0] : x[E]; v.JSONArray(T, E, C) } else v.JSONArray(T, 0, x); y && T.setDataSource(y), this.emit(a.ADD, m, T) } return T }, addAtlasJSONHash: function (m, g, x, y) { let T = null; if (this.checkKey(m)) { if (T = this.create(m, g), Array.isArray(x)) for (let S = 0; S < x.length; S++)v.JSONHash(T, S, x[S]); else v.JSONHash(T, 0, x); y && T.setDataSource(y), this.emit(a.ADD, m, T) } return T }, addAtlasXML: function (m, g, x, y) { let T = null; return this.checkKey(m) && (T = this.create(m, g), v.AtlasXML(T, 0, x), y && T.setDataSource(y), this.emit(a.ADD, m, T)), T }, addUnityAtlas: function (m, g, x, y) { let T = null; return this.checkKey(m) && (T = this.create(m, g), v.UnityYAML(T, 0, x), y && T.setDataSource(y), this.emit(a.ADD, m, T)), T }, addSpriteSheet: function (m, g, x) { let y = null; if (this.checkKey(m)) { y = this.create(m, g); const T = y.source[0].width; const S = y.source[0].height; v.SpriteSheet(y, 0, 0, 0, T, S, x), this.emit(a.ADD, m, y) } return y }, addSpriteSheetFromAtlas: function (m, g) { if (!this.checkKey(m)) return null; const x = u(g, 'atlas', null); const y = u(g, 'frame', null); if (!(!x || !y)) { const T = this.get(x); const S = T.get(y); if (S) { const E = this.create(m, S.source.image); return S.trimmed ? v.SpriteSheetFromAtlas(E, S, g) : v.SpriteSheet(E, 0, S.cutX, S.cutY, S.cutWidth, S.cutHeight, g), this.emit(a.ADD, m, E), E } } }, create: function (m, g, x, y) { let T = null; return this.checkKey(m) && (T = new p(this, m, g, x, y), this.list[m] = T), T }, exists: function (m) { return this.list.hasOwnProperty(m) }, get: function (m) { return m === void 0 && (m = '__DEFAULT'), this.list[m] ? this.list[m] : m instanceof p ? m : this.list.__MISSING }, cloneFrame: function (m, g) { if (this.list[m]) return this.list[m].get(g).clone() }, getFrame: function (m, g) { if (this.list[m]) return this.list[m].get(g) }, getTextureKeys: function () { const m = []; for (const g in this.list)g !== '__DEFAULT' && g !== '__MISSING' && m.push(g); return m }, getPixel: function (m, g, x, y) { const T = this.getFrame(x, y); if (T) { m -= T.x, g -= T.y; const S = T.data.cut; if (m += S.x, g += S.y, m >= S.x && m < S.r && g >= S.y && g < S.b) { const E = this._tempContext; E.clearRect(0, 0, 1, 1), E.drawImage(T.source.image, m, g, 1, 1, 0, 0, 1, 1); const C = E.getImageData(0, 0, 1, 1); return new o(C.data[0], C.data[1], C.data[2], C.data[3]) } } return null }, getPixelAlpha: function (m, g, x, y) { const T = this.getFrame(x, y); if (T) { m -= T.x, g -= T.y; const S = T.data.cut; if (m += S.x, g += S.y, m >= S.x && m < S.r && g >= S.y && g < S.b) { const E = this._tempContext; E.clearRect(0, 0, 1, 1), E.drawImage(T.source.image, m, g, 1, 1, 0, 0, 1, 1); const C = E.getImageData(0, 0, 1, 1); return C.data[3] } } return null }, setTexture: function (m, g, x) { return this.list[g] && (m.texture = this.list[g], m.frame = m.texture.get(x)), m }, renameTexture: function (m, g) { const x = this.get(m); return x && m !== g ? (x.key = g, this.list[g] = x, delete this.list[m], !0) : !1 }, each: function (m, g) { for (var x = [null], y = 1; y < arguments.length; y++)x.push(arguments[y]); for (const T in this.list)x[0] = this.list[T], m.apply(g, x) }, destroy: function () { for (const m in this.list) this.list[m].destroy(); this.list = {}, this.game = null, i.remove(this._tempCanvas) } }); e.exports = c }, function (e, d, t) { const i = t(0); const h = t(18); const n = t(38); const o = t(33); const r = t(138); const s = t(206); const a = new i({ Extends: s, initialize: function (l, u, v, p, c) { s.call(this, l, u, v, p, c), this.add('__BASE', 0, 0, 0, p, c), this._source = this.frames.__BASE.source, this.canvas = this._source.image, this.context = this.canvas.getContext('2d'), this.width = p, this.height = c, this.imageData = this.context.getImageData(0, 0, p, c), this.data = null, this.imageData && (this.data = this.imageData.data), this.pixels = null, this.buffer, this.data && (this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data) }, update: function () { return this.imageData = this.context.getImageData(0, 0, this.width, this.height), this.data = this.imageData.data, this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data, this.manager.game.config.renderType === o.WEBGL && this.refresh(), this }, draw: function (f, l, u) { return this.context.drawImage(u, f, l), this.update() }, drawFrame: function (f, l, u, v) { u === void 0 && (u = 0), v === void 0 && (v = 0); const p = this.manager.getFrame(f, l); if (p) { const c = p.canvasData; const m = p.cutWidth; const g = p.cutHeight; const x = p.source.resolution; return this.context.drawImage(p.source.image, c.x, c.y, m, g, u, v, m / x, g / x), this.update() } else return this }, setPixel: function (f, l, u, v, p, c) { c === void 0 && (c = 255), f = Math.abs(Math.floor(f)), l = Math.abs(Math.floor(l)); const m = this.getIndex(f, l); if (m > -1) { const g = this.context.getImageData(f, l, 1, 1); g.data[0] = u, g.data[1] = v, g.data[2] = p, g.data[3] = c, this.context.putImageData(g, f, l) } return this }, putData: function (f, l, u, v, p, c, m) { return v === void 0 && (v = 0), p === void 0 && (p = 0), c === void 0 && (c = f.width), m === void 0 && (m = f.height), this.context.putImageData(f, l, u, v, p, c, m), this }, getData: function (f, l, u, v) { f = h(Math.floor(f), 0, this.width - 1), l = h(Math.floor(l), 0, this.height - 1), u = h(u, 1, this.width - f), v = h(v, 1, this.height - l); const p = this.context.getImageData(f, l, u, v); return p }, getPixel: function (f, l, u) { u || (u = new n()); const v = this.getIndex(f, l); if (v > -1) { const p = this.data; const c = p[v + 0]; const m = p[v + 1]; const g = p[v + 2]; const x = p[v + 3]; u.setTo(c, m, g, x) } return u }, getPixels: function (f, l, u, v) { f === void 0 && (f = 0), l === void 0 && (l = 0), u === void 0 && (u = this.width), v === void 0 && (v = u), f = Math.abs(Math.round(f)), l = Math.abs(Math.round(l)); for (var p = h(f, 0, this.width), c = h(f + u, 0, this.width), m = h(l, 0, this.height), g = h(l + v, 0, this.height), x = new n(), y = [], T = m; T < g; T++) { for (var S = [], E = p; E < c; E++)x = this.getPixel(E, T, x), S.push({ x: E, y: T, color: x.color, alpha: x.alphaGL }); y.push(S) } return y }, getIndex: function (f, l) { return f = Math.abs(Math.round(f)), l = Math.abs(Math.round(l)), f < this.width && l < this.height ? (f + l * this.width) * 4 : -1 }, refresh: function () { return this._source.update(), this }, getCanvas: function () { return this.canvas }, getContext: function () { return this.context }, clear: function (f, l, u, v) { return f === void 0 && (f = 0), l === void 0 && (l = 0), u === void 0 && (u = this.width), v === void 0 && (v = this.height), this.context.clearRect(f, l, u, v), this.update() }, setSize: function (f, l) { return l === void 0 && (l = f), (f !== this.width || l !== this.height) && (this.canvas.width = f, this.canvas.height = l, this._source.width = f, this._source.height = l, this._source.isPowerOf2 = r(f, l), this.frames.__BASE.setSize(f, l, 0, 0), this.width = f, this.height = l, this.refresh()), this }, destroy: function () { s.prototype.destroy.call(this), this._source = null, this.canvas = null, this.context = null, this.imageData = null, this.data = null, this.pixels = null, this.buffer = null } }); e.exports = a }, function (e, d, t) { const i = t(31); const h = t(0); const n = t(138); const o = t(168); const r = new h({ initialize: function (a, f, l, u, v) { v === void 0 && (v = !1); const p = a.manager.game; this.renderer = p.renderer, this.texture = a, this.source = f, this.image = f, this.compressionAlgorithm = null, this.resolution = 1, this.width = l || f.naturalWidth || f.videoWidth || f.width || 0, this.height = u || f.naturalHeight || f.videoHeight || f.height || 0, this.scaleMode = o.DEFAULT, this.isCanvas = f instanceof HTMLCanvasElement, this.isVideo = window.hasOwnProperty('HTMLVideoElement') && f instanceof HTMLVideoElement, this.isRenderTexture = f.type === 'RenderTexture', this.isGLTexture = window.hasOwnProperty('WebGLTexture') && f instanceof WebGLTexture, this.isPowerOf2 = n(this.width, this.height), this.glTexture = null, this.glIndex = 0, this.glIndexCounter = -1, this.flipY = v, this.init(p) }, init: function (s) { const a = this.renderer; a && (a.gl ? this.isCanvas ? this.glTexture = a.createCanvasTexture(this.image, !1, this.flipY) : this.isVideo ? this.glTexture = a.createVideoTexture(this.image, !1, this.flipY) : this.isRenderTexture ? (this.image = this.source.canvas, this.glTexture = a.createTextureFromSource(null, this.width, this.height, this.scaleMode)) : this.isGLTexture ? this.glTexture = this.source : this.glTexture = a.createTextureFromSource(this.image, this.width, this.height, this.scaleMode) : this.isRenderTexture && (this.image = this.source.canvas)), s.config.antialias || this.setFilter(1) }, setFilter: function (s) { this.renderer.gl && this.renderer.setTextureFilter(this.glTexture, s), this.scaleMode = s }, setFlipY: function (s) { return s === void 0 && (s = !0), this.flipY = s, this }, update: function () { const s = this.renderer.gl; s && this.isCanvas ? this.glTexture = this.renderer.updateCanvasTexture(this.image, this.glTexture, this.flipY) : s && this.isVideo && (this.glTexture = this.renderer.updateVideoTexture(this.image, this.glTexture, this.flipY)) }, destroy: function () { this.glTexture && this.renderer.deleteTexture(this.glTexture, !0), this.isCanvas && i.remove(this.image), this.renderer = null, this.texture = null, this.source = null, this.image = null, this.glTexture = null } }); e.exports = r }, function (e, d, t) { e.exports = { AtlasXML: t(979), Canvas: t(980), Image: t(981), JSONArray: t(982), JSONHash: t(983), SpriteSheet: t(984), SpriteSheetFromAtlas: t(985), UnityYAML: t(986) } }, function (e, d, t) { const i = t(427); const h = t(430); const n = t(432); const o = { create: function (r) { const s = r.config.audio; const a = r.device.audio; return s.noAudio || !a.webAudio && !a.audioData ? new h(r) : a.webAudio && !s.disableWebAudio ? new n(r) : new i(r) } }; e.exports = o }, function (e, d, t) { const i = t(145); const h = t(0); const n = t(70); const o = t(429); const r = new h({ Extends: i, initialize: function (a) { this.override = !0, this.audioPlayDelay = 0.1, this.loopEndOffset = 0.05, this.onBlurPausedSounds = [], this.locked = 'ontouchstart' in window, this.lockedActionsQueue = this.locked ? [] : null, this._mute = !1, this._volume = 1, i.call(this, a) }, add: function (s, a) { const f = new o(this, s, a); return this.sounds.push(f), f }, unlock: function () { this.locked = !1; const s = this; if (this.game.cache.audio.entries.each(function (u, v) { for (let p = 0; p < v.length; p++) if (v[p].dataset.locked === 'true') return s.locked = !0, !1; return !0 }), !!this.locked) { let a = !1; const f = function () { a = !0 }; var l = function () { if (a) { a = !1; return }document.body.removeEventListener('touchmove', f), document.body.removeEventListener('touchend', l); const u = []; if (s.game.cache.audio.entries.each(function (p, c) { for (let m = 0; m < c.length; m++) { const g = c[m]; g.dataset.locked === 'true' && u.push(g) } return !0 }), u.length !== 0) { const v = u[u.length - 1]; v.oncanplaythrough = function () { v.oncanplaythrough = null, u.forEach(function (p) { p.dataset.locked = 'false' }), s.unlocked = !0 }, u.forEach(function (p) { p.load() }) } }; this.once(n.UNLOCKED, function () { for (this.forEachActiveSound(function (v) { v.currentMarker === null && v.duration === 0 && (v.duration = v.tags[0].duration), v.totalDuration = v.tags[0].duration }); this.lockedActionsQueue.length;) { const u = this.lockedActionsQueue.shift(); u.sound[u.prop].apply ? u.sound[u.prop].apply(u.sound, u.value || []) : u.sound[u.prop] = u.value } }, this), document.body.addEventListener('touchmove', f, !1), document.body.addEventListener('touchend', l, !1) } }, onBlur: function () { this.forEachActiveSound(function (s) { s.isPlaying && (this.onBlurPausedSounds.push(s), s.onBlur()) }) }, onFocus: function () { this.onBlurPausedSounds.forEach(function (s) { s.onFocus() }), this.onBlurPausedSounds.length = 0 }, destroy: function () { i.prototype.destroy.call(this), this.onBlurPausedSounds.length = 0, this.onBlurPausedSounds = null }, isLocked: function (s, a, f) { return s.tags[0].dataset.locked === 'true' ? (this.lockedActionsQueue.push({ sound: s, prop: a, value: f }), !0) : !1 }, setMute: function (s) { return this.mute = s, this }, mute: { get: function () { return this._mute }, set: function (s) { this._mute = s, this.forEachActiveSound(function (a) { a.updateMute() }), this.emit(n.GLOBAL_MUTE, this, s) } }, setVolume: function (s) { return this.volume = s, this }, volume: { get: function () { return this._volume }, set: function (s) { this._volume = s, this.forEachActiveSound(function (a) { a.updateVolume() }), this.emit(n.GLOBAL_VOLUME, this, s) } } }); e.exports = r }, function (e, d, t) { const i = t(78); const h = function (n, o, r, s, a) { if (s === void 0 && (s = 0), a === void 0 && (a = n.length), i(n, s, a)) for (let f = s; f < a; f++) { const l = n[f]; if (!o || o && r === void 0 && l.hasOwnProperty(o) || o && r !== void 0 && l[o] === r) return l } return null }; e.exports = h }, function (e, d, t) { const i = t(146); const h = t(0); const n = t(70); const o = t(18); const r = new h({ Extends: i, initialize: function (a, f, l) { if (l === void 0 && (l = {}), this.tags = a.game.cache.audio.get(f), !this.tags) throw new Error('There is no audio asset with key "' + f + '" in the audio cache'); this.audio = null, this.startTime = 0, this.previousTime = 0, this.duration = this.tags[0].duration, this.totalDuration = this.tags[0].duration, i.call(this, a, f, l) }, play: function (s, a) { return this.manager.isLocked(this, 'play', [s, a]) || !i.prototype.play.call(this, s, a) || !this.pickAndPlayAudioTag() ? !1 : (this.emit(n.PLAY, this), !0) }, pause: function () { return this.manager.isLocked(this, 'pause') || this.startTime > 0 || !i.prototype.pause.call(this) ? !1 : (this.currentConfig.seek = this.audio.currentTime - (this.currentMarker ? this.currentMarker.start : 0), this.stopAndReleaseAudioTag(), this.emit(n.PAUSE, this), !0) }, resume: function () { return this.manager.isLocked(this, 'resume') || this.startTime > 0 || !i.prototype.resume.call(this) || !this.pickAndPlayAudioTag() ? !1 : (this.emit(n.RESUME, this), !0) }, stop: function () { return this.manager.isLocked(this, 'stop') || !i.prototype.stop.call(this) ? !1 : (this.stopAndReleaseAudioTag(), this.emit(n.STOP, this), !0) }, pickAndPlayAudioTag: function () { if (!this.pickAudioTag()) return this.reset(), !1; const s = this.currentConfig.seek; const a = this.currentConfig.delay; const f = (this.currentMarker ? this.currentMarker.start : 0) + s; return this.previousTime = f, this.audio.currentTime = f, this.applyConfig(), a === 0 ? (this.startTime = 0, this.audio.paused && this.playCatchPromise()) : (this.startTime = window.performance.now() + a * 1e3, this.audio.paused || this.audio.pause()), this.resetConfig(), !0 }, pickAudioTag: function () { if (this.audio) return !0; for (let s = 0; s < this.tags.length; s++) { const a = this.tags[s]; if (a.dataset.used === 'false') return a.dataset.used = 'true', this.audio = a, !0 } if (!this.manager.override) return !1; const f = []; this.manager.forEachActiveSound(function (u) { u.key === this.key && u.audio && f.push(u) }, this), f.sort(function (u, v) { return u.loop === v.loop ? v.seek / v.duration - u.seek / u.duration : u.loop ? 1 : -1 }); const l = f[0]; return this.audio = l.audio, l.reset(), l.audio = null, l.startTime = 0, l.previousTime = 0, !0 }, playCatchPromise: function () { const s = this.audio.play(); s && s.catch(function (a) { console.warn(a) }) }, stopAndReleaseAudioTag: function () { this.startTime = 0, this.previousTime = 0, this.audio && (this.audio.pause(), this.audio.dataset.used = 'false', this.audio = null) }, reset: function () { i.prototype.stop.call(this) }, onBlur: function () { this.isPlaying = !1, this.isPaused = !0, this.currentConfig.seek = this.audio.currentTime - (this.currentMarker ? this.currentMarker.start : 0), this.currentConfig.delay = Math.max(0, (this.startTime - window.performance.now()) / 1e3), this.stopAndReleaseAudioTag() }, onFocus: function () { this.isPlaying = !0, this.isPaused = !1, this.pickAndPlayAudioTag() }, update: function (s) { if (this.isPlaying) { if (this.startTime > 0) { this.startTime < s - this.manager.audioPlayDelay && (this.audio.currentTime += Math.max(0, s - this.startTime) / 1e3, this.startTime = 0, this.previousTime = this.audio.currentTime, this.playCatchPromise()); return } const a = this.currentMarker ? this.currentMarker.start : 0; const f = a + this.duration; let l = this.audio.currentTime; if (this.currentConfig.loop)l >= f - this.manager.loopEndOffset ? (this.audio.currentTime = a + Math.max(0, l - f), l = this.audio.currentTime) : l < a && (this.audio.currentTime += a, l = this.audio.currentTime), l < this.previousTime && this.emit(n.LOOPED, this); else if (l >= f) { this.reset(), this.stopAndReleaseAudioTag(), this.emit(n.COMPLETE, this); return } this.previousTime = l } }, destroy: function () { i.prototype.destroy.call(this), this.tags = null, this.audio && this.stopAndReleaseAudioTag() }, updateMute: function () { this.audio && (this.audio.muted = this.currentConfig.mute || this.manager.mute) }, updateVolume: function () { this.audio && (this.audio.volume = o(this.currentConfig.volume * this.manager.volume, 0, 1)) }, calculateRate: function () { i.prototype.calculateRate.call(this), this.audio && (this.audio.playbackRate = this.totalRate) }, mute: { get: function () { return this.currentConfig.mute }, set: function (s) { this.currentConfig.mute = s, !this.manager.isLocked(this, 'mute', s) && (this.updateMute(), this.emit(n.MUTE, this, s)) } }, setMute: function (s) { return this.mute = s, this }, volume: { get: function () { return this.currentConfig.volume }, set: function (s) { this.currentConfig.volume = s, !this.manager.isLocked(this, 'volume', s) && (this.updateVolume(), this.emit(n.VOLUME, this, s)) } }, setVolume: function (s) { return this.volume = s, this }, rate: { get: function () { return this.currentConfig.rate }, set: function (s) { this.currentConfig.rate = s, !this.manager.isLocked(this, n.RATE, s) && (this.calculateRate(), this.emit(n.RATE, this, s)) } }, setRate: function (s) { return this.rate = s, this }, detune: { get: function () { return this.currentConfig.detune }, set: function (s) { this.currentConfig.detune = s, !this.manager.isLocked(this, n.DETUNE, s) && (this.calculateRate(), this.emit(n.DETUNE, this, s)) } }, setDetune: function (s) { return this.detune = s, this }, seek: { get: function () { return this.isPlaying ? this.audio.currentTime - (this.currentMarker ? this.currentMarker.start : 0) : this.isPaused ? this.currentConfig.seek : 0 }, set: function (s) { this.manager.isLocked(this, 'seek', s) || this.startTime > 0 || (this.isPlaying || this.isPaused) && (s = Math.min(Math.max(0, s), this.duration), this.isPlaying ? (this.previousTime = s, this.audio.currentTime = s) : this.isPaused && (this.currentConfig.seek = s), this.emit(n.SEEK, this, s)) } }, setSeek: function (s) { return this.seek = s, this }, loop: { get: function () { return this.currentConfig.loop }, set: function (s) { this.currentConfig.loop = s, !this.manager.isLocked(this, 'loop', s) && (this.audio && (this.audio.loop = s), this.emit(n.LOOP, this, s)) } }, setLoop: function (s) { return this.loop = s, this }, pan: { get: function () { return this.currentConfig.pan }, set: function (s) { this.currentConfig.pan = s, this.emit(n.PAN, this, s) } }, setPan: function (s) { return this.pan = s, this } }); e.exports = r }, function (e, d, t) { const i = t(145); const h = t(0); const n = t(9); const o = t(431); const r = t(1); const s = new h({ Extends: n, initialize: function (f) { n.call(this), this.game = f, this.sounds = [], this.mute = !1, this.volume = 1, this.rate = 1, this.detune = 0, this.pauseOnBlur = !0, this.locked = !1 }, add: function (a, f) { const l = new o(this, a, f); return this.sounds.push(l), l }, addAudioSprite: function (a, f) { const l = this.add(a, f); return l.spritemap = {}, l }, play: function (a, f) { return !1 }, playAudioSprite: function (a, f, l) { return !1 }, remove: function (a) { return i.prototype.remove.call(this, a) }, removeByKey: function (a) { return i.prototype.removeByKey.call(this, a) }, pauseAll: r, resumeAll: r, stopAll: r, update: r, setRate: r, setDetune: r, setMute: r, setVolume: r, forEachActiveSound: function (a, f) { i.prototype.forEachActiveSound.call(this, a, f) }, destroy: function () { i.prototype.destroy.call(this) } }); e.exports = s }, function (e, d, t) { const i = t(146); const h = t(0); const n = t(9); const o = t(17); const r = function () { return !1 }; const s = function () { return null }; const a = function () { return this }; const f = new h({ Extends: n, initialize: function (u, v, p) { p === void 0 && (p = {}), n.call(this), this.manager = u, this.key = v, this.isPlaying = !1, this.isPaused = !1, this.totalRate = 1, this.duration = 0, this.totalDuration = 0, this.config = o({ mute: !1, volume: 1, rate: 1, detune: 0, seek: 0, loop: !1, delay: 0, pan: 0 }, p), this.currentConfig = this.config, this.mute = !1, this.volume = 1, this.rate = 1, this.detune = 0, this.seek = 0, this.loop = !1, this.pan = 0, this.markers = {}, this.currentMarker = null, this.pendingRemove = !1 }, addMarker: r, updateMarker: r, removeMarker: s, play: r, pause: r, resume: r, stop: r, destroy: function () { i.prototype.destroy.call(this) }, setMute: a, setVolume: a, setRate: a, setDetune: a, setSeek: a, setLoop: a, setPan: a }); e.exports = f }, function (e, d, t) { const i = t(433); const h = t(145); const n = t(0); const o = t(70); const r = t(22); const s = t(434); const a = new n({ Extends: h, initialize: function (l) { this.context = this.createAudioContext(l), this.masterMuteNode = this.context.createGain(), this.masterVolumeNode = this.context.createGain(), this.masterMuteNode.connect(this.masterVolumeNode), this.masterVolumeNode.connect(this.context.destination), this.destination = this.masterMuteNode, this.locked = this.context.state === 'suspended' && ('ontouchstart' in window || 'onclick' in window), h.call(this, l), this.locked && l.isBooted ? this.unlock() : l.events.once(r.BOOT, this.unlock, this) }, createAudioContext: function (f) { const l = f.config.audio; if (l.context) return l.context.resume(), l.context; if (window.hasOwnProperty('AudioContext')) return new AudioContext(); if (window.hasOwnProperty('webkitAudioContext')) return new window.webkitAudioContext() }, setAudioContext: function (f) { return this.context && this.context.close(), this.masterMuteNode && this.masterMuteNode.disconnect(), this.masterVolumeNode && this.masterVolumeNode.disconnect(), this.context = f, this.masterMuteNode = f.createGain(), this.masterVolumeNode = f.createGain(), this.masterMuteNode.connect(this.masterVolumeNode), this.masterVolumeNode.connect(f.destination), this.destination = this.masterMuteNode, this }, add: function (f, l) { const u = new s(this, f, l); return this.sounds.push(u), u }, decodeAudio: function (f, l) { let u; Array.isArray(f) ? u = f : u = [{ key: f, data: l }]; for (var v = this.game.cache.audio, p = u.length, c = 0; c < u.length; c++) { const m = u[c]; const g = m.key; let x = m.data; typeof x === 'string' && (x = i(x)); const y = function (S, E) { v.add(S, E), this.emit(o.DECODED, S), p--, p === 0 && this.emit(o.DECODED_ALL) }.bind(this, g); const T = function (S, E) { console.error('Error decoding audio: ' + S + ' - ', E ? E.message : ''), p--, p === 0 && this.emit(o.DECODED_ALL) }.bind(this, g); this.context.decodeAudioData(x, y, T) } }, unlock: function () { const f = this; const l = document.body; const u = function v () { if (f.context && l) { const p = l.removeEventListener; f.context.resume().then(function () { p('touchstart', v), p('touchend', v), p('click', v), p('keydown', v), f.unlocked = !0 }, function () { p('touchstart', v), p('touchend', v), p('click', v), p('keydown', v) }) } }; l && (l.addEventListener('touchstart', u, !1), l.addEventListener('touchend', u, !1), l.addEventListener('click', u, !1), l.addEventListener('keydown', u, !1)) }, onBlur: function () { this.locked || this.context.suspend() }, onFocus: function () { const f = this.context; (f.state === 'suspended' || f.state === 'interrupted') && !this.locked && f.resume() }, update: function (f, l) { h.prototype.update.call(this, f, l); const u = this.context; u && u.state === 'interrupted' && u.resume() }, destroy: function () { if (this.destination = null, this.masterVolumeNode.disconnect(), this.masterVolumeNode = null, this.masterMuteNode.disconnect(), this.masterMuteNode = null, this.game.config.audio.context) this.context.suspend(); else { const f = this; this.context.close().then(function () { f.context = null }) }h.prototype.destroy.call(this) }, setMute: function (f) { return this.mute = f, this }, mute: { get: function () { return this.masterMuteNode.gain.value === 0 }, set: function (f) { this.masterMuteNode.gain.setValueAtTime(f ? 0 : 1, 0), this.emit(o.GLOBAL_MUTE, this, f) } }, setVolume: function (f) { return this.volume = f, this }, volume: { get: function () { return this.masterVolumeNode.gain.value }, set: function (f) { this.masterVolumeNode.gain.setValueAtTime(f, 0), this.emit(o.GLOBAL_VOLUME, this, f) } } }); e.exports = a }, function (e, d) { for (var t = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/', i = new Uint8Array(256), h = 0; h < t.length; h++)i[t.charCodeAt(h)] = h; const n = function (o) { o = o.substr(o.indexOf(',') + 1); const r = o.length; let s = r * 0.75; let a = 0; let f; let l; let u; let v; o[r - 1] === '=' && (s--, o[r - 2] === '=' && s--); for (var p = new ArrayBuffer(s), c = new Uint8Array(p), m = 0; m < r; m += 4)f = i[o.charCodeAt(m)], l = i[o.charCodeAt(m + 1)], u = i[o.charCodeAt(m + 2)], v = i[o.charCodeAt(m + 3)], c[a++] = f << 2 | l >> 4, c[a++] = (l & 15) << 4 | u >> 2, c[a++] = (u & 3) << 6 | v & 63; return p }; e.exports = n }, function (e, d, t) { const i = t(146); const h = t(0); const n = t(70); const o = new h({ Extends: i, initialize: function (s, a, f) { if (f === void 0 && (f = {}), this.audioBuffer = s.game.cache.audio.get(a), !this.audioBuffer) throw new Error('Audio key "' + a + '" missing from cache'); this.source = null, this.loopSource = null, this.muteNode = s.context.createGain(), this.volumeNode = s.context.createGain(), this.pannerNode = null, this.playTime = 0, this.startTime = 0, this.loopTime = 0, this.rateUpdates = [], this.hasEnded = !1, this.hasLooped = !1, this.muteNode.connect(this.volumeNode), s.context.createStereoPanner ? (this.pannerNode = s.context.createStereoPanner(), this.volumeNode.connect(this.pannerNode), this.pannerNode.connect(s.destination)) : this.volumeNode.connect(s.destination), this.duration = this.audioBuffer.duration, this.totalDuration = this.audioBuffer.duration, i.call(this, s, a, f) }, play: function (r, s) { return i.prototype.play.call(this, r, s) ? (this.stopAndRemoveBufferSource(), this.createAndStartBufferSource(), this.emit(n.PLAY, this), !0) : !1 }, pause: function () { return this.manager.context.currentTime < this.startTime || !i.prototype.pause.call(this) ? !1 : (this.currentConfig.seek = this.getCurrentTime(), this.stopAndRemoveBufferSource(), this.emit(n.PAUSE, this), !0) }, resume: function () { return this.manager.context.currentTime < this.startTime || !i.prototype.resume.call(this) ? !1 : (this.createAndStartBufferSource(), this.emit(n.RESUME, this), !0) }, stop: function () { return i.prototype.stop.call(this) ? (this.stopAndRemoveBufferSource(), this.emit(n.STOP, this), !0) : !1 }, createAndStartBufferSource: function () { const r = this.currentConfig.seek; const s = this.currentConfig.delay; const a = this.manager.context.currentTime + s; const f = (this.currentMarker ? this.currentMarker.start : 0) + r; const l = this.duration - r; this.playTime = a - r, this.startTime = a, this.source = this.createBufferSource(), this.applyConfig(), this.source.start(Math.max(0, a), Math.max(0, f), Math.max(0, l)), this.resetConfig() }, createAndStartLoopBufferSource: function () { const r = this.getLoopTime(); const s = this.currentMarker ? this.currentMarker.start : 0; const a = this.duration; this.loopTime = r, this.loopSource = this.createBufferSource(), this.loopSource.playbackRate.setValueAtTime(this.totalRate, 0), this.loopSource.start(Math.max(0, r), Math.max(0, s), Math.max(0, a)) }, createBufferSource: function () { const r = this; const s = this.manager.context.createBufferSource(); return s.buffer = this.audioBuffer, s.connect(this.muteNode), s.onended = function (a) { a.target === r.source && (r.currentConfig.loop ? r.hasLooped = !0 : r.hasEnded = !0) }, s }, stopAndRemoveBufferSource: function () { this.source && (this.source.stop(), this.source.disconnect(), this.source = null), this.playTime = 0, this.startTime = 0, this.stopAndRemoveLoopBufferSource() }, stopAndRemoveLoopBufferSource: function () { this.loopSource && (this.loopSource.stop(), this.loopSource.disconnect(), this.loopSource = null), this.loopTime = 0 }, applyConfig: function () { this.rateUpdates.length = 0, this.rateUpdates.push({ time: 0, rate: 1 }), i.prototype.applyConfig.call(this) }, update: function () { this.hasEnded ? (this.hasEnded = !1, i.prototype.stop.call(this), this.stopAndRemoveBufferSource(), this.emit(n.COMPLETE, this)) : this.hasLooped && (this.hasLooped = !1, this.source = this.loopSource, this.loopSource = null, this.playTime = this.startTime = this.loopTime, this.rateUpdates.length = 0, this.rateUpdates.push({ time: 0, rate: this.totalRate }), this.createAndStartLoopBufferSource(), this.emit(n.LOOPED, this)) }, destroy: function () { i.prototype.destroy.call(this), this.audioBuffer = null, this.stopAndRemoveBufferSource(), this.muteNode.disconnect(), this.muteNode = null, this.volumeNode.disconnect(), this.volumeNode = null, this.pannerNode && (this.pannerNode.disconnect(), this.pannerNode = null), this.rateUpdates.length = 0, this.rateUpdates = null }, calculateRate: function () { i.prototype.calculateRate.call(this); const r = this.manager.context.currentTime; this.source && typeof this.totalRate === 'number' && this.source.playbackRate.setValueAtTime(this.totalRate, r), this.isPlaying && (this.rateUpdates.push({ time: Math.max(this.startTime, r) - this.playTime, rate: this.totalRate }), this.loopSource && (this.stopAndRemoveLoopBufferSource(), this.createAndStartLoopBufferSource())) }, getCurrentTime: function () { for (var r = 0, s = 0; s < this.rateUpdates.length; s++) { let a = 0; s < this.rateUpdates.length - 1 ? a = this.rateUpdates[s + 1].time : a = this.manager.context.currentTime - this.playTime, r += (a - this.rateUpdates[s].time) * this.rateUpdates[s].rate } return r }, getLoopTime: function () { for (var r = 0, s = 0; s < this.rateUpdates.length - 1; s++)r += (this.rateUpdates[s + 1].time - this.rateUpdates[s].time) * this.rateUpdates[s].rate; const a = this.rateUpdates[this.rateUpdates.length - 1]; return this.playTime + a.time + (this.duration - r) / a.rate }, rate: { get: function () { return this.currentConfig.rate }, set: function (r) { this.currentConfig.rate = r, this.calculateRate(), this.emit(n.RATE, this, r) } }, setRate: function (r) { return this.rate = r, this }, detune: { get: function () { return this.currentConfig.detune }, set: function (r) { this.currentConfig.detune = r, this.calculateRate(), this.emit(n.DETUNE, this, r) } }, setDetune: function (r) { return this.detune = r, this }, mute: { get: function () { return this.muteNode.gain.value === 0 }, set: function (r) { this.currentConfig.mute = r, this.muteNode.gain.setValueAtTime(r ? 0 : 1, 0), this.emit(n.MUTE, this, r) } }, setMute: function (r) { return this.mute = r, this }, volume: { get: function () { return this.volumeNode.gain.value }, set: function (r) { this.currentConfig.volume = r, this.volumeNode.gain.setValueAtTime(r, 0), this.emit(n.VOLUME, this, r) } }, setVolume: function (r) { return this.volume = r, this }, seek: { get: function () { return this.isPlaying ? this.manager.context.currentTime < this.startTime ? this.startTime - this.playTime : this.getCurrentTime() : this.isPaused ? this.currentConfig.seek : 0 }, set: function (r) { this.manager.context.currentTime < this.startTime || (this.isPlaying || this.isPaused) && (r = Math.min(Math.max(0, r), this.duration), this.currentConfig.seek = r, this.isPlaying && (this.stopAndRemoveBufferSource(), this.createAndStartBufferSource()), this.emit(n.SEEK, this, r)) } }, setSeek: function (r) { return this.seek = r, this }, loop: { get: function () { return this.currentConfig.loop }, set: function (r) { this.currentConfig.loop = r, this.isPlaying && (this.stopAndRemoveLoopBufferSource(), r && this.createAndStartLoopBufferSource()), this.emit(n.LOOP, this, r) } }, setLoop: function (r) { return this.loop = r, this }, pan: { get: function () { return this.pannerNode ? this.pannerNode.pan.value : 0 }, set: function (r) { this.currentConfig.pan = r, this.pannerNode && this.pannerNode.pan.setValueAtTime(r, this.manager.context.currentTime), this.emit(n.PAN, this, r) } }, setPan: function (r) { return this.pan = r, this } }); e.exports = o }, function (e, d) { const t = function (i) { for (var h = i.length, n = i[0].length, o = new Array(n), r = 0; r < n; r++) { o[r] = new Array(h); for (let s = h - 1; s > -1; s--)o[r][s] = i[s][r] } return o }; e.exports = t }, function (e, d) { function t (n, o, r) { const s = n[o]; n[o] = n[r], n[r] = s } function i (n, o) { return n < o ? -1 : n > o ? 1 : 0 } var h = function (n, o, r, s, a) { for (r === void 0 && (r = 0), s === void 0 && (s = n.length - 1), a === void 0 && (a = i); s > r;) { if (s - r > 600) { const f = s - r + 1; const l = o - r + 1; const u = Math.log(f); const v = 0.5 * Math.exp(2 * u / 3); const p = 0.5 * Math.sqrt(u * v * (f - v) / f) * (l - f / 2 < 0 ? -1 : 1); const c = Math.max(r, Math.floor(o - l * v / f + p)); const m = Math.min(s, Math.floor(o + (f - l) * v / f + p)); h(n, o, c, m, a) } const g = n[o]; let x = r; let y = s; for (t(n, r, o), a(n[s], g) > 0 && t(n, r, s); x < y;) { for (t(n, x, y), x++, y--; a(n[x], g) < 0;)x++; for (;a(n[y], g) > 0;)y-- }a(n[r], g) === 0 ? t(n, r, y) : (y++, t(n, y, s)), y <= o && (r = y + 1), o <= y && (s = y - 1) } }; e.exports = h }, function (e, d, t) { const i = t(6); const h = t(131); const n = function (r, s, a) { for (var f = [], l = 0; l < r.length; l++) for (let u = 0; u < s.length; u++) for (let v = 0; v < a; v++)f.push({ a: r[l], b: s[u] }); return f }; const o = function (r, s, a) { const f = i(a, 'max', 0); const l = i(a, 'qty', 1); const u = i(a, 'random', !1); const v = i(a, 'randomB', !1); let p = i(a, 'repeat', 0); const c = i(a, 'yoyo', !1); let m = []; if (v && h(s), p === -1) if (f === 0)p = 0; else { let g = r.length * s.length * l; c && (g *= 2), p = Math.ceil(f / g) } for (let x = 0; x <= p; x++) { const y = n(r, s, l); u && h(y), m = m.concat(y), c && (y.reverse(), m = m.concat(y)) } return f && m.splice(f), m }; e.exports = o }, function (e, d, t) { e.exports = { PROCESS_QUEUE_ADD: t(1041), PROCESS_QUEUE_REMOVE: t(1042) } }, function (e, d, t) { const i = t(13); const h = function (n, o) { const r = i(o, 'anims', null); if (r === null) return n; if (typeof r === 'string')n.anims.play(r); else if (typeof r === 'object') { const s = n.anims; const a = i(r, 'key', void 0); if (a) { const f = i(r, 'startFrame', void 0); const l = i(r, 'delay', 0); const u = i(r, 'repeat', 0); const v = i(r, 'repeatDelay', 0); const p = i(r, 'yoyo', !1); const c = i(r, 'play', !1); const m = i(r, 'delayedPlay', 0); const g = { key: a, delay: l, repeat: u, repeatDelay: v, yoyo: p, startFrame: f }; c ? s.play(g) : m > 0 ? s.playAfterDelay(g, m) : s.load(g) } } return n }; e.exports = h }, function (e, d, t) { const i = t(0); const h = t(109); const n = new i({ initialize: function (r, s, a, f, l) { this.parent = r, this.x = s, this.y = a, this.frame = f, this.data = {}, this.tint = 16777215, this._visible = l, this._alpha = 1, this.flipX = !1, this.flipY = !1 }, setFrame: function (o) { return o === void 0 ? this.frame = this.parent.frame : o instanceof h && o.texture === this.parent.texture ? this.frame = o : this.frame = this.parent.texture.get(o), this }, resetFlip: function () { return this.flipX = !1, this.flipY = !1, this }, reset: function (o, r, s) { return this.x = o, this.y = r, this.flipX = !1, this.flipY = !1, this._alpha = 1, this._visible = !0, this.parent.dirty = !0, s && this.setFrame(s), this }, setPosition: function (o, r) { return this.x = o, this.y = r, this }, setFlipX: function (o) { return this.flipX = o, this }, setFlipY: function (o) { return this.flipY = o, this }, setFlip: function (o, r) { return this.flipX = o, this.flipY = r, this }, setVisible: function (o) { return this.visible = o, this }, setAlpha: function (o) { return this.alpha = o, this }, setTint: function (o) { return this.tint = o, this }, destroy: function () { this.parent.dirty = !0, this.parent.children.remove(this), this.parent = void 0, this.frame = void 0, this.data = void 0 }, visible: { get: function () { return this._visible }, set: function (o) { this.parent.dirty |= this._visible !== o, this._visible = o } }, alpha: { get: function () { return this._alpha }, set: function (o) { this.parent.dirty |= this._alpha > 0 != o > 0, this._alpha = o } } }); e.exports = n }, function (e, d, t) { const i = t(10); const h = function (n, o, r) { r === void 0 && (r = new i()); const s = Math.min(n.x, o.x); const a = Math.min(n.y, o.y); const f = Math.max(n.right, o.right) - s; const l = Math.max(n.bottom, o.bottom) - a; return r.setTo(s, a, f, l) }; e.exports = h }, function (e, d, t) { const i = t(0); const h = t(11); const n = t(1055); const o = t(15); const r = t(7); const s = t(202); const a = t(20); const f = t(140); const l = new i({ Extends: o, Mixins: [h.AlphaSingle, h.BlendMode, h.Depth, h.Origin, h.ScrollFactor, h.Transform, h.Visible, n], initialize: function (v, p, c, m, g, x) { o.call(this, v, 'DOMElement'), this.parent = v.sys.game.domContainer, this.cache = v.sys.cache.html, this.node, this.transformOnly = !1, this.skewX = 0, this.skewY = 0, this.rotate3d = new f(), this.rotate3dAngle = 'deg', this.pointerEvents = 'auto', this.width = 0, this.height = 0, this.displayWidth = 0, this.displayHeight = 0, this.handler = this.dispatchNativeEvent.bind(this), this.setPosition(p, c), typeof m === 'string' ? m[0] === '#' ? this.setElement(m.substr(1), g, x) : this.createElement(m, g, x) : m && this.setElement(m, g, x), v.sys.events.on(a.SLEEP, this.handleSceneEvent, this), v.sys.events.on(a.WAKE, this.handleSceneEvent, this) }, addedToScene: function () { this.scene.sys.updateList.add(this) }, removedFromScene: function () { this.scene.sys.updateList.remove(this) }, handleSceneEvent: function (u) { const v = this.node; const p = v.style; v && (p.display = u.settings.visible ? 'block' : 'none') }, setSkew: function (u, v) { return u === void 0 && (u = 0), v === void 0 && (v = u), this.skewX = u, this.skewY = v, this }, setPerspective: function (u) { return this.parent.style.perspective = u + 'px', this }, perspective: { get: function () { return parseFloat(this.parent.style.perspective) }, set: function (u) { this.parent.style.perspective = u + 'px' } }, addListener: function (u) { if (this.node) { u = u.split(' '); for (let v = 0; v < u.length; v++) this.node.addEventListener(u[v], this.handler, !1) } return this }, removeListener: function (u) { if (this.node) { u = u.split(' '); for (let v = 0; v < u.length; v++) this.node.removeEventListener(u[v], this.handler) } return this }, dispatchNativeEvent: function (u) { this.emit(u.type, u) }, createElement: function (u, v, p) { return this.setElement(document.createElement(u), v, p) }, setElement: function (u, v, p) { this.removeElement(); let c; if (typeof u === 'string' ? (u[0] === '#' && (u = u.substr(1)), c = document.getElementById(u)) : typeof u === 'object' && u.nodeType === 1 && (c = u), !c) return this; if (this.node = c, v && r(v)) for (const m in v)c.style[m] = v[m]; else typeof v === 'string' && (c.style = v); return c.style.zIndex = '0', c.style.display = 'inline', c.style.position = 'absolute', c.phaser = this, this.parent && this.parent.appendChild(c), p && (c.innerText = p), this.updateSize() }, createFromCache: function (u, v) { const p = this.cache.get(u); return p && this.createFromHTML(p, v), this }, createFromHTML: function (u, v) { v === void 0 && (v = 'div'), this.removeElement(); const p = document.createElement(v); return this.node = p, p.style.zIndex = '0', p.style.display = 'inline', p.style.position = 'absolute', p.phaser = this, this.parent && this.parent.appendChild(p), p.innerHTML = u, this.updateSize() }, removeElement: function () { return this.node && (s(this.node), this.node = null), this }, updateSize: function () { const u = this.node; const v = u.getBoundingClientRect(); return this.width = u.clientWidth, this.height = u.clientHeight, this.displayWidth = v.width || 0, this.displayHeight = v.height || 0, this }, getChildByProperty: function (u, v) { if (this.node) { for (let p = this.node.querySelectorAll('*'), c = 0; c < p.length; c++) if (p[c][u] === v) return p[c] } return null }, getChildByID: function (u) { return this.getChildByProperty('id', u) }, getChildByName: function (u) { return this.getChildByProperty('name', u) }, setClassName: function (u) { return this.node && (this.node.className = u, this.updateSize()), this }, setText: function (u) { return this.node && (this.node.innerText = u, this.updateSize()), this }, setHTML: function (u) { return this.node && (this.node.innerHTML = u, this.updateSize()), this }, preUpdate: function () { const u = this.parentContainer; const v = this.node; v && u && !u.willRender() && (v.style.display = 'none') }, willRender: function () { return !0 }, preDestroy: function () { this.removeElement(), this.scene.sys.events.off(a.SLEEP, this.handleSceneEvent, this), this.scene.sys.events.off(a.WAKE, this.handleSceneEvent, this) } }); e.exports = l }, function (e, d, t) { const i = t(1056); const h = t(15); const n = t(25); const o = new n(); const r = new n(); const s = new n(); const a = function (f, l, u, v) { if (l.node) { const p = l.node.style; const c = l.scene.sys.settings; if (!p || !c.visible || h.RENDER_MASK !== l.renderFlags || l.cameraFilter !== 0 && l.cameraFilter & u.id || l.parentContainer && !l.parentContainer.willRender()) { p.display = 'none'; return } const m = l.parentContainer; let g = u.alpha * l.alpha; m && (g *= m.alpha); const x = o; const y = r; const T = s; let S = 0; let E = 0; let C = '0%'; let P = '0%'; v ? (S = l.width * l.scaleX * l.originX, E = l.height * l.scaleY * l.originY, y.applyITRS(l.x - S, l.y - E, l.rotation, l.scaleX, l.scaleY), x.copyFrom(u.matrix), x.multiplyWithOffset(v, -u.scrollX * l.scrollFactorX, -u.scrollY * l.scrollFactorY), y.e = l.x - S, y.f = l.y - E, x.multiply(y, T)) : (S = l.width * l.originX, E = l.height * l.originY, y.applyITRS(l.x - S, l.y - E, l.rotation, l.scaleX, l.scaleY), x.copyFrom(u.matrix), C = 100 * l.originX + '%', P = 100 * l.originY + '%', y.e -= u.scrollX * l.scrollFactorX, y.f -= u.scrollY * l.scrollFactorY, x.multiply(y, T)), l.transformOnly || (p.display = 'block', p.opacity = g, p.zIndex = l._depth, p.pointerEvents = l.pointerEvents, p.mixBlendMode = i[l._blendMode]), p.transform = T.getCSSMatrix() + ' skew(' + l.skewX + 'rad, ' + l.skewY + 'rad) rotate3d(' + l.rotate3d.x + ',' + l.rotate3d.y + ',' + l.rotate3d.z + ',' + l.rotate3d.w + l.rotate3dAngle + ')', p.transformOrigin = C + ' ' + P } }; e.exports = a }, function (e, d, t) { const i = t(0); const h = t(11); const n = t(15); const o = t(1060); const r = new i({ Extends: n, Mixins: [h.Alpha, h.BlendMode, h.Depth, h.Flip, h.Origin, h.ScrollFactor, h.Size, h.Texture, h.Tint, h.Transform, h.Visible, o], initialize: function (a) { n.call(this, a, 'Extern') }, addedToScene: function () { this.scene.sys.updateList.add(this) }, removedFromScene: function () { this.scene.sys.updateList.remove(this) }, preUpdate: function () {}, render: function () {} }); e.exports = r }, function (e, d, t) { const i = t(218); const h = t(98); const n = t(14); const o = t(4); const r = function (s, a, f) { f === void 0 && (f = new o()); const l = h(a, 0, n.PI2); return i(s, l, f) }; e.exports = r }, function (e, d, t) { const i = t(447); const h = t(218); const n = t(98); const o = t(14); const r = function (s, a, f, l) { l === void 0 && (l = []), !a && f > 0 && (a = i(s) / f); for (let u = 0; u < a; u++) { const v = n(u / a, 0, o.PI2); l.push(h(s, v)) } return l }; e.exports = r }, function (e, d) { const t = function (i) { const h = i.width / 2; const n = i.height / 2; const o = Math.pow(h - n, 2) / Math.pow(h + n, 2); return Math.PI * (h + n) * (1 + 3 * o / (10 + Math.sqrt(4 - 3 * o))) }; e.exports = t }, function (e, d, t) { const i = t(217); const h = t(30); const n = function (o, r, s, a, f, l) { const u = r.commandBuffer; const v = u.length; const p = f || o.currentContext; if (!(v === 0 || !h(o, p, r, s, a))) { s.addToRenderList(r); let c = 1; let m = 1; let g = 0; let x = 0; let y = 1; let T = 0; let S = 0; let E = 0; p.beginPath(); for (let C = 0; C < v; ++C) { const P = u[C]; switch (P) { case i.ARC:p.arc(u[C + 1], u[C + 2], u[C + 3], u[C + 4], u[C + 5], u[C + 6]), C += 7; break; case i.LINE_STYLE:y = u[C + 1], g = u[C + 2], c = u[C + 3], T = (g & 16711680) >>> 16, S = (g & 65280) >>> 8, E = g & 255, p.strokeStyle = 'rgba(' + T + ',' + S + ',' + E + ',' + c + ')', p.lineWidth = y, C += 3; break; case i.FILL_STYLE:x = u[C + 1], m = u[C + 2], T = (x & 16711680) >>> 16, S = (x & 65280) >>> 8, E = x & 255, p.fillStyle = 'rgba(' + T + ',' + S + ',' + E + ',' + m + ')', C += 2; break; case i.BEGIN_PATH:p.beginPath(); break; case i.CLOSE_PATH:p.closePath(); break; case i.FILL_PATH:l || p.fill(); break; case i.STROKE_PATH:l || p.stroke(); break; case i.FILL_RECT:l ? p.rect(u[C + 1], u[C + 2], u[C + 3], u[C + 4]) : p.fillRect(u[C + 1], u[C + 2], u[C + 3], u[C + 4]), C += 4; break; case i.FILL_TRIANGLE:p.beginPath(), p.moveTo(u[C + 1], u[C + 2]), p.lineTo(u[C + 3], u[C + 4]), p.lineTo(u[C + 5], u[C + 6]), p.closePath(), l || p.fill(), C += 6; break; case i.STROKE_TRIANGLE:p.beginPath(), p.moveTo(u[C + 1], u[C + 2]), p.lineTo(u[C + 3], u[C + 4]), p.lineTo(u[C + 5], u[C + 6]), p.closePath(), l || p.stroke(), C += 6; break; case i.LINE_TO:p.lineTo(u[C + 1], u[C + 2]), C += 2; break; case i.MOVE_TO:p.moveTo(u[C + 1], u[C + 2]), C += 2; break; case i.LINE_FX_TO:p.lineTo(u[C + 1], u[C + 2]), C += 5; break; case i.MOVE_FX_TO:p.moveTo(u[C + 1], u[C + 2]), C += 5; break; case i.SAVE:p.save(); break; case i.RESTORE:p.restore(); break; case i.TRANSLATE:p.translate(u[C + 1], u[C + 2]), C += 2; break; case i.SCALE:p.scale(u[C + 1], u[C + 2]), C += 2; break; case i.ROTATE:p.rotate(u[C + 1]), C += 1; break; case i.GRADIENT_FILL_STYLE:C += 5; break; case i.GRADIENT_LINE_STYLE:C += 6; break } }p.restore() } }; e.exports = n }, function (e, d, t) { const i = t(0); const h = t(137); const n = t(80); const o = t(2); const r = t(68); const s = new i({ initialize: function (f, l, u, v) { v === void 0 && (v = !1), this.propertyKey = l, this.propertyValue = u, this.defaultValue = u, this.steps = 0, this.counter = 0, this.start = 0, this.end = 0, this.ease, this.emitOnly = v, this.onEmit = this.defaultEmit, this.onUpdate = this.defaultUpdate, this.loadConfig(f) }, loadConfig: function (a, f) { a === void 0 && (a = {}), f && (this.propertyKey = f), this.propertyValue = o(a, this.propertyKey, this.defaultValue), this.setMethods(), this.emitOnly && (this.onUpdate = this.defaultUpdate) }, toJSON: function () { return this.propertyValue }, onChange: function (a) { return this.propertyValue = a, this.setMethods() }, setMethods: function () { const a = this.propertyValue; const f = typeof a; if (this.onEmit = this.defaultEmit, this.onUpdate = this.defaultUpdate, f === 'number') this.onEmit = this.staticValueEmit, this.onUpdate = this.staticValueUpdate; else if (Array.isArray(a)) this.onEmit = this.randomStaticValueEmit; else if (f === 'function') this.emitOnly ? this.onEmit = a : this.onUpdate = a; else if (f === 'object' && this.hasBoth(a, 'start', 'end')) { this.start = a.start, this.end = a.end; const l = this.has(a, 'random'); if (l && (this.onEmit = this.randomRangedValueEmit), this.has(a, 'steps')) this.steps = a.steps, this.counter = this.start, this.onEmit = this.steppedEmit; else { const u = this.has(a, 'ease') ? a.ease : 'Linear'; this.ease = n(u, a.easeParams), l || (this.onEmit = this.easedValueEmit), this.onUpdate = this.easeValueUpdate } } else if (f === 'object' && this.hasBoth(a, 'min', 'max')) this.start = a.min, this.end = a.max, this.onEmit = this.randomRangedValueEmit; else if (f === 'object' && this.has(a, 'random')) { const v = a.random; Array.isArray(v) && (this.start = v[0], this.end = v[1]), this.onEmit = this.randomRangedValueEmit } else f === 'object' && this.hasEither(a, 'onEmit', 'onUpdate') && (this.has(a, 'onEmit') && (this.onEmit = a.onEmit), this.has(a, 'onUpdate') && (this.onUpdate = a.onUpdate)); return this }, has: function (a, f) { return a.hasOwnProperty(f) }, hasBoth: function (a, f, l) { return a.hasOwnProperty(f) && a.hasOwnProperty(l) }, hasEither: function (a, f, l) { return a.hasOwnProperty(f) || a.hasOwnProperty(l) }, defaultEmit: function (a, f, l) { return l }, defaultUpdate: function (a, f, l, u) { return u }, staticValueEmit: function () { return this.propertyValue }, staticValueUpdate: function () { return this.propertyValue }, randomStaticValueEmit: function () { const a = Math.floor(Math.random() * this.propertyValue.length); return this.propertyValue[a] }, randomRangedValueEmit: function (a, f) { const l = h(this.start, this.end); return a && a.data[f] && (a.data[f].min = l), l }, steppedEmit: function () { const a = this.counter; const f = this.counter + (this.end - this.start) / this.steps; return this.counter = r(f, this.start, this.end), a }, easedValueEmit: function (a, f) { if (a && a.data[f]) { const l = a.data[f]; l.min = this.start, l.max = this.end } return this.start }, easeValueUpdate: function (a, f, l) { const u = a.data[f]; return (u.max - u.min) * this.ease(l) + u.min } }); e.exports = s }, function (e, d, t) { const i = t(0); const h = t(2); const n = new i({ initialize: function (r, s, a, f, l) { if (typeof r === 'object') { const u = r; r = h(u, 'x', 0), s = h(u, 'y', 0), a = h(u, 'power', 0), f = h(u, 'epsilon', 100), l = h(u, 'gravity', 50) } else r === void 0 && (r = 0), s === void 0 && (s = 0), a === void 0 && (a = 0), f === void 0 && (f = 100), l === void 0 && (l = 50); this.x = r, this.y = s, this.active = !0, this._gravity = l, this._power = 0, this._epsilon = 0, this.power = a, this.epsilon = f }, update: function (o, r) { const s = this.x - o.x; const a = this.y - o.y; let f = s * s + a * a; if (f !== 0) { const l = Math.sqrt(f); f < this._epsilon && (f = this._epsilon); const u = this._power * r / (f * l) * 100; o.velocityX += s * u, o.velocityY += a * u } }, epsilon: { get: function () { return Math.sqrt(this._epsilon) }, set: function (o) { this._epsilon = o * o } }, power: { get: function () { return this._power / this._gravity }, set: function (o) { this._power = o * this._gravity } }, gravity: { get: function () { return this._gravity }, set: function (o) { const r = this.power; this._gravity = o, this.power = r } } }); e.exports = n }, function (e, d, t) { const i = t(0); const h = t(36); const n = t(50); const o = new i({ initialize: function (s) { this.emitter = s, this.frame = null, this.x = 0, this.y = 0, this.velocityX = 0, this.velocityY = 0, this.accelerationX = 0, this.accelerationY = 0, this.maxVelocityX = 1e4, this.maxVelocityY = 1e4, this.bounce = 0, this.scaleX = 1, this.scaleY = 1, this.alpha = 1, this.angle = 0, this.rotation = 0, this.tint = 16777215, this.life = 1e3, this.lifeCurrent = 1e3, this.delayCurrent = 0, this.lifeT = 0, this.data = { tint: { min: 16777215, max: 16777215, current: 16777215 }, alpha: { min: 1, max: 1 }, rotate: { min: 0, max: 0 }, scaleX: { min: 1, max: 1 }, scaleY: { min: 1, max: 1 } } }, isAlive: function () { return this.lifeCurrent > 0 }, resetPosition: function () { this.x = 0, this.y = 0 }, fire: function (r, s) { const a = this.emitter; this.frame = a.getFrame(), a.emitZone && a.emitZone.getPoint(this), r === void 0 ? this.x += a.x.onEmit(this, 'x') : this.x += r, s === void 0 ? this.y += a.y.onEmit(this, 'y') : this.y += s, this.life = a.lifespan.onEmit(this, 'lifespan'), this.lifeCurrent = this.life, this.lifeT = 0; const f = a.speedX.onEmit(this, 'speedX'); const l = a.speedY ? a.speedY.onEmit(this, 'speedY') : f; if (a.radial) { const u = h(a.angle.onEmit(this, 'angle')); this.velocityX = Math.cos(u) * Math.abs(f), this.velocityY = Math.sin(u) * Math.abs(l) } else if (a.moveTo) { const v = a.moveToX.onEmit(this, 'moveToX'); const p = a.moveToY ? a.moveToY.onEmit(this, 'moveToY') : v; const c = Math.atan2(p - this.y, v - this.x); const m = n(this.x, this.y, v, p) / (this.life / 1e3); this.velocityX = Math.cos(c) * m, this.velocityY = Math.sin(c) * m } else this.velocityX = f, this.velocityY = l; a.acceleration && (this.accelerationX = a.accelerationX.onEmit(this, 'accelerationX'), this.accelerationY = a.accelerationY.onEmit(this, 'accelerationY')), this.maxVelocityX = a.maxVelocityX.onEmit(this, 'maxVelocityX'), this.maxVelocityY = a.maxVelocityY.onEmit(this, 'maxVelocityY'), this.delayCurrent = a.delay.onEmit(this, 'delay'), this.scaleX = a.scaleX.onEmit(this, 'scaleX'), this.scaleY = a.scaleY ? a.scaleY.onEmit(this, 'scaleY') : this.scaleX, this.angle = a.rotate.onEmit(this, 'rotate'), this.rotation = h(this.angle), this.bounce = a.bounce.onEmit(this, 'bounce'), this.alpha = a.alpha.onEmit(this, 'alpha'), this.tint = a.tint.onEmit(this, 'tint') }, computeVelocity: function (r, s, a, f) { let l = this.velocityX; let u = this.velocityY; const v = this.accelerationX; const p = this.accelerationY; const c = this.maxVelocityX; const m = this.maxVelocityY; l += r.gravityX * a, u += r.gravityY * a, v && (l += v * a), p && (u += p * a), l > c ? l = c : l < -c && (l = -c), u > m ? u = m : u < -m && (u = -m), this.velocityX = l, this.velocityY = u; for (let g = 0; g < f.length; g++)f[g].update(this, s, a) }, checkBounds: function (r) { const s = r.bounds; const a = -this.bounce; this.x < s.x && r.collideLeft ? (this.x = s.x, this.velocityX *= a) : this.x > s.right && r.collideRight && (this.x = s.right, this.velocityX *= a), this.y < s.y && r.collideTop ? (this.y = s.y, this.velocityY *= a) : this.y > s.bottom && r.collideBottom && (this.y = s.bottom, this.velocityY *= a) }, update: function (r, s, a) { if (this.delayCurrent > 0) return this.delayCurrent -= r, !1; const f = this.emitter; const l = 1 - this.lifeCurrent / this.life; return this.lifeT = l, this.computeVelocity(f, r, s, a), this.x += this.velocityX * s, this.y += this.velocityY * s, f.bounds && this.checkBounds(f), f.deathZone && f.deathZone.willKill(this) ? (this.lifeCurrent = 0, !0) : (this.scaleX = f.scaleX.onUpdate(this, 'scaleX', l, this.scaleX), f.scaleY ? this.scaleY = f.scaleY.onUpdate(this, 'scaleY', l, this.scaleY) : this.scaleY = this.scaleX, this.angle = f.rotate.onUpdate(this, 'rotate', l, this.angle), this.rotation = h(this.angle), this.alpha = f.alpha.onUpdate(this, 'alpha', l, this.alpha), this.tint = f.tint.onUpdate(this, 'tint', l, this.tint), this.lifeCurrent -= r, this.lifeCurrent <= 0) } }); e.exports = o }, function (e, d, t) { const i = t(35); const h = t(0); const n = t(11); const o = t(453); const r = t(454); const s = t(449); const a = t(2); const f = t(210); const l = t(455); const u = t(126); const v = t(451); const p = t(456); const c = t(10); const m = t(79); const g = t(3); const x = t(68); const y = new h({ Mixins: [n.BlendMode, n.Mask, n.ScrollFactor, n.Visible], initialize: function (S, E) { this.manager = S, this.texture = S.texture, this.frames = [S.defaultFrame], this.defaultFrame = S.defaultFrame, this.configFastMap = ['active', 'blendMode', 'collideBottom', 'collideLeft', 'collideRight', 'collideTop', 'deathCallback', 'deathCallbackScope', 'emitCallback', 'emitCallbackScope', 'follow', 'frequency', 'gravityX', 'gravityY', 'maxParticles', 'name', 'on', 'particleBringToTop', 'particleClass', 'radial', 'timeScale', 'trackVisible', 'visible'], this.configOpMap = ['accelerationX', 'accelerationY', 'angle', 'alpha', 'bounce', 'delay', 'lifespan', 'maxVelocityX', 'maxVelocityY', 'moveToX', 'moveToY', 'quantity', 'rotate', 'scaleX', 'scaleY', 'speedX', 'speedY', 'tint', 'x', 'y'], this.name = '', this.particleClass = v, this.x = new s(E, 'x', 0, !0), this.y = new s(E, 'y', 0, !0), this.radial = !0, this.gravityX = 0, this.gravityY = 0, this.acceleration = !1, this.accelerationX = new s(E, 'accelerationX', 0, !0), this.accelerationY = new s(E, 'accelerationY', 0, !0), this.maxVelocityX = new s(E, 'maxVelocityX', 1e4, !0), this.maxVelocityY = new s(E, 'maxVelocityY', 1e4, !0), this.speedX = new s(E, 'speedX', 0, !0), this.speedY = new s(E, 'speedY', 0, !0), this.moveTo = !1, this.moveToX = new s(E, 'moveToX', 0, !0), this.moveToY = new s(E, 'moveToY', 0, !0), this.bounce = new s(E, 'bounce', 0, !0), this.scaleX = new s(E, 'scaleX', 1), this.scaleY = new s(E, 'scaleY', 1), this.tint = new s(E, 'tint', 16777215), this.alpha = new s(E, 'alpha', 1), this.lifespan = new s(E, 'lifespan', 1e3, !0), this.angle = new s(E, 'angle', { min: 0, max: 360 }, !0), this.rotate = new s(E, 'rotate', 0), this.emitCallback = null, this.emitCallbackScope = null, this.deathCallback = null, this.deathCallbackScope = null, this.maxParticles = 0, this.quantity = new s(E, 'quantity', 1, !0), this.delay = new s(E, 'delay', 0, !0), this.frequency = 0, this.on = !0, this.particleBringToTop = !0, this.timeScale = 1, this.emitZone = null, this.deathZone = null, this.bounds = null, this.collideLeft = !0, this.collideRight = !0, this.collideTop = !0, this.collideBottom = !0, this.active = !0, this.visible = !0, this.blendMode = i.NORMAL, this.follow = null, this.followOffset = new g(), this.trackVisible = !1, this.currentFrame = 0, this.randomFrame = !0, this.frameQuantity = 1, this.dead = [], this.alive = [], this._counter = 0, this._frameCounter = 0, E && this.fromJSON(E) }, fromJSON: function (T) { if (!T) return this; let S = 0; let E = ''; for (S = 0; S < this.configFastMap.length; S++)E = this.configFastMap[S], u(T, E) && (this[E] = a(T, E)); for (S = 0; S < this.configOpMap.length; S++)E = this.configOpMap[S], u(T, E) && this[E].loadConfig(T); if (this.acceleration = this.accelerationX.propertyValue !== 0 || this.accelerationY.propertyValue !== 0, this.moveTo = this.moveToX.propertyValue !== 0 || this.moveToY.propertyValue !== 0, u(T, 'speed') && (this.speedX.loadConfig(T, 'speed'), this.speedY = null), (l(T, ['speedX', 'speedY']) || this.moveTo) && (this.radial = !1), u(T, 'scale') && (this.scaleX.loadConfig(T, 'scale'), this.scaleY = null), u(T, 'callbackScope')) { const C = a(T, 'callbackScope', null); this.emitCallbackScope = C, this.deathCallbackScope = C } return u(T, 'emitZone') && this.setEmitZone(T.emitZone), u(T, 'deathZone') && this.setDeathZone(T.deathZone), u(T, 'bounds') && this.setBounds(T.bounds), u(T, 'followOffset') && this.followOffset.setFromObject(a(T, 'followOffset', 0)), u(T, 'frame') && this.setFrame(T.frame), u(T, 'reserve') && this.reserve(T.reserve), this }, toJSON: function (T) { T === void 0 && (T = {}); let S = 0; let E = ''; for (S = 0; S < this.configFastMap.length; S++)E = this.configFastMap[S], T[E] = this[E]; for (S = 0; S < this.configOpMap.length; S++)E = this.configOpMap[S], this[E] && (T[E] = this[E].toJSON()); return this.speedY || (delete T.speedX, T.speed = this.speedX.toJSON()), this.scaleY || (delete T.scaleX, T.scale = this.scaleX.toJSON()), T }, startFollow: function (T, S, E, C) { return S === void 0 && (S = 0), E === void 0 && (E = 0), C === void 0 && (C = !1), this.follow = T, this.followOffset.set(S, E), this.trackVisible = C, this }, stopFollow: function () { return this.follow = null, this.followOffset.set(0, 0), this.trackVisible = !1, this }, getFrame: function () { if (this.frames.length === 1) return this.defaultFrame; if (this.randomFrame) return f(this.frames); const T = this.frames[this.currentFrame]; return this._frameCounter++, this._frameCounter === this.frameQuantity && (this._frameCounter = 0, this.currentFrame = x(this.currentFrame + 1, 0, this._frameLength)), T }, setFrame: function (T, S, E) { S === void 0 && (S = !0), E === void 0 && (E = 1), this.randomFrame = S, this.frameQuantity = E, this.currentFrame = 0, this._frameCounter = 0; const C = typeof T; if (Array.isArray(T) || C === 'string' || C === 'number') this.manager.setEmitterFrames(T, this); else if (C === 'object') { const P = T; T = a(P, 'frames', null), T && this.manager.setEmitterFrames(T, this); const A = a(P, 'cycle', !1); this.randomFrame = !A, this.frameQuantity = a(P, 'quantity', E) } return this._frameLength = this.frames.length, this._frameLength === 1 && (this.frameQuantity = 1, this.randomFrame = !1), this }, setRadial: function (T) { return T === void 0 && (T = !0), this.radial = T, this }, setPosition: function (T, S) { return this.x.onChange(T), this.y.onChange(S), this }, setBounds: function (T, S, E, C) { if (typeof T === 'object') { const P = T; T = P.x, S = P.y, E = u(P, 'w') ? P.w : P.width, C = u(P, 'h') ? P.h : P.height } return this.bounds ? this.bounds.setTo(T, S, E, C) : this.bounds = new c(T, S, E, C), this }, setSpeedX: function (T) { return this.speedX.onChange(T), this.radial = !1, this }, setSpeedY: function (T) { return this.speedY && (this.speedY.onChange(T), this.radial = !1), this }, setSpeed: function (T) { return this.speedX.onChange(T), this.speedY = null, this.radial = !0, this }, setScaleX: function (T) { return this.scaleX.onChange(T), this }, setScaleY: function (T) { return this.scaleY.onChange(T), this }, setScale: function (T) { return this.scaleX.onChange(T), this.scaleY = null, this }, setGravityX: function (T) { return this.gravityX = T, this }, setGravityY: function (T) { return this.gravityY = T, this }, setGravity: function (T, S) { return this.gravityX = T, this.gravityY = S, this }, setAlpha: function (T) { return this.alpha.onChange(T), this }, setTint: function (T) { return this.tint.onChange(T), this }, setEmitterAngle: function (T) { return this.angle.onChange(T), this }, setAngle: function (T) { return this.angle.onChange(T), this }, setLifespan: function (T) { return this.lifespan.onChange(T), this }, setQuantity: function (T) { return this.quantity.onChange(T), this }, setFrequency: function (T, S) { return this.frequency = T, this._counter = 0, S && this.quantity.onChange(S), this }, setEmitZone: function (T) { if (T === void 0) this.emitZone = null; else { const S = a(T, 'type', 'random'); const E = a(T, 'source', null); switch (S) { case 'random':this.emitZone = new p(E); break; case 'edge':var C = a(T, 'quantity', 1); var P = a(T, 'stepRate', 0); var A = a(T, 'yoyo', !1); var M = a(T, 'seamless', !0); this.emitZone = new r(E, C, P, A, M); break } } return this }, setDeathZone: function (T) { if (T === void 0) this.deathZone = null; else { const S = a(T, 'type', 'onEnter'); const E = a(T, 'source', null); if (E && typeof E.contains === 'function') { const C = S === 'onEnter'; this.deathZone = new o(E, C) } } return this }, reserve: function (T) { for (let S = this.dead, E = 0; E < T; E++)S.push(new this.particleClass(this)); return this }, getAliveParticleCount: function () { return this.alive.length }, getDeadParticleCount: function () { return this.dead.length }, getParticleCount: function () { return this.getAliveParticleCount() + this.getDeadParticleCount() }, atLimit: function () { return this.maxParticles > 0 && this.getParticleCount() === this.maxParticles }, onParticleEmit: function (T, S) { return T === void 0 ? (this.emitCallback = null, this.emitCallbackScope = null) : typeof T === 'function' && (this.emitCallback = T, S && (this.emitCallbackScope = S)), this }, onParticleDeath: function (T, S) { return T === void 0 ? (this.deathCallback = null, this.deathCallbackScope = null) : typeof T === 'function' && (this.deathCallback = T, S && (this.deathCallbackScope = S)), this }, killAll: function () { for (let T = this.dead, S = this.alive; S.length > 0;)T.push(S.pop()); return this }, forEachAlive: function (T, S) { for (let E = this.alive, C = E.length, P = 0; P < C; ++P)T.call(S, E[P], this); return this }, forEachDead: function (T, S) { for (let E = this.dead, C = E.length, P = 0; P < C; ++P)T.call(S, E[P], this); return this }, start: function () { return this.on = !0, this._counter = 0, this }, stop: function () { return this.on = !1, this }, pause: function () { return this.active = !1, this }, resume: function () { return this.active = !0, this }, remove: function () { return this.manager.removeEmitter(this), this }, depthSort: function () { return m(this.alive, this.depthSortCallback), this }, flow: function (T, S) { return S === void 0 && (S = 1), this.frequency = T, this.quantity.onChange(S), this.start() }, explode: function (T, S, E) { return this.frequency = -1, this.emitParticle(T, S, E) }, emitParticleAt: function (T, S, E) { return this.emitParticle(E, T, S) }, emitParticle: function (T, S, E) { if (!this.atLimit()) { T === void 0 && (T = this.quantity.onEmit()); for (let C = this.dead, P = this.follow ? this.follow.x + this.followOffset.x : S, A = this.follow ? this.follow.y + this.followOffset.y : E, M = 0; M < T; M++) { var L = C.pop(); if (L || (L = new this.particleClass(this)), L.fire(P, A), this.particleBringToTop ? this.alive.push(L) : this.alive.unshift(L), this.emitCallback && this.emitCallback.call(this.emitCallbackScope, L, this), this.atLimit()) break } return L } }, preUpdate: function (T, S) { S *= this.timeScale; const E = S / 1e3; this.trackVisible && (this.visible = this.follow.visible); const C = this.manager.getProcessors(); const P = this.alive; const A = this.dead; let M = 0; const L = []; let F = P.length; for (M = 0; M < F; M++) { const I = P[M]; I.update(S, E, C) && L.push({ index: M, particle: I }) } if (F = L.length, F > 0) { const G = this.deathCallback; const U = this.deathCallbackScope; for (M = F - 1; M >= 0; M--) { const Y = L[M]; P.splice(Y.index, 1), A.push(Y.particle), G && G.call(U, Y.particle), Y.particle.resetPosition() } }!this.on || (this.frequency === 0 ? this.emitParticle() : this.frequency > 0 && (this._counter -= S, this._counter <= 0 && (this.emitParticle(), this._counter = this.frequency - Math.abs(this._counter)))) }, depthSortCallback: function (T, S) { return T.y - S.y } }); e.exports = y }, function (e, d, t) { const i = t(0); const h = new i({ initialize: function (o, r) { this.source = o, this.killOnEnter = r }, willKill: function (n) { const o = this.source.contains(n.x, n.y); return o && this.killOnEnter || !o && !this.killOnEnter } }); e.exports = h }, function (e, d, t) { const i = t(0); const h = new i({ initialize: function (o, r, s, a, f) { a === void 0 && (a = !1), f === void 0 && (f = !0), this.source = o, this.points = [], this.quantity = r, this.stepRate = s, this.yoyo = a, this.counter = -1, this.seamless = f, this._length = 0, this._direction = 0, this.updateSource() }, updateSource: function () { if (this.points = this.source.getPoints(this.quantity, this.stepRate), this.seamless) { const n = this.points[0]; const o = this.points[this.points.length - 1]; n.x === o.x && n.y === o.y && this.points.pop() } const r = this._length; return this._length = this.points.length, this._length < r && this.counter > this._length && (this.counter = this._length - 1), this }, changeSource: function (n) { return this.source = n, this.updateSource() }, getPoint: function (n) { this._direction === 0 ? (this.counter++, this.counter >= this._length && (this.yoyo ? (this._direction = 1, this.counter = this._length - 1) : this.counter = 0)) : (this.counter--, this.counter === -1 && (this.yoyo ? (this._direction = 0, this.counter = 0) : this.counter = this._length - 1)); const o = this.points[this.counter]; o && (n.x = o.x, n.y = o.y) } }); e.exports = h }, function (e, d) { const t = function (i, h) { for (let n = 0; n < h.length; n++) if (i.hasOwnProperty(h[n])) return !0; return !1 }; e.exports = t }, function (e, d, t) { const i = t(0); const h = t(3); const n = new i({ initialize: function (r) { this.source = r, this._tempVec = new h() }, getPoint: function (o) { const r = this._tempVec; this.source.getRandomPoint(r), o.x = r.x, o.y = r.y } }); e.exports = n }, function (e, d, t) { const i = t(0); const h = t(11); const n = t(73); const o = new i({ Extends: n, Mixins: [h.PathFollower], initialize: function (s, a, f, l, u, v) { n.call(this, s, f, l, u, v), this.path = a }, preUpdate: function (r, s) { this.anims.update(r, s), this.pathUpdate(r) } }); e.exports = o }, function (e, d) { const t = function (i, h, n) { const o = i.canvas; const r = i.context; const s = i.style; const a = []; let f = 0; let l = n.length; s.maxLines > 0 && s.maxLines < n.length && (l = s.maxLines), s.syncFont(o, r); for (let u = 0; u < l; u++) { let v = s.strokeThickness; v += r.measureText(n[u]).width, s.wordWrap && (v -= r.measureText(' ').width), a[u] = Math.ceil(v), f = Math.max(f, a[u]) } const p = h.fontSize + s.strokeThickness; let c = p * l; const m = i.lineSpacing; return l > 1 && (c += m * (l - 1)), { width: f, height: c, lines: l, lineWidths: a, lineSpacing: m, lineHeight: p } }; e.exports = t }, function (e, d, t) { const i = t(0); const h = t(13); const n = t(6); const o = t(460); const r = { fontFamily: ['fontFamily', 'Courier'], fontSize: ['fontSize', '16px'], fontStyle: ['fontStyle', ''], backgroundColor: ['backgroundColor', null], color: ['color', '#fff'], stroke: ['stroke', '#fff'], strokeThickness: ['strokeThickness', 0], shadowOffsetX: ['shadow.offsetX', 0], shadowOffsetY: ['shadow.offsetY', 0], shadowColor: ['shadow.color', '#000'], shadowBlur: ['shadow.blur', 0], shadowStroke: ['shadow.stroke', !1], shadowFill: ['shadow.fill', !1], align: ['align', 'left'], maxLines: ['maxLines', 0], fixedWidth: ['fixedWidth', 0], fixedHeight: ['fixedHeight', 0], resolution: ['resolution', 0], rtl: ['rtl', !1], testString: ['testString', '|M\xC3\u2030qgy'], baselineX: ['baselineX', 1.2], baselineY: ['baselineY', 1.4], wordWrapWidth: ['wordWrap.width', null], wordWrapCallback: ['wordWrap.callback', null], wordWrapCallbackScope: ['wordWrap.callbackScope', null], wordWrapUseAdvanced: ['wordWrap.useAdvancedWrap', !1] }; const s = new i({ initialize: function (f, l) { this.parent = f, this.fontFamily, this.fontSize, this.fontStyle, this.backgroundColor, this.color, this.stroke, this.strokeThickness, this.shadowOffsetX, this.shadowOffsetY, this.shadowColor, this.shadowBlur, this.shadowStroke, this.shadowFill, this.align, this.maxLines, this.fixedWidth, this.fixedHeight, this.resolution, this.rtl, this.testString, this.baselineX, this.baselineY, this.wordWrapWidth, this.wordWrapCallback, this.wordWrapCallbackScope, this.wordWrapUseAdvanced, this._font, this.setStyle(l, !1, !0); const u = n(l, 'metrics', !1); u ? this.metrics = { ascent: n(u, 'ascent', 0), descent: n(u, 'descent', 0), fontSize: n(u, 'fontSize', 0) } : this.metrics = o(this) }, setStyle: function (a, f, l) { f === void 0 && (f = !0), l === void 0 && (l = !1), a && a.hasOwnProperty('fontSize') && typeof a.fontSize === 'number' && (a.fontSize = a.fontSize.toString() + 'px'); for (const u in r) { const v = l ? r[u][1] : this[u]; u === 'wordWrapCallback' || u === 'wordWrapCallbackScope' ? this[u] = n(a, r[u][0], v) : this[u] = h(a, r[u][0], v) } const p = n(a, 'font', null); p !== null && this.setFont(p, !1), this._font = [this.fontStyle, this.fontSize, this.fontFamily].join(' ').trim(); const c = n(a, 'fill', null); return c !== null && (this.color = c), f ? this.update(!0) : this.parent }, syncFont: function (a, f) { f.font = this._font }, syncStyle: function (a, f) { f.textBaseline = 'alphabetic', f.fillStyle = this.color, f.strokeStyle = this.stroke, f.lineWidth = this.strokeThickness, f.lineCap = 'round', f.lineJoin = 'round' }, syncShadow: function (a, f) { f ? (a.shadowOffsetX = this.shadowOffsetX, a.shadowOffsetY = this.shadowOffsetY, a.shadowColor = this.shadowColor, a.shadowBlur = this.shadowBlur) : (a.shadowOffsetX = 0, a.shadowOffsetY = 0, a.shadowColor = 0, a.shadowBlur = 0) }, update: function (a) { return a && (this._font = [this.fontStyle, this.fontSize, this.fontFamily].join(' ').trim(), this.metrics = o(this)), this.parent.updateText() }, setFont: function (a, f) { f === void 0 && (f = !0); let l = a; let u = ''; let v = ''; if (typeof a !== 'string')l = n(a, 'fontFamily', 'Courier'), u = n(a, 'fontSize', '16px'), v = n(a, 'fontStyle', ''); else { const p = a.split(' '); let c = 0; v = p.length > 2 ? p[c++] : '', u = p[c++] || '16px', l = p[c++] || 'Courier' } return (l !== this.fontFamily || u !== this.fontSize || v !== this.fontStyle) && (this.fontFamily = l, this.fontSize = u, this.fontStyle = v, f && this.update(!0)), this.parent }, setFontFamily: function (a) { return this.fontFamily !== a && (this.fontFamily = a, this.update(!0)), this.parent }, setFontStyle: function (a) { return this.fontStyle !== a && (this.fontStyle = a, this.update(!0)), this.parent }, setFontSize: function (a) { return typeof a === 'number' && (a = a.toString() + 'px'), this.fontSize !== a && (this.fontSize = a, this.update(!0)), this.parent }, setTestString: function (a) { return this.testString = a, this.update(!0) }, setFixedSize: function (a, f) { return this.fixedWidth = a, this.fixedHeight = f, a && (this.parent.width = a), f && (this.parent.height = f), this.update(!1) }, setBackgroundColor: function (a) { return this.backgroundColor = a, this.update(!1) }, setFill: function (a) { return this.color = a, this.update(!1) }, setColor: function (a) { return this.color = a, this.update(!1) }, setResolution: function (a) { return this.resolution = a, this.update(!1) }, setStroke: function (a, f) { return f === void 0 && (f = this.strokeThickness), a === void 0 && this.strokeThickness !== 0 ? (this.strokeThickness = 0, this.update(!0)) : (this.stroke !== a || this.strokeThickness !== f) && (this.stroke = a, this.strokeThickness = f, this.update(!0)), this.parent }, setShadow: function (a, f, l, u, v, p) { return a === void 0 && (a = 0), f === void 0 && (f = 0), l === void 0 && (l = '#000'), u === void 0 && (u = 0), v === void 0 && (v = !1), p === void 0 && (p = !0), this.shadowOffsetX = a, this.shadowOffsetY = f, this.shadowColor = l, this.shadowBlur = u, this.shadowStroke = v, this.shadowFill = p, this.update(!1) }, setShadowOffset: function (a, f) { return a === void 0 && (a = 0), f === void 0 && (f = a), this.shadowOffsetX = a, this.shadowOffsetY = f, this.update(!1) }, setShadowColor: function (a) { return a === void 0 && (a = '#000'), this.shadowColor = a, this.update(!1) }, setShadowBlur: function (a) { return a === void 0 && (a = 0), this.shadowBlur = a, this.update(!1) }, setShadowStroke: function (a) { return this.shadowStroke = a, this.update(!1) }, setShadowFill: function (a) { return this.shadowFill = a, this.update(!1) }, setWordWrapWidth: function (a, f) { return f === void 0 && (f = !1), this.wordWrapWidth = a, this.wordWrapUseAdvanced = f, this.update(!1) }, setWordWrapCallback: function (a, f) { return f === void 0 && (f = null), this.wordWrapCallback = a, this.wordWrapCallbackScope = f, this.update(!1) }, setAlign: function (a) { return a === void 0 && (a = 'left'), this.align = a, this.update(!1) }, setMaxLines: function (a) { return a === void 0 && (a = 0), this.maxLines = a, this.update(!1) }, getTextMetrics: function () { const a = this.metrics; return { ascent: a.ascent, descent: a.descent, fontSize: a.fontSize } }, toJSON: function () { const a = {}; for (const f in r)a[f] = this[f]; return a.metrics = this.getTextMetrics(), a }, destroy: function () { this.parent = void 0 } }); e.exports = s }, function (e, d, t) { const i = t(31); const h = function (n) { const o = i.create(this); const r = o.getContext('2d'); n.syncFont(o, r); const s = r.measureText(n.testString); if ('actualBoundingBoxAscent' in s) { const a = s.actualBoundingBoxAscent; const f = s.actualBoundingBoxDescent; return i.remove(o), { ascent: a, descent: f, fontSize: a + f } } const l = Math.ceil(s.width * n.baselineX); let u = l; const v = 2 * u; u = u * n.baselineY | 0, o.width = l, o.height = v, r.fillStyle = '#f00', r.fillRect(0, 0, l, v), r.font = n._font, r.textBaseline = 'alphabetic', r.fillStyle = '#000', r.fillText(n.testString, 0, u); const p = { ascent: 0, descent: 0, fontSize: 0 }; const c = r.getImageData(0, 0, l, v); if (!c) return p.ascent = u, p.descent = u + 6, p.fontSize = p.ascent + p.descent, i.remove(o), p; const m = c.data; const g = m.length; const x = l * 4; let y; let T; let S = 0; let E = !1; for (y = 0; y < u; y++) { for (T = 0; T < x; T += 4) if (m[S + T] !== 255) { E = !0; break } if (!E)S += x; else break } for (p.ascent = u - y, S = g - x, E = !1, y = v; y > u; y--) { for (T = 0; T < x; T += 4) if (m[S + T] !== 255) { E = !0; break } if (!E)S -= x; else break } return p.descent = y - u, p.fontSize = p.ascent + p.descent, i.remove(o), p }; e.exports = h }, function (e, d, t) { const i = t(1097); const h = t(0); const n = t(36); const o = t(59); const r = t(65); const s = t(14); const a = t(34); const f = new h({ Extends: a, Mixins: [i], initialize: function (u, v, p, c, m, g, x, y, T) { v === void 0 && (v = 0), p === void 0 && (p = 0), c === void 0 && (c = 128), m === void 0 && (m = 0), g === void 0 && (g = 360), x === void 0 && (x = !1), a.call(this, u, 'Arc', new r(0, 0, c)), this._startAngle = m, this._endAngle = g, this._anticlockwise = x, this._iterations = 0.01, this.setPosition(v, p); const S = this.geom.radius * 2; this.setSize(S, S), y !== void 0 && this.setFillStyle(y, T), this.updateDisplayOrigin(), this.updateData() }, iterations: { get: function () { return this._iterations }, set: function (l) { this._iterations = l, this.updateData() } }, radius: { get: function () { return this.geom.radius }, set: function (l) { this.geom.radius = l; const u = l * 2; this.setSize(u, u), this.updateDisplayOrigin(), this.updateData() } }, startAngle: { get: function () { return this._startAngle }, set: function (l) { this._startAngle = l, this.updateData() } }, endAngle: { get: function () { return this._endAngle }, set: function (l) { this._endAngle = l, this.updateData() } }, anticlockwise: { get: function () { return this._anticlockwise }, set: function (l) { this._anticlockwise = l, this.updateData() } }, setRadius: function (l) { return this.radius = l, this }, setIterations: function (l) { return l === void 0 && (l = 0.01), this.iterations = l, this }, setStartAngle: function (l, u) { return this._startAngle = l, u !== void 0 && (this._anticlockwise = u), this.updateData() }, setEndAngle: function (l, u) { return this._endAngle = l, u !== void 0 && (this._anticlockwise = u), this.updateData() }, updateData: function () { const l = this._iterations; let u = l; const v = this.geom.radius; const p = n(this._startAngle); let c = n(this._endAngle); const m = this._anticlockwise; const g = v; const x = v; c -= p, m ? c < -s.PI2 ? c = -s.PI2 : c > 0 && (c = -s.PI2 + c % s.PI2) : c > s.PI2 ? c = s.PI2 : c < 0 && (c = s.PI2 + c % s.PI2); for (var y = [g + Math.cos(p) * v, x + Math.sin(p) * v], T; u < 1;)T = c * u + p, y.push(g + Math.cos(T) * v, x + Math.sin(T) * v), u += l; return T = c + p, y.push(g + Math.cos(T) * v, x + Math.sin(T) * v), y.push(g + Math.cos(p) * v, x + Math.sin(p) * v), this.pathIndexes = o(y), this.pathData = y, this } }); e.exports = f }, function (e, d, t) { const i = t(0); const h = t(1100); const n = t(59); const o = t(10); const r = t(34); const s = new i({ Extends: r, Mixins: [h], initialize: function (f, l, u, v, p, c) { l === void 0 && (l = 0), u === void 0 && (u = 0), r.call(this, f, 'Curve', v), this._smoothness = 32, this._curveBounds = new o(), this.closePath = !1, this.setPosition(l, u), p !== void 0 && this.setFillStyle(p, c), this.updateData() }, smoothness: { get: function () { return this._smoothness }, set: function (a) { this._smoothness = a, this.updateData() } }, setSmoothness: function (a) { return this._smoothness = a, this.updateData() }, updateData: function () { const a = this._curveBounds; const f = this._smoothness; this.geom.getBounds(a, f), this.setSize(a.width, a.height), this.updateDisplayOrigin(); for (var l = [], u = this.geom.getPoints(f), v = 0; v < u.length; v++)l.push(u[v].x, u[v].y); return l.push(u[0].x, u[0].y), this.pathIndexes = n(l), this.pathData = l, this } }); e.exports = s }, function (e, d, t) { const i = t(0); const h = t(59); const n = t(1103); const o = t(111); const r = t(34); const s = new i({ Extends: r, Mixins: [n], initialize: function (f, l, u, v, p, c, m) { l === void 0 && (l = 0), u === void 0 && (u = 0), v === void 0 && (v = 128), p === void 0 && (p = 128), r.call(this, f, 'Ellipse', new o(v / 2, p / 2, v, p)), this._smoothness = 64, this.setPosition(l, u), this.width = v, this.height = p, c !== void 0 && this.setFillStyle(c, m), this.updateDisplayOrigin(), this.updateData() }, smoothness: { get: function () { return this._smoothness }, set: function (a) { this._smoothness = a, this.updateData() } }, setSize: function (a, f) { return this.width = a, this.height = f, this.geom.setPosition(a / 2, f / 2), this.geom.setSize(a, f), this.updateData() }, setSmoothness: function (a) { return this._smoothness = a, this.updateData() }, updateData: function () { for (var a = [], f = this.geom.getPoints(this._smoothness), l = 0; l < f.length; l++)a.push(f[l].x, f[l].y); return a.push(f[0].x, f[0].y), this.pathIndexes = h(a), this.pathData = a, this } }); e.exports = s }, function (e, d, t) { const i = t(0); const h = t(34); const n = t(1106); const o = new i({ Extends: h, Mixins: [n], initialize: function (s, a, f, l, u, v, p, c, m, g, x) { a === void 0 && (a = 0), f === void 0 && (f = 0), l === void 0 && (l = 128), u === void 0 && (u = 128), v === void 0 && (v = 32), p === void 0 && (p = 32), h.call(this, s, 'Grid', null), this.cellWidth = v, this.cellHeight = p, this.showCells = !0, this.outlineFillColor = 0, this.outlineFillAlpha = 0, this.showOutline = !0, this.showAltCells = !1, this.altFillColor, this.altFillAlpha, this.setPosition(a, f), this.setSize(l, u), this.setFillStyle(c, m), g !== void 0 && this.setOutlineStyle(g, x), this.updateDisplayOrigin() }, setFillStyle: function (r, s) { return s === void 0 && (s = 1), r === void 0 ? this.showCells = !1 : (this.fillColor = r, this.fillAlpha = s, this.showCells = !0), this }, setAltFillStyle: function (r, s) { return s === void 0 && (s = 1), r === void 0 ? this.showAltCells = !1 : (this.altFillColor = r, this.altFillAlpha = s, this.showAltCells = !0), this }, setOutlineStyle: function (r, s) { return s === void 0 && (s = 1), r === void 0 ? this.showOutline = !1 : (this.outlineFillColor = r, this.outlineFillAlpha = s, this.showOutline = !0), this } }); e.exports = o }, function (e, d, t) { const i = t(1109); const h = t(0); const n = t(34); const o = new h({ Extends: n, Mixins: [i], initialize: function (s, a, f, l, u, v, p, c) { a === void 0 && (a = 0), f === void 0 && (f = 0), l === void 0 && (l = 48), u === void 0 && (u = 32), v === void 0 && (v = 15658734), p === void 0 && (p = 10066329), c === void 0 && (c = 13421772), n.call(this, s, 'IsoBox', null), this.projection = 4, this.fillTop = v, this.fillLeft = p, this.fillRight = c, this.showTop = !0, this.showLeft = !0, this.showRight = !0, this.isFilled = !0, this.setPosition(a, f), this.setSize(l, u), this.updateDisplayOrigin() }, setProjection: function (r) { return this.projection = r, this }, setFaces: function (r, s, a) { return r === void 0 && (r = !0), s === void 0 && (s = !0), a === void 0 && (a = !0), this.showTop = r, this.showLeft = s, this.showRight = a, this }, setFillStyle: function (r, s, a) { return this.fillTop = r, this.fillLeft = s, this.fillRight = a, this.isFilled = !0, this } }); e.exports = o }, function (e, d, t) { const i = t(0); const h = t(1112); const n = t(34); const o = new i({ Extends: n, Mixins: [h], initialize: function (s, a, f, l, u, v, p, c, m) { a === void 0 && (a = 0), f === void 0 && (f = 0), l === void 0 && (l = 48), u === void 0 && (u = 32), v === void 0 && (v = !1), p === void 0 && (p = 15658734), c === void 0 && (c = 10066329), m === void 0 && (m = 13421772), n.call(this, s, 'IsoTriangle', null), this.projection = 4, this.fillTop = p, this.fillLeft = c, this.fillRight = m, this.showTop = !0, this.showLeft = !0, this.showRight = !0, this.isReversed = v, this.isFilled = !0, this.setPosition(a, f), this.setSize(l, u), this.updateDisplayOrigin() }, setProjection: function (r) { return this.projection = r, this }, setReversed: function (r) { return this.isReversed = r, this }, setFaces: function (r, s, a) { return r === void 0 && (r = !0), s === void 0 && (s = !0), a === void 0 && (a = !0), this.showTop = r, this.showLeft = s, this.showRight = a, this }, setFillStyle: function (r, s, a) { return this.fillTop = r, this.fillLeft = s, this.fillRight = a, this.isFilled = !0, this } }); e.exports = o }, function (e, d, t) { const i = t(0); const h = t(34); const n = t(47); const o = t(1115); const r = new i({ Extends: h, Mixins: [o], initialize: function (a, f, l, u, v, p, c, m, g) { f === void 0 && (f = 0), l === void 0 && (l = 0), u === void 0 && (u = 0), v === void 0 && (v = 0), p === void 0 && (p = 128), c === void 0 && (c = 0), h.call(this, a, 'Line', new n(u, v, p, c)); const x = Math.max(1, this.geom.right - this.geom.left); const y = Math.max(1, this.geom.bottom - this.geom.top); this.lineWidth = 1, this._startWidth = 1, this._endWidth = 1, this.setPosition(f, l), this.setSize(x, y), m !== void 0 && this.setStrokeStyle(1, m, g), this.updateDisplayOrigin() }, setLineWidth: function (s, a) { return a === void 0 && (a = s), this._startWidth = s, this._endWidth = a, this.lineWidth = s, this }, setTo: function (s, a, f, l) { return this.geom.setTo(s, a, f, l), this } }); e.exports = r }, function (e, d, t) { const i = t(1118); const h = t(0); const n = t(59); const o = t(469); const r = t(227); const s = t(34); const a = t(472); const f = new h({ Extends: s, Mixins: [i], initialize: function (u, v, p, c, m, g) { v === void 0 && (v = 0), p === void 0 && (p = 0), s.call(this, u, 'Polygon', new r(c)); const x = o(this.geom); this.setPosition(v, p), this.setSize(x.width, x.height), m !== void 0 && this.setFillStyle(m, g), this.updateDisplayOrigin(), this.updateData() }, smooth: function (l) { l === void 0 && (l = 1); for (let u = 0; u < l; u++)a(this.geom); return this.updateData() }, updateData: function () { for (var l = [], u = this.geom.points, v = 0; v < u.length; v++)l.push(u[v].x, u[v].y); return l.push(u[0].x, u[0].y), this.pathIndexes = n(l), this.pathData = l, this } }); e.exports = f }, function (e, d, t) { const i = t(10); const h = function (n, o) { o === void 0 && (o = new i()); for (var r = 1 / 0, s = 1 / 0, a = -r, f = -s, l, u = 0; u < n.points.length; u++)l = n.points[u], r = Math.min(r, l.x), s = Math.min(s, l.y), a = Math.max(a, l.x), f = Math.max(f, l.y); return o.x = r, o.y = s, o.width = a - r, o.height = f - s, o }; e.exports = h }, function (e, d, t) { const i = t(67); const h = t(47); const n = t(471); const o = function (r, s, a, f) { f === void 0 && (f = []); const l = r.points; const u = n(r); !s && a > 0 && (s = u / a); for (let v = 0; v < s; v++) for (let p = u * (v / s), c = 0, m = 0; m < l.length; m++) { const g = l[m]; const x = l[(m + 1) % l.length]; const y = new h(g.x, g.y, x.x, x.y); const T = i(y); if (p < c || p > c + T) { c += T; continue } const S = y.getPoint((p - c) / T); f.push(S); break } return f }; e.exports = o }, function (e, d, t) { const i = t(67); const h = t(47); const n = function (o) { for (var r = o.points, s = 0, a = 0; a < r.length; a++) { const f = r[a]; const l = r[(a + 1) % r.length]; const u = new h(f.x, f.y, l.x, l.y); s += i(u) } return s }; e.exports = n }, function (e, d) { const t = function (h, n) { return h[0] = n[0], h[1] = n[1], h }; const i = function (h) { let n; const o = []; const r = h.points; for (n = 0; n < r.length; n++)o.push([r[n].x, r[n].y]); const s = []; for (o.length > 0 && s.push(t([0, 0], o[0])), n = 0; n < o.length - 1; n++) { const a = o[n]; const f = o[n + 1]; const l = a[0]; const u = a[1]; const v = f[0]; const p = f[1]; s.push([0.85 * l + 0.15 * v, 0.85 * u + 0.15 * p]), s.push([0.15 * l + 0.85 * v, 0.15 * u + 0.85 * p]) } return o.length > 1 && s.push(t([0, 0], o[o.length - 1])), h.setTo(s) }; e.exports = i }, function (e, d, t) { const i = t(0); const h = t(10); const n = t(34); const o = t(1121); const r = new i({ Extends: n, Mixins: [o], initialize: function (a, f, l, u, v, p, c) { f === void 0 && (f = 0), l === void 0 && (l = 0), u === void 0 && (u = 128), v === void 0 && (v = 128), n.call(this, a, 'Rectangle', new h(0, 0, u, v)), this.setPosition(f, l), this.setSize(u, v), p !== void 0 && this.setFillStyle(p, c), this.updateDisplayOrigin(), this.updateData() }, setSize: function (s, a) { return this.width = s, this.height = a, this.geom.setSize(s, a), this.updateData(), this }, updateData: function () { const s = []; const a = this.geom; const f = this._tempLine; return a.getLineA(f), s.push(f.x1, f.y1, f.x2, f.y2), a.getLineB(f), s.push(f.x2, f.y2), a.getLineC(f), s.push(f.x2, f.y2), a.getLineD(f), s.push(f.x2, f.y2), this.pathData = s, this } }); e.exports = r }, function (e, d, t) { const i = t(1124); const h = t(0); const n = t(59); const o = t(34); const r = new h({ Extends: o, Mixins: [i], initialize: function (a, f, l, u, v, p, c, m) { f === void 0 && (f = 0), l === void 0 && (l = 0), u === void 0 && (u = 5), v === void 0 && (v = 32), p === void 0 && (p = 64), o.call(this, a, 'Star', null), this._points = u, this._innerRadius = v, this._outerRadius = p, this.setPosition(f, l), this.setSize(p * 2, p * 2), c !== void 0 && this.setFillStyle(c, m), this.updateDisplayOrigin(), this.updateData() }, setPoints: function (s) { return this._points = s, this.updateData() }, setInnerRadius: function (s) { return this._innerRadius = s, this.updateData() }, setOuterRadius: function (s) { return this._outerRadius = s, this.updateData() }, points: { get: function () { return this._points }, set: function (s) { this._points = s, this.updateData() } }, innerRadius: { get: function () { return this._innerRadius }, set: function (s) { this._innerRadius = s, this.updateData() } }, outerRadius: { get: function () { return this._outerRadius }, set: function (s) { this._outerRadius = s, this.updateData() } }, updateData: function () { const s = []; const a = this._points; const f = this._innerRadius; const l = this._outerRadius; let u = Math.PI / 2 * 3; const v = Math.PI / a; const p = l; const c = l; s.push(p, c + -l); for (let m = 0; m < a; m++)s.push(p + Math.cos(u) * l, c + Math.sin(u) * l), u += v, s.push(p + Math.cos(u) * f, c + Math.sin(u) * f), u += v; return s.push(p, c + -l), this.pathIndexes = n(s), this.pathData = s, this } }); e.exports = r }, function (e, d, t) { const i = t(0); const h = t(34); const n = t(82); const o = t(1127); const r = new i({ Extends: h, Mixins: [o], initialize: function (a, f, l, u, v, p, c, m, g, x, y) { f === void 0 && (f = 0), l === void 0 && (l = 0), u === void 0 && (u = 0), v === void 0 && (v = 128), p === void 0 && (p = 64), c === void 0 && (c = 0), m === void 0 && (m = 128), g === void 0 && (g = 128), h.call(this, a, 'Triangle', new n(u, v, p, c, m, g)); const T = this.geom.right - this.geom.left; const S = this.geom.bottom - this.geom.top; this.setPosition(f, l), this.setSize(T, S), x !== void 0 && this.setFillStyle(x, y), this.updateDisplayOrigin(), this.updateData() }, setTo: function (s, a, f, l, u, v) { return this.geom.setTo(s, a, f, l, u, v), this.updateData() }, updateData: function () { const s = []; const a = this.geom; const f = this._tempLine; return a.getLineA(f), s.push(f.x1, f.y1, f.x2, f.y2), a.getLineB(f), s.push(f.x2, f.y2), a.getLineC(f), s.push(f.x2, f.y2), this.pathData = s, this } }); e.exports = r }, function (e, d, t) { const i = t(4); const h = t(67); const n = function (o, r, s) { s === void 0 && (s = new i()); const a = o.getLineA(); const f = o.getLineB(); const l = o.getLineC(); if (r <= 0 || r >= 1) return s.x = a.x1, s.y = a.y1, s; const u = h(a); const v = h(f); const p = h(l); const c = u + v + p; let m = c * r; let g = 0; return m < u ? (g = m / u, s.x = a.x1 + (a.x2 - a.x1) * g, s.y = a.y1 + (a.y2 - a.y1) * g) : m > u + v ? (m -= u + v, g = m / p, s.x = l.x1 + (l.x2 - l.x1) * g, s.y = l.y1 + (l.y2 - l.y1) * g) : (m -= u, g = m / v, s.x = f.x1 + (f.x2 - f.x1) * g, s.y = f.y1 + (f.y2 - f.y1) * g), s }; e.exports = n }, function (e, d, t) { const i = t(67); const h = t(4); const n = function (o, r, s, a) { a === void 0 && (a = []); const f = o.getLineA(); const l = o.getLineB(); const u = o.getLineC(); const v = i(f); const p = i(l); const c = i(u); const m = v + p + c; !r && s > 0 && (r = m / s); for (let g = 0; g < r; g++) { let x = m * (g / r); let y = 0; const T = new h(); x < v ? (y = x / v, T.x = f.x1 + (f.x2 - f.x1) * y, T.y = f.y1 + (f.y2 - f.y1) * y) : x > v + p ? (x -= v + p, y = x / c, T.x = u.x1 + (u.x2 - u.x1) * y, T.y = u.y1 + (u.y2 - u.y1) * y) : (x -= v, y = x / p, T.x = l.x1 + (l.x2 - l.x1) * y, T.y = l.y1 + (l.y2 - l.y1) * y), a.push(T) } return a }; e.exports = n }, function (e, d) { const t = function (i, h, n) { if (!i || typeof i === 'number') return !1; if (i.hasOwnProperty(h)) return i[h] = n, !0; if (h.indexOf('.') !== -1) { for (var o = h.split('.'), r = i, s = i, a = 0; a < o.length; a++) if (r.hasOwnProperty(o[a]))s = r, r = r[o[a]]; else return !1; return s[o[o.length - 1]] = n, !0 } return !1 }; e.exports = t }, function (e, d, t) { const i = t(116); const h = t(117); const n = function (o, r, s, a, f, l, u) { if (a === void 0 && (a = !1), l === void 0 && (l = 16777215), u === void 0 && (u = 1), o.length !== r.length) { console.warn('GenerateVerts: vertices and uvs count not equal'); return } const v = { faces: [], vertices: [] }; let p; let c; let m; let g; let x; let y; let T; let S; let E; let C; let P; const A = a ? 3 : 2; const M = Array.isArray(l); const L = Array.isArray(u); if (Array.isArray(s) && s.length > 0) for (p = 0; p < s.length; p++) { const F = s[p]; const I = s[p] * 2; const G = s[p] * A; c = o[G], m = o[G + 1], g = a ? o[G + 2] : 0, x = r[I], y = r[I + 1], T = M ? l[F] : l, S = L ? u[F] : u, E = 0, C = 0, P = 0, f && (E = f[G], C = f[G + 1], P = a ? f[G + 2] : 0), v.vertices.push(new h(c, m, g, x, y, T, S, E, C, P)) } else { let U = 0; let Y = 0; for (p = 0; p < o.length; p += A)c = o[p], m = o[p + 1], g = a ? o[p + 2] : 0, x = r[U], y = r[U + 1], T = M ? l[Y] : l, S = L ? u[Y] : u, E = 0, C = 0, P = 0, f && (E = f[p], C = f[p + 1], P = a ? f[p + 2] : 0), v.vertices.push(new h(c, m, g, x, y, T, S, E, C, P)), U += 2, Y++ } for (p = 0; p < v.vertices.length; p += 3) { const X = v.vertices[p]; const O = v.vertices[p + 1]; const R = v.vertices[p + 2]; v.faces.push(new i(X, O, R)) } return v }; e.exports = n }, function (e, d, t) { const i = t(116); const h = t(69); const n = t(39); const o = t(117); const r = new n(); const s = new n(); const a = new h(); const f = function (l, u, v, p, c, m, g, x, y, T) { v === void 0 && (v = 1), p === void 0 && (p = 0), c === void 0 && (c = 0), m === void 0 && (m = 0), g === void 0 && (g = 0), x === void 0 && (x = 0), y === void 0 && (y = 0), T === void 0 && (T = !0); const S = { faces: [], verts: [] }; const E = l.materials; r.set(p, c, m), s.set(g, x, y), a.fromRotationXYTranslation(s, r, T); for (let C = 0; C < l.models.length; C++) for (let P = l.models[C], A = P.vertices, M = P.textureCoords, L = P.faces, F = 0; F < L.length; F++) { const I = L[F]; const G = I.vertices[0]; const U = I.vertices[1]; const Y = I.vertices[2]; const X = A[G.vertexIndex]; const O = A[U.vertexIndex]; const R = A[Y.vertexIndex]; const D = G.textureCoordsIndex; const B = U.textureCoordsIndex; const N = Y.textureCoordsIndex; const w = D === -1 ? { u: 0, v: 1 } : M[D]; const z = B === -1 ? { u: 0, v: 0 } : M[B]; const V = N === -1 ? { u: 1, v: 1 } : M[N]; let W = 16777215; I.material !== '' && E[I.material] && (W = E[I.material]); const H = new o(X.x * v, X.y * v, X.z * v, w.u, w.v, W).transformMat4(a); const K = new o(O.x * v, O.y * v, O.z * v, z.u, z.v, W).transformMat4(a); const Q = new o(R.x * v, R.y * v, R.z * v, V.u, V.v, W).transformMat4(a); S.verts.push(H, K, Q), S.faces.push(new i(H, K, Q)) } return u && (u.faces = u.faces.concat(S.faces), u.vertices = u.vertices.concat(S.verts)), S }; e.exports = f }, function (e, d, t) { const i = t(65); const h = t(0); const n = t(11); const o = t(200); const r = t(12); var s = new h({ Extends: i, Mixins: [n.ScrollFactor, n.Visible], initialize: function (f, l, u, v, p, c, m) { i.call(this, f, l, u), this.color = new o(v, p, c), this.intensity = m, this.renderFlags = 15, this.cameraFilter = 0, this.setScrollFactor(1, 1) }, willRender: function (a) { return !(s.RENDER_MASK !== this.renderFlags || this.cameraFilter !== 0 && this.cameraFilter & a.id) }, setColor: function (a) { const f = r.getFloatsFromUintRGB(a); return this.color.set(f[0], f[1], f[2]), this }, setIntensity: function (a) { return this.intensity = a, this }, setRadius: function (a) { return this.radius = a, this } }); s.RENDER_MASK = 15, e.exports = s }, function (e, d, t) { const i = t(151); const h = t(0); const n = t(50); const o = t(481); const r = t(150); const s = t(200); const a = t(74); const f = t(79); const l = t(12); const u = new h({ initialize: function () { this.lights = [], this.ambientColor = new s(0.1, 0.1, 0.1), this.active = !1, this.maxLights = -1, this.visibleLights = 0 }, addPointLight: function (v, p, c, m, g, x) { return this.systems.displayList.add(new r(this.scene, v, p, c, m, g, x)) }, enable: function () { return this.maxLights === -1 && (this.maxLights = this.systems.renderer.config.maxLights), this.active = !0, this }, disable: function () { return this.active = !1, this }, getLights: function (v) { for (var p = this.lights, c = v.worldView, m = [], g = 0; g < p.length; g++) { const x = p[g]; x.willRender(v) && i(x, c) && m.push({ light: x, distance: n(x.x, x.y, c.centerX, c.centerY) }) } return m.length > this.maxLights && (f(m, this.sortByDistance), m = m.slice(0, this.maxLights)), this.visibleLights = m.length, m }, sortByDistance: function (v, p) { return v.distance >= p.distance }, setAmbientColor: function (v) { const p = l.getFloatsFromUintRGB(v); return this.ambientColor.set(p[0], p[1], p[2]), this }, getMaxVisibleLights: function () { return this.maxLights }, getLightCount: function () { return this.lights.length }, addLight: function (v, p, c, m, g) { v === void 0 && (v = 0), p === void 0 && (p = 0), c === void 0 && (c = 128), m === void 0 && (m = 16777215), g === void 0 && (g = 1); const x = l.getFloatsFromUintRGB(m); const y = new o(v, p, c, x[0], x[1], x[2], g); return this.lights.push(y), y }, removeLight: function (v) { const p = this.lights.indexOf(v); return p >= 0 && a(this.lights, p), this }, shutdown: function () { this.lights.length = 0 }, destroy: function () { this.shutdown() } }); e.exports = u }, function (e, d, t) { const i = t(56); const h = t(17); let n = { Circle: t(1191), Ellipse: t(1201), Intersects: t(484), Line: t(1221), Mesh: t(1243), Point: t(1246), Polygon: t(1260), Rectangle: t(502), Triangle: t(1293) }; n = h(!1, n, i), e.exports = n }, function (e, d, t) { e.exports = { CircleToCircle: t(231), CircleToRectangle: t(151), GetCircleToCircle: t(1211), GetCircleToRectangle: t(1212), GetLineToCircle: t(232), GetLineToLine: t(485), GetLineToPoints: t(486), GetLineToPolygon: t(487), GetLineToRectangle: t(234), GetRaysFromPointToPolygon: t(1213), GetRectangleIntersection: t(1214), GetRectangleToRectangle: t(1215), GetRectangleToTriangle: t(1216), GetTriangleToCircle: t(1217), GetTriangleToLine: t(492), GetTriangleToTriangle: t(1218), LineToCircle: t(233), LineToLine: t(96), LineToRectangle: t(488), PointToLine: t(496), PointToLineSegment: t(1219), RectangleToRectangle: t(152), RectangleToTriangle: t(489), RectangleToValues: t(1220), TriangleToCircle: t(491), TriangleToLine: t(493), TriangleToTriangle: t(494) } }, function (e, d, t) { const i = t(39); const h = function (n, o, r) { const s = n.x1; const a = n.y1; const f = n.x2; const l = n.y2; const u = o.x1; const v = o.y1; const p = o.x2; const c = o.y2; const m = f - s; const g = l - a; const x = p - u; const y = c - v; const T = y * m - x * g; if (m === 0 || T === 0) return !1; const S = (m * (v - a) + g * (s - u)) / (x * g - y * m); const E = (u + x * S - s) / m; return E < 0 || S < 0 || S > 1 ? null : (r === void 0 && (r = new i()), r.set(s + m * E, a + g * E, E)) }; e.exports = h }, function (e, d, t) { const i = t(39); const h = t(485); const n = t(47); const o = new n(); const r = new i(); const s = function (a, f, l) { l === void 0 && (l = new i()); let u = !1; l.set(), r.set(); for (let v = f[0], p = 1; p < f.length; p++) { const c = f[p]; o.setTo(v.x, v.y, c.x, c.y), v = c, h(a, o, r) && (!u || r.z < l.z) && (l.copy(r), u = !0) } return u ? l : null }; e.exports = s }, function (e, d, t) { const i = t(39); const h = t(140); const n = t(486); const o = new i(); const r = function (s, a, f) { f === void 0 && (f = new h()), Array.isArray(a) || (a = [a]); let l = !1; f.set(), o.set(); for (let u = 0; u < a.length; u++)n(s, a[u].points, o) && (!l || o.z < f.z) && (f.set(o.x, o.y, o.z, u), l = !0); return l ? f : null }; e.exports = r }, function (e, d) { const t = function (i, h) { const n = i.x1; const o = i.y1; const r = i.x2; const s = i.y2; const a = h.x; const f = h.y; const l = h.right; const u = h.bottom; let v = 0; if (n >= a && n <= l && o >= f && o <= u || r >= a && r <= l && s >= f && s <= u) return !0; if (n < a && r >= a) { if (v = o + (s - o) * (a - n) / (r - n), v > f && v <= u) return !0 } else if (n > l && r <= l && (v = o + (s - o) * (l - n) / (r - n), v >= f && v <= u)) return !0; if (o < f && s >= f) { if (v = n + (r - n) * (f - o) / (s - o), v >= a && v <= l) return !0 } else if (o > u && s <= u && (v = n + (r - n) * (u - o) / (s - o), v >= a && v <= l)) return !0; return !1 }; e.exports = t }, function (e, d, t) { const i = t(96); const h = t(57); const n = t(235); const o = t(490); const r = function (s, a) { if (a.left > s.right || a.right < s.left || a.top > s.bottom || a.bottom < s.top) return !1; const f = a.getLineA(); const l = a.getLineB(); const u = a.getLineC(); if (h(s, f.x1, f.y1) || h(s, f.x2, f.y2) || h(s, l.x1, l.y1) || h(s, l.x2, l.y2) || h(s, u.x1, u.y1) || h(s, u.x2, u.y2)) return !0; const v = s.getLineA(); const p = s.getLineB(); const c = s.getLineC(); const m = s.getLineD(); if (i(f, v) || i(f, p) || i(f, c) || i(f, m) || i(l, v) || i(l, p) || i(l, c) || i(l, m) || i(u, v) || i(u, p) || i(u, c) || i(u, m)) return !0; const g = o(s); const x = n(a, g, !0); return x.length > 0 }; e.exports = r }, function (e, d) { const t = function (i, h) { return h === void 0 && (h = []), h.push({ x: i.x, y: i.y }), h.push({ x: i.right, y: i.y }), h.push({ x: i.right, y: i.bottom }), h.push({ x: i.x, y: i.bottom }), h }; e.exports = t }, function (e, d, t) { const i = t(233); const h = t(115); const n = function (o, r) { return o.left > r.right || o.right < r.left || o.top > r.bottom || o.bottom < r.top ? !1 : !!(h(o, r.x, r.y) || i(o.getLineA(), r) || i(o.getLineB(), r) || i(o.getLineC(), r)) }; e.exports = n }, function (e, d, t) { const i = t(4); const h = t(493); const n = t(96); const o = function (r, s, a) { if (a === void 0 && (a = []), h(r, s)) for (let f = r.getLineA(), l = r.getLineB(), u = r.getLineC(), v = [new i(), new i(), new i()], p = [n(f, s, v[0]), n(l, s, v[1]), n(u, s, v[2])], c = 0; c < 3; c++)p[c] && a.push(v[c]); return a }; e.exports = o }, function (e, d, t) { const i = t(96); const h = function (n, o) { return !!(n.contains(o.x1, o.y1) || n.contains(o.x2, o.y2) || i(n.getLineA(), o) || i(n.getLineB(), o) || i(n.getLineC(), o)) }; e.exports = h }, function (e, d, t) { const i = t(235); const h = t(495); const n = t(96); const o = function (r, s) { if (r.left > s.right || r.right < s.left || r.top > s.bottom || r.bottom < s.top) return !1; const a = r.getLineA(); const f = r.getLineB(); const l = r.getLineC(); const u = s.getLineA(); const v = s.getLineB(); const p = s.getLineC(); if (n(a, u) || n(a, v) || n(a, p) || n(f, u) || n(f, v) || n(f, p) || n(l, u) || n(l, v) || n(l, p)) return !0; let c = h(r); let m = i(s, c, !0); return !!(m.length > 0 || (c = h(s), m = i(r, c, !0), m.length > 0)) }; e.exports = o }, function (e, d) { const t = function (i, h) { return h === void 0 && (h = []), h.push({ x: i.x1, y: i.y1 }), h.push({ x: i.x2, y: i.y2 }), h.push({ x: i.x3, y: i.y3 }), h }; e.exports = t }, function (e, d) { const t = function (i, h, n) { n === void 0 && (n = 1); const o = h.x1; const r = h.y1; const s = h.x2; const a = h.y2; const f = i.x; const l = i.y; const u = (s - o) * (s - o) + (a - r) * (a - r); if (u === 0) return !1; const v = ((f - o) * (s - o) + (l - r) * (a - r)) / u; if (v < 0) return Math.sqrt((o - f) * (o - f) + (r - l) * (r - l)) <= n; if (v >= 0 && v <= 1) { const p = ((r - l) * (s - o) - (o - f) * (a - r)) / u; return Math.abs(p) * Math.sqrt(u) <= n } else return Math.sqrt((s - f) * (s - f) + (a - l) * (a - l)) <= n }; e.exports = t }, function (e, d, t) { const i = t(14); const h = t(68); const n = t(97); const o = function (r) { const s = n(r) - i.TAU; return h(s, -Math.PI, Math.PI) }; e.exports = o }, function (e, d) {
        let t = !0; const i = 'untitled'; let h = ''; let n = ''; function o (g) { const x = g.indexOf('#'); return x > -1 ? g.substring(0, x) : g } function r (g) { return g.models.length === 0 && g.models.push({ faces: [], name: i, textureCoords: [], vertexNormals: [], vertices: [] }), h = '', g.models[g.models.length - 1] } function s (g, x) { const y = g.length >= 2 ? g[1] : i; x.models.push({ faces: [], name: y, textureCoords: [], vertexNormals: [], vertices: [] }), h = '' } function a (g) { g.length === 2 && (h = g[1]) } function f (g, x) { const y = g.length; const T = y >= 2 ? parseFloat(g[1]) : 0; const S = y >= 3 ? parseFloat(g[2]) : 0; const E = y >= 4 ? parseFloat(g[3]) : 0; r(x).vertices.push({ x: T, y: S, z: E }) } function l (g, x) { const y = g.length; let T = y >= 2 ? parseFloat(g[1]) : 0; let S = y >= 3 ? parseFloat(g[2]) : 0; let E = y >= 4 ? parseFloat(g[3]) : 0; isNaN(T) && (T = 0), isNaN(S) && (S = 0), isNaN(E) && (E = 0), t && (S = 1 - S), r(x).textureCoords.push({ u: T, v: S, w: E }) } function u (g, x) { const y = g.length; const T = y >= 2 ? parseFloat(g[1]) : 0; const S = y >= 3 ? parseFloat(g[2]) : 0; const E = y >= 4 ? parseFloat(g[3]) : 0; r(x).vertexNormals.push({ x: T, y: S, z: E }) } function v (g, x) { const y = g.length - 1; if (!(y < 3)) { for (var T = { group: h, material: n, vertices: [] }, S = 0; S < y; S++) { const E = g[S + 1]; const C = E.split('/'); const P = C.length; if (!(P < 1 || P > 3)) { let A = 0; let M = 0; let L = 0; A = parseInt(C[0], 10), P > 1 && C[1] !== '' && (M = parseInt(C[1], 10)), P > 2 && (L = parseInt(C[2], 10)), A !== 0 && (A < 0 && (A = r(x).vertices.length + 1 + A), M -= 1, A -= 1, L -= 1, T.vertices.push({ textureCoordsIndex: M, vertexIndex: A, vertexNormalIndex: L })) } }r(x).faces.push(T) } } function p (g, x) { g.length >= 2 && x.materialLibraries.push(g[1]) } function c (g) { g.length >= 2 && (n = g[1]) } const m = function (g, x) {
          x === void 0 && (x = !0), t = x; const y = { materials: {}, materialLibraries: [], models: [] }; h = '', n = ''; for (let T = g.split(`
`), S = 0; S < T.length; S++) { const E = o(T[S]); const C = E.replace(/\s\s+/g, ' ').trim().split(' '); switch (C[0].toLowerCase()) { case 'o':s(C, y); break; case 'g':a(C); break; case 'v':f(C, y); break; case 'vt':l(C, y); break; case 'vn':u(C, y); break; case 'f':v(C, y); break; case 'mtllib':p(C, y); break; case 'usemtl':c(C); break } } return y
        }; e.exports = m
      }, function (e, d, t) {
        const i = t(103); const h = function (n) {
          for (var o = {}, r = n.split(`
`), s = '', a = 0; a < r.length; a++) { const f = r[a].trim(); if (!(f.indexOf('#') === 0 || f === '')) { const l = f.replace(/\s\s+/g, ' ').trim().split(' '); switch (l[0].toLowerCase()) { case 'newmtl': { s = l[1]; break } case 'kd': { const u = Math.floor(l[1] * 255); const v = l.length >= 2 ? Math.floor(l[2] * 255) : u; const p = l.length >= 3 ? Math.floor(l[3] * 255) : u; o[s] = i(u, v, p); break } } } } return o
        }; e.exports = h
      }, function (e, d) { const t = function (i) { return Math.sqrt(i.x * i.x + i.y * i.y) }; e.exports = t }, function (e, d) { const t = function (i) { return i.x * i.x + i.y * i.y }; e.exports = t }, function (e, d, t) { const i = t(10); i.Area = t(1267), i.Ceil = t(1268), i.CeilAll = t(1269), i.CenterOn = t(190), i.Clone = t(1270), i.Contains = t(57), i.ContainsPoint = t(1271), i.ContainsRect = t(503), i.CopyFrom = t(1272), i.Decompose = t(490), i.Equals = t(1273), i.FitInside = t(1274), i.FitOutside = t(1275), i.Floor = t(1276), i.FloorAll = t(1277), i.FromPoints = t(199), i.FromXY = t(1278), i.GetAspectRatio = t(237), i.GetCenter = t(1279), i.GetPoint = t(171), i.GetPoints = t(306), i.GetSize = t(1280), i.Inflate = t(1281), i.Intersection = t(1282), i.MarchingAnts = t(316), i.MergePoints = t(1283), i.MergeRect = t(1284), i.MergeXY = t(1285), i.Offset = t(1286), i.OffsetPoint = t(1287), i.Overlaps = t(1288), i.Perimeter = t(130), i.PerimeterPoint = t(1289), i.Random = t(174), i.RandomOutside = t(1290), i.SameDimensions = t(1291), i.Scale = t(1292), i.Union = t(441), e.exports = i }, function (e, d) { const t = function (i, h) { return h.width * h.height > i.width * i.height ? !1 : h.x > i.x && h.x < i.right && h.right > i.x && h.right < i.right && h.y > i.y && h.y < i.bottom && h.bottom > i.y && h.bottom < i.bottom }; e.exports = t }, function (e, d, t) { const i = t(4); const h = function (n, o) { return o === void 0 && (o = new i()), o.x = (n.x1 + n.x2 + n.x3) / 3, o.y = (n.y1 + n.y2 + n.y3) / 3, o }; e.exports = h }, function (e, d) { const t = function (i, h, n) { return i.x1 += h, i.y1 += n, i.x2 += h, i.y2 += n, i.x3 += h, i.y3 += n, i }; e.exports = t }, function (e, d, t) { const i = t(4); function h (o, r, s, a) { const f = o - s; const l = r - a; const u = f * f + l * l; return Math.sqrt(u) } const n = function (o, r) { r === void 0 && (r = new i()); const s = o.x1; const a = o.y1; const f = o.x2; const l = o.y2; const u = o.x3; const v = o.y3; const p = h(u, v, f, l); const c = h(s, a, u, v); const m = h(f, l, s, a); const g = p + c + m; return r.x = (s * p + f * c + u * m) / g, r.y = (a * p + l * c + v * m) / g, r }; e.exports = n }, function (e, d) { const t = function (i, h) { return function (n, o, r, s) { const a = i.getPixelAlpha(o, r, s.texture.key, s.frame.name); return a && a >= h } }; e.exports = t }, function (e, d) { const t = function (i, h, n) { return { gameObject: i, enabled: !0, alwaysEnabled: !1, draggable: !1, dropZone: !1, cursor: !1, target: null, camera: null, hitArea: h, hitAreaCallback: n, hitAreaDebug: null, customHitArea: !1, localX: 0, localY: 0, dragState: 0, dragStartX: 0, dragStartY: 0, dragStartXGlobal: 0, dragStartYGlobal: 0, dragX: 0, dragY: 0 } }; e.exports = t }, function (e, d, t) { const i = t(0); const h = new i({ initialize: function (o, r) { this.pad = o, this.events = o.events, this.index = r, this.value = 0, this.threshold = 0.1 }, update: function (n) { this.value = n }, getValue: function () { return Math.abs(this.value) < this.threshold ? 0 : this.value }, destroy: function () { this.pad = null, this.events = null } }); e.exports = h }, function (e, d, t) { const i = t(0); const h = t(239); const n = new i({ initialize: function (r, s) { this.pad = r, this.events = r.manager, this.index = s, this.value = 0, this.threshold = 1, this.pressed = !1 }, update: function (o) { this.value = o; const r = this.pad; const s = this.index; o >= this.threshold ? this.pressed || (this.pressed = !0, this.events.emit(h.BUTTON_DOWN, r, this, o), this.pad.emit(h.GAMEPAD_BUTTON_DOWN, s, o, this)) : this.pressed && (this.pressed = !1, this.events.emit(h.BUTTON_UP, r, this, o), this.pad.emit(h.GAMEPAD_BUTTON_UP, s, o, this)) }, destroy: function () { this.pad = null, this.events = null } }); e.exports = n }, function (e, d, t) { const i = t(509); const h = t(510); const n = t(0); const o = t(9); const r = t(3); const s = new n({ Extends: o, initialize: function (f, l) { o.call(this), this.manager = f, this.pad = l, this.id = l.id, this.index = l.index; for (var u = [], v = 0; v < l.buttons.length; v++)u.push(new h(this, v)); this.buttons = u; const p = []; for (v = 0; v < l.axes.length; v++)p.push(new i(this, v)); this.axes = p, this.vibration = l.vibrationActuator; const c = { value: 0, pressed: !1 }; this._LCLeft = u[14] ? u[14] : c, this._LCRight = u[15] ? u[15] : c, this._LCTop = u[12] ? u[12] : c, this._LCBottom = u[13] ? u[13] : c, this._RCLeft = u[2] ? u[2] : c, this._RCRight = u[1] ? u[1] : c, this._RCTop = u[3] ? u[3] : c, this._RCBottom = u[0] ? u[0] : c, this._FBLeftTop = u[4] ? u[4] : c, this._FBLeftBottom = u[6] ? u[6] : c, this._FBRightTop = u[5] ? u[5] : c, this._FBRightBottom = u[7] ? u[7] : c; const m = { value: 0 }; this._HAxisLeft = p[0] ? p[0] : m, this._VAxisLeft = p[1] ? p[1] : m, this._HAxisRight = p[2] ? p[2] : m, this._VAxisRight = p[3] ? p[3] : m, this.leftStick = new r(), this.rightStick = new r(), this._created = performance.now() }, getAxisTotal: function () { return this.axes.length }, getAxisValue: function (a) { return this.axes[a].getValue() }, setAxisThreshold: function (a) { for (let f = 0; f < this.axes.length; f++) this.axes[f].threshold = a }, getButtonTotal: function () { return this.buttons.length }, getButtonValue: function (a) { return this.buttons[a].value }, isButtonDown: function (a) { return this.buttons[a].pressed }, update: function (a) { if (!(a.timestamp < this._created)) { let f; const l = this.buttons; const u = a.buttons; let v = l.length; for (f = 0; f < v; f++)l[f].update(u[f].value); const p = this.axes; const c = a.axes; for (v = p.length, f = 0; f < v; f++)p[f].update(c[f]); v >= 2 && (this.leftStick.set(p[0].getValue(), p[1].getValue()), v >= 4 && this.rightStick.set(p[2].getValue(), p[3].getValue())) } }, destroy: function () { this.removeAllListeners(), this.manager = null, this.pad = null; let a; for (a = 0; a < this.buttons.length; a++) this.buttons[a].destroy(); for (a = 0; a < this.axes.length; a++) this.axes[a].destroy(); this.buttons = [], this.axes = [] }, connected: { get: function () { return this.pad.connected } }, timestamp: { get: function () { return this.pad.timestamp } }, left: { get: function () { return this._LCLeft.pressed } }, right: { get: function () { return this._LCRight.pressed } }, up: { get: function () { return this._LCTop.pressed } }, down: { get: function () { return this._LCBottom.pressed } }, A: { get: function () { return this._RCBottom.pressed } }, Y: { get: function () { return this._RCTop.pressed } }, X: { get: function () { return this._RCLeft.pressed } }, B: { get: function () { return this._RCRight.pressed } }, L1: { get: function () { return this._FBLeftTop.value } }, L2: { get: function () { return this._FBLeftBottom.value } }, R1: { get: function () { return this._FBRightTop.value } }, R2: { get: function () { return this._FBRightBottom.value } } }); e.exports = s }, function (e, d, t) { const i = t(0); const h = t(9); const n = t(154); const o = new i({ Extends: h, initialize: function (s, a) { h.call(this), this.plugin = s, this.keyCode = a, this.originalEvent = void 0, this.enabled = !0, this.isDown = !1, this.isUp = !0, this.altKey = !1, this.ctrlKey = !1, this.shiftKey = !1, this.metaKey = !1, this.location = 0, this.timeDown = 0, this.duration = 0, this.timeUp = 0, this.emitOnRepeat = !1, this.repeats = 0, this._justDown = !1, this._justUp = !1, this._tick = -1 }, setEmitOnRepeat: function (r) { return this.emitOnRepeat = r, this }, onDown: function (r) { this.originalEvent = r, !!this.enabled && (this.altKey = r.altKey, this.ctrlKey = r.ctrlKey, this.shiftKey = r.shiftKey, this.metaKey = r.metaKey, this.location = r.location, this.repeats++, this.isDown ? this.emitOnRepeat && this.emit(n.DOWN, this, r) : (this.isDown = !0, this.isUp = !1, this.timeDown = r.timeStamp, this.duration = 0, this._justDown = !0, this._justUp = !1, this.emit(n.DOWN, this, r))) }, onUp: function (r) { this.originalEvent = r, !!this.enabled && (this.isDown = !1, this.isUp = !0, this.timeUp = r.timeStamp, this.duration = this.timeUp - this.timeDown, this.repeats = 0, this._justDown = !1, this._justUp = !0, this._tick = -1, this.emit(n.UP, this, r)) }, reset: function () { return this.preventDefault = !0, this.enabled = !0, this.isDown = !1, this.isUp = !0, this.altKey = !1, this.ctrlKey = !1, this.shiftKey = !1, this.metaKey = !1, this.timeDown = 0, this.duration = 0, this.timeUp = 0, this.repeats = 0, this._justDown = !1, this._justUp = !1, this._tick = -1, this }, getDuration: function () { return this.isDown ? this.plugin.game.loop.time - this.timeDown : 0 }, destroy: function () { this.removeAllListeners(), this.originalEvent = null, this.plugin = null } }); e.exports = o }, function (e, d, t) { const i = t(0); const h = t(154); const n = t(2); const o = t(514); const r = t(516); const s = new i({ initialize: function (f, l, u) { if (u === void 0 && (u = {}), l.length < 2) return !1; this.manager = f, this.enabled = !0, this.keyCodes = []; for (let v = 0; v < l.length; v++) { const p = l[v]; typeof p === 'string' ? this.keyCodes.push(p.toUpperCase().charCodeAt(0)) : typeof p === 'number' ? this.keyCodes.push(p) : p.hasOwnProperty('keyCode') && this.keyCodes.push(p.keyCode) } this.current = this.keyCodes[0], this.index = 0, this.size = this.keyCodes.length, this.timeLastMatched = 0, this.matched = !1, this.timeMatched = 0, this.resetOnWrongKey = n(u, 'resetOnWrongKey', !0), this.maxKeyDelay = n(u, 'maxKeyDelay', 0), this.resetOnMatch = n(u, 'resetOnMatch', !1), this.deleteOnMatch = n(u, 'deleteOnMatch', !1); const c = this; const m = function (g) { if (!(c.matched || !c.enabled)) { const x = o(g, c); x && (c.manager.emit(h.COMBO_MATCH, c, g), c.resetOnMatch ? r(c) : c.deleteOnMatch && c.destroy()) } }; this.onKeyDown = m, this.manager.on(h.ANY_KEY_DOWN, this.onKeyDown) }, progress: { get: function () { return this.index / this.size } }, destroy: function () { this.enabled = !1, this.keyCodes = [], this.manager.off(h.ANY_KEY_DOWN, this.onKeyDown), this.manager = null } }); e.exports = s }, function (e, d, t) { const i = t(515); const h = function (n, o) { if (o.matched) return !0; let r = !1; let s = !1; if (n.keyCode === o.current) if (o.index > 0 && o.maxKeyDelay > 0) { const a = o.timeLastMatched + o.maxKeyDelay; n.timeStamp <= a && (s = !0, r = i(n, o)) } else s = !0, r = i(n, o); return !s && o.resetOnWrongKey && (o.index = 0, o.current = o.keyCodes[0]), r && (o.timeLastMatched = n.timeStamp, o.matched = !0, o.timeMatched = n.timeStamp), r }; e.exports = h }, function (e, d) { const t = function (i, h) { return h.timeLastMatched = i.timeStamp, h.index++, h.index === h.size ? !0 : (h.current = h.keyCodes[h.index], !1) }; e.exports = t }, function (e, d) { const t = function (i) { return i.current = i.keyCodes[0], i.index = 0, i.timeLastMatched = 0, i.matched = !1, i.timeMatched = 0, i }; e.exports = t }, function (e, d, t) { const i = t(240); const h = function (n, o) { const r = i(o, n.xhrSettings); const s = new XMLHttpRequest(); if (s.open('GET', n.src, r.async, r.user, r.password), s.responseType = n.xhrSettings.responseType, s.timeout = r.timeout, r.headers) for (const a in r.headers)s.setRequestHeader(a, r.headers[a]); return r.header && r.headerValue && s.setRequestHeader(r.header, r.headerValue), r.requestedWith && s.setRequestHeader('X-Requested-With', r.requestedWith), r.overrideMimeType && s.overrideMimeType(r.overrideMimeType), r.withCredentials && (s.withCredentials = !0), s.onload = n.onLoad.bind(n, s), s.onerror = n.onError.bind(n, s), s.onprogress = n.onProgress.bind(n), s.send(), s }; e.exports = h }, function (e, d, t) { const i = t(0); const h = t(21); const n = t(23); const o = t(8); const r = t(2); const s = t(519); const a = t(7); const f = new i({ Extends: n, initialize: function (u, v, p, c, m) { if (a(v)) { const g = v; v = r(g, 'key'), c = r(g, 'xhrSettings'), m = r(g, 'context', m) } const x = { type: 'audio', cache: u.cacheManager.audio, extension: p.type, responseType: 'arraybuffer', key: v, url: p.url, xhrSettings: c, config: { context: m } }; n.call(this, u, x) }, onProcess: function () { this.state = h.FILE_PROCESSING; const l = this; this.config.context.decodeAudioData(this.xhrLoader.response, function (u) { l.data = u, l.onProcessComplete() }, function (u) { console.error('Error decoding audio: ' + l.key + ' - ', u ? u.message : null), l.onProcessError() }), this.config.context = null } }); f.create = function (l, u, v, p, c) { const m = l.systems.game; const g = m.config.audio; const x = m.device.audio; a(u) && (v = r(u, 'url', []), p = r(u, 'config', {})); const y = f.getAudioURL(m, v); return y ? x.webAudio && !g.disableWebAudio ? new f(l, u, y, c, m.sound.context) : new s(l, u, y, p) : null }, f.getAudioURL = function (l, u) { Array.isArray(u) || (u = [u]); for (let v = 0; v < u.length; v++) { const p = r(u[v], 'url', u[v]); if (p.indexOf('blob:') === 0 || p.indexOf('data:') === 0) return { url: p, type: '' }; let c = p.match(/\.([a-zA-Z0-9]+)($|\?)/); if (c = r(u[v], 'type', c ? c[1] : '').toLowerCase(), l.device.audio[c]) return { url: p, type: c } } return null }, o.register('audio', function (l, u, v, p) { const c = this.systems.game; const m = c.config.audio; const g = c.device.audio; if (m.noAudio || !g.webAudio && !g.audioData) return this; let x; if (Array.isArray(l)) for (let y = 0; y < l.length; y++)x = f.create(this, l[y]), x && this.addFile(x); else x = f.create(this, l, u, v, p), x && this.addFile(x); return this }), e.exports = f }, function (e, d, t) { const i = t(0); const h = t(95); const n = t(23); const o = t(2); const r = t(155); const s = t(7); const a = new i({ Extends: n, initialize: function (l, u, v, p) { if (s(u)) { const c = u; u = o(c, 'key'), p = o(c, 'config', p) } const m = { type: 'audio', cache: l.cacheManager.audio, extension: v.type, key: u, url: v.url, config: p }; n.call(this, l, m), this.locked = 'ontouchstart' in window, this.loaded = !1, this.filesLoaded = 0, this.filesTotal = 0 }, onLoad: function () { this.loaded || (this.loaded = !0, this.loader.nextFile(this, !0)) }, onError: function () { for (let f = 0; f < this.data.length; f++) { const l = this.data[f]; l.oncanplaythrough = null, l.onerror = null } this.loader.nextFile(this, !1) }, onProgress: function (f) { const l = f.target; l.oncanplaythrough = null, l.onerror = null, this.filesLoaded++, this.percentComplete = Math.min(this.filesLoaded / this.filesTotal, 1), this.loader.emit(h.FILE_PROGRESS, this, this.percentComplete), this.filesLoaded === this.filesTotal && this.onLoad() }, load: function () { this.data = []; const f = this.config && this.config.instances || 1; this.filesTotal = f, this.filesLoaded = 0, this.percentComplete = 0; for (var l = 0; l < f; l++) { var u = new Audio(); u.dataset || (u.dataset = {}), u.dataset.name = this.key + ('0' + l).slice(-2), u.dataset.used = 'false', this.locked ? u.dataset.locked = 'true' : (u.dataset.locked = 'false', u.preload = 'auto', u.oncanplaythrough = this.onProgress.bind(this), u.onerror = this.onError.bind(this)), this.data.push(u) } for (l = 0; l < this.data.length; l++)u = this.data[l], u.src = r(this, this.loader.baseURL), this.locked || u.load(); this.locked && setTimeout(this.onLoad.bind(this)) } }); e.exports = a }, function (e, d, t) { const i = t(0); const h = t(21); const n = t(23); const o = t(8); const r = t(2); const s = t(7); const a = new i({ Extends: n, initialize: function (l, u, v, p) { let c = 'js'; if (s(u)) { const m = u; u = r(m, 'key'), v = r(m, 'url'), p = r(m, 'xhrSettings'), c = r(m, 'extension', c) } const g = { type: 'script', cache: !1, extension: c, responseType: 'text', key: u, url: v, xhrSettings: p }; n.call(this, l, g) }, onProcess: function () { this.state = h.FILE_PROCESSING, this.data = document.createElement('script'), this.data.language = 'javascript', this.data.type = 'text/javascript', this.data.defer = !1, this.data.text = this.xhrLoader.responseText, document.head.appendChild(this.data), this.onProcessComplete() } }); o.register('script', function (f, l, u) { if (Array.isArray(f)) for (let v = 0; v < f.length; v++) this.addFile(new a(this, f[v])); else this.addFile(new a(this, f, l, u)); return this }), e.exports = a }, function (e, d, t) { const i = t(522); const h = t(157); const n = t(0); const o = t(62); const r = t(524); const s = t(525); const a = new n({ initialize: function (l) { this.world = l, this.scene = l.scene, this.sys = l.scene.sys }, collider: function (f, l, u, v, p) { return this.world.addCollider(f, l, u, v, p) }, overlap: function (f, l, u, v, p) { return this.world.addOverlap(f, l, u, v, p) }, existing: function (f, l) { const u = l ? o.STATIC_BODY : o.DYNAMIC_BODY; return this.world.enableBody(f, u), f }, staticImage: function (f, l, u, v) { const p = new i(this.scene, f, l, u, v); return this.sys.displayList.add(p), this.world.enableBody(p, o.STATIC_BODY), p }, image: function (f, l, u, v) { const p = new i(this.scene, f, l, u, v); return this.sys.displayList.add(p), this.world.enableBody(p, o.DYNAMIC_BODY), p }, staticSprite: function (f, l, u, v) { const p = new h(this.scene, f, l, u, v); return this.sys.displayList.add(p), this.sys.updateList.add(p), this.world.enableBody(p, o.STATIC_BODY), p }, sprite: function (f, l, u, v) { const p = new h(this.scene, f, l, u, v); return this.sys.displayList.add(p), this.sys.updateList.add(p), this.world.enableBody(p, o.DYNAMIC_BODY), p }, staticGroup: function (f, l) { return this.sys.updateList.add(new s(this.world, this.world.scene, f, l)) }, group: function (f, l) { return this.sys.updateList.add(new r(this.world, this.world.scene, f, l)) }, destroy: function () { this.world = null, this.scene = null, this.sys = null } }); e.exports = a }, function (e, d, t) { const i = t(0); const h = t(243); const n = t(125); const o = new i({ Extends: n, Mixins: [h.Acceleration, h.Angular, h.Bounce, h.Debug, h.Drag, h.Enable, h.Friction, h.Gravity, h.Immovable, h.Mass, h.Pushable, h.Size, h.Velocity], initialize: function (s, a, f, l, u) { n.call(this, s, a, f, l, u), this.body = null } }); e.exports = o }, function (e, d, t) { const i = t(244); const h = t(65); const n = t(231); const o = t(151); const r = function (s, a, f, l, u, v) { const p = i(s, a - l, f - l, 2 * l, 2 * l, u, v); if (p.length === 0) return p; for (var c = new h(a, f, l), m = new h(), g = [], x = 0; x < p.length; x++) { const y = p[x]; y.isCircle ? (m.setTo(y.center.x, y.center.y, y.halfWidth), n(c, m) && g.push(y)) : o(c, y) && g.push(y) } return g }; e.exports = r }, function (e, d, t) { const i = t(157); const h = t(0); const n = t(62); const o = t(2); const r = t(113); const s = t(7); const a = new h({ Extends: r, initialize: function (l, u, v, p) { if (!v && !p)p = { internalCreateCallback: this.createCallbackHandler, internalRemoveCallback: this.removeCallbackHandler }; else if (s(v))p = v, v = null, p.internalCreateCallback = this.createCallbackHandler, p.internalRemoveCallback = this.removeCallbackHandler; else if (Array.isArray(v) && s(v[0])) { p = v[0]; const c = this; v.forEach(function (m) { m.internalCreateCallback = c.createCallbackHandler, m.internalRemoveCallback = c.removeCallbackHandler }), v = null } else p = { internalCreateCallback: this.createCallbackHandler, internalRemoveCallback: this.removeCallbackHandler }; this.world = l, p.classType = o(p, 'classType', i), this.physicsType = n.DYNAMIC_BODY, this.defaults = { setCollideWorldBounds: o(p, 'collideWorldBounds', !1), setBoundsRectangle: o(p, 'customBoundsRectangle', null), setAccelerationX: o(p, 'accelerationX', 0), setAccelerationY: o(p, 'accelerationY', 0), setAllowDrag: o(p, 'allowDrag', !0), setAllowGravity: o(p, 'allowGravity', !0), setAllowRotation: o(p, 'allowRotation', !0), setBounceX: o(p, 'bounceX', 0), setBounceY: o(p, 'bounceY', 0), setDragX: o(p, 'dragX', 0), setDragY: o(p, 'dragY', 0), setEnable: o(p, 'enable', !0), setGravityX: o(p, 'gravityX', 0), setGravityY: o(p, 'gravityY', 0), setFrictionX: o(p, 'frictionX', 0), setFrictionY: o(p, 'frictionY', 0), setMaxVelocityX: o(p, 'maxVelocityX', 1e4), setMaxVelocityY: o(p, 'maxVelocityY', 1e4), setVelocityX: o(p, 'velocityX', 0), setVelocityY: o(p, 'velocityY', 0), setAngularVelocity: o(p, 'angularVelocity', 0), setAngularAcceleration: o(p, 'angularAcceleration', 0), setAngularDrag: o(p, 'angularDrag', 0), setMass: o(p, 'mass', 1), setImmovable: o(p, 'immovable', !1) }, r.call(this, u, v, p), this.type = 'PhysicsGroup' }, createCallbackHandler: function (f) { f.body || this.world.enableBody(f, n.DYNAMIC_BODY); const l = f.body; for (const u in this.defaults)l[u](this.defaults[u]) }, removeCallbackHandler: function (f) { f.body && this.world.disableBody(f) }, setVelocity: function (f, l, u) { u === void 0 && (u = 0); for (let v = this.getChildren(), p = 0; p < v.length; p++)v[p].body.velocity.set(f + p * u, l + p * u); return this }, setVelocityX: function (f, l) { l === void 0 && (l = 0); for (let u = this.getChildren(), v = 0; v < u.length; v++)u[v].body.velocity.x = f + v * l; return this }, setVelocityY: function (f, l) { l === void 0 && (l = 0); for (let u = this.getChildren(), v = 0; v < u.length; v++)u[v].body.velocity.y = f + v * l; return this } }); e.exports = a }, function (e, d, t) { const i = t(157); const h = t(0); const n = t(62); const o = t(2); const r = t(113); const s = t(7); const a = new h({ Extends: r, initialize: function (l, u, v, p) { !v && !p ? p = { internalCreateCallback: this.createCallbackHandler, internalRemoveCallback: this.removeCallbackHandler, createMultipleCallback: this.createMultipleCallbackHandler, classType: i } : s(v) ? (p = v, v = null, p.internalCreateCallback = this.createCallbackHandler, p.internalRemoveCallback = this.removeCallbackHandler, p.createMultipleCallback = this.createMultipleCallbackHandler, p.classType = o(p, 'classType', i)) : Array.isArray(v) && s(v[0]) ? (p = v, v = null, p.forEach(function (c) { c.internalCreateCallback = this.createCallbackHandler, c.internalRemoveCallback = this.removeCallbackHandler, c.createMultipleCallback = this.createMultipleCallbackHandler, c.classType = o(c, 'classType', i) })) : p = { internalCreateCallback: this.createCallbackHandler, internalRemoveCallback: this.removeCallbackHandler }, this.world = l, this.physicsType = n.STATIC_BODY, r.call(this, u, v, p), this.type = 'StaticPhysicsGroup' }, createCallbackHandler: function (f) { f.body || this.world.enableBody(f, n.STATIC_BODY) }, removeCallbackHandler: function (f) { f.body && this.world.disableBody(f) }, createMultipleCallbackHandler: function () { this.refresh() }, refresh: function () { for (let f = this.children.entries, l = 0; l < f.length; l++)f[l].body.reset(); return this } }); e.exports = a }, function (e, d, t) { const i = t(350); const h = t(527); const n = t(18); const o = t(0); const r = t(528); const s = t(62); const a = t(50); const f = t(9); const l = t(245); const u = t(124); const v = t(354); const p = t(355); const c = t(246); const m = t(247); const g = t(529); const x = t(6); const y = t(14); const T = t(211); const S = t(530); const E = t(10); const C = t(531); const P = t(532); const A = t(537); const M = t(538); const L = t(149); const F = t(539); const I = t(248); const G = t(25); const U = t(3); const Y = t(68); const X = new o({ Extends: f, initialize: function (R, D) { f.call(this), this.scene = R, this.bodies = new L(), this.staticBodies = new L(), this.pendingDestroy = new L(), this.colliders = new T(), this.gravity = new U(x(D, 'gravity.x', 0), x(D, 'gravity.y', 0)), this.bounds = new E(x(D, 'x', 0), x(D, 'y', 0), x(D, 'width', R.sys.scale.width), x(D, 'height', R.sys.scale.height)), this.checkCollision = { up: x(D, 'checkCollision.up', !0), down: x(D, 'checkCollision.down', !0), left: x(D, 'checkCollision.left', !0), right: x(D, 'checkCollision.right', !0) }, this.fps = x(D, 'fps', 60), this.fixedStep = x(D, 'fixedStep', !0), this._elapsed = 0, this._frameTime = 1 / this.fps, this._frameTimeMS = 1e3 * this._frameTime, this.stepsLastFrame = 0, this.timeScale = x(D, 'timeScale', 1), this.OVERLAP_BIAS = x(D, 'overlapBias', 4), this.TILE_BIAS = x(D, 'tileBias', 16), this.forceX = x(D, 'forceX', !1), this.isPaused = x(D, 'isPaused', !1), this._total = 0, this.drawDebug = x(D, 'debug', !1), this.debugGraphic, this.defaults = { debugShowBody: x(D, 'debugShowBody', !0), debugShowStaticBody: x(D, 'debugShowStaticBody', !0), debugShowVelocity: x(D, 'debugShowVelocity', !0), bodyDebugColor: x(D, 'debugBodyColor', 16711935), staticBodyDebugColor: x(D, 'debugStaticBodyColor', 255), velocityDebugColor: x(D, 'debugVelocityColor', 65280) }, this.maxEntries = x(D, 'maxEntries', 16), this.useTree = x(D, 'useTree', !0), this.tree = new C(this.maxEntries), this.staticTree = new C(this.maxEntries), this.treeMinMax = { minX: 0, minY: 0, maxX: 0, maxY: 0 }, this._tempMatrix = new G(), this._tempMatrix2 = new G(), this.drawDebug && this.createDebugGraphic() }, enable: function (O, R) { R === void 0 && (R = s.DYNAMIC_BODY), Array.isArray(O) || (O = [O]); for (let D = 0; D < O.length; D++) { const B = O[D]; if (B.isParent) for (let N = B.getChildren(), w = 0; w < N.length; w++) { const z = N[w]; z.isParent ? this.enable(z, R) : this.enableBody(z, R) } else this.enableBody(B, R) } }, enableBody: function (O, R) { return R === void 0 && (R = s.DYNAMIC_BODY), O.body || (R === s.DYNAMIC_BODY ? O.body = new h(this, O) : R === s.STATIC_BODY && (O.body = new F(this, O))), this.add(O.body), O }, add: function (O) { return O.physicsType === s.DYNAMIC_BODY ? this.bodies.set(O) : O.physicsType === s.STATIC_BODY && (this.staticBodies.set(O), this.staticTree.insert(O)), O.enable = !0, O }, disable: function (O) { Array.isArray(O) || (O = [O]); for (let R = 0; R < O.length; R++) { const D = O[R]; if (D.isParent) for (let B = D.getChildren(), N = 0; N < B.length; N++) { const w = B[N]; w.isParent ? this.disable(w) : this.disableBody(w.body) } else this.disableBody(D.body) } }, disableBody: function (O) { this.remove(O), O.enable = !1 }, remove: function (O) { O.physicsType === s.DYNAMIC_BODY ? (this.tree.remove(O), this.bodies.delete(O)) : O.physicsType === s.STATIC_BODY && (this.staticBodies.delete(O), this.staticTree.remove(O)) }, createDebugGraphic: function () { const O = this.scene.sys.add.graphics({ x: 0, y: 0 }); return O.setDepth(Number.MAX_VALUE), this.debugGraphic = O, this.drawDebug = !0, O }, setBounds: function (O, R, D, B, N, w, z, V) { return this.bounds.setTo(O, R, D, B), N !== void 0 && this.setBoundsCollision(N, w, z, V), this }, setBoundsCollision: function (O, R, D, B) { return O === void 0 && (O = !0), R === void 0 && (R = !0), D === void 0 && (D = !0), B === void 0 && (B = !0), this.checkCollision.left = O, this.checkCollision.right = R, this.checkCollision.up = D, this.checkCollision.down = B, this }, pause: function () { return this.isPaused = !0, this.emit(l.PAUSE), this }, resume: function () { return this.isPaused = !1, this.emit(l.RESUME), this }, addCollider: function (O, R, D, B, N) { D === void 0 && (D = null), B === void 0 && (B = null), N === void 0 && (N = D); const w = new r(this, !1, O, R, D, B, N); return this.colliders.add(w), w }, addOverlap: function (O, R, D, B, N) { D === void 0 && (D = null), B === void 0 && (B = null), N === void 0 && (N = D); const w = new r(this, !0, O, R, D, B, N); return this.colliders.add(w), w }, removeCollider: function (O) { return this.colliders.remove(O), this }, setFPS: function (O) { return this.fps = O, this._frameTime = 1 / this.fps, this._frameTimeMS = 1e3 * this._frameTime, this }, update: function (O, R) { if (!(this.isPaused || this.bodies.size === 0)) { let D; let B = this._frameTime; const N = this._frameTimeMS * this.timeScale; this._elapsed += R; let w; const z = this.bodies.entries; let V = this._elapsed >= N; for (this.fixedStep || (B = R * 0.001, V = !0, this._elapsed = 0), D = 0; D < z.length; D++)w = z[D], w.enable && w.preUpdate(V, B); if (V) { this._elapsed -= N, this.stepsLastFrame = 1, this.useTree && (this.tree.clear(), this.tree.load(z)); const W = this.colliders.update(); for (D = 0; D < W.length; D++) { const H = W[D]; H.active && H.update() } this.emit(l.WORLD_STEP, B) } for (;this._elapsed >= N;) this._elapsed -= N, this.step(B) } }, step: function (O) { let R; let D; const B = this.bodies.entries; const N = B.length; for (R = 0; R < N; R++)D = B[R], D.enable && D.update(O); this.useTree && (this.tree.clear(), this.tree.load(B)); const w = this.colliders.update(); for (R = 0; R < w.length; R++) { const z = w[R]; z.active && z.update() } this.emit(l.WORLD_STEP, O), this.stepsLastFrame++ }, postUpdate: function () { let O; let R; let D = this.bodies.entries; let B = D.length; const N = this.bodies; const w = this.staticBodies; if (this.stepsLastFrame) for (this.stepsLastFrame = 0, O = 0; O < B; O++)R = D[O], R.enable && R.postUpdate(); if (this.drawDebug) { const z = this.debugGraphic; for (z.clear(), O = 0; O < B; O++)R = D[O], R.willDrawDebug() && R.drawDebug(z); for (D = w.entries, B = D.length, O = 0; O < B; O++)R = D[O], R.willDrawDebug() && R.drawDebug(z) } const V = this.pendingDestroy; if (V.size > 0) { const W = this.tree; const H = this.staticTree; for (D = V.entries, B = D.length, O = 0; O < B; O++)R = D[O], R.physicsType === s.DYNAMIC_BODY ? (W.remove(R), N.delete(R)) : R.physicsType === s.STATIC_BODY && (H.remove(R), w.delete(R)), R.world = void 0, R.gameObject = void 0; V.clear() } }, updateMotion: function (O, R) { O.allowRotation && this.computeAngularVelocity(O, R), this.computeVelocity(O, R) }, computeAngularVelocity: function (O, R) { let D = O.angularVelocity; const B = O.angularAcceleration; let N = O.angularDrag; const w = O.maxAngular; B ? D += B * R : O.allowDrag && N && (N *= R, v(D - N, 0, 0.1) ? D -= N : p(D + N, 0, 0.1) ? D += N : D = 0), D = n(D, -w, w); const z = D - O.angularVelocity; O.angularVelocity += z, O.rotation += O.angularVelocity * R }, computeVelocity: function (O, R) { let D = O.velocity.x; const B = O.acceleration.x; let N = O.drag.x; const w = O.maxVelocity.x; let z = O.velocity.y; const V = O.acceleration.y; let W = O.drag.y; const H = O.maxVelocity.y; let K = O.speed; const Q = O.maxSpeed; const J = O.allowDrag; const q = O.useDamping; O.allowGravity && (D += (this.gravity.x + O.gravity.x) * R, z += (this.gravity.y + O.gravity.y) * R), B ? D += B * R : J && N && (q ? (N = Math.pow(N, R), D *= N, K = Math.sqrt(D * D + z * z), u(K, 0, 0.001) && (D = 0)) : (N *= R, v(D - N, 0, 0.01) ? D -= N : p(D + N, 0, 0.01) ? D += N : D = 0)), V ? z += V * R : J && W && (q ? (W = Math.pow(W, R), z *= W, K = Math.sqrt(D * D + z * z), u(K, 0, 0.001) && (z = 0)) : (W *= R, v(z - W, 0, 0.01) ? z -= W : p(z + W, 0, 0.01) ? z += W : z = 0)), D = n(D, -w, w), z = n(z, -H, H), O.velocity.set(D, z), Q > -1 && K > Q && (O.velocity.normalize().scale(Q), K = Q), O.speed = K }, separate: function (O, R, D, B, N, w) { if (!w && !O.enable || !R.enable || O.checkCollision.none || R.checkCollision.none || !this.intersects(O, R) || D && D.call(B, O.gameObject, R.gameObject) === !1) return !1; if (O.isCircle && R.isCircle) return this.separateCircle(O, R, N); if (O.isCircle !== R.isCircle) { const z = O.isCircle ? R : O; const V = O.isCircle ? O : R; const W = { x: z.x, y: z.y, right: z.right, bottom: z.bottom }; const H = V.center; if ((H.y < W.y || H.y > W.bottom) && (H.x < W.x || H.x > W.right)) return this.separateCircle(O, R, N) } let K = !1; let Q = !1; N ? (K = A(O, R, N, this.OVERLAP_BIAS), Q = M(O, R, N, this.OVERLAP_BIAS)) : this.forceX || Math.abs(this.gravity.y + O.gravity.y) < Math.abs(this.gravity.x + O.gravity.x) ? (K = A(O, R, N, this.OVERLAP_BIAS), this.intersects(O, R) && (Q = M(O, R, N, this.OVERLAP_BIAS))) : (Q = M(O, R, N, this.OVERLAP_BIAS), this.intersects(O, R) && (K = A(O, R, N, this.OVERLAP_BIAS))); const J = K || Q; return J && (N ? (O.onOverlap || R.onOverlap) && this.emit(l.OVERLAP, O.gameObject, R.gameObject, O, R) : (O.onCollide || R.onCollide) && this.emit(l.COLLIDE, O.gameObject, R.gameObject, O, R)), J }, separateCircle: function (O, R, D, B) { c(O, R, !1, B), m(O, R, !1, B); let N = 0; if (O.isCircle !== R.isCircle) { const w = { x: R.isCircle ? O.position.x : R.position.x, y: R.isCircle ? O.position.y : R.position.y, right: R.isCircle ? O.right : R.right, bottom: R.isCircle ? O.bottom : R.bottom }; const z = { x: O.isCircle ? O.center.x : R.center.x, y: O.isCircle ? O.center.y : R.center.y, radius: O.isCircle ? O.halfWidth : R.halfWidth }; z.y < w.y ? z.x < w.x ? N = a(z.x, z.y, w.x, w.y) - z.radius : z.x > w.right && (N = a(z.x, z.y, w.right, w.y) - z.radius) : z.y > w.bottom && (z.x < w.x ? N = a(z.x, z.y, w.x, w.bottom) - z.radius : z.x > w.right && (N = a(z.x, z.y, w.right, w.bottom) - z.radius)), N *= -1 } else N = O.halfWidth + R.halfWidth - a(O.center.x, O.center.y, R.center.x, R.center.y); if (O.overlapR = N, R.overlapR = N, D || N === 0 || O.immovable && R.immovable || O.customSeparateX || R.customSeparateX) return N !== 0 && (O.onOverlap || R.onOverlap) && this.emit(l.OVERLAP, O.gameObject, R.gameObject, O, R), N !== 0; const V = O.center.x - R.center.x; const W = O.center.y - R.center.y; const H = Math.sqrt(Math.pow(V, 2) + Math.pow(W, 2)); const K = (R.center.x - O.center.x) / H || 0; const Q = (R.center.y - O.center.y) / H || 0; let J = 2 * (O.velocity.x * K + O.velocity.y * Q - R.velocity.x * K - R.velocity.y * Q) / (O.mass + R.mass); (O.immovable || R.immovable) && (J *= 2), O.immovable || (O.velocity.x = O.velocity.x - J / O.mass * K, O.velocity.y = O.velocity.y - J / O.mass * Q), R.immovable || (R.velocity.x = R.velocity.x + J / R.mass * K, R.velocity.y = R.velocity.y + J / R.mass * Q), !O.immovable && !R.immovable && (N /= 2); const q = i(O.center, R.center); const j = (N + y.EPSILON) * Math.cos(q); const _ = (N + y.EPSILON) * Math.sin(q); return O.immovable || (O.x -= j, O.y -= _, O.updateCenter()), R.immovable || (R.x += j, R.y += _, R.updateCenter()), O.velocity.x *= O.bounce.x, O.velocity.y *= O.bounce.y, R.velocity.x *= R.bounce.x, R.velocity.y *= R.bounce.y, (O.onCollide || R.onCollide) && this.emit(l.COLLIDE, O.gameObject, R.gameObject, O, R), !0 }, intersects: function (O, R) { return O === R ? !1 : !O.isCircle && !R.isCircle ? !(O.right <= R.position.x || O.bottom <= R.position.y || O.position.x >= R.right || O.position.y >= R.bottom) : O.isCircle ? R.isCircle ? a(O.center.x, O.center.y, R.center.x, R.center.y) <= O.halfWidth + R.halfWidth : this.circleBodyIntersects(O, R) : this.circleBodyIntersects(R, O) }, circleBodyIntersects: function (O, R) { const D = n(O.center.x, R.left, R.right); const B = n(O.center.y, R.top, R.bottom); const N = (O.center.x - D) * (O.center.x - D); const w = (O.center.y - B) * (O.center.y - B); return N + w <= O.halfWidth * O.halfWidth }, overlap: function (O, R, D, B, N) { return D === void 0 && (D = null), B === void 0 && (B = null), N === void 0 && (N = D), this.collideObjects(O, R, D, B, N, !0) }, collide: function (O, R, D, B, N) { return D === void 0 && (D = null), B === void 0 && (B = null), N === void 0 && (N = D), this.collideObjects(O, R, D, B, N, !1) }, collideObjects: function (O, R, D, B, N, w) { let z, V; O.isParent && O.physicsType === void 0 && (O = O.children.entries), R && R.isParent && R.physicsType === void 0 && (R = R.children.entries); const W = Array.isArray(O); const H = Array.isArray(R); if (this._total = 0, !W && !H) this.collideHandler(O, R, D, B, N, w); else if (!W && H) for (z = 0; z < R.length; z++) this.collideHandler(O, R[z], D, B, N, w); else if (W && !H) if (R) for (z = 0; z < O.length; z++) this.collideHandler(O[z], R, D, B, N, w); else for (z = 0; z < O.length; z++) { const K = O[z]; for (V = z + 1; V < O.length; V++)z !== V && this.collideHandler(K, O[V], D, B, N, w) } else for (z = 0; z < O.length; z++) for (V = 0; V < R.length; V++) this.collideHandler(O[z], R[V], D, B, N, w); return this._total > 0 }, collideHandler: function (O, R, D, B, N, w) { if (R === void 0 && O.isParent) return this.collideGroupVsGroup(O, O, D, B, N, w); if (!O || !R) return !1; if (O.body) { if (R.body) return this.collideSpriteVsSprite(O, R, D, B, N, w); if (R.isParent) return this.collideSpriteVsGroup(O, R, D, B, N, w); if (R.isTilemap) return this.collideSpriteVsTilemapLayer(O, R, D, B, N, w) } else if (O.isParent) { if (R.body) return this.collideSpriteVsGroup(R, O, D, B, N, w); if (R.isParent) return this.collideGroupVsGroup(O, R, D, B, N, w); if (R.isTilemap) return this.collideGroupVsTilemapLayer(O, R, D, B, N, w) } else if (O.isTilemap) { if (R.body) return this.collideSpriteVsTilemapLayer(R, O, D, B, N, w); if (R.isParent) return this.collideGroupVsTilemapLayer(R, O, D, B, N, w) } }, collideSpriteVsSprite: function (O, R, D, B, N, w) { return !O.body || !R.body ? !1 : (this.separate(O.body, R.body, B, N, w) && (D && D.call(N, O, R), this._total++), !0) }, collideSpriteVsGroup: function (O, R, D, B, N, w) { const z = O.body; if (!(R.length === 0 || !z || !z.enable || z.checkCollision.none)) { let V, W, H; if (this.useTree || R.physicsType === s.STATIC_BODY) { const K = this.treeMinMax; K.minX = z.left, K.minY = z.top, K.maxX = z.right, K.maxY = z.bottom; const Q = R.physicsType === s.DYNAMIC_BODY ? this.tree.search(K) : this.staticTree.search(K); for (W = Q.length, V = 0; V < W; V++)H = Q[V], !(z === H || !H.enable || H.checkCollision.none || !R.contains(H.gameObject)) && this.separate(z, H, B, N, w, !0) && (D && D.call(N, z.gameObject, H.gameObject), this._total++) } else { const J = R.getChildren(); const q = R.children.entries.indexOf(O); for (W = J.length, V = 0; V < W; V++)H = J[V].body, !(!H || V === q || !H.enable) && this.separate(z, H, B, N, w) && (D && D.call(N, z.gameObject, H.gameObject), this._total++) } } }, collideGroupVsTilemapLayer: function (O, R, D, B, N, w) { const z = O.getChildren(); if (z.length === 0) return !1; for (var V = !1, W = 0; W < z.length; W++)z[W].body && this.collideSpriteVsTilemapLayer(z[W], R, D, B, N, w) && (V = !0); return V }, collideTiles: function (O, R, D, B, N) { return !O.body.enable || R.length === 0 ? !1 : this.collideSpriteVsTilesHandler(O, R, D, B, N, !1, !1) }, overlapTiles: function (O, R, D, B, N) { return !O.body.enable || R.length === 0 ? !1 : this.collideSpriteVsTilesHandler(O, R, D, B, N, !0, !1) }, collideSpriteVsTilemapLayer: function (O, R, D, B, N, w) { const z = O.body; if (!z.enable || z.checkCollision.none) return !1; let V = z.position.x; const W = z.position.y; let H = z.width; let K = z.height; const Q = R.layer; if (Q.tileWidth > Q.baseTileWidth) { const J = (Q.tileWidth - Q.baseTileWidth) * R.scaleX; V -= J, H += J } if (Q.tileHeight > Q.baseTileHeight) { const q = (Q.tileHeight - Q.baseTileHeight) * R.scaleY; K += q } const j = g(V, W, H, K, null, R.scene.cameras.main, R.layer); return j.length === 0 ? !1 : this.collideSpriteVsTilesHandler(O, j, D, B, N, w, !0) }, collideSpriteVsTilesHandler: function (O, R, D, B, N, w, z) { for (var V = O.body, W, H = { left: 0, right: 0, top: 0, bottom: 0 }, K, Q = !1, J = 0; J < R.length; J++) { W = R[J], K = W.tilemapLayer; const q = K.tileToWorldXY(W.x, W.y); H.left = q.x, H.top = q.y, W.baseHeight !== W.height && (H.top -= (W.height - W.baseHeight) * K.scaleY), H.right = H.left + W.width * K.scaleX, H.bottom = H.top + W.height * K.scaleY, I(H, V) && (!B || B.call(N, O, W)) && S(W, O) && (w || P(J, V, W, H, K, this.TILE_BIAS, z)) && (this._total++, Q = !0, D && D.call(N, O, W), w && V.onOverlap ? this.emit(l.TILE_OVERLAP, O, W, V) : V.onCollide && this.emit(l.TILE_COLLIDE, O, W, V)) } return Q }, collideGroupVsGroup: function (O, R, D, B, N, w) { if (!(O.length === 0 || R.length === 0)) for (let z = O.getChildren(), V = 0; V < z.length; V++) this.collideSpriteVsGroup(z[V], R, D, B, N, w) }, wrap: function (O, R) { O.body ? this.wrapObject(O, R) : O.getChildren ? this.wrapArray(O.getChildren(), R) : Array.isArray(O) ? this.wrapArray(O, R) : this.wrapObject(O, R) }, wrapArray: function (O, R) { for (let D = 0; D < O.length; D++) this.wrapObject(O[D], R) }, wrapObject: function (O, R) { R === void 0 && (R = 0), O.x = Y(O.x, this.bounds.left - R, this.bounds.right + R), O.y = Y(O.y, this.bounds.top - R, this.bounds.bottom + R) }, shutdown: function () { this.tree.clear(), this.staticTree.clear(), this.bodies.clear(), this.staticBodies.clear(), this.colliders.destroy(), this.removeAllListeners() }, destroy: function () { this.shutdown(), this.scene = null } }); e.exports = X }, function (e, d, t) { const i = t(0); const h = t(62); const n = t(245); const o = t(196); const r = t(10); const s = t(57); const a = t(3); const f = new i({ initialize: function (u, v) { const p = v.displayWidth ? v.displayWidth : 64; const c = v.displayHeight ? v.displayHeight : 64; this.world = u, this.gameObject = v, this.transform = { x: v.x, y: v.y, rotation: v.angle, scaleX: v.scaleX, scaleY: v.scaleY, displayOriginX: v.displayOriginX, displayOriginY: v.displayOriginY }, this.debugShowBody = u.defaults.debugShowBody, this.debugShowVelocity = u.defaults.debugShowVelocity, this.debugBodyColor = u.defaults.bodyDebugColor, this.enable = !0, this.isCircle = !1, this.radius = 0, this.offset = new a(), this.position = new a(v.x - v.scaleX * v.displayOriginX, v.y - v.scaleY * v.displayOriginY), this.prev = this.position.clone(), this.prevFrame = this.position.clone(), this.allowRotation = !0, this.rotation = v.angle, this.preRotation = v.angle, this.width = p, this.height = c, this.sourceWidth = p, this.sourceHeight = c, v.frame && (this.sourceWidth = v.frame.realWidth, this.sourceHeight = v.frame.realHeight), this.halfWidth = Math.abs(p / 2), this.halfHeight = Math.abs(c / 2), this.center = new a(this.position.x + this.halfWidth, this.position.y + this.halfHeight), this.velocity = new a(), this.newVelocity = new a(), this.deltaMax = new a(), this.acceleration = new a(), this.allowDrag = !0, this.drag = new a(), this.allowGravity = !0, this.gravity = new a(), this.bounce = new a(), this.worldBounce = null, this.customBoundsRectangle = u.bounds, this.onWorldBounds = !1, this.onCollide = !1, this.onOverlap = !1, this.maxVelocity = new a(1e4, 1e4), this.maxSpeed = -1, this.friction = new a(1, 0), this.useDamping = !1, this.angularVelocity = 0, this.angularAcceleration = 0, this.angularDrag = 0, this.maxAngular = 1e3, this.mass = 1, this.angle = 0, this.speed = 0, this.facing = h.FACING_NONE, this.immovable = !1, this.pushable = !0, this.moves = !0, this.customSeparateX = !1, this.customSeparateY = !1, this.overlapX = 0, this.overlapY = 0, this.overlapR = 0, this.embedded = !1, this.collideWorldBounds = !1, this.checkCollision = { none: !1, up: !0, down: !0, left: !0, right: !0 }, this.touching = { none: !0, up: !1, down: !1, left: !1, right: !1 }, this.wasTouching = { none: !0, up: !1, down: !1, left: !1, right: !1 }, this.blocked = { none: !0, up: !1, down: !1, left: !1, right: !1 }, this.syncBounds = !1, this.physicsType = h.DYNAMIC_BODY, this._sx = v.scaleX, this._sy = v.scaleY, this._dx = 0, this._dy = 0, this._tx = 0, this._ty = 0, this._bounds = new r() }, updateBounds: function () { const l = this.gameObject; const u = this.transform; if (l.parentContainer) { const v = l.getWorldTransformMatrix(this.world._tempMatrix, this.world._tempMatrix2); u.x = v.tx, u.y = v.ty, u.rotation = o(v.rotation), u.scaleX = v.scaleX, u.scaleY = v.scaleY, u.displayOriginX = l.displayOriginX, u.displayOriginY = l.displayOriginY } else u.x = l.x, u.y = l.y, u.rotation = l.angle, u.scaleX = l.scaleX, u.scaleY = l.scaleY, u.displayOriginX = l.displayOriginX, u.displayOriginY = l.displayOriginY; let p = !1; if (this.syncBounds) { const c = l.getBounds(this._bounds); this.width = c.width, this.height = c.height, p = !0 } else { const m = Math.abs(u.scaleX); const g = Math.abs(u.scaleY); (this._sx !== m || this._sy !== g) && (this.width = this.sourceWidth * m, this.height = this.sourceHeight * g, this._sx = m, this._sy = g, p = !0) }p && (this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.updateCenter()) }, updateCenter: function () { this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight) }, updateFromGameObject: function () { this.updateBounds(); const l = this.transform; this.position.x = l.x + l.scaleX * (this.offset.x - l.displayOriginX), this.position.y = l.y + l.scaleY * (this.offset.y - l.displayOriginY), this.updateCenter() }, resetFlags: function (l) { l === void 0 && (l = !1); const u = this.wasTouching; const v = this.touching; const p = this.blocked; l ? (u.none = !0, u.up = !1, u.down = !1, u.left = !1, u.right = !1) : (u.none = v.none, u.up = v.up, u.down = v.down, u.left = v.left, u.right = v.right), v.none = !0, v.up = !1, v.down = !1, v.left = !1, v.right = !1, p.none = !0, p.up = !1, p.down = !1, p.left = !1, p.right = !1, this.overlapR = 0, this.overlapX = 0, this.overlapY = 0, this.embedded = !1 }, preUpdate: function (l, u) { l && this.resetFlags(), this.updateFromGameObject(), this.rotation = this.transform.rotation, this.preRotation = this.rotation, this.moves && (this.prev.x = this.position.x, this.prev.y = this.position.y, this.prevFrame.x = this.position.x, this.prevFrame.y = this.position.y), l && this.update(u) }, update: function (l) { if (this.prev.x = this.position.x, this.prev.y = this.position.y, this.moves) { this.world.updateMotion(this, l); const u = this.velocity.x; const v = this.velocity.y; this.newVelocity.set(u * l, v * l), this.position.add(this.newVelocity), this.updateCenter(), this.angle = Math.atan2(v, u), this.speed = Math.sqrt(u * u + v * v), this.collideWorldBounds && this.checkWorldBounds() && this.onWorldBounds && this.world.emit(n.WORLD_BOUNDS, this, this.blocked.up, this.blocked.down, this.blocked.left, this.blocked.right) } this._dx = this.position.x - this.prev.x, this._dy = this.position.y - this.prev.y }, postUpdate: function () { let l = this.position.x - this.prevFrame.x; let u = this.position.y - this.prevFrame.y; if (this.moves) { const v = this.deltaMax.x; const p = this.deltaMax.y; v !== 0 && l !== 0 && (l < 0 && l < -v ? l = -v : l > 0 && l > v && (l = v)), p !== 0 && u !== 0 && (u < 0 && u < -p ? u = -p : u > 0 && u > p && (u = p)), this.gameObject.x += l, this.gameObject.y += u }l < 0 ? this.facing = h.FACING_LEFT : l > 0 && (this.facing = h.FACING_RIGHT), u < 0 ? this.facing = h.FACING_UP : u > 0 && (this.facing = h.FACING_DOWN), this.allowRotation && (this.gameObject.angle += this.deltaZ()), this._tx = l, this._ty = u }, setBoundsRectangle: function (l) { return this.customBoundsRectangle = l || this.world.bounds, this }, checkWorldBounds: function () { const l = this.position; const u = this.customBoundsRectangle; const v = this.world.checkCollision; const p = this.worldBounce ? -this.worldBounce.x : -this.bounce.x; const c = this.worldBounce ? -this.worldBounce.y : -this.bounce.y; let m = !1; return l.x < u.x && v.left ? (l.x = u.x, this.velocity.x *= p, this.blocked.left = !0, m = !0) : this.right > u.right && v.right && (l.x = u.right - this.width, this.velocity.x *= p, this.blocked.right = !0, m = !0), l.y < u.y && v.up ? (l.y = u.y, this.velocity.y *= c, this.blocked.up = !0, m = !0) : this.bottom > u.bottom && v.down && (l.y = u.bottom - this.height, this.velocity.y *= c, this.blocked.down = !0, m = !0), m && (this.blocked.none = !1, this.updateCenter()), m }, setOffset: function (l, u) { return u === void 0 && (u = l), this.offset.set(l, u), this }, setSize: function (l, u, v) { v === void 0 && (v = !0); const p = this.gameObject; if (!l && p.frame && (l = p.frame.realWidth), !u && p.frame && (u = p.frame.realHeight), this.sourceWidth = l, this.sourceHeight = u, this.width = this.sourceWidth * this._sx, this.height = this.sourceHeight * this._sy, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.updateCenter(), v && p.getCenter) { const c = (p.width - l) / 2; const m = (p.height - u) / 2; this.offset.set(c, m) } return this.isCircle = !1, this.radius = 0, this }, setCircle: function (l, u, v) { return u === void 0 && (u = this.offset.x), v === void 0 && (v = this.offset.y), l > 0 ? (this.isCircle = !0, this.radius = l, this.sourceWidth = l * 2, this.sourceHeight = l * 2, this.width = this.sourceWidth * this._sx, this.height = this.sourceHeight * this._sy, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.offset.set(u, v), this.updateCenter()) : this.isCircle = !1, this }, reset: function (l, u) { this.stop(); const v = this.gameObject; v.setPosition(l, u), v.getTopLeft ? v.getTopLeft(this.position) : this.position.set(l, u), this.prev.copy(this.position), this.prevFrame.copy(this.position), this.rotation = v.angle, this.preRotation = v.angle, this.updateBounds(), this.updateCenter(), this.resetFlags(!0) }, stop: function () { return this.velocity.set(0), this.acceleration.set(0), this.speed = 0, this.angularVelocity = 0, this.angularAcceleration = 0, this }, getBounds: function (l) { return l.x = this.x, l.y = this.y, l.right = this.right, l.bottom = this.bottom, l }, hitTest: function (l, u) { if (!this.isCircle) return s(this, l, u); if (this.radius > 0 && l >= this.left && l <= this.right && u >= this.top && u <= this.bottom) { const v = (this.center.x - l) * (this.center.x - l); const p = (this.center.y - u) * (this.center.y - u); return v + p <= this.radius * this.radius } return !1 }, onFloor: function () { return this.blocked.down }, onCeiling: function () { return this.blocked.up }, onWall: function () { return this.blocked.left || this.blocked.right }, deltaAbsX: function () { return this._dx > 0 ? this._dx : -this._dx }, deltaAbsY: function () { return this._dy > 0 ? this._dy : -this._dy }, deltaX: function () { return this._dx }, deltaY: function () { return this._dy }, deltaXFinal: function () { return this._tx }, deltaYFinal: function () { return this._ty }, deltaZ: function () { return this.rotation - this.preRotation }, destroy: function () { this.enable = !1, this.world && this.world.pendingDestroy.set(this) }, drawDebug: function (l) { const u = this.position; const v = u.x + this.halfWidth; const p = u.y + this.halfHeight; this.debugShowBody && (l.lineStyle(l.defaultStrokeWidth, this.debugBodyColor), this.isCircle ? l.strokeCircle(v, p, this.width / 2) : (this.checkCollision.up && l.lineBetween(u.x, u.y, u.x + this.width, u.y), this.checkCollision.right && l.lineBetween(u.x + this.width, u.y, u.x + this.width, u.y + this.height), this.checkCollision.down && l.lineBetween(u.x, u.y + this.height, u.x + this.width, u.y + this.height), this.checkCollision.left && l.lineBetween(u.x, u.y, u.x, u.y + this.height))), this.debugShowVelocity && (l.lineStyle(l.defaultStrokeWidth, this.world.defaults.velocityDebugColor, 1), l.lineBetween(v, p, v + this.velocity.x / 2, p + this.velocity.y / 2)) }, willDrawDebug: function () { return this.debugShowBody || this.debugShowVelocity }, setCollideWorldBounds: function (l, u, v, p) { l === void 0 && (l = !0), this.collideWorldBounds = l; const c = u !== void 0; const m = v !== void 0; return (c || m) && (this.worldBounce || (this.worldBounce = new a()), c && (this.worldBounce.x = u), m && (this.worldBounce.y = v)), p !== void 0 && (this.onWorldBounds = p), this }, setVelocity: function (l, u) { return this.velocity.set(l, u), l = this.velocity.x, u = this.velocity.y, this.speed = Math.sqrt(l * l + u * u), this }, setVelocityX: function (l) { this.velocity.x = l; const u = l; const v = this.velocity.y; return this.speed = Math.sqrt(u * u + v * v), this }, setVelocityY: function (l) { this.velocity.y = l; const u = this.velocity.x; const v = l; return this.speed = Math.sqrt(u * u + v * v), this }, setMaxVelocity: function (l, u) { return this.maxVelocity.set(l, u), this }, setMaxVelocityX: function (l) { return this.maxVelocity.x = l, this }, setMaxVelocityY: function (l) { return this.maxVelocity.y = l, this }, setMaxSpeed: function (l) { return this.maxSpeed = l, this }, setBounce: function (l, u) { return this.bounce.set(l, u), this }, setBounceX: function (l) { return this.bounce.x = l, this }, setBounceY: function (l) { return this.bounce.y = l, this }, setAcceleration: function (l, u) { return this.acceleration.set(l, u), this }, setAccelerationX: function (l) { return this.acceleration.x = l, this }, setAccelerationY: function (l) { return this.acceleration.y = l, this }, setAllowDrag: function (l) { return l === void 0 && (l = !0), this.allowDrag = l, this }, setAllowGravity: function (l) { return l === void 0 && (l = !0), this.allowGravity = l, this }, setAllowRotation: function (l) { return l === void 0 && (l = !0), this.allowRotation = l, this }, setDrag: function (l, u) { return this.drag.set(l, u), this }, setDamping: function (l) { return this.useDamping = l, this }, setDragX: function (l) { return this.drag.x = l, this }, setDragY: function (l) { return this.drag.y = l, this }, setGravity: function (l, u) { return this.gravity.set(l, u), this }, setGravityX: function (l) { return this.gravity.x = l, this }, setGravityY: function (l) { return this.gravity.y = l, this }, setFriction: function (l, u) { return this.friction.set(l, u), this }, setFrictionX: function (l) { return this.friction.x = l, this }, setFrictionY: function (l) { return this.friction.y = l, this }, setAngularVelocity: function (l) { return this.angularVelocity = l, this }, setAngularAcceleration: function (l) { return this.angularAcceleration = l, this }, setAngularDrag: function (l) { return this.angularDrag = l, this }, setMass: function (l) { return this.mass = l, this }, setImmovable: function (l) { return l === void 0 && (l = !0), this.immovable = l, this }, setEnable: function (l) { return l === void 0 && (l = !0), this.enable = l, this }, processX: function (l, u, v, p) { this.x += l, this.updateCenter(), u !== null && (this.velocity.x = u); const c = this.blocked; v && (c.left = !0), p && (c.right = !0) }, processY: function (l, u, v, p) { this.y += l, this.updateCenter(), u !== null && (this.velocity.y = u); const c = this.blocked; v && (c.up = !0), p && (c.down = !0) }, x: { get: function () { return this.position.x }, set: function (l) { this.position.x = l } }, y: { get: function () { return this.position.y }, set: function (l) { this.position.y = l } }, left: { get: function () { return this.position.x } }, right: { get: function () { return this.position.x + this.width } }, top: { get: function () { return this.position.y } }, bottom: { get: function () { return this.position.y + this.height } } }); e.exports = f }, function (e, d, t) { const i = t(0); const h = new i({ initialize: function (o, r, s, a, f, l, u) { this.world = o, this.name = '', this.active = !0, this.overlapOnly = r, this.object1 = s, this.object2 = a, this.collideCallback = f, this.processCallback = l, this.callbackContext = u }, setName: function (n) { return this.name = n, this }, update: function () { this.world.collideObjects(this.object1, this.object2, this.collideCallback, this.processCallback, this.callbackContext, this.overlapOnly) }, destroy: function () { this.world.removeCollider(this), this.active = !1, this.world = null, this.object1 = null, this.object2 = null, this.collideCallback = null, this.processCallback = null, this.callbackContext = null } }); e.exports = h }, function (e, d, t) { const i = t(26); const h = t(3); const n = new h(); const o = new h(); const r = function (s, a, f, l, u, v, p) { const c = p.tilemapLayer.tilemap._convert.WorldToTileXY; c(s, a, !0, n, v, p); const m = n.x; const g = n.y; c(s + f, a + l, !1, o, v, p); const x = Math.ceil(o.x); const y = Math.ceil(o.y); return i(m, g, x - m, y - g, u, p) }; e.exports = r }, function (e, d) { const t = function (i, h) { return i.collisionCallback ? !i.collisionCallback.call(i.collisionCallbackContext, h, i) : i.layer.callbacks[i.index] ? !i.layer.callbacks[i.index].callback.call(i.layer.callbacks[i.index].callbackContext, h, i) : !0 }; e.exports = t }, function (e, d, t) { const i = t(436); function h (y) { const T = ['.left', '.top', '.right', '.bottom']; if (!(this instanceof h)) return new h(y, T); this._maxEntries = Math.max(4, y || 9), this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4)), this.clear() }h.prototype = { all: function () { return this._all(this.data, []) }, search: function (y) { let T = this.data; const S = []; const E = this.toBBox; if (!m(y, T)) return S; for (var C = [], P, A, M, L; T;) { for (P = 0, A = T.children.length; P < A; P++)M = T.children[P], L = T.leaf ? E(M) : M, m(y, L) && (T.leaf ? S.push(M) : c(y, L) ? this._all(M, S) : C.push(M)); T = C.pop() } return S }, collides: function (y) { let T = this.data; const S = this.toBBox; if (!m(y, T)) return !1; for (var E = [], C, P, A, M; T;) { for (C = 0, P = T.children.length; C < P; C++) if (A = T.children[C], M = T.leaf ? S(A) : A, m(y, M)) { if (T.leaf || c(y, M)) return !0; E.push(A) }T = E.pop() } return !1 }, load: function (y) { if (!(y && y.length)) return this; if (y.length < this._minEntries) { for (let T = 0, S = y.length; T < S; T++) this.insert(y[T]); return this } let E = this._build(y.slice(), 0, y.length - 1, 0); if (!this.data.children.length) this.data = E; else if (this.data.height === E.height) this._splitRoot(this.data, E); else { if (this.data.height < E.height) { const C = this.data; this.data = E, E = C } this._insert(E, this.data.height - E.height - 1, !0) } return this }, insert: function (y) { return y && this._insert(y, this.data.height - 1), this }, clear: function () { return this.data = g([]), this }, remove: function (y, T) { if (!y) return this; for (var S = this.data, E = this.toBBox(y), C = [], P = [], A, M, L, F; S || C.length;) { if (S || (S = C.pop(), M = C[C.length - 1], A = P.pop(), F = !0), S.leaf && (L = n(y, S.children, T), L !== -1)) return S.children.splice(L, 1), C.push(S), this._condense(C), this; !F && !S.leaf && c(S, E) ? (C.push(S), P.push(A), A = 0, M = S, S = S.children[0]) : M ? (A++, S = M.children[A], F = !1) : S = null } return this }, toBBox: function (y) { return y }, compareMinX: a, compareMinY: f, toJSON: function () { return this.data }, fromJSON: function (y) { return this.data = y, this }, _all: function (y, T) { for (let S = []; y;)y.leaf ? T.push.apply(T, y.children) : S.push.apply(S, y.children), y = S.pop(); return T }, _build: function (y, T, S, E) { const C = S - T + 1; let P = this._maxEntries; let A; if (C <= P) return A = g(y.slice(T, S + 1)), o(A, this.toBBox), A; E || (E = Math.ceil(Math.log(C) / Math.log(P)), P = Math.ceil(C / Math.pow(P, E - 1))), A = g([]), A.leaf = !1, A.height = E; const M = Math.ceil(C / P); const L = M * Math.ceil(Math.sqrt(P)); let F; let I; let G; let U; for (x(y, T, S, L, this.compareMinX), F = T; F <= S; F += L) for (G = Math.min(F + L - 1, S), x(y, F, G, M, this.compareMinY), I = F; I <= G; I += M)U = Math.min(I + M - 1, G), A.children.push(this._build(y, I, U, E - 1)); return o(A, this.toBBox), A }, _chooseSubtree: function (y, T, S, E) { for (var C, P, A, M, L, F, I, G; E.push(T), !(T.leaf || E.length - 1 === S);) { for (I = G = 1 / 0, C = 0, P = T.children.length; C < P; C++)A = T.children[C], L = l(A), F = v(y, A) - L, F < G ? (G = F, I = L < I ? L : I, M = A) : F === G && L < I && (I = L, M = A); T = M || T.children[0] } return T }, _insert: function (y, T, S) { const E = this.toBBox; const C = S ? y : E(y); const P = []; const A = this._chooseSubtree(C, this.data, T, P); for (A.children.push(y), s(A, C); T >= 0 && P[T].children.length > this._maxEntries;) this._split(P, T), T--; this._adjustParentBBoxes(C, P, T) }, _split: function (y, T) { const S = y[T]; const E = S.children.length; const C = this._minEntries; this._chooseSplitAxis(S, C, E); const P = this._chooseSplitIndex(S, C, E); const A = g(S.children.splice(P, S.children.length - P)); A.height = S.height, A.leaf = S.leaf, o(S, this.toBBox), o(A, this.toBBox), T ? y[T - 1].children.push(A) : this._splitRoot(S, A) }, _splitRoot: function (y, T) { this.data = g([y, T]), this.data.height = y.height + 1, this.data.leaf = !1, o(this.data, this.toBBox) }, _chooseSplitIndex: function (y, T, S) { let E, C, P, A, M, L, F, I; for (L = F = 1 / 0, E = T; E <= S - T; E++)C = r(y, 0, E, this.toBBox), P = r(y, E, S, this.toBBox), A = p(C, P), M = l(C) + l(P), A < L ? (L = A, I = E, F = M < F ? M : F) : A === L && M < F && (F = M, I = E); return I }, _chooseSplitAxis: function (y, T, S) { const E = y.leaf ? this.compareMinX : a; const C = y.leaf ? this.compareMinY : f; const P = this._allDistMargin(y, T, S, E); const A = this._allDistMargin(y, T, S, C); P < A && y.children.sort(E) }, _allDistMargin: function (y, T, S, E) { y.children.sort(E); const C = this.toBBox; const P = r(y, 0, T, C); const A = r(y, S - T, S, C); let M = u(P) + u(A); let L; let F; for (L = T; L < S - T; L++)F = y.children[L], s(P, y.leaf ? C(F) : F), M += u(P); for (L = S - T - 1; L >= T; L--)F = y.children[L], s(A, y.leaf ? C(F) : F), M += u(A); return M }, _adjustParentBBoxes: function (y, T, S) { for (let E = S; E >= 0; E--)s(T[E], y) }, _condense: function (y) { for (var T = y.length - 1, S; T >= 0; T--)y[T].children.length === 0 ? T > 0 ? (S = y[T - 1].children, S.splice(S.indexOf(y[T]), 1)) : this.clear() : o(y[T], this.toBBox) }, compareMinX: function (y, T) { return y.left - T.left }, compareMinY: function (y, T) { return y.top - T.top }, toBBox: function (y) { return { minX: y.left, minY: y.top, maxX: y.right, maxY: y.bottom } } }; function n (y, T, S) { if (!S) return T.indexOf(y); for (let E = 0; E < T.length; E++) if (S(y, T[E])) return E; return -1 } function o (y, T) { r(y, 0, y.children.length, T, y) } function r (y, T, S, E, C) { C || (C = g(null)), C.minX = 1 / 0, C.minY = 1 / 0, C.maxX = -1 / 0, C.maxY = -1 / 0; for (var P = T, A; P < S; P++)A = y.children[P], s(C, y.leaf ? E(A) : A); return C } function s (y, T) { return y.minX = Math.min(y.minX, T.minX), y.minY = Math.min(y.minY, T.minY), y.maxX = Math.max(y.maxX, T.maxX), y.maxY = Math.max(y.maxY, T.maxY), y } function a (y, T) { return y.minX - T.minX } function f (y, T) { return y.minY - T.minY } function l (y) { return (y.maxX - y.minX) * (y.maxY - y.minY) } function u (y) { return y.maxX - y.minX + (y.maxY - y.minY) } function v (y, T) { return (Math.max(T.maxX, y.maxX) - Math.min(T.minX, y.minX)) * (Math.max(T.maxY, y.maxY) - Math.min(T.minY, y.minY)) } function p (y, T) { const S = Math.max(y.minX, T.minX); const E = Math.max(y.minY, T.minY); const C = Math.min(y.maxX, T.maxX); const P = Math.min(y.maxY, T.maxY); return Math.max(0, C - S) * Math.max(0, P - E) } function c (y, T) { return y.minX <= T.minX && y.minY <= T.minY && T.maxX <= y.maxX && T.maxY <= y.maxY } function m (y, T) { return T.minX <= y.maxX && T.minY <= y.maxY && T.maxX >= y.minX && T.maxY >= y.minY } function g (y) { return { children: y, height: 1, leaf: !0, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 } } function x (y, T, S, E, C) { for (var P = [T, S], A; P.length;)S = P.pop(), T = P.pop(), !(S - T <= E) && (A = T + Math.ceil((S - T) / E / 2) * E, i(y, A, T, S, C), P.push(T, A, A, S)) }e.exports = h }, function (e, d, t) { const i = t(533); const h = t(535); const n = t(248); const o = function (r, s, a, f, l, u, v) { const p = f.left; const c = f.top; const m = f.right; const g = f.bottom; let x = a.faceLeft || a.faceRight; let y = a.faceTop || a.faceBottom; if (v || (x = !0, y = !0), !x && !y) return !1; let T = 0; let S = 0; let E = 0; let C = 1; if (s.deltaAbsX() > s.deltaAbsY() ? E = -1 : s.deltaAbsX() < s.deltaAbsY() && (C = -1), s.deltaX() !== 0 && s.deltaY() !== 0 && x && y && (E = Math.min(Math.abs(s.position.x - m), Math.abs(s.right - p)), C = Math.min(Math.abs(s.position.y - g), Math.abs(s.bottom - c))), E < C) { if (x && (T = i(s, a, p, m, u, v), T !== 0 && !n(f, s))) return !0; y && (S = h(s, a, c, g, u, v)) } else { if (y && (S = h(s, a, c, g, u, v), S !== 0 && !n(f, s))) return !0; x && (T = i(s, a, p, m, u, v)) } return T !== 0 || S !== 0 }; e.exports = o }, function (e, d, t) { const i = t(534); const h = function (n, o, r, s, a, f) { let l = 0; let u = o.faceLeft; let v = o.faceRight; let p = o.collideLeft; let c = o.collideRight; return f || (u = !0, v = !0, p = !0, c = !0), n.deltaX() < 0 && c && n.checkCollision.left ? v && n.x < s && (l = n.x - s, l < -a && (l = 0)) : n.deltaX() > 0 && p && n.checkCollision.right && u && n.right > r && (l = n.right - r, l > a && (l = 0)), l !== 0 && (n.customSeparateX ? n.overlapX = l : i(n, l)), l }; e.exports = h }, function (e, d) { const t = function (i, h) { h < 0 ? (i.blocked.none = !1, i.blocked.left = !0) : h > 0 && (i.blocked.none = !1, i.blocked.right = !0), i.position.x -= h, i.bounce.x === 0 ? i.velocity.x = 0 : i.velocity.x = -i.velocity.x * i.bounce.x }; e.exports = t }, function (e, d, t) { const i = t(536); const h = function (n, o, r, s, a, f) { let l = 0; let u = o.faceTop; let v = o.faceBottom; let p = o.collideUp; let c = o.collideDown; return f || (u = !0, v = !0, p = !0, c = !0), n.deltaY() < 0 && c && n.checkCollision.up ? v && n.y < s && (l = n.y - s, l < -a && (l = 0)) : n.deltaY() > 0 && p && n.checkCollision.down && u && n.bottom > r && (l = n.bottom - r, l > a && (l = 0)), l !== 0 && (n.customSeparateY ? n.overlapY = l : i(n, l)), l }; e.exports = h }, function (e, d) { const t = function (i, h) { h < 0 ? (i.blocked.none = !1, i.blocked.up = !0) : h > 0 && (i.blocked.none = !1, i.blocked.down = !0), i.position.y -= h, i.bounce.y === 0 ? i.velocity.y = 0 : i.velocity.y = -i.velocity.y * i.bounce.y }; e.exports = t }, function (e, d, t) { const i = t(246); const h = t(1389); const n = function (o, r, s, a) { const f = i(o, r, s, a); const l = o.immovable; const u = r.immovable; if (s || f === 0 || l && u || o.customSeparateX || r.customSeparateX) return f !== 0 || o.embedded && r.embedded; const v = h.Set(o, r, f); return !l && !u ? v > 0 ? !0 : h.Check() : (l ? h.RunImmovableBody1(v) : u && h.RunImmovableBody2(v), !0) }; e.exports = n }, function (e, d, t) { const i = t(247); const h = t(1390); const n = function (o, r, s, a) { const f = i(o, r, s, a); const l = o.immovable; const u = r.immovable; if (s || f === 0 || l && u || o.customSeparateY || r.customSeparateY) return f !== 0 || o.embedded && r.embedded; const v = h.Set(o, r, f); return !l && !u ? v > 0 ? !0 : h.Check() : (l ? h.RunImmovableBody1(v) : u && h.RunImmovableBody2(v), !0) }; e.exports = n }, function (e, d, t) { const i = t(66); const h = t(0); const n = t(62); const o = t(57); const r = t(3); const s = new h({ initialize: function (f, l) { const u = l.displayWidth ? l.displayWidth : 64; const v = l.displayHeight ? l.displayHeight : 64; this.world = f, this.gameObject = l, this.debugShowBody = f.defaults.debugShowStaticBody, this.debugBodyColor = f.defaults.staticBodyDebugColor, this.enable = !0, this.isCircle = !1, this.radius = 0, this.offset = new r(), this.position = new r(l.x - u * l.originX, l.y - v * l.originY), this.width = u, this.height = v, this.halfWidth = Math.abs(this.width / 2), this.halfHeight = Math.abs(this.height / 2), this.center = new r(this.position.x + this.halfWidth, this.position.y + this.halfHeight), this.velocity = r.ZERO, this.allowGravity = !1, this.gravity = r.ZERO, this.bounce = r.ZERO, this.onWorldBounds = !1, this.onCollide = !1, this.onOverlap = !1, this.mass = 1, this.immovable = !0, this.pushable = !1, this.customSeparateX = !1, this.customSeparateY = !1, this.overlapX = 0, this.overlapY = 0, this.overlapR = 0, this.embedded = !1, this.collideWorldBounds = !1, this.checkCollision = { none: !1, up: !0, down: !0, left: !0, right: !0 }, this.touching = { none: !0, up: !1, down: !1, left: !1, right: !1 }, this.wasTouching = { none: !0, up: !1, down: !1, left: !1, right: !1 }, this.blocked = { none: !0, up: !1, down: !1, left: !1, right: !1 }, this.physicsType = n.STATIC_BODY, this._dx = 0, this._dy = 0 }, setGameObject: function (a, f) { return a && a !== this.gameObject && (this.gameObject.body = null, a.body = this, this.gameObject = a), f && this.updateFromGameObject(), this }, updateFromGameObject: function () { this.world.staticTree.remove(this); const a = this.gameObject; return a.getTopLeft(this.position), this.width = a.displayWidth, this.height = a.displayHeight, this.halfWidth = Math.abs(this.width / 2), this.halfHeight = Math.abs(this.height / 2), this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight), this.world.staticTree.insert(this), this }, setOffset: function (a, f) { return f === void 0 && (f = a), this.world.staticTree.remove(this), this.position.x -= this.offset.x, this.position.y -= this.offset.y, this.offset.set(a, f), this.position.x += this.offset.x, this.position.y += this.offset.y, this.updateCenter(), this.world.staticTree.insert(this), this }, setSize: function (a, f, l) { l === void 0 && (l = !0); const u = this.gameObject; if (!a && u.frame && (a = u.frame.realWidth), !f && u.frame && (f = u.frame.realHeight), this.world.staticTree.remove(this), this.width = a, this.height = f, this.halfWidth = Math.floor(a / 2), this.halfHeight = Math.floor(f / 2), l && u.getCenter) { const v = u.displayWidth / 2; const p = u.displayHeight / 2; this.position.x -= this.offset.x, this.position.y -= this.offset.y, this.offset.set(v - this.halfWidth, p - this.halfHeight), this.position.x += this.offset.x, this.position.y += this.offset.y } return this.updateCenter(), this.isCircle = !1, this.radius = 0, this.world.staticTree.insert(this), this }, setCircle: function (a, f, l) { return f === void 0 && (f = this.offset.x), l === void 0 && (l = this.offset.y), a > 0 ? (this.world.staticTree.remove(this), this.isCircle = !0, this.radius = a, this.width = a * 2, this.height = a * 2, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.offset.set(f, l), this.updateCenter(), this.world.staticTree.insert(this)) : this.isCircle = !1, this }, updateCenter: function () { this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight) }, reset: function (a, f) { const l = this.gameObject; a === void 0 && (a = l.x), f === void 0 && (f = l.y), this.world.staticTree.remove(this), l.setPosition(a, f), l.getTopLeft(this.position), this.updateCenter(), this.world.staticTree.insert(this) }, stop: function () { return this }, getBounds: function (a) { return a.x = this.x, a.y = this.y, a.right = this.right, a.bottom = this.bottom, a }, hitTest: function (a, f) { return this.isCircle ? i(this, a, f) : o(this, a, f) }, postUpdate: function () {}, deltaAbsX: function () { return 0 }, deltaAbsY: function () { return 0 }, deltaX: function () { return 0 }, deltaY: function () { return 0 }, deltaZ: function () { return 0 }, destroy: function () { this.enable = !1, this.world.pendingDestroy.set(this) }, drawDebug: function (a) { const f = this.position; const l = f.x + this.halfWidth; const u = f.y + this.halfHeight; this.debugShowBody && (a.lineStyle(a.defaultStrokeWidth, this.debugBodyColor, 1), this.isCircle ? a.strokeCircle(l, u, this.width / 2) : a.strokeRect(f.x, f.y, this.width, this.height)) }, willDrawDebug: function () { return this.debugShowBody }, setMass: function (a) { return a <= 0 && (a = 0.1), this.mass = a, this }, x: { get: function () { return this.position.x }, set: function (a) { this.world.staticTree.remove(this), this.position.x = a, this.world.staticTree.insert(this) } }, y: { get: function () { return this.position.y }, set: function (a) { this.world.staticTree.remove(this), this.position.y = a, this.world.staticTree.insert(this) } }, left: { get: function () { return this.position.x } }, right: { get: function () { return this.position.x + this.width } }, top: { get: function () { return this.position.y } }, bottom: { get: function () { return this.position.y + this.height } } }); e.exports = s }, function (e, d, t) { const i = t(0); const h = new i({ initialize: function (o) { this.pluginManager = o, this.game = o.game }, init: function () {}, start: function () {}, stop: function () {}, destroy: function () { this.pluginManager = null, this.game = null, this.scene = null, this.systems = null } }); e.exports = h }, function (e, d, t) { const i = t(3); const h = new i(); const n = function (o, r, s, a) { const f = s.tilemapLayer; const l = f.cullPaddingX; const u = f.cullPaddingY; const v = f.tilemap.tileToWorldXY(o, r, h, a, f); return v.x > a.worldView.x + f.scaleX * s.tileWidth * (-l - 0.5) && v.x < a.worldView.right + f.scaleX * s.tileWidth * (l - 0.5) && v.y > a.worldView.y + f.scaleY * s.tileHeight * (-u - 1) && v.y < a.worldView.bottom + f.scaleY * s.tileHeight * (u - 0.5) }; e.exports = n }, function (e, d, t) { const i = t(26); const h = function (n, o, r, s, a, f, l) { for (let u = i(r, s, a, f, null, l), v = 0; v < u.length; v++)u[v] && u[v].index === n && (u[v].index = o) }; e.exports = h }, function (e, d, t) { const i = t(10); const h = t(139); const n = t(76); const o = new i(); const r = function (s, a) { const f = s.tilemapLayer.tilemap; const l = s.tilemapLayer; const u = Math.floor(f.tileWidth * l.scaleX); const v = Math.floor(f.tileHeight * l.scaleY); const p = n(a.worldView.x - l.x, u, 0, !0) - l.cullPaddingX; const c = h(a.worldView.right - l.x, u, 0, !0) + l.cullPaddingX; const m = n(a.worldView.y - l.y, v, 0, !0) - l.cullPaddingY; const g = h(a.worldView.bottom - l.y, v, 0, !0) + l.cullPaddingY; return o.setTo(p, m, c - p, g - m) }; e.exports = r }, function (e, d, t) { const i = t(543); const h = t(159); const n = function (o, r, s, a) { s === void 0 && (s = []), a === void 0 && (a = 0), s.length = 0; const f = o.tilemapLayer; const l = i(o, r); return (f.skipCull || f.scrollFactorX !== 1 || f.scrollFactorY !== 1) && (l.left = 0, l.right = o.width, l.top = 0, l.bottom = o.height), h(o, l, a, s), s }; e.exports = n }, function (e, d, t) { const i = t(546); const h = t(159); const n = function (o, r, s, a) { s === void 0 && (s = []), a === void 0 && (a = 0), s.length = 0; const f = o.tilemapLayer; if (!f.skipCull && f.scrollFactorX === 1 && f.scrollFactorY === 1) { const l = i(o, r); h(o, l, a, s) } return s }; e.exports = n }, function (e, d, t) { const i = t(139); const h = t(76); const n = function (o, r) { const s = o.tilemapLayer.tilemap; const a = o.tilemapLayer; const f = Math.floor(s.tileWidth * a.scaleX); const l = Math.floor(s.tileHeight * a.scaleY); const u = o.hexSideLength; const v = (l - u) / 2 + u; const p = h(r.worldView.x - a.x, f, 0, !0) - a.cullPaddingX; const c = i(r.worldView.right - a.x, f, 0, !0) + a.cullPaddingX; const m = h(r.worldView.y - a.y, v, 0, !0) - a.cullPaddingY; const g = i(r.worldView.bottom - a.y, v, 0, !0) + a.cullPaddingY; return { left: p, right: c, top: m, bottom: g } }; e.exports = n }, function (e, d, t) { const i = t(541); const h = function (n, o, r, s) { r === void 0 && (r = []), s === void 0 && (s = 0), r.length = 0; const a = n.tilemapLayer; const f = n.data; const l = n.width; const u = n.height; const v = 0; const p = l; const c = 0; const m = u; if (!a.skipCull) { let g, x, y; if (s === 0) { for (x = c; x < m; x++) for (g = v; f[x] && g < p; g++) if (i(g, x, n, o)) { if (y = f[x][g], !y || y.index === -1 || !y.visible || y.alpha === 0) continue; r.push(y) } } else if (s === 1) { for (x = c; x < m; x++) for (g = p; f[x] && g >= v; g--) if (i(g, x, n, o)) { if (y = f[x][g], !y || y.index === -1 || !y.visible || y.alpha === 0) continue; r.push(y) } } else if (s === 2) { for (x = m; x >= c; x--) for (g = v; f[x] && g < p; g++) if (i(g, x, n, o)) { if (y = f[x][g], !y || y.index === -1 || !y.visible || y.alpha === 0) continue; r.push(y) } } else if (s === 3) { for (x = m; x >= c; x--) for (g = p; f[x] && g >= v; g--) if (i(g, x, n, o)) { if (y = f[x][g], !y || y.index === -1 || !y.visible || y.alpha === 0) continue; r.push(y) } } } return a.tilesDrawn = r.length, a.tilesTotal = l * u, r }; e.exports = h }, function (e, d, t) { const i = t(549); const h = t(159); const n = function (o, r, s, a) { s === void 0 && (s = []), a === void 0 && (a = 0), s.length = 0; const f = o.tilemapLayer; if (!f.skipCull && f.scrollFactorX === 1 && f.scrollFactorY === 1) { const l = i(o, r); h(o, l, a, s) } return s }; e.exports = n }, function (e, d, t) { const i = t(139); const h = t(76); const n = function (o, r) { const s = o.tilemapLayer.tilemap; const a = o.tilemapLayer; const f = Math.floor(s.tileWidth * a.scaleX); const l = Math.floor(s.tileHeight * a.scaleY); const u = h(r.worldView.x - a.x, f, 0, !0) - a.cullPaddingX; const v = i(r.worldView.right - a.x, f, 0, !0) + a.cullPaddingX; const p = h(r.worldView.y - a.y, l / 2, 0, !0) - a.cullPaddingY; const c = i(r.worldView.bottom - a.y, l / 2, 0, !0) + a.cullPaddingY; return { left: u, right: v, top: p, bottom: c } }; e.exports = n }, function (e, d, t) { const i = t(3); const h = function (n, o, r, s, a) { r || (r = new i()); let f = a.baseTileWidth; let l = a.baseTileHeight; const u = a.tilemapLayer; let v = 0; let p = 0; u && (s || (s = u.scene.cameras.main), v = u.x + s.scrollX * (1 - u.scrollFactorX), f *= u.scaleX, p = u.y + s.scrollY * (1 - u.scrollFactorY), l *= u.scaleY); const c = a.hexSideLength; const m = (l - c) / 2 + c; const g = v + n * f + o % 2 * (f / 2); const x = p + o * m; return r.set(g, x) }; e.exports = h }, function (e, d, t) { const i = t(3); const h = function (n, o, r, s, a) { r || (r = new i()); let f = a.baseTileWidth; let l = a.baseTileHeight; const u = a.tilemapLayer; let v = 0; let p = 0; u && (s || (s = u.scene.cameras.main), v = u.x + s.scrollX * (1 - u.scrollFactorX), f *= u.scaleX, p = u.y + s.scrollY * (1 - u.scrollFactorY), l *= u.scaleY); const c = v + (n - o) * (f / 2); const m = p + (n + o) * (l / 2); return r.set(c, m) }; e.exports = h }, function (e, d, t) { const i = t(3); const h = function (n, o, r, s, a) { r || (r = new i()); let f = a.baseTileWidth; let l = a.baseTileHeight; const u = a.tilemapLayer; let v = 0; let p = 0; u && (s || (s = u.scene.cameras.main), v = u.x + s.scrollX * (1 - u.scrollFactorX), f *= u.scaleX, p = u.y + s.scrollY * (1 - u.scrollFactorY), l *= u.scaleY); const c = v + n * f + o % 2 * (f / 2); const m = p + o * (l / 2); return r.set(c, m) }; e.exports = h }, function (e, d, t) { const i = t(253); const h = t(254); const n = t(3); const o = function (r, s, a, f, l) { return a || (a = new n(0, 0)), a.x = i(r, f, l), a.y = h(s, f, l), a }; e.exports = o }, function (e, d) { const t = function (i, h, n) { let o = n.baseTileHeight; const r = n.tilemapLayer; let s = 0; r && (h === void 0 && (h = r.scene.cameras.main), s = r.y + h.scrollY * (1 - r.scrollFactorY), o *= r.scaleY); const a = r.tilemap.hexSideLength; const f = (o - a) / 2 + a; return s + i * f }; e.exports = t }, function (e, d) { const t = function (i, h, n) { let o = n.baseTileHeight; const r = n.tilemapLayer; let s = 0; return r && (h === void 0 && (h = r.scene.cameras.main), s = r.y + h.scrollY * (1 - r.scrollFactorY), o *= r.scaleY), s + i * (o / 2) }; e.exports = t }, function (e, d, t) { const i = t(3); const h = function (n, o, r, s, a, f) { s || (s = new i()); let l = f.baseTileWidth; let u = f.baseTileHeight; const v = f.tilemapLayer; v && (a || (a = v.scene.cameras.main), o = o - (v.y + a.scrollY * (1 - v.scrollFactorY)), u *= v.scaleY, n = n - (v.x + a.scrollX * (1 - v.scrollFactorX)), l *= v.scaleX); const p = f.hexSideLength; const c = (u - p) / 2 + p; const m = r ? Math.floor(o / c) : o / c; const g = r ? Math.floor((n - m % 2 * 0.5 * l) / l) : (n - m % 2 * 0.5 * l) / l; return s.set(g, m) }; e.exports = h }, function (e, d, t) { const i = t(3); const h = function (n, o, r, s, a, f) { s || (s = new i()); let l = f.baseTileWidth; let u = f.baseTileHeight; const v = f.tilemapLayer; v && (a || (a = v.scene.cameras.main), o = o - (v.y + a.scrollY * (1 - v.scrollFactorY)), u *= v.scaleY, n = n - (v.x + a.scrollX * (1 - v.scrollFactorX)), l *= v.scaleX); const p = r ? Math.floor((n / (l / 2) + o / (u / 2)) / 2) : (n / (l / 2) + o / (u / 2)) / 2; const c = r ? Math.floor((o / (u / 2) - n / (l / 2)) / 2) : (o / (u / 2) - n / (l / 2)) / 2; return s.set(p, c) }; e.exports = h }, function (e, d, t) { const i = t(3); const h = function (n, o, r, s, a, f) { s || (s = new i()); let l = f.baseTileWidth; let u = f.baseTileHeight; const v = f.tilemapLayer; v && (a || (a = v.scene.cameras.main), o = o - (v.y + a.scrollY * (1 - v.scrollFactorY)), u *= v.scaleY, n = n - (v.x + a.scrollX * (1 - v.scrollFactorX)), l *= v.scaleX); const p = r ? Math.floor(o / (u / 2)) : o / (u / 2); const c = r ? Math.floor((n + p % 2 * 0.5 * l) / l) : (n + p % 2 * 0.5 * l) / l; return s.set(c, p) }; e.exports = h }, function (e, d, t) { const i = t(255); const h = t(256); const n = t(3); const o = function (r, s, a, f, l, u) { return a === void 0 && (a = !0), f || (f = new n(0, 0)), f.x = i(r, a, l, u), f.y = h(s, a, l, u), f }; e.exports = o }, function (e, d) { const t = function (i, h, n, o) { let r = o.baseTileHeight; const s = o.tilemapLayer; s && (n || (n = s.scene.cameras.main), i = i - (s.y + n.scrollY * (1 - s.scrollFactorY)), r *= s.scaleY); const a = o.hexSideLength; const f = (r - a) / 2 + a; return h ? Math.floor(i / f) : i / f }; e.exports = t }, function (e, d) { const t = function (i, h, n, o) { let r = o.baseTileHeight; const s = o.tilemapLayer; return s && (n || (n = s.scene.cameras.main), i = i - (s.y + n.scrollY * (1 - s.scrollFactorY)), r *= s.scaleY), h ? Math.floor(i / (r / 2)) : i / (r / 2) }; e.exports = t }, function (e, d, t) { const i = t(119); const h = function (n, o, r) { if (i(n, o, r)) { const s = r.data[o][n]; return s !== null && s.index > -1 } else return !1 }; e.exports = h }, function (e, d, t) { const i = t(85); const h = t(119); const n = t(252); const o = function (r, s, a, f, l) { if (a === void 0 && (a = !0), f === void 0 && (f = !0), !h(r, s, l)) return null; const u = l.data[s][r]; if (u)l.data[s][r] = a ? null : new i(l, -1, r, s, l.tileWidth, l.tileHeight); else return null; return f && u && u.collides && n(r, s, l), u }; e.exports = o }, function (e, d, t) { const i = t(40); const h = t(259); const n = t(565); const o = t(566); const r = t(577); const s = function (a, f, l, u, v, p) { let c; switch (f) { case i.ARRAY_2D:c = h(a, l, u, v, p); break; case i.CSV:c = n(a, l, u, v, p); break; case i.TILED_JSON:c = o(a, l, p); break; case i.WELTMEISTER:c = r(a, l, p); break; default:console.warn('Unrecognized tilemap data format: ' + f), c = null } return c }; e.exports = s }, function (e, d, t) {
        const i = t(40); const h = t(259); const n = function (o, r, s, a, f) {
          const l = r.trim().split(`
`).map(function (v) { return v.split(',') }); const u = h(o, l, s, a, f); return u.format = i.CSV, u
        }; e.exports = n
      }, function (e, d, t) { const i = t(567); const h = t(568); const n = t(29); const o = t(40); const r = t(258); const s = t(121); const a = t(569); const f = t(570); const l = t(573); const u = t(575); const v = function (p, c, m) { const g = new s({ width: c.width, height: c.height, name: p, tileWidth: c.tilewidth, tileHeight: c.tileheight, orientation: r(c.orientation), format: o.TILED_JSON, version: c.version, properties: c.properties, renderOrder: c.renderorder, infinite: c.infinite }); g.orientation === n.HEXAGONAL && (g.hexSideLength = c.hexsidelength), g.layers = l(c, m), g.images = a(c); const x = u(c); return g.tilesets = x.tilesets, g.imageCollections = x.imageCollections, g.objects = f(c), g.tiles = h(g), i(g), g }; e.exports = v }, function (e, d, t) { const i = t(17); const h = function (n) { for (var o, r, s, a, f, l = 0; l < n.layers.length; l++) { o = n.layers[l], a = null; for (let u = 0; u < o.data.length; u++) { f = o.data[u]; for (let v = 0; v < f.length; v++)r = f[v], !(r === null || r.index < 0) && (s = n.tiles[r.index][2], a = n.tilesets[s], r.width = a.tileWidth, r.height = a.tileHeight, a.tileProperties && a.tileProperties[r.index - a.firstgid] && (r.properties = i(r.properties, a.tileProperties[r.index - a.firstgid]))) } } }; e.exports = h }, function (e, d, t) { const i = t(122); const h = function (n) { let o; let r; const s = []; for (o = 0; o < n.imageCollections.length; o++) for (let a = n.imageCollections[o], f = a.images, l = 0; l < f.length; l++) { const u = f[l]; r = new i(u.image, u.gid, a.imageWidth, a.imageHeight, 0, 0), r.updateTileData(a.imageWidth, a.imageHeight), n.tilesets.push(r) } for (o = 0; o < n.tilesets.length; o++) { r = n.tilesets[o]; for (let v = r.tileMargin, p = r.tileMargin, c = 0, m = 0, g = 0, x = r.firstgid; x < r.firstgid + r.total && (s[x] = [v, p, o], v += r.tileWidth + r.tileSpacing, c++, !(c === r.total || (m++, m === r.columns && (v = r.tileMargin, p += r.tileHeight + r.tileSpacing, m = 0, g++, g === r.rows)))); x++); } return s }; e.exports = h }, function (e, d, t) { const i = t(2); const h = t(161); const n = function (o) { for (var r = [], s = [], a = h(o); a.i < a.layers.length || s.length > 0;) { if (a.i >= a.layers.length) { if (s.length < 1) { console.warn('TilemapParser.parseTiledJSON - Invalid layer group hierarchy'); break }a = s.pop(); continue } const f = a.layers[a.i]; if (a.i++, f.type !== 'imagelayer') { if (f.type === 'group') { const l = h(o, f, a); s.push(a), a = l } continue } const u = i(f, 'offsetx', 0) + i(f, 'startx', 0); const v = i(f, 'offsety', 0) + i(f, 'starty', 0); r.push({ name: a.name + f.name, image: f.image, x: a.x + u + f.x, y: a.y + v + f.y, alpha: a.opacity * f.opacity, visible: a.visible && f.visible, properties: i(f, 'properties', {}) }) } return r }; e.exports = n }, function (e, d, t) { const i = t(2); const h = t(260); const n = t(572); const o = t(161); const r = function (s) { for (var a = [], f = [], l = o(s); l.i < l.layers.length || f.length > 0;) { if (l.i >= l.layers.length) { if (f.length < 1) { console.warn('TilemapParser.parseTiledJSON - Invalid layer group hierarchy'); break }l = f.pop(); continue } const u = l.layers[l.i]; if (l.i++, u.opacity *= l.opacity, u.visible = l.visible && u.visible, u.type !== 'objectgroup') { if (u.type === 'group') { const v = o(s, u, l); f.push(l), l = v } continue }u.name = l.name + u.name; for (var p = l.x + i(u, 'startx', 0) + i(u, 'offsetx', 0), c = l.y + i(u, 'starty', 0) + i(u, 'offsety', 0), m = [], g = 0; g < u.objects.length; g++) { const x = h(u.objects[g], p, c); m.push(x) } const y = new n(u); y.objects = m, a.push(y) } return a }; e.exports = r }, function (e, d, t) { const i = t(126); const h = function (n, o) { for (var r = {}, s = 0; s < o.length; s++) { const a = o[s]; i(n, a) && (r[a] = n[a]) } return r }; e.exports = h }, function (e, d, t) { const i = t(0); const h = t(2); const n = new i({ initialize: function (r) { r === void 0 && (r = {}), this.name = h(r, 'name', 'object layer'), this.opacity = h(r, 'opacity', 1), this.properties = h(r, 'properties', {}), this.propertyTypes = h(r, 'propertytypes', {}), this.type = h(r, 'type', 'objectgroup'), this.visible = h(r, 'visible', !0), this.objects = h(r, 'objects', []) } }); e.exports = n }, function (e, d, t) { const i = t(574); const h = t(29); const n = t(161); const o = t(258); const r = t(2); const s = t(120); const a = t(261); const f = t(85); const l = function (u, v) { for (var p = r(u, 'infinite', !1), c = [], m = [], g = n(u); g.i < g.layers.length || m.length > 0;) { if (g.i >= g.layers.length) { if (m.length < 1) { console.warn('TilemapParser.parseTiledJSON - Invalid layer group hierarchy'); break }g = m.pop(); continue } const x = g.layers[g.i]; if (g.i++, x.type !== 'tilelayer') { if (x.type === 'group') { const y = n(u, x, g); m.push(g), g = y } continue } if (x.compression) { console.warn("TilemapParser.parseTiledJSON - Layer compression is unsupported, skipping layer '" + x.name + "'"); continue } else if (x.encoding && x.encoding === 'base64') { if (x.chunks) for (let T = 0; T < x.chunks.length; T++)x.chunks[T].data = i(x.chunks[T].data); x.data && (x.data = i(x.data)), delete x.encoding } var S; var E; var C; var P; const A = []; let M = 0; if (p) { const L = r(x, 'startx', 0) + x.x; const F = r(x, 'starty', 0) + x.y; S = new s({ name: g.name + x.name, x: g.x + r(x, 'offsetx', 0) + L * u.tilewidth, y: g.y + r(x, 'offsety', 0) + F * u.tileheight, width: x.width, height: x.height, tileWidth: u.tilewidth, tileHeight: u.tileheight, alpha: g.opacity * x.opacity, visible: g.visible && x.visible, properties: r(x, 'properties', []), orientation: o(u.orientation) }), S.orientation === h.HEXAGONAL && (S.hexSideLength = u.hexsidelength); for (var I = 0; I < x.height; I++) { A.push([null]); for (let G = 0; G < x.width; G++)A[I][G] = null } for (I = 0, V = x.chunks.length; I < V; I++) for (let U = x.chunks[I], Y = U.x - L, X = U.y - F, O = 0, R = 0, D = U.data.length; R < D; R++) { const B = M + Y; const N = O + X; E = a(U.data[R]), E.gid > 0 ? (C = new f(S, E.gid, B, N, u.tilewidth, u.tileheight), C.rotation = E.rotation, C.flipX = E.flipped, A[N][B] = C) : (P = v ? null : new f(S, -1, B, N, u.tilewidth, u.tileheight), A[N][B] = P), M++, M === U.width && (O++, M = 0) } } else { S = new s({ name: g.name + x.name, x: g.x + r(x, 'offsetx', 0) + x.x, y: g.y + r(x, 'offsety', 0) + x.y, width: x.width, height: x.height, tileWidth: u.tilewidth, tileHeight: u.tileheight, alpha: g.opacity * x.opacity, visible: g.visible && x.visible, properties: r(x, 'properties', []), orientation: o(u.orientation) }), S.orientation === h.HEXAGONAL && (S.hexSideLength = u.hexsidelength); for (var w = [], z = 0, V = x.data.length; z < V; z++)E = a(x.data[z]), E.gid > 0 ? (C = new f(S, E.gid, M, A.length, u.tilewidth, u.tileheight), C.rotation = E.rotation, C.flipX = E.flipped, w.push(C)) : (P = v ? null : new f(S, -1, M, A.length, u.tilewidth, u.tileheight), w.push(P)), M++, M === x.width && (A.push(w), M = 0, w = []) }S.data = A, c.push(S) } return c }; e.exports = l }, function (e, d) { const t = function (i) { for (var h = window.atob(i), n = h.length, o = new Array(n / 4), r = 0; r < n; r += 4)o[r / 4] = (h.charCodeAt(r) | h.charCodeAt(r + 1) << 8 | h.charCodeAt(r + 2) << 16 | h.charCodeAt(r + 3) << 24) >>> 0; return o }; e.exports = t }, function (e, d, t) { const i = t(122); const h = t(576); const n = t(260); const o = t(1453); const r = function (s) { for (var a = [], f = [], l = null, u, v = 0; v < s.tilesets.length; v++) { const p = s.tilesets[v]; if (p.source)console.warn('External tilesets unsupported. Use Embed Tileset and re-export'); else if (p.image) { const c = new i(p.name, p.firstgid, p.tilewidth, p.tileheight, p.margin, p.spacing); if (s.version > 1) { let m = void 0; let g = void 0; if (Array.isArray(p.tiles)) { m = m || {}, g = g || {}; for (var x = 0; x < p.tiles.length; x++) { var y = p.tiles[x]; if (y.properties) { var T = {}; y.properties.forEach(function (I) { T[I.name] = I.value }), g[y.id] = T } if (y.objectgroup && ((m[y.id] || (m[y.id] = {})).objectgroup = y.objectgroup, y.objectgroup.objects)) { const S = y.objectgroup.objects.map(function (I) { return n(I) }); m[y.id].objectgroup.objects = S }y.animation && ((m[y.id] || (m[y.id] = {})).animation = y.animation), y.type && ((m[y.id] || (m[y.id] = {})).type = y.type) } }Array.isArray(p.wangsets) && (m = m || {}, g = g || {}, o(p.wangsets, m)), m && (c.tileData = m, c.tileProperties = g) } else if (p.tileproperties && (c.tileProperties = p.tileproperties), p.tiles) { c.tileData = p.tiles; for (u in c.tileData) { const E = c.tileData[u].objectgroup; if (E && E.objects) { const C = E.objects.map(function (I) { return n(I) }); c.tileData[u].objectgroup.objects = C } } }c.updateTileData(p.imagewidth, p.imageheight), a.push(c) } else { const P = new h(p.name, p.firstgid, p.tilewidth, p.tileheight, p.margin, p.spacing, p.properties); let A = 0; for (x = 0; x < p.tiles.length; x++) { y = p.tiles[x]; const M = y.image; const L = parseInt(y.id, 10); const F = p.firstgid + L; P.addImage(F, M), A = Math.max(L, A) }P.maxId = A, f.push(P) }l && (l.lastgid = p.firstgid - 1), l = p } return { tilesets: a, imageCollections: f } }; e.exports = r }, function (e, d, t) { const i = t(0); const h = new i({ initialize: function (o, r, s, a, f, l, u) { (s === void 0 || s <= 0) && (s = 32), (a === void 0 || a <= 0) && (a = 32), f === void 0 && (f = 0), l === void 0 && (l = 0), this.name = o, this.firstgid = r | 0, this.imageWidth = s | 0, this.imageHeight = a | 0, this.imageMargin = f | 0, this.imageSpacing = l | 0, this.properties = u || {}, this.images = [], this.total = 0 }, containsImageIndex: function (n) { return n >= this.firstgid && n < this.firstgid + this.total }, addImage: function (n, o) { return this.images.push({ gid: n, image: o }), this.total++, this } }); e.exports = h }, function (e, d, t) { const i = t(40); const h = t(121); const n = t(578); const o = t(579); const r = function (s, a, f) { if (a.layer.length === 0) return console.warn('No layers found in the Weltmeister map: ' + s), null; for (var l = 0, u = 0, v = 0; v < a.layer.length; v++)a.layer[v].width > l && (l = a.layer[v].width), a.layer[v].height > u && (u = a.layer[v].height); const p = new h({ width: l, height: u, name: s, tileWidth: a.layer[0].tilesize, tileHeight: a.layer[0].tilesize, format: i.WELTMEISTER }); return p.layers = n(a, f), p.tilesets = o(a), p }; e.exports = r }, function (e, d, t) { const i = t(120); const h = t(85); const n = function (o, r) { for (var s = [], a = 0; a < o.layer.length; a++) { for (var f = o.layer[a], l = new i({ name: f.name, width: f.width, height: f.height, tileWidth: f.tilesize, tileHeight: f.tilesize, visible: f.visible === 1 }), u = [], v = [], p = 0; p < f.data.length; p++) { for (let c = 0; c < f.data[p].length; c++) { const m = f.data[p][c] - 1; var g; m > -1 ? g = new h(l, m, c, p, f.tilesize, f.tilesize) : g = r ? null : new h(l, -1, c, p, f.tilesize, f.tilesize), u.push(g) }v.push(u), u = [] }l.data = v, s.push(l) } return s }; e.exports = n }, function (e, d, t) { const i = t(122); const h = function (n) { for (var o = [], r = [], s = 0; s < n.layer.length; s++) { const a = n.layer[s]; const f = a.tilesetName; f !== '' && r.indexOf(f) === -1 && (r.push(f), o.push(new i(f, 0, a.tilesize, a.tilesize, 0, 0))) } return o }; e.exports = h }, function (e, d, t) {
        const i = t(0); const h = t(36); const n = t(40); const o = t(2); const r = t(120); const s = t(29); const a = t(362); const f = t(74); const l = t(73); const u = t(85); const v = t(251); const p = t(581); const c = t(122); const m = new i({
          initialize: function (x, y) { this.scene = x, this.tileWidth = y.tileWidth, this.tileHeight = y.tileHeight, this.width = y.width, this.height = y.height, this.orientation = y.orientation, this.renderOrder = y.renderOrder, this.format = y.format, this.version = y.version, this.properties = y.properties, this.widthInPixels = y.widthInPixels, this.heightInPixels = y.heightInPixels, this.imageCollections = y.imageCollections, this.images = y.images, this.layers = y.layers, this.tilesets = y.tilesets, this.objects = y.objects, this.currentLayerIndex = 0, this.hexSideLength = y.hexSideLength; const T = this.orientation; this._convert = { WorldToTileXY: v.GetWorldToTileXYFunction(T), WorldToTileX: v.GetWorldToTileXFunction(T), WorldToTileY: v.GetWorldToTileYFunction(T), TileToWorldXY: v.GetTileToWorldXYFunction(T), TileToWorldX: v.GetTileToWorldXFunction(T), TileToWorldY: v.GetTileToWorldYFunction(T) } },
          createBlankDynamicLayer: function (g, x, y, T, S, E, C, P) { return console.warn('createBlankDynamicLayer is deprecated. Use createBlankLayer'), this.createBlankLayer(g, x, y, T, S, E, C, P) },
          createDynamicLayer: function (g, x, y, T) { return console.warn('createDynamicLayer is deprecated. Use createLayer'), this.createLayer(g, x, y, T) },
          createStaticLayer: function (g, x, y, T) { return console.warn('createStaticLayer is deprecated. Use createLayer'), this.createLayer(g, x, y, T) },
          setRenderOrder: function (g) { const x = ['right-down', 'left-down', 'right-up', 'left-up']; return typeof g === 'number' && (g = x[g]), x.indexOf(g) > -1 && (this.renderOrder = g), this },
          addTilesetImage: function (g, x, y, T, S, E, C) { if (g === void 0) return null; if (x == null && (x = g), !this.scene.sys.textures.exists(x)) return console.warn('Invalid Tileset Image: ' + x), null; const P = this.scene.sys.textures.get(x); const A = this.getTilesetIndex(g); if (A === null && this.format === n.TILED_JSON) return console.warn('No data found for Tileset: ' + g), null; let M = this.tilesets[A]; return M ? (M.setTileSize(y, T), M.setSpacing(S, E), M.setImage(P), M) : (y === void 0 && (y = this.tileWidth), T === void 0 && (T = this.tileHeight), S === void 0 && (S = 0), E === void 0 && (E = 0), C === void 0 && (C = 0), M = new c(g, C, y, T, S, E), M.setImage(P), this.tilesets.push(M), M) },
          copy: function (g, x, y, T, S, E, C, P) { return P = this.getLayer(P), P !== null ? (v.Copy(g, x, y, T, S, E, C, P), this) : null },
          createBlankLayer: function (g, x, y, T, S, E, C, P) { y === void 0 && (y = 0), T === void 0 && (T = 0), S === void 0 && (S = this.width), E === void 0 && (E = this.height), C === void 0 && (C = this.tileWidth), P === void 0 && (P = this.tileHeight); const A = this.getLayerIndex(g); if (A !== null) return console.warn('Invalid Tilemap Layer ID: ' + g), null; for (var M = new r({ name: g, tileWidth: C, tileHeight: P, width: S, height: E, orientation: this.orientation }), L, F = 0; F < E; F++) { L = []; for (let I = 0; I < S; I++)L.push(new u(M, -1, I, F, C, P, this.tileWidth, this.tileHeight)); M.data.push(L) } this.layers.push(M), this.currentLayerIndex = this.layers.length - 1; const G = new p(this.scene, this, this.currentLayerIndex, x, y, T); return G.setRenderOrder(this.renderOrder), this.scene.sys.displayList.add(G), G },
          createLayer: function (g, x, y, T) {
            const S = this.getLayerIndex(g); if (S === null) {
              return console.warn('Invalid Tilemap Layer ID: ' + g), typeof g === 'string' && console.warn(`Valid tilelayer names:
	` + this.getTileLayerNames().join(`,
	`)), null
            } const E = this.layers[S]; if (E.tilemapLayer) return console.warn('Tilemap Layer ID already exists:' + g), null; this.currentLayerIndex = S, y === void 0 && (y = E.x), T === void 0 && (T = E.y); const C = new p(this.scene, this, S, x, y, T); return C.setRenderOrder(this.renderOrder), this.scene.sys.displayList.add(C), C
          },
          createFromObjects: function (g, x) { const y = []; const T = this.getObjectLayer(g); if (!T) return console.warn('createFromObjects: Invalid objectLayerName given: ' + g), y; Array.isArray(x) || (x = [x]); for (let S = T.objects, E = 0; E < x.length; E++) { for (var C = x[E], P = o(C, 'id', null), A = o(C, 'gid', null), M = o(C, 'name', null), L, F = [], I = 0; I < S.length; I++)L = S[I], (P === null && A === null && M === null || P !== null && L.id === P || A !== null && L.gid === A || M !== null && L.name === M) && F.push(L); for (let G = o(C, 'classType', l), U = o(C, 'scene', this.scene), Y = o(C, 'container', null), X = o(C, 'key', null), O = o(C, 'frame', null), R = 0; R < F.length; R++) { L = F[R]; var D = new G(U); D.setName(L.name), D.setPosition(L.x, L.y), D.setTexture(X, O), L.width && (D.displayWidth = L.width), L.height && (D.displayHeight = L.height); const B = { x: D.originX * L.width, y: (D.originY - 1) * L.height }; if (L.rotation) { const N = h(L.rotation); a(B, N), D.rotation = N } if (D.x += B.x, D.y += B.y, (L.flippedHorizontal !== void 0 || L.flippedVertical !== void 0) && D.setFlip(L.flippedHorizontal, L.flippedVertical), L.visible || (D.visible = !1), Array.isArray(L.properties))L.properties.forEach(function (z) { const V = z.name; D[V] !== void 0 ? D[V] = z.value : D.setData(V, z.value) }); else for (const w in L.properties)D[w] !== void 0 ? D[w] = L.properties[w] : D.setData(w, L.properties[w]); Y ? Y.add(D) : U.add.existing(D), y.push(D) } } return y },
          createFromTiles: function (g, x, y, T, S, E) { return E = this.getLayer(E), E === null ? null : v.CreateFromTiles(g, x, y, T, S, E) },
          fill: function (g, x, y, T, S, E, C) { return E === void 0 && (E = !0), C = this.getLayer(C), C === null ? null : (v.Fill(g, x, y, T, S, E, C), this) },
          filterObjects: function (g, x, y) { if (typeof g === 'string') { const T = g; if (g = this.getObjectLayer(g), !g) return console.warn('No object layer found with the name: ' + T), null } return g.objects.filter(x, y) },
          filterTiles: function (g, x, y, T, S, E, C, P) { return P = this.getLayer(P), P === null ? null : v.FilterTiles(g, x, y, T, S, E, C, P) },
          findByIndex: function (g, x, y, T) { return T = this.getLayer(T), T === null ? null : v.FindByIndex(g, x, y, T) },
          findObject: function (g, x, y) { if (typeof g === 'string') { const T = g; if (g = this.getObjectLayer(g), !g) return console.warn('No object layer found with the name: ' + T), null } return g.objects.find(x, y) || null },
          findTile: function (g, x, y, T, S, E, C, P) { return P = this.getLayer(P), P === null ? null : v.FindTile(g, x, y, T, S, E, C, P) },
          forEachTile: function (g, x, y, T, S, E, C, P) { return P = this.getLayer(P), P === null ? null : (v.ForEachTile(g, x, y, T, S, E, C, P), this) },
          getImageIndex: function (g) { return this.getIndex(this.images, g) },
          getImageLayerNames: function () { return !this.images || !Array.isArray(this.images) ? [] : this.images.map(function (g) { return g.name }) },
          getIndex: function (g, x) { for (let y = 0; y < g.length; y++) if (g[y].name === x) return y; return null },
          getLayer: function (g) { const x = this.getLayerIndex(g); return x !== null ? this.layers[x] : null },
          getObjectLayer: function (g) { const x = this.getIndex(this.objects, g); return x !== null ? this.objects[x] : null },
          getObjectLayerNames: function () { return !this.objects || !Array.isArray(this.objects) ? [] : this.objects.map(function (g) { return g.name }) },
          getLayerIndex: function (g) { return g === void 0 ? this.currentLayerIndex : typeof g === 'string' ? this.getLayerIndexByName(g) : typeof g === 'number' && g < this.layers.length ? g : g instanceof p ? g.layerIndex : null },
          getLayerIndexByName: function (g) { return this.getIndex(this.layers, g) },
          getTileAt: function (g, x, y, T) { return T = this.getLayer(T), T === null ? null : v.GetTileAt(g, x, y, T) },
          getTileAtWorldXY: function (g, x, y, T, S) { return S = this.getLayer(S), S === null ? null : v.GetTileAtWorldXY(g, x, y, T, S) },
          getTileLayerNames: function () { return !this.layers || !Array.isArray(this.layers) ? [] : this.layers.map(function (g) { return g.name }) },
          getTilesWithin: function (g, x, y, T, S, E) { return E = this.getLayer(E), E === null ? null : v.GetTilesWithin(g, x, y, T, S, E) },
          getTilesWithinShape: function (g, x, y, T) { return T = this.getLayer(T), T === null ? null : v.GetTilesWithinShape(g, x, y, T) },
          getTilesWithinWorldXY: function (g, x, y, T, S, E, C) { return C = this.getLayer(C), C === null ? null : v.GetTilesWithinWorldXY(g, x, y, T, S, E, C) },
          getTileset: function (g) { const x = this.getIndex(this.tilesets, g); return x !== null ? this.tilesets[x] : null },
          getTilesetIndex: function (g) { return this.getIndex(this.tilesets, g) },
          hasTileAt: function (g, x, y) { return y = this.getLayer(y), y === null ? null : v.HasTileAt(g, x, y) },
          hasTileAtWorldXY: function (g, x, y, T) { return T = this.getLayer(T), T === null ? null : v.HasTileAtWorldXY(g, x, y, T) },
          layer: { get: function () { return this.layers[this.currentLayerIndex] }, set: function (g) { this.setLayer(g) } },
          putTileAt: function (g, x, y, T, S) { return T === void 0 && (T = !0), S = this.getLayer(S), S === null ? null : v.PutTileAt(g, x, y, T, S) },
          putTileAtWorldXY: function (g, x, y, T, S, E) { return T === void 0 && (T = !0), E = this.getLayer(E), E === null ? null : v.PutTileAtWorldXY(g, x, y, T, S, E) },
          putTilesAt: function (g, x, y, T, S) { return T === void 0 && (T = !0), S = this.getLayer(S), S === null ? null : (v.PutTilesAt(g, x, y, T, S), this) },
          randomize: function (g, x, y, T, S, E) { return E = this.getLayer(E), E === null ? null : (v.Randomize(g, x, y, T, S, E), this) },
          calculateFacesAt: function (g, x, y) { return y = this.getLayer(y), y === null ? null : (v.CalculateFacesAt(g, x, y), this) },
          calculateFacesWithin: function (g, x, y, T, S) { return S = this.getLayer(S), S === null ? null : (v.CalculateFacesWithin(g, x, y, T, S), this) },
          removeLayer: function (g) { const x = this.getLayerIndex(g); if (x !== null) { f(this.layers, x); for (let y = x; y < this.layers.length; y++) this.layers[y].tilemapLayer && this.layers[y].tilemapLayer.layerIndex--; return this.currentLayerIndex === x && (this.currentLayerIndex = 0), this } else return null },
          destroyLayer: function (g) { const x = this.getLayerIndex(g); return x !== null ? (g = this.layers[x], g.destroy(), f(this.layers, x), this.currentLayerIndex === x && (this.currentLayerIndex = 0), this) : null },
          removeAllLayers: function () { for (var g = this.layers, x = 0; x < g.length; x++)g[x].tilemapLayer && g[x].tilemapLayer.destroy(!1); return g.length = 0, this.currentLayerIndex = 0, this },
          removeTile: function (g, x, y) { x === void 0 && (x = -1), y === void 0 && (y = !0); const T = []; Array.isArray(g) || (g = [g]); for (let S = 0; S < g.length; S++) { const E = g[S]; T.push(this.removeTileAt(E.x, E.y, !0, y, E.tilemapLayer)), x > -1 && this.putTileAt(x, E.x, E.y, y, E.tilemapLayer) } return T },
          removeTileAt: function (g, x, y, T, S) { return y === void 0 && (y = !0), T === void 0 && (T = !0), S = this.getLayer(S), S === null ? null : v.RemoveTileAt(g, x, y, T, S) },
          removeTileAtWorldXY: function (g, x, y, T, S, E) { return y === void 0 && (y = !0), T === void 0 && (T = !0), E = this.getLayer(E), E === null ? null : v.RemoveTileAtWorldXY(g, x, y, T, S, E) },
          renderDebug: function (g, x, y) { return y = this.getLayer(y), y === null ? null : (this.orientation === s.ORTHOGONAL && v.RenderDebug(g, x, y), this) },
          renderDebugFull: function (g, x) { for (let y = this.layers, T = 0; T < y.length; T++)v.RenderDebug(g, x, y[T]); return this },
          replaceByIndex: function (g, x, y, T, S, E, C) { return C = this.getLayer(C), C === null ? null : (v.ReplaceByIndex(g, x, y, T, S, E, C), this) },
          setCollision: function (g, x, y, T, S) { return x === void 0 && (x = !0), y === void 0 && (y = !0), S === void 0 && (S = !0), T = this.getLayer(T), T === null ? null : (v.SetCollision(g, x, y, T, S), this) },
          setCollisionBetween: function (g, x, y, T, S) { return y === void 0 && (y = !0), T === void 0 && (T = !0), S = this.getLayer(S), S === null ? null : (v.SetCollisionBetween(g, x, y, T, S), this) },
          setCollisionByProperty: function (g, x, y, T) { return x === void 0 && (x = !0), y === void 0 && (y = !0), T = this.getLayer(T), T === null ? null : (v.SetCollisionByProperty(g, x, y, T), this) },
          setCollisionByExclusion: function (g, x, y, T) { return x === void 0 && (x = !0), y === void 0 && (y = !0), T = this.getLayer(T), T === null ? null : (v.SetCollisionByExclusion(g, x, y, T), this) },
          setCollisionFromCollisionGroup: function (g, x, y) { return g === void 0 && (g = !0), x === void 0 && (x = !0), y = this.getLayer(y), y === null ? null : (v.SetCollisionFromCollisionGroup(g, x, y), this) },
          setTileIndexCallback: function (g, x, y, T) { return T = this.getLayer(T), T === null ? null : (v.SetTileIndexCallback(g, x, y, T), this) },
          setTileLocationCallback: function (g, x, y, T, S, E, C) { return C = this.getLayer(C), C === null ? null : (v.SetTileLocationCallback(g, x, y, T, S, E, C), this) },
          setLayer: function (g) { const x = this.getLayerIndex(g); return x !== null && (this.currentLayerIndex = x), this },
          setBaseTileSize: function (g, x) { this.tileWidth = g, this.tileHeight = x, this.widthInPixels = this.width * g, this.heightInPixels = this.height * x; for (let y = 0; y < this.layers.length; y++) { this.layers[y].baseTileWidth = g, this.layers[y].baseTileHeight = x; for (let T = this.layers[y].data, S = this.layers[y].width, E = this.layers[y].height, C = 0; C < E; C++) for (let P = 0; P < S; P++) { const A = T[C][P]; A !== null && A.setSize(void 0, void 0, g, x) } } return this },
          setLayerTileSize: function (g, x, y) { if (y = this.getLayer(y), y === null) return this; y.tileWidth = g, y.tileHeight = x; for (let T = y.data, S = y.width, E = y.height, C = 0; C < E; C++) for (let P = 0; P < S; P++) { const A = T[C][P]; A !== null && A.setSize(g, x) } return this },
          shuffle: function (g, x, y, T, S) { return S = this.getLayer(S), S === null ? null : (v.Shuffle(g, x, y, T, S), this) },
          swapByIndex: function (g, x, y, T, S, E, C) { return C = this.getLayer(C), C === null ? null : (v.SwapByIndex(g, x, y, T, S, E, C), this) },
          tileToWorldX: function (g, x, y) { return y = this.getLayer(y), y === null ? null : this._convert.TileToWorldX(g, x, y) },
          tileToWorldY: function (g, x, y) { return y = this.getLayer(y), y === null ? null : this._convert.TileToWorldY(g, x, y) },
          tileToWorldXY: function (g, x, y, T, S) { return S = this.getLayer(S), S === null ? null : this._convert.TileToWorldXY(g, x, y, T, S) },
          weightedRandomize: function (g, x, y, T, S, E) { return E = this.getLayer(E), E === null ? null : (v.WeightedRandomize(x, y, T, S, g, E), this) },
          worldToTileX: function (g, x, y, T) { return T = this.getLayer(T), T === null ? null : this._convert.WorldToTileX(g, x, y, T) },
          worldToTileY: function (g, x, y, T) { return T = this.getLayer(T), T === null ? null : this._convert.WorldToTileY(g, x, y, T) },
          worldToTileXY: function (g, x, y, T, S, E) { return E = this.getLayer(E), E === null ? null : this._convert.WorldToTileXY(g, x, y, T, S, E) },
          destroy: function () { this.removeAllLayers(), this.tilesets.length = 0, this.objects.length = 0, this.scene = null }
        }); e.exports = m
      }, function (e, d, t) { const i = t(0); const h = t(11); const n = t(15); const o = t(251); const r = t(1456); const s = new i({ Extends: n, Mixins: [h.Alpha, h.BlendMode, h.ComputedSize, h.Depth, h.Flip, h.GetBounds, h.Origin, h.Pipeline, h.Transform, h.Visible, h.ScrollFactor, r], initialize: function (f, l, u, v, p, c) { n.call(this, f, 'TilemapLayer'), this.isTilemap = !0, this.tilemap = l, this.layerIndex = u, this.layer = l.layers[u], this.layer.tilemapLayer = this, this.tileset = [], this.tilesDrawn = 0, this.tilesTotal = this.layer.width * this.layer.height, this.culledTiles = [], this.skipCull = !1, this.cullPaddingX = 1, this.cullPaddingY = 1, this.cullCallback = o.GetCullTilesFunction(this.layer.orientation), this._renderOrder = 0, this.gidMap = [], this.setTilesets(v), this.setAlpha(this.layer.alpha), this.setPosition(p, c), this.setOrigin(), this.setSize(l.tileWidth * this.layer.width, l.tileHeight * this.layer.height), this.initPipeline() }, setTilesets: function (a) { const f = []; const l = []; const u = this.tilemap; Array.isArray(a) || (a = [a]); for (let v = 0; v < a.length; v++) { let p = a[v]; if (typeof p === 'string' && (p = u.getTileset(p)), p) { l.push(p); for (let c = p.firstgid, m = 0; m < p.total; m++)f[c + m] = p } } this.gidMap = f, this.tileset = l }, setRenderOrder: function (a) { const f = ['right-down', 'left-down', 'right-up', 'left-up']; return typeof a === 'string' && (a = f.indexOf(a)), a >= 0 && a < 4 && (this._renderOrder = a), this }, calculateFacesAt: function (a, f) { return o.CalculateFacesAt(a, f, this.layer), this }, calculateFacesWithin: function (a, f, l, u) { return o.CalculateFacesWithin(a, f, l, u, this.layer), this }, createFromTiles: function (a, f, l, u, v) { return o.CreateFromTiles(a, f, l, u, v, this.layer) }, cull: function (a) { return this.cullCallback(this.layer, a, this.culledTiles, this._renderOrder) }, copy: function (a, f, l, u, v, p, c) { return o.Copy(a, f, l, u, v, p, c, this.layer), this }, fill: function (a, f, l, u, v, p) { return o.Fill(a, f, l, u, v, p, this.layer), this }, filterTiles: function (a, f, l, u, v, p, c) { return o.FilterTiles(a, f, l, u, v, p, c, this.layer) }, findByIndex: function (a, f, l) { return o.FindByIndex(a, f, l, this.layer) }, findTile: function (a, f, l, u, v, p, c) { return o.FindTile(a, f, l, u, v, p, c, this.layer) }, forEachTile: function (a, f, l, u, v, p, c) { return o.ForEachTile(a, f, l, u, v, p, c, this.layer), this }, getTileAt: function (a, f, l) { return o.GetTileAt(a, f, l, this.layer) }, getTileAtWorldXY: function (a, f, l, u) { return o.GetTileAtWorldXY(a, f, l, u, this.layer) }, getTilesWithin: function (a, f, l, u, v) { return o.GetTilesWithin(a, f, l, u, v, this.layer) }, getTilesWithinShape: function (a, f, l) { return o.GetTilesWithinShape(a, f, l, this.layer) }, getTilesWithinWorldXY: function (a, f, l, u, v, p) { return o.GetTilesWithinWorldXY(a, f, l, u, v, p, this.layer) }, hasTileAt: function (a, f) { return o.HasTileAt(a, f, this.layer) }, hasTileAtWorldXY: function (a, f, l) { return o.HasTileAtWorldXY(a, f, l, this.layer) }, putTileAt: function (a, f, l, u) { return o.PutTileAt(a, f, l, u, this.layer) }, putTileAtWorldXY: function (a, f, l, u, v) { return o.PutTileAtWorldXY(a, f, l, u, v, this.layer) }, putTilesAt: function (a, f, l, u) { return o.PutTilesAt(a, f, l, u, this.layer), this }, randomize: function (a, f, l, u, v) { return o.Randomize(a, f, l, u, v, this.layer), this }, removeTileAt: function (a, f, l, u) { return o.RemoveTileAt(a, f, l, u, this.layer) }, removeTileAtWorldXY: function (a, f, l, u, v) { return o.RemoveTileAtWorldXY(a, f, l, u, v, this.layer) }, renderDebug: function (a, f) { return o.RenderDebug(a, f, this.layer), this }, replaceByIndex: function (a, f, l, u, v, p) { return o.ReplaceByIndex(a, f, l, u, v, p, this.layer), this }, setSkipCull: function (a) { return a === void 0 && (a = !0), this.skipCull = a, this }, setCullPadding: function (a, f) { return a === void 0 && (a = 1), f === void 0 && (f = 1), this.cullPaddingX = a, this.cullPaddingY = f, this }, setCollision: function (a, f, l, u) { return o.SetCollision(a, f, l, this.layer, u), this }, setCollisionBetween: function (a, f, l, u) { return o.SetCollisionBetween(a, f, l, u, this.layer), this }, setCollisionByProperty: function (a, f, l) { return o.SetCollisionByProperty(a, f, l, this.layer), this }, setCollisionByExclusion: function (a, f, l) { return o.SetCollisionByExclusion(a, f, l, this.layer), this }, setCollisionFromCollisionGroup: function (a, f) { return o.SetCollisionFromCollisionGroup(a, f, this.layer), this }, setTileIndexCallback: function (a, f, l) { return o.SetTileIndexCallback(a, f, l, this.layer), this }, setTileLocationCallback: function (a, f, l, u, v, p) { return o.SetTileLocationCallback(a, f, l, u, v, p, this.layer), this }, shuffle: function (a, f, l, u) { return o.Shuffle(a, f, l, u, this.layer), this }, swapByIndex: function (a, f, l, u, v, p) { return o.SwapByIndex(a, f, l, u, v, p, this.layer), this }, tileToWorldX: function (a, f) { return this.tilemap.tileToWorldX(a, f, this) }, tileToWorldY: function (a, f) { return this.tilemap.tileToWorldY(a, f, this) }, tileToWorldXY: function (a, f, l, u) { return this.tilemap.tileToWorldXY(a, f, l, u, this) }, weightedRandomize: function (a, f, l, u, v) { return o.WeightedRandomize(f, l, u, v, a, this.layer), this }, worldToTileX: function (a, f, l) { return this.tilemap.worldToTileX(a, f, l, this) }, worldToTileY: function (a, f, l) { return this.tilemap.worldToTileY(a, f, l, this) }, worldToTileXY: function (a, f, l, u, v) { return this.tilemap.worldToTileXY(a, f, l, u, v, this) }, destroy: function (a) { a === void 0 && (a = !0), !!this.tilemap && (this.layer.tilemapLayer === this && (this.layer.tilemapLayer = void 0), a && this.tilemap.removeLayer(this), this.tilemap = void 0, this.layer = void 0, this.culledTiles.length = 0, this.cullCallback = null, this.gidMap = [], this.tileset = [], n.prototype.destroy.call(this)) } }); e.exports = s }, function (e, d, t) { const i = t(0); const h = t(2); const n = new i({ initialize: function (r) { this.delay = 0, this.repeat = 0, this.repeatCount = 0, this.loop = !1, this.callback, this.callbackScope, this.args, this.timeScale = 1, this.startAt = 0, this.elapsed = 0, this.paused = !1, this.hasDispatched = !1, this.reset(r) }, reset: function (o) { return this.delay = h(o, 'delay', 0), this.repeat = h(o, 'repeat', 0), this.loop = h(o, 'loop', !1), this.callback = h(o, 'callback', void 0), this.callbackScope = h(o, 'callbackScope', this.callback), this.args = h(o, 'args', []), this.timeScale = h(o, 'timeScale', 1), this.startAt = h(o, 'startAt', 0), this.paused = h(o, 'paused', !1), this.elapsed = this.startAt, this.hasDispatched = !1, this.repeatCount = this.repeat === -1 || this.loop ? 999999999999 : this.repeat, this }, getProgress: function () { return this.elapsed / this.delay }, getOverallProgress: function () { if (this.repeat > 0) { const o = this.delay + this.delay * this.repeat; const r = this.elapsed + this.delay * (this.repeat - this.repeatCount); return r / o } else return this.getProgress() }, getRepeatCount: function () { return this.repeatCount }, getElapsed: function () { return this.elapsed }, getElapsedSeconds: function () { return this.elapsed * 0.001 }, getRemaining: function () { return this.delay - this.elapsed }, getRemainingSeconds: function () { return this.getRemaining() * 0.001 }, getOverallRemaining: function () { return this.delay * (1 + this.repeatCount) - this.elapsed }, getOverallRemainingSeconds: function () { return this.getOverallRemaining() * 0.001 }, remove: function (o) { o === void 0 && (o = !1), this.elapsed = this.delay, this.hasDispatched = !o, this.repeatCount = 0 }, destroy: function () { this.callback = void 0, this.callbackScope = void 0, this.args = [] } }); e.exports = n }, function (e, d, t) { const i = t(1465); const h = function (n) { let o; const r = []; if (n.hasOwnProperty('props')) for (o in n.props)o.substr(0, 1) !== '_' && r.push({ key: o, value: n.props[o] }); else for (o in n)i.indexOf(o) === -1 && o.substr(0, 1) !== '_' && r.push({ key: o, value: n[o] }); return r }; e.exports = h }, function (e, d, t) { const i = t(6); const h = function (n) { let o = i(n, 'tweens', null); return o === null ? [] : (typeof o === 'function' && (o = o.call()), Array.isArray(o) || (o = [o]), o) }; e.exports = h }, function (e, d, t) { const i = t(265); const h = t(13); const n = t(99); const o = t(80); const r = t(162); const s = t(6); const a = t(264); const f = t(266); const l = t(268); const u = function (v, p, c) { c === void 0 && (c = i); const m = s(p, 'from', 0); const g = s(p, 'to', 1); const x = [{ value: m }]; const y = r(p, 'delay', c.delay); const T = r(p, 'duration', c.duration); const S = s(p, 'easeParams', c.easeParams); const E = o(s(p, 'ease', c.ease), S); const C = r(p, 'hold', c.hold); const P = r(p, 'repeat', c.repeat); const A = r(p, 'repeatDelay', c.repeatDelay); const M = n(p, 'yoyo', c.yoyo); const L = []; const F = a('value', g); const I = l(x[0], 0, 'value', F.getEnd, F.getStart, F.getActive, E, y, T, M, C, P, A, !1, !1); I.start = m, I.current = m, I.to = g, L.push(I); const G = new f(v, L, x); G.offset = h(p, 'offset', null), G.completeDelay = h(p, 'completeDelay', 0), G.loop = Math.round(h(p, 'loop', 0)), G.loopDelay = Math.round(h(p, 'loopDelay', 0)), G.paused = n(p, 'paused', !1), G.useFrames = n(p, 'useFrames', !1); for (let U = s(p, 'callbackScope', G), Y = [G, null], X = f.TYPES, O = 0; O < X.length; O++) { const R = X[O]; const D = s(p, R, !1); if (D) { const B = s(p, R + 'Scope', U); const N = s(p, R + 'Params', []); G.setCallback(R, D, Y.concat(N), B) } } return G }; e.exports = u }, function (e, d, t) { const i = t(80); const h = t(6); const n = t(14); const o = function (r, s) { s === void 0 && (s = {}); let a; let f = h(s, 'start', 0); const l = h(s, 'ease', null); const u = h(s, 'grid', null); const v = h(s, 'from', 0); const p = v === 'first'; const c = v === 'center'; const m = v === 'last'; const g = typeof v === 'number'; const x = Array.isArray(r); const y = parseFloat(x ? r[0] : r); const T = x ? parseFloat(r[1]) : 0; const S = Math.max(y, T); if (x && (f += y), u) { var E = u[0]; var C = u[1]; let P = 0; let A = 0; let M = 0; let L = 0; var F = []; m ? (P = E - 1, A = C - 1) : g ? (P = v % E, A = Math.floor(v / E)) : c && (P = (E - 1) / 2, A = (C - 1) / 2); for (var I = n.MIN_SAFE_INTEGER, G = 0; G < C; G++) { F[G] = []; for (let U = 0; U < E; U++) { M = P - U, L = A - G; const Y = Math.sqrt(M * M + L * L); Y > I && (I = Y), F[G][U] = Y } } } const X = l ? i(l) : null; return u ? a = function (O, R, D, B) { let N = 0; const w = B % E; const z = Math.floor(B / E); w >= 0 && w < E && z >= 0 && z < C && (N = F[z][w]); let V; if (x) { const W = T - y; X ? V = N / I * W * X(N / I) : V = N / I * W } else X ? V = N * y * X(N / I) : V = N * y; return V + f } : a = function (O, R, D, B, N) { N--; let w; p ? w = B : c ? w = Math.abs(N / 2 - B) : m ? w = N - B : g && (w = Math.abs(v - B)); let z; if (x) { let V; c ? V = (T - y) / N * (w * 2) : V = (T - y) / N * w, X ? z = V * X(w / N) : z = V } else X ? z = N * S * X(w / N) : z = w * y; return z + f }, a }; e.exports = o }, function (e, d, t) { const i = t(77); const h = t(265); const n = t(13); const o = t(99); const r = t(80); const s = t(162); const a = t(263); const f = t(584); const l = t(6); const u = t(588); const v = t(163); const p = function (c, m) { const g = new u(c); g.completeDelay = n(m, 'completeDelay', 0), g.loop = Math.round(n(m, 'loop', 0)), g.loopDelay = Math.round(n(m, 'loopDelay', 0)), g.paused = o(m, 'paused', !1), g.useFrames = o(m, 'useFrames', !1); const x = l(m, 'callbackScope', g); const y = [g]; const T = l(m, 'onStart', !1); if (T) { const S = l(m, 'onStartScope', x); const E = l(m, 'onStartParams', []); g.setCallback('onStart', T, y.concat(E), S) } const C = l(m, 'onUpdate', !1); if (C) { const P = l(m, 'onUpdateScope', x); const A = l(m, 'onUpdateParams', []); g.setCallback('onUpdate', C, y.concat(A), P) } const M = l(m, 'onLoop', !1); if (M) { const L = l(m, 'onLoopScope', x); const F = l(m, 'onLoopParams', []); g.setCallback('onLoop', M, y.concat(F), L) } const I = l(m, 'onYoyo', !1); if (I) { const G = l(m, 'onYoyoScope', x); const U = l(m, 'onYoyoParams', []); g.setCallback('onYoyo', I, y.concat(null, U), G) } const Y = l(m, 'onComplete', !1); if (Y) { const X = l(m, 'onCompleteScope', x); const O = l(m, 'onCompleteParams', []); g.setCallback('onComplete', Y, y.concat(O), X) } const R = f(m); if (R.length === 0) return g.paused = !0, g; const D = i(h); D.targets = a(m); const B = n(m, 'totalDuration', 0); B > 0 ? D.duration = Math.floor(B / R.length) : D.duration = s(m, 'duration', D.duration), D.delay = s(m, 'delay', D.delay), D.easeParams = l(m, 'easeParams', D.easeParams), D.ease = r(l(m, 'ease', D.ease), D.easeParams), D.hold = s(m, 'hold', D.hold), D.repeat = s(m, 'repeat', D.repeat), D.repeatDelay = s(m, 'repeatDelay', D.repeatDelay), D.yoyo = o(m, 'yoyo', D.yoyo), D.flipX = o(m, 'flipX', D.flipX), D.flipY = o(m, 'flipY', D.flipY); for (let N = 0; N < R.length; N++)g.queue(v(g, R[N], D)); return g }; e.exports = p }, function (e, d, t) { const i = t(0); const h = t(9); const n = t(267); const o = t(163); const r = t(100); var s = new i({ Extends: h, initialize: function (f) { h.call(this), this.manager = f, this.isTimeline = !0, this.data = [], this.totalData = 0, this.useFrames = !1, this.timeScale = 1, this.loop = 0, this.loopDelay = 0, this.loopCounter = 0, this.completeDelay = 0, this.countdown = 0, this.state = r.PENDING_ADD, this._pausedState = r.PENDING_ADD, this.paused = !1, this.elapsed = 0, this.totalElapsed = 0, this.duration = 0, this.progress = 0, this.totalDuration = 0, this.totalProgress = 0, this.callbacks = { onComplete: null, onLoop: null, onStart: null, onUpdate: null, onYoyo: null }, this.callbackScope }, dispatchTimelineEvent: function (a, f) { this.emit(a, this), f && f.func.apply(f.scope, f.params) }, setTimeScale: function (a) { return this.timeScale = a, this }, getTimeScale: function () { return this.timeScale }, isPlaying: function () { return this.state === r.ACTIVE }, add: function (a) { return this.queue(o(this, a)) }, queue: function (a) { return this.isPlaying() || (a.parent = this, a.parentIsTimeline = !0, this.data.push(a), this.totalData = this.data.length), this }, hasOffset: function (a) { return a.offset !== null }, isOffsetAbsolute: function (a) { return typeof a === 'number' }, isOffsetRelative: function (a) { const f = typeof a; if (f === 'string') { const l = a[0]; if (l === '-' || l === '+') return !0 } return !1 }, getRelativeOffset: function (a, f) { const l = a[0]; const u = parseFloat(a.substr(2)); let v = f; switch (l) { case '+':v += u; break; case '-':v -= u; break } return Math.max(0, v) }, calcDuration: function () { for (var a = 0, f = 0, l = 0, u = 0; u < this.totalData; u++) { const v = this.data[u]; v.init(), this.hasOffset(v) ? this.isOffsetAbsolute(v.offset) ? (v.calculatedOffset = v.offset, v.offset === 0 && (l = 0)) : this.isOffsetRelative(v.offset) && (v.calculatedOffset = this.getRelativeOffset(v.offset, a)) : v.calculatedOffset = l, a = v.totalDuration + v.calculatedOffset, f += v.totalDuration, l += v.totalDuration } this.duration = f, this.loopCounter = this.loop === -1 ? 999999999999 : this.loop, this.loopCounter > 0 ? this.totalDuration = this.duration + this.completeDelay + (this.duration + this.loopDelay) * this.loopCounter : this.totalDuration = this.duration + this.completeDelay }, init: function () { return this.calcDuration(), this.progress = 0, this.totalProgress = 0, this.paused ? (this.state = r.PAUSED, !1) : !0 }, resetTweens: function (a) { for (let f = 0; f < this.totalData; f++) { const l = this.data[f]; l.play(a) } }, setCallback: function (a, f, l, u) { return s.TYPES.indexOf(a) !== -1 && (this.callbacks[a] = { func: f, scope: u, params: l }), this }, makeActive: function (a) { return this.manager.makeActive(a) }, play: function () { if (this.state !== r.ACTIVE) { if (this.paused) { this.paused = !1, this.manager.makeActive(this); return } else this.resetTweens(!1), this.state = r.ACTIVE; this.dispatchTimelineEvent(n.TIMELINE_START, this.callbacks.onStart) } }, nextState: function () { this.loopCounter > 0 ? (this.elapsed = 0, this.progress = 0, this.loopCounter--, this.resetTweens(!0), this.loopDelay > 0 ? (this.countdown = this.loopDelay, this.state = r.LOOP_DELAY) : (this.state = r.ACTIVE, this.dispatchTimelineEvent(n.TIMELINE_LOOP, this.callbacks.onLoop))) : this.completeDelay > 0 ? (this.state = r.COMPLETE_DELAY, this.countdown = this.completeDelay) : (this.state = r.PENDING_REMOVE, this.dispatchTimelineEvent(n.TIMELINE_COMPLETE, this.callbacks.onComplete)) }, update: function (a, f) { if (this.state !== r.PAUSED) { switch (this.useFrames && (f = 1 * this.manager.timeScale), f *= this.timeScale, this.elapsed += f, this.progress = Math.min(this.elapsed / this.duration, 1), this.totalElapsed += f, this.totalProgress = Math.min(this.totalElapsed / this.totalDuration, 1), this.state) { case r.ACTIVE:for (var l = this.totalData, u = 0; u < this.totalData; u++) { const v = this.data[u]; v.update(a, f) && l-- } this.dispatchTimelineEvent(n.TIMELINE_UPDATE, this.callbacks.onUpdate), l === 0 && this.nextState(); break; case r.LOOP_DELAY:this.countdown -= f, this.countdown <= 0 && (this.state = r.ACTIVE, this.dispatchTimelineEvent(n.TIMELINE_LOOP, this.callbacks.onLoop)); break; case r.COMPLETE_DELAY:this.countdown -= f, this.countdown <= 0 && (this.state = r.PENDING_REMOVE, this.dispatchTimelineEvent(n.TIMELINE_COMPLETE, this.callbacks.onComplete)); break } return this.state === r.PENDING_REMOVE } }, stop: function () { this.state = r.PENDING_REMOVE }, pause: function () { if (this.state !== r.PAUSED) return this.paused = !0, this._pausedState = this.state, this.state = r.PAUSED, this.emit(n.TIMELINE_PAUSE, this), this }, resume: function () { return this.state === r.PAUSED && (this.paused = !1, this.state = this._pausedState, this.emit(n.TIMELINE_RESUME, this)), this }, hasTarget: function (a) { for (let f = 0; f < this.data.length; f++) if (this.data[f].hasTarget(a)) return !0; return !1 }, destroy: function () { for (let a = 0; a < this.data.length; a++) this.data[a].stop() } }); s.TYPES = ['onStart', 'onUpdate', 'onLoop', 'onComplete', 'onYoyo'], e.exports = s }, function (e, d, t) { const i = t(86); const h = t(41); const n = t(32); const o = t(2); const r = t(64); const s = { parseBody: function (a, f, l, u) { u === void 0 && (u = {}); for (var v = o(l, 'fixtures', []), p = [], c = 0; c < v.length; c++) for (let m = this.parseFixture(v[c]), g = 0; g < m.length; g++)p.push(m[g]); const x = n.clone(l, !0); n.extend(x, u, !0), delete x.fixtures, delete x.type; const y = h.create(x); return h.setParts(y, p), h.setPosition(y, { x: a, y: f }), y }, parseFixture: function (a) { const f = n.extend({}, !1, a); delete f.circle, delete f.vertices; let l; if (a.circle) { const u = o(a.circle, 'x'); const v = o(a.circle, 'y'); const p = o(a.circle, 'radius'); l = [i.circle(u, v, p, f)] } else a.vertices && (l = this.parseVertices(a.vertices, f)); return l }, parseVertices: function (a, f) { f === void 0 && (f = {}); for (var l = [], u = 0; u < a.length; u++)r.clockwiseSort(a[u]), l.push(h.create(n.extend({ position: r.centre(a[u]), vertices: a[u] }, f))); return i.flagCoincidentParts(l) } }; e.exports = s }, function (e, d, t) { const i = t(86); const h = t(41); const n = { parseBody: function (o, r, s, a) { a === void 0 && (a = {}); let f; const l = s.vertices; if (l.length === 1)a.vertices = l[0], f = h.create(a), i.flagCoincidentParts(f.parts); else { for (var u = [], v = 0; v < l.length; v++) { const p = h.create({ vertices: l[v] }); u.push(p) }i.flagCoincidentParts(u), a.parts = u, f = h.create(a) } return f.label = s.label, h.setPosition(f, { x: o, y: r }), f } }; e.exports = n }, function (e, d, t) { const i = {}; e.exports = i; const h = t(118); const n = t(128); const o = t(32); const r = t(41); const s = t(86); (function () { i.stack = function (a, f, l, u, v, p, c) { for (var m = h.create({ label: 'Stack' }), g = a, x = f, y, T = 0, S = 0; S < u; S++) { for (var E = 0, C = 0; C < l; C++) { const P = c(g, x, C, S, y, T); if (P) { const A = P.bounds.max.y - P.bounds.min.y; const M = P.bounds.max.x - P.bounds.min.x; A > E && (E = A), r.translate(P, { x: M * 0.5, y: A * 0.5 }), g = P.bounds.max.x + v, h.addBody(m, P), y = P, T += 1 } else g += v }x += E + p, g = a } return m }, i.chain = function (a, f, l, u, v, p) { for (let c = a.bodies, m = 1; m < c.length; m++) { const g = c[m - 1]; const x = c[m]; const y = g.bounds.max.y - g.bounds.min.y; const T = g.bounds.max.x - g.bounds.min.x; const S = x.bounds.max.y - x.bounds.min.y; const E = x.bounds.max.x - x.bounds.min.x; const C = { bodyA: g, pointA: { x: T * f, y: y * l }, bodyB: x, pointB: { x: E * u, y: S * v } }; const P = o.extend(C, p); h.addConstraint(a, n.create(P)) } return a.label += ' Chain', a }, i.mesh = function (a, f, l, u, v) { const p = a.bodies; let c; let m; let g; let x; let y; for (c = 0; c < l; c++) { for (m = 1; m < f; m++)g = p[m - 1 + c * f], x = p[m + c * f], h.addConstraint(a, n.create(o.extend({ bodyA: g, bodyB: x }, v))); if (c > 0) for (m = 0; m < f; m++)g = p[m + (c - 1) * f], x = p[m + c * f], h.addConstraint(a, n.create(o.extend({ bodyA: g, bodyB: x }, v))), u && m > 0 && (y = p[m - 1 + (c - 1) * f], h.addConstraint(a, n.create(o.extend({ bodyA: y, bodyB: x }, v)))), u && m < f - 1 && (y = p[m + 1 + (c - 1) * f], h.addConstraint(a, n.create(o.extend({ bodyA: y, bodyB: x }, v)))) } return a.label += ' Mesh', a }, i.pyramid = function (a, f, l, u, v, p, c) { return i.stack(a, f, l, u, v, p, function (m, g, x, y, T, S) { const E = Math.min(u, Math.ceil(l / 2)); const C = T ? T.bounds.max.x - T.bounds.min.x : 0; if (!(y > E)) { y = E - y; const P = y; const A = l - 1 - y; if (!(x < P || x > A)) { S === 1 && r.translate(T, { x: (x + (l % 2 == 1 ? 1 : -1)) * C, y: 0 }); const M = T ? x * C : 0; return c(a + M + x * v, g, x, y, T, S) } } }) }, i.newtonsCradle = function (a, f, l, u, v) { for (var p = h.create({ label: 'Newtons Cradle' }), c = 0; c < l; c++) { const m = 1.9; const g = s.circle(a + c * (u * m), f + v, u, { inertia: 1 / 0, restitution: 1, friction: 0, frictionAir: 1e-4, slop: 1 }); const x = n.create({ pointA: { x: a + c * (u * m), y: f }, bodyB: g }); h.addBody(p, g), h.addConstraint(p, x) } return p }, i.car = function (a, f, l, u, v) { const p = r.nextGroup(!0); const c = 20; const m = -l * 0.5 + c; const g = l * 0.5 - c; const x = 0; const y = h.create({ label: 'Car' }); const T = s.rectangle(a, f, l, u, { collisionFilter: { group: p }, chamfer: { radius: u * 0.5 }, density: 2e-4 }); const S = s.circle(a + m, f + x, v, { collisionFilter: { group: p }, friction: 0.8 }); const E = s.circle(a + g, f + x, v, { collisionFilter: { group: p }, friction: 0.8 }); const C = n.create({ bodyB: T, pointB: { x: m, y: x }, bodyA: S, stiffness: 1, length: 0 }); const P = n.create({ bodyB: T, pointB: { x: g, y: x }, bodyA: E, stiffness: 1, length: 0 }); return h.addBody(y, T), h.addBody(y, S), h.addBody(y, E), h.addConstraint(y, C), h.addConstraint(y, P), y }, i.softBody = function (a, f, l, u, v, p, c, m, g, x) { g = o.extend({ inertia: 1 / 0 }, g), x = o.extend({ stiffness: 0.2, render: { type: 'line', anchors: !1 } }, x); const y = i.stack(a, f, l, u, v, p, function (T, S) { return s.circle(T, S, m, g) }); return i.mesh(y, l, u, c, x), y.label = 'Soft Body', y } })() }, function (e, d, t) { const i = {}; e.exports = i; const h = t(84); const n = t(32); (function () { i.pathToVertices = function (o, r) { typeof window !== 'undefined' && !('SVGPathSeg' in window) && n.warn('Svg.pathToVertices: SVGPathSeg not defined, a polyfill is required.'); let s; let a; let f; let l; let u; let v; let p; let c; let m; let g; const x = []; let y; let T; let S = 0; let E = 0; let C = 0; r = r || 15; const P = function (M, L, F) { const I = F % 2 == 1 && F > 1; if (!m || M != m.x || L != m.y) { m && I ? (y = m.x, T = m.y) : (y = 0, T = 0); const G = { x: y + M, y: T + L }; (I || !m) && (m = G), x.push(G), E = y + M, C = T + L } }; const A = function (M) { const L = M.pathSegTypeAsLetter.toUpperCase(); if (L !== 'Z') { switch (L) { case 'M':case 'L':case 'T':case 'C':case 'S':case 'Q':E = M.x, C = M.y; break; case 'H':E = M.x; break; case 'V':C = M.y; break }P(E, C, M.pathSegType) } }; for (i._svgPathToAbsolute(o), f = o.getTotalLength(), v = [], s = 0; s < o.pathSegList.numberOfItems; s += 1)v.push(o.pathSegList.getItem(s)); for (p = v.concat(); S < f;) { if (g = o.getPathSegAtLength(S), u = v[g], u != c) { for (;p.length && p[0] != u;)A(p.shift()); c = u } switch (u.pathSegTypeAsLetter.toUpperCase()) { case 'C':case 'T':case 'S':case 'Q':case 'A':l = o.getPointAtLength(S), P(l.x, l.y, 0); break }S += r } for (s = 0, a = p.length; s < a; ++s)A(p[s]); return x }, i._svgPathToAbsolute = function (o) { for (var r, s, a, f, l, u, v = o.pathSegList, p = 0, c = 0, m = v.numberOfItems, g = 0; g < m; ++g) { const x = v.getItem(g); const y = x.pathSegTypeAsLetter; if (/[MLHVCSQTA]/.test(y))'x' in x && (p = x.x), 'y' in x && (c = x.y); else switch ('x1' in x && (a = p + x.x1), 'x2' in x && (l = p + x.x2), 'y1' in x && (f = c + x.y1), 'y2' in x && (u = c + x.y2), 'x' in x && (p += x.x), 'y' in x && (c += x.y), y) { case 'm':v.replaceItem(o.createSVGPathSegMovetoAbs(p, c), g); break; case 'l':v.replaceItem(o.createSVGPathSegLinetoAbs(p, c), g); break; case 'h':v.replaceItem(o.createSVGPathSegLinetoHorizontalAbs(p), g); break; case 'v':v.replaceItem(o.createSVGPathSegLinetoVerticalAbs(c), g); break; case 'c':v.replaceItem(o.createSVGPathSegCurvetoCubicAbs(p, c, a, f, l, u), g); break; case 's':v.replaceItem(o.createSVGPathSegCurvetoCubicSmoothAbs(p, c, l, u), g); break; case 'q':v.replaceItem(o.createSVGPathSegCurvetoQuadraticAbs(p, c, a, f), g); break; case 't':v.replaceItem(o.createSVGPathSegCurvetoQuadraticSmoothAbs(p, c), g); break; case 'a':v.replaceItem(o.createSVGPathSegArcAbs(p, c, x.r1, x.r2, x.angle, x.largeArcFlag, x.sweepFlag), g); break; case 'z':case 'Z':p = r, c = s; break }(y == 'M' || y == 'm') && (r = p, s = c) } } })() }, function (e, d, t) { const i = t(86); const h = t(41); const n = t(0); const o = t(249); const r = t(9); const s = t(2); const a = t(126); const f = t(64); const l = new n({ Extends: r, Mixins: [o.Bounce, o.Collision, o.Friction, o.Gravity, o.Mass, o.Sensor, o.Sleep, o.Static], initialize: function (v, p, c) { r.call(this), this.tile = p, this.world = v, p.physics.matterBody && p.physics.matterBody.destroy(), p.physics.matterBody = this; const m = s(c, 'body', null); const g = s(c, 'addToWorld', !0); if (m) this.setBody(m, g); else { const x = p.getCollisionGroup(); const y = s(x, 'objects', []); y.length > 0 ? this.setFromTileCollision(c) : this.setFromTileRectangle(c) } }, setFromTileRectangle: function (u) { u === void 0 && (u = {}), a(u, 'isStatic') || (u.isStatic = !0), a(u, 'addToWorld') || (u.addToWorld = !0); const v = this.tile.getBounds(); const p = v.x + v.width / 2; const c = v.y + v.height / 2; const m = i.rectangle(p, c, v.width, v.height, u); return this.setBody(m, u.addToWorld), this }, setFromTileCollision: function (u) { u === void 0 && (u = {}), a(u, 'isStatic') || (u.isStatic = !0), a(u, 'addToWorld') || (u.addToWorld = !0); for (var v = this.tile.tilemapLayer.scaleX, p = this.tile.tilemapLayer.scaleY, c = this.tile.getLeft(), m = this.tile.getTop(), g = this.tile.getCollisionGroup(), x = s(g, 'objects', []), y = [], T = 0; T < x.length; T++) { const S = x[T]; let E = c + S.x * v; let C = m + S.y * p; const P = S.width * v; const A = S.height * p; let M = null; if (S.rectangle)M = i.rectangle(E + P / 2, C + A / 2, P, A, u); else if (S.ellipse)M = i.circle(E + P / 2, C + A / 2, P / 2, u); else if (S.polygon || S.polyline) { const L = S.polygon ? S.polygon : S.polyline; const F = L.map(function (U) { return { x: U.x * v, y: U.y * p } }); const I = f.create(F); const G = f.centre(I); E += G.x, C += G.y, M = i.fromVertices(E, C, I, u) }M && y.push(M) } return y.length === 1 ? this.setBody(y[0], u.addToWorld) : y.length > 1 && (u.parts = y, this.setBody(h.create(u), u.addToWorld)), this }, setBody: function (u, v) { return v === void 0 && (v = !0), this.body && this.removeBody(), this.body = u, this.body.gameObject = this, v && this.world.add(this.body), this }, removeBody: function () { return this.body && (this.world.remove(this.body), this.body.gameObject = void 0, this.body = void 0), this }, destroy: function () { this.removeBody(), this.tile.physics.matterBody = void 0, this.removeAllListeners() } }); e.exports = l }, function (e, d, t) { const i = t(1399); i.Body = t(41), i.Composite = t(118), i.World = t(596), i.Detector = t(273), i.Grid = t(597), i.Pairs = t(598), i.Pair = t(250), i.Query = t(1400), i.Resolver = t(599), i.SAT = t(274), i.Constraint = t(128), i.Common = t(32), i.Engine = t(1401), i.Events = t(166), i.Sleeping = t(165), i.Plugin = t(595), i.Bodies = t(86), i.Composites = t(591), i.Axes = t(271), i.Bounds = t(84), i.Svg = t(592), i.Vector = t(83), i.Vertices = t(64), i.World.add = i.Composite.add, i.World.remove = i.Composite.remove, i.World.addComposite = i.Composite.addComposite, i.World.addBody = i.Composite.addBody, i.World.addConstraint = i.Composite.addConstraint, i.World.clear = i.Composite.clear, e.exports = i }, function (e, d, t) { const i = {}; e.exports = i; const h = t(32); (function () { i._registry = {}, i.register = function (n) { if (i.isPlugin(n) || h.warn('Plugin.register:', i.toString(n), 'does not implement all required fields.'), n.name in i._registry) { const o = i._registry[n.name]; const r = i.versionParse(n.version).number; const s = i.versionParse(o.version).number; r > s ? (h.warn('Plugin.register:', i.toString(o), 'was upgraded to', i.toString(n)), i._registry[n.name] = n) : r < s ? h.warn('Plugin.register:', i.toString(o), 'can not be downgraded to', i.toString(n)) : n !== o && h.warn('Plugin.register:', i.toString(n), 'is already registered to different plugin object') } else i._registry[n.name] = n; return n }, i.resolve = function (n) { return i._registry[i.dependencyParse(n).name] }, i.toString = function (n) { return typeof n === 'string' ? n : (n.name || 'anonymous') + '@' + (n.version || n.range || '0.0.0') }, i.isPlugin = function (n) { return n && n.name && n.version && n.install }, i.isUsed = function (n, o) { return n.used.indexOf(o) > -1 }, i.isFor = function (n, o) { const r = n.for && i.dependencyParse(n.for); return !n.for || o.name === r.name && i.versionSatisfies(o.version, r.range) }, i.use = function (n, o) { if (n.uses = (n.uses || []).concat(o || []), n.uses.length === 0) { h.warn('Plugin.use:', i.toString(n), 'does not specify any dependencies to install.'); return } for (var r = i.dependencies(n), s = h.topologicalSort(r), a = [], f = 0; f < s.length; f += 1) if (s[f] !== n.name) { var l = i.resolve(s[f]); if (!l) { a.push('\u274C ' + s[f]); continue }i.isUsed(n, l.name) || (i.isFor(l, n) || (h.warn('Plugin.use:', i.toString(l), 'is for', l.for, 'but installed on', i.toString(n) + '.'), l._warned = !0), l.install ? l.install(n) : (h.warn('Plugin.use:', i.toString(l), 'does not specify an install function.'), l._warned = !0), l._warned ? (a.push('\u{1F536} ' + i.toString(l)), delete l._warned) : a.push('\u2705 ' + i.toString(l)), n.used.push(l.name)) }a.length > 0 && !l.silent && h.info(a.join('  ')) }, i.dependencies = function (n, o) { const r = i.dependencyParse(n); const s = r.name; if (o = o || {}, !(s in o)) { n = i.resolve(n) || n, o[s] = h.map(n.uses || [], function (f) { i.isPlugin(f) && i.register(f); const l = i.dependencyParse(f); const u = i.resolve(f); return u && !i.versionSatisfies(u.version, l.range) ? (h.warn('Plugin.dependencies:', i.toString(u), 'does not satisfy', i.toString(l), 'used by', i.toString(r) + '.'), u._warned = !0, n._warned = !0) : u || (h.warn('Plugin.dependencies:', i.toString(f), 'used by', i.toString(r), 'could not be resolved.'), n._warned = !0), l.name }); for (let a = 0; a < o[s].length; a += 1)i.dependencies(o[s][a], o); return o } }, i.dependencyParse = function (n) { if (h.isString(n)) { const o = /^[\w-]+(@(\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-]+)?))?$/; return o.test(n) || h.warn('Plugin.dependencyParse:', n, 'is not a valid dependency string.'), { name: n.split('@')[0], range: n.split('@')[1] || '*' } } return { name: n.name, range: n.range || n.version } }, i.versionParse = function (n) { const o = /^\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-]+)?$/; o.test(n) || h.warn('Plugin.versionParse:', n, 'is not a valid version or range.'); const r = n.split('-'); n = r[0]; const s = isNaN(Number(n[0])); const a = s ? n.substr(1) : n; const f = h.map(a.split('.'), function (l) { return Number(l) }); return { isRange: s, version: a, range: n, operator: s ? n[0] : '', parts: f, prerelease: r[1], number: f[0] * 1e8 + f[1] * 1e4 + f[2] } }, i.versionSatisfies = function (n, o) { o = o || '*'; const r = i.versionParse(o); const s = r.parts; const a = i.versionParse(n); const f = a.parts; if (r.isRange) { if (r.operator === '*' || n === '*') return !0; if (r.operator === '~') return f[0] === s[0] && f[1] === s[1] && f[2] >= s[2]; if (r.operator === '^') return s[0] > 0 ? f[0] === s[0] && a.number >= r.number : s[1] > 0 ? f[1] === s[1] && f[2] >= s[2] : f[2] === s[2] } return n === o || n === '*' } })() }, function (e, d, t) { const i = {}; e.exports = i; const h = t(118); const n = t(128); const o = t(32); (function () { i.create = function (r) { const s = h.create(); const a = { label: 'World', gravity: { x: 0, y: 1, scale: 0.001 }, bounds: { min: { x: -1 / 0, y: -1 / 0 }, max: { x: 1 / 0, y: 1 / 0 } } }; return o.extend(s, a, r) } })() }, function (e, d, t) { const i = {}; e.exports = i; const h = t(250); const n = t(273); const o = t(32); (function () { i.create = function (r) { const s = { controller: i, detector: n.collisions, buckets: {}, pairs: {}, pairsList: [], bucketWidth: 48, bucketHeight: 48 }; return o.extend(s, r) }, i.update = function (r, s, a, f) { let l; let u; let v; const p = a.world; const c = r.buckets; let m; let g; let x = !1; const y = a.metrics; for (y.broadphaseTests = 0, l = 0; l < s.length; l++) { const T = s[l]; if (!(T.isSleeping && !f) && !(T.bounds.max.x < p.bounds.min.x || T.bounds.min.x > p.bounds.max.x || T.bounds.max.y < p.bounds.min.y || T.bounds.min.y > p.bounds.max.y)) { const S = i._getRegion(r, T); if (!T.region || S.id !== T.region.id || f) { y.broadphaseTests += 1, (!T.region || f) && (T.region = S); const E = i._regionUnion(S, T.region); for (u = E.startCol; u <= E.endCol; u++) for (v = E.startRow; v <= E.endRow; v++) { g = i._getBucketId(u, v), m = c[g]; const C = u >= S.startCol && u <= S.endCol && v >= S.startRow && v <= S.endRow; const P = u >= T.region.startCol && u <= T.region.endCol && v >= T.region.startRow && v <= T.region.endRow; !C && P && P && m && i._bucketRemoveBody(r, m, T), (T.region === S || C && !P || f) && (m || (m = i._createBucket(c, g)), i._bucketAddBody(r, m, T)) }T.region = S, x = !0 } } }x && (r.pairsList = i._createActivePairsList(r)) }, i.clear = function (r) { r.buckets = {}, r.pairs = {}, r.pairsList = [] }, i._regionUnion = function (r, s) { const a = Math.min(r.startCol, s.startCol); const f = Math.max(r.endCol, s.endCol); const l = Math.min(r.startRow, s.startRow); const u = Math.max(r.endRow, s.endRow); return i._createRegion(a, f, l, u) }, i._getRegion = function (r, s) { const a = s.bounds; const f = Math.floor(a.min.x / r.bucketWidth); const l = Math.floor(a.max.x / r.bucketWidth); const u = Math.floor(a.min.y / r.bucketHeight); const v = Math.floor(a.max.y / r.bucketHeight); return i._createRegion(f, l, u, v) }, i._createRegion = function (r, s, a, f) { return { id: r + ',' + s + ',' + a + ',' + f, startCol: r, endCol: s, startRow: a, endRow: f } }, i._getBucketId = function (r, s) { return 'C' + r + 'R' + s }, i._createBucket = function (r, s) { const a = r[s] = []; return a }, i._bucketAddBody = function (r, s, a) { for (let f = 0; f < s.length; f++) { const l = s[f]; if (!(a.id === l.id || a.isStatic && l.isStatic)) { const u = h.id(a, l); const v = r.pairs[u]; v ? v[2] += 1 : r.pairs[u] = [a, l, 1] } }s.push(a) }, i._bucketRemoveBody = function (r, s, a) { s.splice(s.indexOf(a), 1); for (let f = 0; f < s.length; f++) { const l = s[f]; const u = h.id(a, l); const v = r.pairs[u]; v && (v[2] -= 1) } }, i._createActivePairsList = function (r) { let s; let a; const f = []; s = o.keys(r.pairs); for (let l = 0; l < s.length; l++)a = r.pairs[s[l]], a[2] > 0 ? f.push(a) : delete r.pairs[s[l]]; return f } })() }, function (e, d, t) { const i = {}; e.exports = i; const h = t(250); const n = t(32); (function () { i._pairMaxIdleLife = 1e3, i.create = function (o) { return n.extend({ table: {}, list: [], collisionStart: [], collisionActive: [], collisionEnd: [] }, o) }, i.update = function (o, r, s) { const a = o.list; const f = o.table; const l = o.collisionStart; const u = o.collisionEnd; const v = o.collisionActive; let p; let c; let m; let g; for (l.length = 0, u.length = 0, v.length = 0, g = 0; g < a.length; g++)a[g].confirmedActive = !1; for (g = 0; g < r.length; g++)p = r[g], p.collided && (c = h.id(p.bodyA, p.bodyB), m = f[c], m ? (m.isActive ? v.push(m) : l.push(m), h.update(m, p, s), m.confirmedActive = !0) : (m = h.create(p, s), f[c] = m, l.push(m), a.push(m))); for (g = 0; g < a.length; g++)m = a[g], m.isActive && !m.confirmedActive && (h.setActive(m, !1, s), u.push(m)) }, i.removeOld = function (o, r) { const s = o.list; const a = o.table; const f = []; let l; let u; let v; let p; for (p = 0; p < s.length; p++) { if (l = s[p], u = l.collision, u.bodyA.isSleeping || u.bodyB.isSleeping) { l.timeUpdated = r; continue }r - l.timeUpdated > i._pairMaxIdleLife && f.push(p) } for (p = 0; p < f.length; p++)v = f[p] - p, l = s[v], delete a[l.id], s.splice(v, 1) }, i.clear = function (o) { return o.table = {}, o.list.length = 0, o.collisionStart.length = 0, o.collisionActive.length = 0, o.collisionEnd.length = 0, o } })() }, function (e, d, t) { const i = {}; e.exports = i; const h = t(64); const n = t(83); const o = t(32); const r = t(84); (function () { i._restingThresh = 4, i._restingThreshTangent = 6, i._positionDampen = 0.9, i._positionWarming = 0.8, i._frictionNormalMultiplier = 5, i.preSolvePosition = function (s) { let a, f, l; for (a = 0; a < s.length; a++)f = s[a], !!f.isActive && (l = f.activeContacts.length, f.collision.parentA.totalContacts += l, f.collision.parentB.totalContacts += l) }, i.solvePosition = function (s, a, f) { let l; let u; let v; let p; let c; let m; let g; let x; let y; let T; let S; let E; let C; let P; let A; let M; const L = f * i._positionDampen; for (l = 0; l < a.length; l++) { const F = a[l]; F.previousPositionImpulse.x = F.positionImpulse.x, F.previousPositionImpulse.y = F.positionImpulse.y } for (l = 0; l < s.length; l++)p = s[l], !(!p.isActive || p.isSensor) && (c = p.collision, m = c.parentA, g = c.parentB, x = c.normal, S = m.previousPositionImpulse, E = g.previousPositionImpulse, T = c.penetration, P = E.x - S.x + T.x, A = E.y - S.y + T.y, u = x.x, v = x.y, y = u * P + v * A, p.separation = y, M = (y - p.slop) * L, (m.isStatic || g.isStatic) && (M *= 2), m.isStatic || m.isSleeping || (C = M / m.totalContacts, m.positionImpulse.x += u * C, m.positionImpulse.y += v * C), g.isStatic || g.isSleeping || (C = M / g.totalContacts, g.positionImpulse.x -= u * C, g.positionImpulse.y -= v * C)) }, i.postSolvePosition = function (s) { for (let a = 0; a < s.length; a++) { const f = s[a]; if (f.totalContacts = 0, f.positionImpulse.x !== 0 || f.positionImpulse.y !== 0) { for (let l = 0; l < f.parts.length; l++) { const u = f.parts[l]; h.translate(u.vertices, f.positionImpulse), r.update(u.bounds, u.vertices, f.velocity), u.position.x += f.positionImpulse.x, u.position.y += f.positionImpulse.y }f.positionPrev.x += f.positionImpulse.x, f.positionPrev.y += f.positionImpulse.y, n.dot(f.positionImpulse, f.velocity) < 0 ? (f.positionImpulse.x = 0, f.positionImpulse.y = 0) : (f.positionImpulse.x *= i._positionWarming, f.positionImpulse.y *= i._positionWarming) } } }, i.preSolveVelocity = function (s) { let a; let f; let l; let u; let v; let p; let c; let m; let g; let x; let y; let T; let S; let E; const C = n._temp[0]; const P = n._temp[1]; for (a = 0; a < s.length; a++) if (l = s[a], !(!l.isActive || l.isSensor)) for (u = l.activeContacts, v = l.collision, p = v.parentA, c = v.parentB, m = v.normal, g = v.tangent, f = 0; f < u.length; f++)x = u[f], y = x.vertex, T = x.normalImpulse, S = x.tangentImpulse, (T !== 0 || S !== 0) && (C.x = m.x * T + g.x * S, C.y = m.y * T + g.y * S, p.isStatic || p.isSleeping || (E = n.sub(y, p.position, P), p.positionPrev.x += C.x * p.inverseMass, p.positionPrev.y += C.y * p.inverseMass, p.anglePrev += n.cross(E, C) * p.inverseInertia), c.isStatic || c.isSleeping || (E = n.sub(y, c.position, P), c.positionPrev.x -= C.x * c.inverseMass, c.positionPrev.y -= C.y * c.inverseMass, c.anglePrev -= n.cross(E, C) * c.inverseInertia)) }, i.solveVelocity = function (s, a) { for (let f = a * a, l = n._temp[0], u = n._temp[1], v = n._temp[2], p = n._temp[3], c = n._temp[4], m = n._temp[5], g = 0; g < s.length; g++) { const x = s[g]; if (!(!x.isActive || x.isSensor)) { const y = x.collision; const T = y.parentA; const S = y.parentB; const E = y.normal; const C = y.tangent; const P = x.activeContacts; const A = 1 / P.length; T.velocity.x = T.position.x - T.positionPrev.x, T.velocity.y = T.position.y - T.positionPrev.y, S.velocity.x = S.position.x - S.positionPrev.x, S.velocity.y = S.position.y - S.positionPrev.y, T.angularVelocity = T.angle - T.anglePrev, S.angularVelocity = S.angle - S.anglePrev; for (let M = 0; M < P.length; M++) { const L = P[M]; const F = L.vertex; const I = n.sub(F, T.position, u); const G = n.sub(F, S.position, v); const U = n.add(T.velocity, n.mult(n.perp(I), T.angularVelocity), p); const Y = n.add(S.velocity, n.mult(n.perp(G), S.angularVelocity), c); const X = n.sub(U, Y, m); const O = n.dot(E, X); const R = n.dot(C, X); const D = Math.abs(R); const B = o.sign(R); let N = (1 + x.restitution) * O; const w = o.clamp(x.separation + O, 0, 1) * i._frictionNormalMultiplier; let z = R; let V = 1 / 0; D > x.friction * x.frictionStatic * w * f && (V = D, z = o.clamp(x.friction * B * f, -V, V)); const W = n.cross(I, E); const H = n.cross(G, E); const K = A / (T.inverseMass + S.inverseMass + T.inverseInertia * W * W + S.inverseInertia * H * H); if (N *= K, z *= K, O < 0 && O * O > i._restingThresh * f)L.normalImpulse = 0; else { const Q = L.normalImpulse; L.normalImpulse = Math.min(L.normalImpulse + N, 0), N = L.normalImpulse - Q } if (R * R > i._restingThreshTangent * f)L.tangentImpulse = 0; else { const J = L.tangentImpulse; L.tangentImpulse = o.clamp(L.tangentImpulse + z, -V, V), z = L.tangentImpulse - J }l.x = E.x * N + C.x * z, l.y = E.y * N + C.y * z, T.isStatic || T.isSleeping || (T.positionPrev.x += l.x * T.inverseMass, T.positionPrev.y += l.y * T.inverseMass, T.anglePrev += n.cross(I, l) * T.inverseInertia), S.isStatic || S.isSleeping || (S.positionPrev.x -= l.x * S.inverseMass, S.positionPrev.y -= l.y * S.inverseMass, S.anglePrev -= n.cross(G, l) * S.inverseInertia) } } } } })() }, function (e, d) { let t; t = (function () { return this }()); try { t = t || new Function('return this')() } catch (i) { typeof window === 'object' && (t = window) }e.exports = t }, function (e, d, t) { const i = t(276); const h = function (n, o, r, s) { for (let a = n[0], f = 1; f < n.length; f++) { const l = n[f]; i(l, a, o, r, s), a = l } return n }; e.exports = h }, function (e, d, t) { const i = t(46); const h = function (n, o, r, s, a) { return i(n, 'angle', o, r, s, a) }; e.exports = h }, function (e, d) { const t = function (i, h, n) { for (let o = 0; o < i.length; o++) { const r = i[o]; h.call(n, r) } return i }; e.exports = t }, function (e, d) { const t = function (i, h, n) { n === void 0 && (n = 0); for (let o = n; o < i.length; o++) { const r = i[o]; let s = !0; for (const a in h)r[a] !== h[a] && (s = !1); if (s) return r } return null }; e.exports = t }, function (e, d) { const t = function (i, h, n) { n === void 0 && (n = 0); for (let o = n; o < i.length; o++) { const r = i[o]; let s = !0; for (const a in h)r[a] !== h[a] && (s = !1); if (s) return r } return null }; e.exports = t }, function (e, d, t) { const i = t(289); const h = t(123); const n = t(2); const o = t(1); const r = t(129); const s = new r({ sys: { queueDepthSort: o, events: { once: o } } }, 0, 0, 1, 1); const a = function (f, l) { l === void 0 && (l = {}); const u = l.hasOwnProperty('width'); const v = l.hasOwnProperty('height'); const p = n(l, 'width', -1); const c = n(l, 'height', -1); const m = n(l, 'cellWidth', 1); const g = n(l, 'cellHeight', m); const x = n(l, 'position', h.TOP_LEFT); const y = n(l, 'x', 0); const T = n(l, 'y', 0); let S = 0; let E = 0; const C = p * m; const P = c * g; s.setPosition(y, T), s.setSize(m, g); for (let A = 0; A < f.length; A++) if (i(f[A], s, x), u && p === -1)s.x += m; else if (v && c === -1)s.y += g; else if (v && !u) { if (E += g, s.y += g, E === P && (E = 0, S += m, s.y = T, s.x += m, S === C)) break } else if (S += m, s.x += m, S === C && (S = 0, E += g, s.x = y, s.y += g, E === P)) break; return f }; e.exports = a }, function (e, d, t) { const i = t(18); const h = 2; const n = { _alpha: 1, _alphaTL: 1, _alphaTR: 1, _alphaBL: 1, _alphaBR: 1, clearAlpha: function () { return this.setAlpha(1) }, setAlpha: function (o, r, s, a) { return o === void 0 && (o = 1), r === void 0 ? this.alpha = o : (this._alphaTL = i(o, 0, 1), this._alphaTR = i(r, 0, 1), this._alphaBL = i(s, 0, 1), this._alphaBR = i(a, 0, 1)), this }, alpha: { get: function () { return this._alpha }, set: function (o) { const r = i(o, 0, 1); this._alpha = r, this._alphaTL = r, this._alphaTR = r, this._alphaBL = r, this._alphaBR = r, r === 0 ? this.renderFlags &= ~h : this.renderFlags |= h } }, alphaTopLeft: { get: function () { return this._alphaTL }, set: function (o) { const r = i(o, 0, 1); this._alphaTL = r, r !== 0 && (this.renderFlags |= h) } }, alphaTopRight: { get: function () { return this._alphaTR }, set: function (o) { const r = i(o, 0, 1); this._alphaTR = r, r !== 0 && (this.renderFlags |= h) } }, alphaBottomLeft: { get: function () { return this._alphaBL }, set: function (o) { const r = i(o, 0, 1); this._alphaBL = r, r !== 0 && (this.renderFlags |= h) } }, alphaBottomRight: { get: function () { return this._alphaBR }, set: function (o) { const r = i(o, 0, 1); this._alphaBR = r, r !== 0 && (this.renderFlags |= h) } } }; e.exports = n }, function (e, d) { const t = { width: 0, height: 0, displayWidth: { get: function () { return this.scaleX * this.width }, set: function (i) { this.scaleX = i / this.width } }, displayHeight: { get: function () { return this.scaleY * this.height }, set: function (i) { this.scaleY = i / this.height } }, setSize: function (i, h) { return this.width = i, this.height = h, this }, setDisplaySize: function (i, h) { return this.displayWidth = i, this.displayHeight = h, this } }; e.exports = t }, function (e, d) { const t = { texture: null, frame: null, isCropped: !1, setCrop: function (i, h, n, o) { if (i === void 0) this.isCropped = !1; else if (this.frame) { if (typeof i === 'number') this.frame.setCropUVs(this._crop, i, h, n, o, this.flipX, this.flipY); else { const r = i; this.frame.setCropUVs(this._crop, r.x, r.y, r.width, r.height, this.flipX, this.flipY) } this.isCropped = !0 } return this }, resetCropObject: function () { return { u0: 0, v0: 0, u1: 0, v1: 0, width: 0, height: 0, x: 0, y: 0, flipX: !1, flipY: !1, cx: 0, cy: 0, cw: 0, ch: 0 } } }; e.exports = t }, function (e, d) { const t = { flipX: !1, flipY: !1, toggleFlipX: function () { return this.flipX = !this.flipX, this }, toggleFlipY: function () { return this.flipY = !this.flipY, this }, setFlipX: function (i) { return this.flipX = i, this }, setFlipY: function (i) { return this.flipY = i, this }, setFlip: function (i, h) { return this.flipX = i, this.flipY = h, this }, resetFlip: function () { return this.flipX = !1, this.flipY = !1, this } }; e.exports = t }, function (e, d, t) { const i = t(10); const h = t(308); const n = t(3); const o = { prepareBoundsOutput: function (r, s) { if (s === void 0 && (s = !1), this.rotation !== 0 && h(r, this.x, this.y, this.rotation), s && this.parentContainer) { const a = this.parentContainer.getBoundsTransformMatrix(); a.transformPoint(r.x, r.y, r) } return r }, getCenter: function (r) { return r === void 0 && (r = new n()), r.x = this.x - this.displayWidth * this.originX + this.displayWidth / 2, r.y = this.y - this.displayHeight * this.originY + this.displayHeight / 2, r }, getTopLeft: function (r, s) { return r || (r = new n()), r.x = this.x - this.displayWidth * this.originX, r.y = this.y - this.displayHeight * this.originY, this.prepareBoundsOutput(r, s) }, getTopCenter: function (r, s) { return r || (r = new n()), r.x = this.x - this.displayWidth * this.originX + this.displayWidth / 2, r.y = this.y - this.displayHeight * this.originY, this.prepareBoundsOutput(r, s) }, getTopRight: function (r, s) { return r || (r = new n()), r.x = this.x - this.displayWidth * this.originX + this.displayWidth, r.y = this.y - this.displayHeight * this.originY, this.prepareBoundsOutput(r, s) }, getLeftCenter: function (r, s) { return r || (r = new n()), r.x = this.x - this.displayWidth * this.originX, r.y = this.y - this.displayHeight * this.originY + this.displayHeight / 2, this.prepareBoundsOutput(r, s) }, getRightCenter: function (r, s) { return r || (r = new n()), r.x = this.x - this.displayWidth * this.originX + this.displayWidth, r.y = this.y - this.displayHeight * this.originY + this.displayHeight / 2, this.prepareBoundsOutput(r, s) }, getBottomLeft: function (r, s) { return r || (r = new n()), r.x = this.x - this.displayWidth * this.originX, r.y = this.y - this.displayHeight * this.originY + this.displayHeight, this.prepareBoundsOutput(r, s) }, getBottomCenter: function (r, s) { return r || (r = new n()), r.x = this.x - this.displayWidth * this.originX + this.displayWidth / 2, r.y = this.y - this.displayHeight * this.originY + this.displayHeight, this.prepareBoundsOutput(r, s) }, getBottomRight: function (r, s) { return r || (r = new n()), r.x = this.x - this.displayWidth * this.originX + this.displayWidth, r.y = this.y - this.displayHeight * this.originY + this.displayHeight, this.prepareBoundsOutput(r, s) }, getBounds: function (r) { r === void 0 && (r = new i()); let s, a, f, l, u, v, p, c; if (this.parentContainer) { const m = this.parentContainer.getBoundsTransformMatrix(); this.getTopLeft(r), m.transformPoint(r.x, r.y, r), s = r.x, a = r.y, this.getTopRight(r), m.transformPoint(r.x, r.y, r), f = r.x, l = r.y, this.getBottomLeft(r), m.transformPoint(r.x, r.y, r), u = r.x, v = r.y, this.getBottomRight(r), m.transformPoint(r.x, r.y, r), p = r.x, c = r.y } else this.getTopLeft(r), s = r.x, a = r.y, this.getTopRight(r), f = r.x, l = r.y, this.getBottomLeft(r), u = r.x, v = r.y, this.getBottomRight(r), p = r.x, c = r.y; return r.x = Math.min(s, f, u, p), r.y = Math.min(a, l, v, c), r.width = Math.max(s, f, u, p) - r.x, r.height = Math.max(a, l, v, c) - r.y, r } }; e.exports = o }, function (e, d) { e.exports = 'blur' }, function (e, d) { e.exports = 'boot' }, function (e, d) { e.exports = 'contextlost' }, function (e, d) { e.exports = 'contextrestored' }, function (e, d) { e.exports = 'destroy' }, function (e, d) { e.exports = 'focus' }, function (e, d) { e.exports = 'hidden' }, function (e, d) { e.exports = 'pause' }, function (e, d) { e.exports = 'postrender' }, function (e, d) { e.exports = 'poststep' }, function (e, d) { e.exports = 'prerender' }, function (e, d) { e.exports = 'prestep' }, function (e, d) { e.exports = 'ready' }, function (e, d) { e.exports = 'resume' }, function (e, d) { e.exports = 'step' }, function (e, d) { e.exports = 'visible' }, function (e, d) { e.exports = 'postrender' }, function (e, d) { e.exports = 'prerender' }, function (e, d) { e.exports = 'render' }, function (e, d) { e.exports = 'resize' }, function (e, d) { const t = { _originComponent: !0, originX: 0.5, originY: 0.5, _displayOriginX: 0, _displayOriginY: 0, displayOriginX: { get: function () { return this._displayOriginX }, set: function (i) { this._displayOriginX = i, this.originX = i / this.width } }, displayOriginY: { get: function () { return this._displayOriginY }, set: function (i) { this._displayOriginY = i, this.originY = i / this.height } }, setOrigin: function (i, h) { return i === void 0 && (i = 0.5), h === void 0 && (h = i), this.originX = i, this.originY = h, this.updateDisplayOrigin() }, setOriginFromFrame: function () { return !this.frame || !this.frame.customPivot ? this.setOrigin() : (this.originX = this.frame.pivotX, this.originY = this.frame.pivotY, this.updateDisplayOrigin()) }, setDisplayOrigin: function (i, h) { return i === void 0 && (i = 0), h === void 0 && (h = i), this.displayOriginX = i, this.displayOriginY = h, this }, updateDisplayOrigin: function () { return this._displayOriginX = this.originX * this.width, this._displayOriginY = this.originY * this.height, this } }; e.exports = t }, function (e, d, t) { const i = t(36); const h = t(99); const n = t(6); const o = t(100); const r = t(3); const s = { path: null, rotateToPath: !1, pathRotationOffset: 0, pathOffset: null, pathVector: null, pathDelta: null, pathTween: null, pathConfig: null, _prevDirection: o.PLAYING_FORWARD, setPath: function (a, f) { f === void 0 && (f = this.pathConfig); const l = this.pathTween; return l && l.isPlaying() && l.stop(), this.path = a, f && this.startFollow(f), this }, setRotateToPath: function (a, f) { return f === void 0 && (f = 0), this.rotateToPath = a, this.pathRotationOffset = f, this }, isFollowing: function () { const a = this.pathTween; return a && a.isPlaying() }, startFollow: function (a, f) { a === void 0 && (a = {}), f === void 0 && (f = 0); const l = this.pathTween; l && l.isPlaying() && l.stop(), typeof a === 'number' && (a = { duration: a }), a.from = n(a, 'from', 0), a.to = n(a, 'to', 1); const u = h(a, 'positionOnPath', !1); this.rotateToPath = h(a, 'rotateToPath', !1), this.pathRotationOffset = n(a, 'rotationOffset', 0); const v = n(a, 'startAt', f); if (v && (a.onStart = function (c) { const m = c.data[0]; m.progress = v, m.elapsed = m.duration * v; const g = m.ease(m.progress); m.current = m.start + (m.end - m.start) * g, m.target[m.key] = m.current }), this.pathOffset || (this.pathOffset = new r(this.x, this.y)), this.pathVector || (this.pathVector = new r()), this.pathDelta || (this.pathDelta = new r()), this.pathDelta.reset(), this.pathTween = this.scene.sys.tweens.addCounter(a), this.path.getStartPoint(this.pathOffset), u && (this.x = this.pathOffset.x, this.y = this.pathOffset.y), this.pathOffset.x = this.x - this.pathOffset.x, this.pathOffset.y = this.y - this.pathOffset.y, this._prevDirection = o.PLAYING_FORWARD, this.rotateToPath) { const p = this.path.getPoint(0.1); this.rotation = Math.atan2(p.y - this.y, p.x - this.x) + i(this.pathRotationOffset) } return this.pathConfig = a, this }, pauseFollow: function () { const a = this.pathTween; return a && a.isPlaying() && a.pause(), this }, resumeFollow: function () { const a = this.pathTween; return a && a.isPaused() && a.resume(), this }, stopFollow: function () { const a = this.pathTween; return a && a.isPlaying() && a.stop(), this }, pathUpdate: function () { const a = this.pathTween; if (a) { const f = a.data[0]; const l = this.pathDelta; const u = this.pathVector; if (l.copy(u).negate(), f.state === o.COMPLETE) { this.path.getPoint(1, u), l.add(u), u.add(this.pathOffset), this.setPosition(u.x, u.y); return } else if (f.state !== o.PLAYING_FORWARD && f.state !== o.PLAYING_BACKWARD) return; this.path.getPoint(a.getValue(), u), l.add(u), u.add(this.pathOffset); const v = this.x; const p = this.y; this.setPosition(u.x, u.y); const c = this.x - v; const m = this.y - p; if (c === 0 && m === 0) return; if (f.state !== this._prevDirection) { this._prevDirection = f.state; return } this.rotateToPath && (this.rotation = Math.atan2(m, c) + i(this.pathRotationOffset)) } } }; e.exports = s }, function (e, d) { const t = { _sizeComponent: !0, width: 0, height: 0, displayWidth: { get: function () { return Math.abs(this.scaleX * this.frame.realWidth) }, set: function (i) { this.scaleX = i / this.frame.realWidth } }, displayHeight: { get: function () { return Math.abs(this.scaleY * this.frame.realHeight) }, set: function (i) { this.scaleY = i / this.frame.realHeight } }, setSizeToFrame: function (i) { return i === void 0 && (i = this.frame), this.width = i.realWidth, this.height = i.realHeight, this }, setSize: function (i, h) { return this.width = i, this.height = h, this }, setDisplaySize: function (i, h) { return this.displayWidth = i, this.displayHeight = h, this } }; e.exports = t }, function (e, d) { const t = 8; const i = { texture: null, frame: null, isCropped: !1, setTexture: function (h, n) { return this.texture = this.scene.sys.textures.get(h), this.setFrame(n) }, setFrame: function (h, n, o) { return n === void 0 && (n = !0), o === void 0 && (o = !0), this.frame = this.texture.get(h), !this.frame.cutWidth || !this.frame.cutHeight ? this.renderFlags &= ~t : this.renderFlags |= t, this._sizeComponent && n && this.setSizeToFrame(), this._originComponent && o && (this.frame.customPivot ? this.setOrigin(this.frame.pivotX, this.frame.pivotY) : this.updateDisplayOrigin()), this } }; e.exports = i }, function (e, d) { const t = 8; const i = { texture: null, frame: null, isCropped: !1, setCrop: function (h, n, o, r) { if (h === void 0) this.isCropped = !1; else if (this.frame) { if (typeof h === 'number') this.frame.setCropUVs(this._crop, h, n, o, r, this.flipX, this.flipY); else { const s = h; this.frame.setCropUVs(this._crop, s.x, s.y, s.width, s.height, this.flipX, this.flipY) } this.isCropped = !0 } return this }, setTexture: function (h, n) { return this.texture = this.scene.sys.textures.get(h), this.setFrame(n) }, setFrame: function (h, n, o) { return n === void 0 && (n = !0), o === void 0 && (o = !0), this.frame = this.texture.get(h), !this.frame.cutWidth || !this.frame.cutHeight ? this.renderFlags &= ~t : this.renderFlags |= t, this._sizeComponent && n && this.setSizeToFrame(), this._originComponent && o && (this.frame.customPivot ? this.setOrigin(this.frame.pivotX, this.frame.pivotY) : this.updateDisplayOrigin()), this.isCropped && this.frame.updateCropUVs(this._crop, this.flipX, this.flipY), this }, resetCropObject: function () { return { u0: 0, v0: 0, u1: 0, v1: 0, width: 0, height: 0, x: 0, y: 0, flipX: !1, flipY: !1, cx: 0, cy: 0, cw: 0, ch: 0 } } }; e.exports = i }, function (e, d) { const t = { tintTopLeft: 16777215, tintTopRight: 16777215, tintBottomLeft: 16777215, tintBottomRight: 16777215, tintFill: !1, clearTint: function () { return this.setTint(16777215), this }, setTint: function (i, h, n, o) { return i === void 0 && (i = 16777215), h === void 0 && (h = i, n = i, o = i), this.tintTopLeft = i, this.tintTopRight = h, this.tintBottomLeft = n, this.tintBottomRight = o, this.tintFill = !1, this }, setTintFill: function (i, h, n, o) { return this.setTint(i, h, n, o), this.tintFill = !0, this }, tint: { set: function (i) { this.setTint(i, i, i, i) } }, isTinted: { get: function () { const i = 16777215; return this.tintFill || this.tintTopLeft !== i || this.tintTopRight !== i || this.tintBottomLeft !== i || this.tintBottomRight !== i } } }; e.exports = t }, function (e, d) { e.exports = 'changedata' }, function (e, d) { e.exports = 'changedata-' }, function (e, d) { e.exports = 'destroy' }, function (e, d) { e.exports = 'removedata' }, function (e, d) { e.exports = 'setdata' }, function (e, d) { e.exports = 'addedtoscene' }, function (e, d) { e.exports = 'destroy' }, function (e, d) { e.exports = 'removedfromscene' }, function (e, d) { e.exports = 'complete' }, function (e, d) { e.exports = 'created' }, function (e, d) { e.exports = 'error' }, function (e, d) { e.exports = 'loop' }, function (e, d) { e.exports = 'play' }, function (e, d) { e.exports = 'seeked' }, function (e, d) { e.exports = 'seeking' }, function (e, d) { e.exports = 'stop' }, function (e, d) { e.exports = 'timeout' }, function (e, d) { e.exports = 'unlocked' }, function (e, d) { e.exports = 'addedtoscene' }, function (e, d) { e.exports = 'boot' }, function (e, d) { e.exports = 'create' }, function (e, d) { e.exports = 'destroy' }, function (e, d) { e.exports = 'pause' }, function (e, d) { e.exports = 'postupdate' }, function (e, d) { e.exports = 'prerender' }, function (e, d) { e.exports = 'preupdate' }, function (e, d) { e.exports = 'ready' }, function (e, d) { e.exports = 'removedfromscene' }, function (e, d) { e.exports = 'render' }, function (e, d) { e.exports = 'resume' }, function (e, d) { e.exports = 'shutdown' }, function (e, d) { e.exports = 'sleep' }, function (e, d) { e.exports = 'start' }, function (e, d) { e.exports = 'transitioncomplete' }, function (e, d) { e.exports = 'transitioninit' }, function (e, d) { e.exports = 'transitionout' }, function (e, d) { e.exports = 'transitionstart' }, function (e, d) { e.exports = 'transitionwake' }, function (e, d) { e.exports = 'update' }, function (e, d) { e.exports = 'wake' }, function (e, d, t) { const i = t(46); const h = function (n, o, r, s, a) { return i(n, 'alpha', o, r, s, a) }; e.exports = h }, function (e, d, t) { const i = t(46); const h = function (n, o, r, s, a) { return i(n, 'x', o, r, s, a) }; e.exports = h }, function (e, d, t) { const i = t(46); const h = function (n, o, r, s, a, f, l) { return r == null && (r = o), i(n, 'x', o, s, f, l), i(n, 'y', r, a, f, l) }; e.exports = h }, function (e, d, t) { const i = t(46); const h = function (n, o, r, s, a) { return i(n, 'y', o, r, s, a) }; e.exports = h }, function (e, d) { const t = function (i, h, n, o) { n === void 0 && (n = 0), o === void 0 && (o = 6.28); for (let r = n, s = (o - n) / i.length, a = 0; a < i.length; a++)i[a].x = h.x + h.radius * Math.cos(r), i[a].y = h.y + h.radius * Math.sin(r), r += s; return i }; e.exports = t }, function (e, d) { const t = function (i, h, n, o) { n === void 0 && (n = 0), o === void 0 && (o = 6.28); for (let r = n, s = (o - n) / i.length, a = h.width / 2, f = h.height / 2, l = 0; l < i.length; l++)i[l].x = h.x + a * Math.cos(r), i[l].y = h.y + f * Math.sin(r), r += s; return i }; e.exports = t }, function (e, d, t) { const i = t(172); const h = function (n, o) { for (let r = i(o, n.length), s = 0; s < n.length; s++) { const a = n[s]; const f = r[s]; a.x = f.x, a.y = f.y } return n }; e.exports = h }, function (e, d, t) { const i = t(316); const h = t(178); const n = t(179); const o = function (r, s, a) { a === void 0 && (a = 0); const f = i(s, !1, r.length); a > 0 ? h(f, a) : a < 0 && n(f, Math.abs(a)); for (let l = 0; l < r.length; l++)r[l].x = f[l].x, r[l].y = f[l].y; return r }; e.exports = o }, function (e, d, t) { const i = t(317); const h = function (n, o, r) { let s = i({ x1: o.x1, y1: o.y1, x2: o.x2, y2: o.y2 }, r); const a = i({ x1: o.x2, y1: o.y2, x2: o.x3, y2: o.y3 }, r); const f = i({ x1: o.x3, y1: o.y3, x2: o.x1, y2: o.y1 }, r); s.pop(), a.pop(), f.pop(), s = s.concat(a, f); for (let l = s.length / n.length, u = 0, v = 0; v < n.length; v++) { const p = n[v]; const c = s[Math.floor(u)]; p.x = c.x, p.y = c.y, u += l } return n }; e.exports = h }, function (e, d) { const t = function (i, h, n) { for (let o = 0; o < i.length; o++) { const r = i[o]; r.anims && r.anims.play(h, n) } return i }; e.exports = t }, function (e, d, t) { const i = t(170); const h = function (n, o) { for (let r = 0; r < n.length; r++)i(o, n[r]); return n }; e.exports = h }, function (e, d, t) { const i = t(180); const h = function (n, o) { for (let r = 0; r < n.length; r++)i(o, n[r]); return n }; e.exports = h }, function (e, d, t) { const i = t(173); const h = function (n, o) { for (let r = 0; r < n.length; r++)i(o, n[r]); return n }; e.exports = h }, function (e, d, t) { const i = t(174); const h = function (n, o) { for (let r = 0; r < n.length; r++)i(o, n[r]); return n }; e.exports = h }, function (e, d, t) { const i = t(181); const h = function (n, o) { for (let r = 0; r < n.length; r++)i(o, n[r]); return n }; e.exports = h }, function (e, d, t) { const i = t(46); const h = function (n, o, r, s, a) { return i(n, 'rotation', o, r, s, a) }; e.exports = h }, function (e, d, t) { const i = t(182); const h = t(50); const n = function (o, r, s) { for (let a = r.x, f = r.y, l = 0; l < o.length; l++) { const u = o[l]; i(u, a, f, s, Math.max(1, h(u.x, u.y, a, f))) } return o }; e.exports = n }, function (e, d, t) { const i = t(182); const h = function (n, o, r, s) { const a = o.x; const f = o.y; if (s === 0) return n; for (let l = 0; l < n.length; l++)i(n[l], a, f, r, s); return n }; e.exports = h }, function (e, d, t) { const i = t(46); const h = function (n, o, r, s, a) { return i(n, 'scaleX', o, r, s, a) }; e.exports = h }, function (e, d, t) { const i = t(46); const h = function (n, o, r, s, a, f, l) { return r == null && (r = o), i(n, 'scaleX', o, s, f, l), i(n, 'scaleY', r, a, f, l) }; e.exports = h }, function (e, d, t) { const i = t(46); const h = function (n, o, r, s, a) { return i(n, 'scaleY', o, r, s, a) }; e.exports = h }, function (e, d, t) { const i = t(27); const h = function (n, o, r, s, a) { return i(n, 'alpha', o, r, s, a) }; e.exports = h }, function (e, d, t) { const i = t(27); const h = function (n, o, r, s) { return i(n, 'blendMode', o, 0, r, s) }; e.exports = h }, function (e, d, t) { const i = t(27); const h = function (n, o, r, s, a) { return i(n, 'depth', o, r, s, a) }; e.exports = h }, function (e, d) { const t = function (i, h, n) { for (let o = 0; o < i.length; o++)i[o].setInteractive(h, n); return i }; e.exports = t }, function (e, d, t) { const i = t(27); const h = function (n, o, r, s, a, f, l) { return r == null && (r = o), i(n, 'originX', o, s, f, l), i(n, 'originY', r, a, f, l), n.forEach(function (u) { u.updateDisplayOrigin() }), n }; e.exports = h }, function (e, d, t) { const i = t(27); const h = function (n, o, r, s, a) { return i(n, 'rotation', o, r, s, a) }; e.exports = h }, function (e, d, t) { const i = t(27); const h = function (n, o, r, s, a, f, l) { return r == null && (r = o), i(n, 'scaleX', o, s, f, l), i(n, 'scaleY', r, a, f, l) }; e.exports = h }, function (e, d, t) { const i = t(27); const h = function (n, o, r, s, a) { return i(n, 'scaleX', o, r, s, a) }; e.exports = h }, function (e, d, t) { const i = t(27); const h = function (n, o, r, s, a) { return i(n, 'scaleY', o, r, s, a) }; e.exports = h }, function (e, d, t) { const i = t(27); const h = function (n, o, r, s, a, f, l) { return r == null && (r = o), i(n, 'scrollFactorX', o, s, f, l), i(n, 'scrollFactorY', r, a, f, l) }; e.exports = h }, function (e, d, t) { const i = t(27); const h = function (n, o, r, s, a) { return i(n, 'scrollFactorX', o, r, s, a) }; e.exports = h }, function (e, d, t) { const i = t(27); const h = function (n, o, r, s, a) { return i(n, 'scrollFactorY', o, r, s, a) }; e.exports = h }, function (e, d) { const t = function (i, h, n, o, r) { for (let s = 0; s < i.length; s++)i[s].setTint(h, n, o, r); return i }; e.exports = t }, function (e, d, t) { const i = t(27); const h = function (n, o, r, s) { return i(n, 'visible', o, 0, r, s) }; e.exports = h }, function (e, d, t) { const i = t(27); const h = function (n, o, r, s, a) { return i(n, 'x', o, r, s, a) }; e.exports = h }, function (e, d, t) { const i = t(27); const h = function (n, o, r, s, a, f, l) { return r == null && (r = o), i(n, 'x', o, s, f, l), i(n, 'y', r, a, f, l) }; e.exports = h }, function (e, d, t) { const i = t(27); const h = function (n, o, r, s, a) { return i(n, 'y', o, r, s, a) }; e.exports = h }, function (e, d, t) { const i = t(3); const h = function (n, o, r, s, a) { s === void 0 && (s = 0), a === void 0 && (a = new i()); let f, l; if (n.length > 1) { let u, v, p, c; if (s === 0) { const m = n.length - 1; for (f = n[m].x, l = n[m].y, u = m - 1; u >= 0; u--)c = n[u], v = c.x, p = c.y, c.x = f, c.y = l, f = v, l = p; n[m].x = o, n[m].y = r } else { for (f = n[0].x, l = n[0].y, u = 1; u < n.length; u++)c = n[u], v = c.x, p = c.y, c.x = f, c.y = l, f = v, l = p; n[0].x = o, n[0].y = r } } else f = n[0].x, l = n[0].y, n[0].x = o, n[0].y = r; return a.x = f, a.y = l, a }; e.exports = h }, function (e, d, t) { const i = t(131); const h = function (n) { return i(n) }; e.exports = h }, function (e, d, t) { const i = t(183); const h = function (n, o, r, s, a) { a === void 0 && (a = !1); const f = Math.abs(s - r) / n.length; let l; if (a) for (l = 0; l < n.length; l++)n[l][o] += i(l * f, r, s); else for (l = 0; l < n.length; l++)n[l][o] = i(l * f, r, s); return n }; e.exports = h }, function (e, d, t) { const i = t(184); const h = function (n, o, r, s, a) { a === void 0 && (a = !1); const f = Math.abs(s - r) / n.length; let l; if (a) for (l = 0; l < n.length; l++)n[l][o] += i(l * f, r, s); else for (l = 0; l < n.length; l++)n[l][o] = i(l * f, r, s); return n }; e.exports = h }, function (e, d) { const t = function (i, h, n, o, r) { r === void 0 && (r = !1); const s = Math.abs(o - n) / i.length; let a; if (r) for (a = 0; a < i.length; a++)i[a][h] += a * s + n; else for (a = 0; a < i.length; a++)i[a][h] = a * s + n; return i }; e.exports = t }, function (e, d) { const t = function (i) { for (let h = 0; h < i.length; h++)i[h].visible = !i[h].visible; return i }; e.exports = t }, function (e, d, t) { const i = t(68); const h = function (n, o, r) { r === void 0 && (r = 0); for (let s = 0; s < n.length; s++) { const a = n[s]; a.x = i(a.x, o.left - r, o.right + r), a.y = i(a.y, o.top - r, o.bottom + r) } return n }; e.exports = h }, function (e, d, t) { e.exports = { Animation: t(185), AnimationFrame: t(319), AnimationManager: t(321), AnimationState: t(164), Events: t(132) } }, function (e, d) { e.exports = 'add' }, function (e, d) { e.exports = 'animationcomplete' }, function (e, d) { e.exports = 'animationcomplete-' }, function (e, d) { e.exports = 'animationrepeat' }, function (e, d) { e.exports = 'animationrestart' }, function (e, d) { e.exports = 'animationstart' }, function (e, d) { e.exports = 'animationstop' }, function (e, d) { e.exports = 'animationupdate' }, function (e, d) { e.exports = 'pauseall' }, function (e, d) { e.exports = 'remove' }, function (e, d) { e.exports = 'resumeall' }, function (e, d, t) { e.exports = { BaseCache: t(323), CacheManager: t(325), Events: t(324) } }, function (e, d) { e.exports = 'add' }, function (e, d) { e.exports = 'remove' }, function (e, d, t) { e.exports = { Controls: t(739), Scene2D: t(742) } }, function (e, d, t) { e.exports = { FixedKeyControl: t(740), SmoothedKeyControl: t(741) } }, function (e, d, t) { const i = t(0); const h = t(6); const n = new i({ initialize: function (r) { this.camera = h(r, 'camera', null), this.left = h(r, 'left', null), this.right = h(r, 'right', null), this.up = h(r, 'up', null), this.down = h(r, 'down', null), this.zoomIn = h(r, 'zoomIn', null), this.zoomOut = h(r, 'zoomOut', null), this.zoomSpeed = h(r, 'zoomSpeed', 0.01), this.minZoom = h(r, 'minZoom', 0.001), this.maxZoom = h(r, 'maxZoom', 1e3), this.speedX = 0, this.speedY = 0; const s = h(r, 'speed', null); typeof s === 'number' ? (this.speedX = s, this.speedY = s) : (this.speedX = h(r, 'speed.x', 0), this.speedY = h(r, 'speed.y', 0)), this._zoom = 0, this.active = this.camera !== null }, start: function () { return this.active = this.camera !== null, this }, stop: function () { return this.active = !1, this }, setCamera: function (o) { return this.camera = o, this }, update: function (o) { if (this.active) { o === void 0 && (o = 1); const r = this.camera; this.up && this.up.isDown ? r.scrollY -= this.speedY * o | 0 : this.down && this.down.isDown && (r.scrollY += this.speedY * o | 0), this.left && this.left.isDown ? r.scrollX -= this.speedX * o | 0 : this.right && this.right.isDown && (r.scrollX += this.speedX * o | 0), this.zoomIn && this.zoomIn.isDown ? (r.zoom -= this.zoomSpeed, r.zoom < this.minZoom && (r.zoom = this.minZoom)) : this.zoomOut && this.zoomOut.isDown && (r.zoom += this.zoomSpeed, r.zoom > this.maxZoom && (r.zoom = this.maxZoom)) } }, destroy: function () { this.camera = null, this.left = null, this.right = null, this.up = null, this.down = null, this.zoomIn = null, this.zoomOut = null } }); e.exports = n }, function (e, d, t) { const i = t(0); const h = t(6); const n = new i({ initialize: function (r) { this.camera = h(r, 'camera', null), this.left = h(r, 'left', null), this.right = h(r, 'right', null), this.up = h(r, 'up', null), this.down = h(r, 'down', null), this.zoomIn = h(r, 'zoomIn', null), this.zoomOut = h(r, 'zoomOut', null), this.zoomSpeed = h(r, 'zoomSpeed', 0.01), this.minZoom = h(r, 'minZoom', 0.001), this.maxZoom = h(r, 'maxZoom', 1e3), this.accelX = 0, this.accelY = 0; const s = h(r, 'acceleration', null); typeof s === 'number' ? (this.accelX = s, this.accelY = s) : (this.accelX = h(r, 'acceleration.x', 0), this.accelY = h(r, 'acceleration.y', 0)), this.dragX = 0, this.dragY = 0; const a = h(r, 'drag', null); typeof a === 'number' ? (this.dragX = a, this.dragY = a) : (this.dragX = h(r, 'drag.x', 0), this.dragY = h(r, 'drag.y', 0)), this.maxSpeedX = 0, this.maxSpeedY = 0; const f = h(r, 'maxSpeed', null); typeof f === 'number' ? (this.maxSpeedX = f, this.maxSpeedY = f) : (this.maxSpeedX = h(r, 'maxSpeed.x', 0), this.maxSpeedY = h(r, 'maxSpeed.y', 0)), this._speedX = 0, this._speedY = 0, this._zoom = 0, this.active = this.camera !== null }, start: function () { return this.active = this.camera !== null, this }, stop: function () { return this.active = !1, this }, setCamera: function (o) { return this.camera = o, this }, update: function (o) { if (this.active) { o === void 0 && (o = 1); const r = this.camera; this._speedX > 0 ? (this._speedX -= this.dragX * o, this._speedX < 0 && (this._speedX = 0)) : this._speedX < 0 && (this._speedX += this.dragX * o, this._speedX > 0 && (this._speedX = 0)), this._speedY > 0 ? (this._speedY -= this.dragY * o, this._speedY < 0 && (this._speedY = 0)) : this._speedY < 0 && (this._speedY += this.dragY * o, this._speedY > 0 && (this._speedY = 0)), this.up && this.up.isDown ? (this._speedY += this.accelY, this._speedY > this.maxSpeedY && (this._speedY = this.maxSpeedY)) : this.down && this.down.isDown && (this._speedY -= this.accelY, this._speedY < -this.maxSpeedY && (this._speedY = -this.maxSpeedY)), this.left && this.left.isDown ? (this._speedX += this.accelX, this._speedX > this.maxSpeedX && (this._speedX = this.maxSpeedX)) : this.right && this.right.isDown && (this._speedX -= this.accelX, this._speedX < -this.maxSpeedX && (this._speedX = -this.maxSpeedX)), this.zoomIn && this.zoomIn.isDown ? this._zoom = -this.zoomSpeed : this.zoomOut && this.zoomOut.isDown ? this._zoom = this.zoomSpeed : this._zoom = 0, this._speedX !== 0 && (r.scrollX -= this._speedX * o | 0), this._speedY !== 0 && (r.scrollY -= this._speedY * o | 0), this._zoom !== 0 && (r.zoom += this._zoom, r.zoom < this.minZoom ? r.zoom = this.minZoom : r.zoom > this.maxZoom && (r.zoom = this.maxZoom)) } }, destroy: function () { this.camera = null, this.left = null, this.right = null, this.up = null, this.down = null, this.zoomIn = null, this.zoomOut = null } }); e.exports = n }, function (e, d, t) { e.exports = { Camera: t(326), BaseCamera: t(133), CameraManager: t(799), Effects: t(333), Events: t(37) } }, function (e, d) { e.exports = 'cameradestroy' }, function (e, d) { e.exports = 'camerafadeincomplete' }, function (e, d) { e.exports = 'camerafadeinstart' }, function (e, d) { e.exports = 'camerafadeoutcomplete' }, function (e, d) { e.exports = 'camerafadeoutstart' }, function (e, d) { e.exports = 'cameraflashcomplete' }, function (e, d) { e.exports = 'cameraflashstart' }, function (e, d) { e.exports = 'followupdate' }, function (e, d) { e.exports = 'camerapancomplete' }, function (e, d) { e.exports = 'camerapanstart' }, function (e, d) { e.exports = 'postrender' }, function (e, d) { e.exports = 'prerender' }, function (e, d) { e.exports = 'camerarotatecomplete' }, function (e, d) { e.exports = 'camerarotatestart' }, function (e, d) { e.exports = 'camerashakecomplete' }, function (e, d) { e.exports = 'camerashakestart' }, function (e, d) { e.exports = 'camerazoomcomplete' }, function (e, d) { e.exports = 'camerazoomstart' }, function (e, d, t) { const i = t(18); const h = t(0); const n = t(37); const o = new h({ initialize: function (s) { this.camera = s, this.isRunning = !1, this.isComplete = !1, this.direction = !0, this.duration = 0, this.red = 0, this.green = 0, this.blue = 0, this.alpha = 0, this.progress = 0, this._elapsed = 0, this._onUpdate, this._onUpdateScope }, start: function (r, s, a, f, l, u, v, p) { if (r === void 0 && (r = !0), s === void 0 && (s = 1e3), a === void 0 && (a = 0), f === void 0 && (f = 0), l === void 0 && (l = 0), u === void 0 && (u = !1), v === void 0 && (v = null), p === void 0 && (p = this.camera.scene), !u && this.isRunning) return this.camera; this.isRunning = !0, this.isComplete = !1, this.duration = s, this.direction = r, this.progress = 0, this.red = a, this.green = f, this.blue = l, this.alpha = r ? Number.MIN_VALUE : 1, this._elapsed = 0, this._onUpdate = v, this._onUpdateScope = p; const c = r ? n.FADE_OUT_START : n.FADE_IN_START; return this.camera.emit(c, this.camera, this, s, a, f, l), this.camera }, update: function (r, s) { !this.isRunning || (this._elapsed += s, this.progress = i(this._elapsed / this.duration, 0, 1), this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.camera, this.progress), this._elapsed < this.duration ? this.alpha = this.direction ? this.progress : 1 - this.progress : (this.alpha = this.direction ? 1 : 0, this.effectComplete())) }, postRenderCanvas: function (r) { if (!this.isRunning && !this.isComplete) return !1; const s = this.camera; return r.fillStyle = 'rgba(' + this.red + ',' + this.green + ',' + this.blue + ',' + this.alpha + ')', r.fillRect(s.x, s.y, s.width, s.height), !0 }, postRenderWebGL: function (r, s) { if (!this.isRunning && !this.isComplete) return !1; const a = this.camera; const f = this.red / 255; const l = this.green / 255; const u = this.blue / 255; return r.drawFillRect(a.x, a.y, a.width, a.height, s(u, l, f, 1), this.alpha), !0 }, effectComplete: function () { this._onUpdate = null, this._onUpdateScope = null, this.isRunning = !1, this.isComplete = !0; const r = this.direction ? n.FADE_OUT_COMPLETE : n.FADE_IN_COMPLETE; this.camera.emit(r, this.camera, this) }, reset: function () { this.isRunning = !1, this.isComplete = !1, this._onUpdate = null, this._onUpdateScope = null }, destroy: function () { this.reset(), this.camera = null } }); e.exports = o }, function (e, d, t) { const i = t(18); const h = t(0); const n = t(37); const o = new h({ initialize: function (s) { this.camera = s, this.isRunning = !1, this.duration = 0, this.red = 0, this.green = 0, this.blue = 0, this.alpha = 0, this.progress = 0, this._elapsed = 0, this._onUpdate, this._onUpdateScope }, start: function (r, s, a, f, l, u, v) { return r === void 0 && (r = 250), s === void 0 && (s = 255), a === void 0 && (a = 255), f === void 0 && (f = 255), l === void 0 && (l = !1), u === void 0 && (u = null), v === void 0 && (v = this.camera.scene), !l && this.isRunning ? this.camera : (this.isRunning = !0, this.duration = r, this.progress = 0, this.red = s, this.green = a, this.blue = f, this.alpha = 1, this._elapsed = 0, this._onUpdate = u, this._onUpdateScope = v, this.camera.emit(n.FLASH_START, this.camera, this, r, s, a, f), this.camera) }, update: function (r, s) { !this.isRunning || (this._elapsed += s, this.progress = i(this._elapsed / this.duration, 0, 1), this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.camera, this.progress), this._elapsed < this.duration ? this.alpha = 1 - this.progress : this.effectComplete()) }, postRenderCanvas: function (r) { if (!this.isRunning) return !1; const s = this.camera; return r.fillStyle = 'rgba(' + this.red + ',' + this.green + ',' + this.blue + ',' + this.alpha + ')', r.fillRect(s.x, s.y, s.width, s.height), !0 }, postRenderWebGL: function (r, s) { if (!this.isRunning) return !1; const a = this.camera; const f = this.red / 255; const l = this.green / 255; const u = this.blue / 255; return r.drawFillRect(a.x, a.y, a.width, a.height, s(u, l, f, 1), this.alpha), !0 }, effectComplete: function () { this._onUpdate = null, this._onUpdateScope = null, this.isRunning = !1, this.camera.emit(n.FLASH_COMPLETE, this.camera, this) }, reset: function () { this.isRunning = !1, this._onUpdate = null, this._onUpdateScope = null }, destroy: function () { this.reset(), this.camera = null } }); e.exports = o }, function (e, d, t) { const i = t(18); const h = t(0); const n = t(134); const o = t(37); const r = t(3); const s = new h({ initialize: function (f) { this.camera = f, this.isRunning = !1, this.duration = 0, this.source = new r(), this.current = new r(), this.destination = new r(), this.ease, this.progress = 0, this._elapsed = 0, this._onUpdate, this._onUpdateScope }, start: function (a, f, l, u, v, p, c) { l === void 0 && (l = 1e3), u === void 0 && (u = n.Linear), v === void 0 && (v = !1), p === void 0 && (p = null), c === void 0 && (c = this.camera.scene); const m = this.camera; return !v && this.isRunning || (this.isRunning = !0, this.duration = l, this.progress = 0, this.source.set(m.scrollX, m.scrollY), this.destination.set(a, f), m.getScroll(a, f, this.current), typeof u === 'string' && n.hasOwnProperty(u) ? this.ease = n[u] : typeof u === 'function' && (this.ease = u), this._elapsed = 0, this._onUpdate = p, this._onUpdateScope = c, this.camera.emit(o.PAN_START, this.camera, this, l, a, f)), m }, update: function (a, f) { if (this.isRunning) { this._elapsed += f; const l = i(this._elapsed / this.duration, 0, 1); this.progress = l; const u = this.camera; if (this._elapsed < this.duration) { const v = this.ease(l); u.getScroll(this.destination.x, this.destination.y, this.current); const p = this.source.x + (this.current.x - this.source.x) * v; const c = this.source.y + (this.current.y - this.source.y) * v; u.setScroll(p, c), this._onUpdate && this._onUpdate.call(this._onUpdateScope, u, l, p, c) } else u.centerOn(this.destination.x, this.destination.y), this._onUpdate && this._onUpdate.call(this._onUpdateScope, u, l, u.scrollX, u.scrollY), this.effectComplete() } }, effectComplete: function () { this._onUpdate = null, this._onUpdateScope = null, this.isRunning = !1, this.camera.emit(o.PAN_COMPLETE, this.camera, this) }, reset: function () { this.isRunning = !1, this._onUpdate = null, this._onUpdateScope = null }, destroy: function () { this.reset(), this.camera = null, this.source = null, this.destination = null } }); e.exports = s }, function (e, d) { const t = function (i, h) { return h === void 0 && (h = 1.70158), i * i * ((h + 1) * i - h) }; e.exports = t }, function (e, d) { const t = function (i, h) { return h === void 0 && (h = 1.70158), --i * i * ((h + 1) * i + h) + 1 }; e.exports = t }, function (e, d) { const t = function (i, h) { h === void 0 && (h = 1.70158); const n = h * 1.525; return (i *= 2) < 1 ? 0.5 * (i * i * ((n + 1) * i - n)) : 0.5 * ((i -= 2) * i * ((n + 1) * i + n) + 2) }; e.exports = t }, function (e, d) { const t = function (i) { return i = 1 - i, i < 1 / 2.75 ? 1 - 7.5625 * i * i : i < 2 / 2.75 ? 1 - (7.5625 * (i -= 1.5 / 2.75) * i + 0.75) : i < 2.5 / 2.75 ? 1 - (7.5625 * (i -= 2.25 / 2.75) * i + 0.9375) : 1 - (7.5625 * (i -= 2.625 / 2.75) * i + 0.984375) }; e.exports = t }, function (e, d) { const t = function (i) { return i < 1 / 2.75 ? 7.5625 * i * i : i < 2 / 2.75 ? 7.5625 * (i -= 1.5 / 2.75) * i + 0.75 : i < 2.5 / 2.75 ? 7.5625 * (i -= 2.25 / 2.75) * i + 0.9375 : 7.5625 * (i -= 2.625 / 2.75) * i + 0.984375 }; e.exports = t }, function (e, d) { const t = function (i) { let h = !1; return i < 0.5 ? (i = 1 - i * 2, h = !0) : i = i * 2 - 1, i < 1 / 2.75 ? i = 7.5625 * i * i : i < 2 / 2.75 ? i = 7.5625 * (i -= 1.5 / 2.75) * i + 0.75 : i < 2.5 / 2.75 ? i = 7.5625 * (i -= 2.25 / 2.75) * i + 0.9375 : i = 7.5625 * (i -= 2.625 / 2.75) * i + 0.984375, h ? (1 - i) * 0.5 : i * 0.5 + 0.5 }; e.exports = t }, function (e, d) { const t = function (i) { return 1 - Math.sqrt(1 - i * i) }; e.exports = t }, function (e, d) { const t = function (i) { return Math.sqrt(1 - --i * i) }; e.exports = t }, function (e, d) { const t = function (i) { return (i *= 2) < 1 ? -0.5 * (Math.sqrt(1 - i * i) - 1) : 0.5 * (Math.sqrt(1 - (i -= 2) * i) + 1) }; e.exports = t }, function (e, d) { const t = function (i) { return i * i * i }; e.exports = t }, function (e, d) { const t = function (i) { return --i * i * i + 1 }; e.exports = t }, function (e, d) { const t = function (i) { return (i *= 2) < 1 ? 0.5 * i * i * i : 0.5 * ((i -= 2) * i * i + 2) }; e.exports = t }, function (e, d) { const t = function (i, h, n) { if (h === void 0 && (h = 0.1), n === void 0 && (n = 0.1), i === 0) return 0; if (i === 1) return 1; let o = n / 4; return h < 1 ? h = 1 : o = n * Math.asin(1 / h) / (2 * Math.PI), -(h * Math.pow(2, 10 * (i -= 1)) * Math.sin((i - o) * (2 * Math.PI) / n)) }; e.exports = t }, function (e, d) { const t = function (i, h, n) { if (h === void 0 && (h = 0.1), n === void 0 && (n = 0.1), i === 0) return 0; if (i === 1) return 1; let o = n / 4; return h < 1 ? h = 1 : o = n * Math.asin(1 / h) / (2 * Math.PI), h * Math.pow(2, -10 * i) * Math.sin((i - o) * (2 * Math.PI) / n) + 1 }; e.exports = t }, function (e, d) { const t = function (i, h, n) { if (h === void 0 && (h = 0.1), n === void 0 && (n = 0.1), i === 0) return 0; if (i === 1) return 1; let o = n / 4; return h < 1 ? h = 1 : o = n * Math.asin(1 / h) / (2 * Math.PI), (i *= 2) < 1 ? -0.5 * (h * Math.pow(2, 10 * (i -= 1)) * Math.sin((i - o) * (2 * Math.PI) / n)) : h * Math.pow(2, -10 * (i -= 1)) * Math.sin((i - o) * (2 * Math.PI) / n) * 0.5 + 1 }; e.exports = t }, function (e, d) { const t = function (i) { return Math.pow(2, 10 * (i - 1)) - 0.001 }; e.exports = t }, function (e, d) { const t = function (i) { return 1 - Math.pow(2, -10 * i) }; e.exports = t }, function (e, d) { const t = function (i) { return (i *= 2) < 1 ? 0.5 * Math.pow(2, 10 * (i - 1)) : 0.5 * (2 - Math.pow(2, -10 * (i - 1))) }; e.exports = t }, function (e, d) { const t = function (i) { return i }; e.exports = t }, function (e, d) { const t = function (i) { return i * i }; e.exports = t }, function (e, d) { const t = function (i) { return i * (2 - i) }; e.exports = t }, function (e, d) { const t = function (i) { return (i *= 2) < 1 ? 0.5 * i * i : -0.5 * (--i * (i - 2) - 1) }; e.exports = t }, function (e, d) { const t = function (i) { return i * i * i * i }; e.exports = t }, function (e, d) { const t = function (i) { return 1 - --i * i * i * i }; e.exports = t }, function (e, d) { const t = function (i) { return (i *= 2) < 1 ? 0.5 * i * i * i * i : -0.5 * ((i -= 2) * i * i * i - 2) }; e.exports = t }, function (e, d) { const t = function (i) { return i * i * i * i * i }; e.exports = t }, function (e, d) { const t = function (i) { return --i * i * i * i * i + 1 }; e.exports = t }, function (e, d) { const t = function (i) { return (i *= 2) < 1 ? 0.5 * i * i * i * i * i : 0.5 * ((i -= 2) * i * i * i * i + 2) }; e.exports = t }, function (e, d) { const t = function (i) { return i === 0 ? 0 : i === 1 ? 1 : 1 - Math.cos(i * Math.PI / 2) }; e.exports = t }, function (e, d) { const t = function (i) { return i === 0 ? 0 : i === 1 ? 1 : Math.sin(i * Math.PI / 2) }; e.exports = t }, function (e, d) { const t = function (i) { return i === 0 ? 0 : i === 1 ? 1 : 0.5 * (1 - Math.cos(Math.PI * i)) }; e.exports = t }, function (e, d) { const t = function (i, h) { return h === void 0 && (h = 1), i <= 0 ? 0 : i >= 1 ? 1 : ((h * i | 0) + 1) * (1 / h) }; e.exports = t }, function (e, d, t) { const i = t(18); const h = t(0); const n = t(37); const o = t(3); const r = new h({ initialize: function (a) { this.camera = a, this.isRunning = !1, this.duration = 0, this.intensity = new o(), this.progress = 0, this._elapsed = 0, this._offsetX = 0, this._offsetY = 0, this._onUpdate, this._onUpdateScope }, start: function (s, a, f, l, u) { return s === void 0 && (s = 100), a === void 0 && (a = 0.05), f === void 0 && (f = !1), l === void 0 && (l = null), u === void 0 && (u = this.camera.scene), !f && this.isRunning ? this.camera : (this.isRunning = !0, this.duration = s, this.progress = 0, typeof a === 'number' ? this.intensity.set(a) : this.intensity.set(a.x, a.y), this._elapsed = 0, this._offsetX = 0, this._offsetY = 0, this._onUpdate = l, this._onUpdateScope = u, this.camera.emit(n.SHAKE_START, this.camera, this, s, a), this.camera) }, preRender: function () { this.isRunning && this.camera.matrix.translate(this._offsetX, this._offsetY) }, update: function (s, a) { if (this.isRunning) if (this._elapsed += a, this.progress = i(this._elapsed / this.duration, 0, 1), this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.camera, this.progress), this._elapsed < this.duration) { const f = this.intensity; const l = this.camera.width; const u = this.camera.height; const v = this.camera.zoom; this._offsetX = (Math.random() * f.x * l * 2 - f.x * l) * v, this._offsetY = (Math.random() * f.y * u * 2 - f.y * u) * v, this.camera.roundPixels && (this._offsetX = Math.round(this._offsetX), this._offsetY = Math.round(this._offsetY)) } else this.effectComplete() }, effectComplete: function () { this._offsetX = 0, this._offsetY = 0, this._onUpdate = null, this._onUpdateScope = null, this.isRunning = !1, this.camera.emit(n.SHAKE_COMPLETE, this.camera, this) }, reset: function () { this.isRunning = !1, this._offsetX = 0, this._offsetY = 0, this._onUpdate = null, this._onUpdateScope = null }, destroy: function () { this.reset(), this.camera = null, this.intensity = null } }); e.exports = r }, function (e, d, t) { const i = t(18); const h = t(0); const n = t(37); const o = t(134); const r = new h({ initialize: function (a) { this.camera = a, this.isRunning = !1, this.duration = 0, this.source = 0, this.current = 0, this.destination = 0, this.ease, this.progress = 0, this._elapsed = 0, this._onUpdate, this._onUpdateScope, this.clockwise = !0, this.shortestPath = !1 }, start: function (s, a, f, l, u, v, p) { f === void 0 && (f = 1e3), l === void 0 && (l = o.Linear), u === void 0 && (u = !1), v === void 0 && (v = null), p === void 0 && (p = this.camera.scene), a === void 0 && (a = !1), this.shortestPath = a; let c = s; s < 0 ? (c = -1 * s, this.clockwise = !1) : this.clockwise = !0; const m = 360 * Math.PI / 180; c = c - Math.floor(c / m) * m; const g = this.camera; if (!u && this.isRunning) return g; if (this.isRunning = !0, this.duration = f, this.progress = 0, this.source = g.rotation, this.destination = c, typeof l === 'string' && o.hasOwnProperty(l) ? this.ease = o[l] : typeof l === 'function' && (this.ease = l), this._elapsed = 0, this._onUpdate = v, this._onUpdateScope = p, this.shortestPath) { let x = 0; let y = 0; this.destination > this.source ? x = Math.abs(this.destination - this.source) : x = Math.abs(this.destination + m) - this.source, this.source > this.destination ? y = Math.abs(this.source - this.destination) : y = Math.abs(this.source + m) - this.destination, x < y ? this.clockwise = !0 : x > y && (this.clockwise = !1) } return this.camera.emit(n.ROTATE_START, this.camera, this, f, c), g }, update: function (s, a) { if (this.isRunning) { this._elapsed += a; const f = i(this._elapsed / this.duration, 0, 1); this.progress = f; const l = this.camera; if (this._elapsed < this.duration) { const u = this.ease(f); this.current = l.rotation; let v = 0; const p = 360 * Math.PI / 180; let c = this.destination; let m = this.current; this.clockwise === !1 && (c = this.current, m = this.destination), c >= m ? v = Math.abs(c - m) : v = Math.abs(c + p) - m; let g = 0; this.clockwise ? g = l.rotation + v * u : g = l.rotation - v * u, l.rotation = g, this._onUpdate && this._onUpdate.call(this._onUpdateScope, l, f, g) } else l.rotation = this.destination, this._onUpdate && this._onUpdate.call(this._onUpdateScope, l, f, this.destination), this.effectComplete() } }, effectComplete: function () { this._onUpdate = null, this._onUpdateScope = null, this.isRunning = !1, this.camera.emit(n.ROTATE_COMPLETE, this.camera, this) }, reset: function () { this.isRunning = !1, this._onUpdate = null, this._onUpdateScope = null }, destroy: function () { this.reset(), this.camera = null, this.source = null, this.destination = null } }); e.exports = r }, function (e, d, t) { const i = t(18); const h = t(0); const n = t(134); const o = t(37); const r = new h({ initialize: function (a) { this.camera = a, this.isRunning = !1, this.duration = 0, this.source = 1, this.destination = 1, this.ease, this.progress = 0, this._elapsed = 0, this._onUpdate, this._onUpdateScope }, start: function (s, a, f, l, u, v) { a === void 0 && (a = 1e3), f === void 0 && (f = n.Linear), l === void 0 && (l = !1), u === void 0 && (u = null), v === void 0 && (v = this.camera.scene); const p = this.camera; return !l && this.isRunning || (this.isRunning = !0, this.duration = a, this.progress = 0, this.source = p.zoom, this.destination = s, typeof f === 'string' && n.hasOwnProperty(f) ? this.ease = n[f] : typeof f === 'function' && (this.ease = f), this._elapsed = 0, this._onUpdate = u, this._onUpdateScope = v, this.camera.emit(o.ZOOM_START, this.camera, this, a, s)), p }, update: function (s, a) { !this.isRunning || (this._elapsed += a, this.progress = i(this._elapsed / this.duration, 0, 1), this._elapsed < this.duration ? (this.camera.zoom = this.source + (this.destination - this.source) * this.ease(this.progress), this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.camera, this.progress, this.camera.zoom)) : (this.camera.zoom = this.destination, this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.camera, this.progress, this.destination), this.effectComplete())) }, effectComplete: function () { this._onUpdate = null, this._onUpdateScope = null, this.isRunning = !1, this.camera.emit(o.ZOOM_COMPLETE, this.camera, this) }, reset: function () { this.isRunning = !1, this._onUpdate = null, this._onUpdateScope = null }, destroy: function () { this.reset(), this.camera = null } }); e.exports = r }, function (e, d, t) { const i = t(326); const h = t(0); const n = t(2); const o = t(24); const r = t(57); const s = t(104); const a = t(20); const f = new h({ initialize: function (u) { this.scene = u, this.systems = u.sys, this.roundPixels = u.sys.game.config.roundPixels, this.cameras = [], this.main, this.default, u.sys.events.once(a.BOOT, this.boot, this), u.sys.events.on(a.START, this.start, this) }, boot: function () { const l = this.systems; l.settings.cameras ? this.fromJSON(l.settings.cameras) : this.add(), this.main = this.cameras[0], this.default = new i(0, 0, l.scale.width, l.scale.height).setScene(this.scene), l.game.scale.on(s.RESIZE, this.onResize, this), this.systems.events.once(a.DESTROY, this.destroy, this) }, start: function () { if (!this.main) { const l = this.systems; l.settings.cameras ? this.fromJSON(l.settings.cameras) : this.add(), this.main = this.cameras[0] } const u = this.systems.events; u.on(a.UPDATE, this.update, this), u.once(a.SHUTDOWN, this.shutdown, this) }, add: function (l, u, v, p, c, m) { l === void 0 && (l = 0), u === void 0 && (u = 0), v === void 0 && (v = this.scene.sys.scale.width), p === void 0 && (p = this.scene.sys.scale.height), c === void 0 && (c = !1), m === void 0 && (m = ''); const g = new i(l, u, v, p); return g.setName(m), g.setScene(this.scene), g.setRoundPixels(this.roundPixels), g.id = this.getNextID(), this.cameras.push(g), c && (this.main = g), g }, addExisting: function (l, u) { u === void 0 && (u = !1); const v = this.cameras.indexOf(l); return v === -1 ? (l.id = this.getNextID(), l.setRoundPixels(this.roundPixels), this.cameras.push(l), u && (this.main = l), l) : null }, getNextID: function () { for (let l = this.cameras, u = 1, v = 0; v < 32; v++) { for (var p = !1, c = 0; c < l.length; c++) { const m = l[c]; if (m && m.id === u) { p = !0; continue } } if (p)u = u << 1; else return u } return 0 }, getTotal: function (l) { l === void 0 && (l = !1); for (var u = 0, v = this.cameras, p = 0; p < v.length; p++) { const c = v[p]; (!l || l && c.visible) && u++ } return u }, fromJSON: function (l) { Array.isArray(l) || (l = [l]); for (let u = this.scene.sys.scale.width, v = this.scene.sys.scale.height, p = 0; p < l.length; p++) { const c = l[p]; const m = n(c, 'x', 0); const g = n(c, 'y', 0); const x = n(c, 'width', u); const y = n(c, 'height', v); const T = this.add(m, g, x, y); T.name = n(c, 'name', ''), T.zoom = n(c, 'zoom', 1), T.rotation = n(c, 'rotation', 0), T.scrollX = n(c, 'scrollX', 0), T.scrollY = n(c, 'scrollY', 0), T.roundPixels = n(c, 'roundPixels', !1), T.visible = n(c, 'visible', !0); const S = n(c, 'backgroundColor', !1); S && T.setBackgroundColor(S); const E = n(c, 'bounds', null); if (E) { const C = n(E, 'x', 0); const P = n(E, 'y', 0); const A = n(E, 'width', u); const M = n(E, 'height', v); T.setBounds(C, P, A, M) } } return this }, getCamera: function (l) { for (let u = this.cameras, v = 0; v < u.length; v++) if (u[v].name === l) return u[v]; return null }, getCamerasBelowPointer: function (l) { for (var u = this.cameras, v = l.x, p = l.y, c = [], m = 0; m < u.length; m++) { const g = u[m]; g.visible && g.inputEnabled && r(g, v, p) && c.unshift(g) } return c }, remove: function (l, u) { u === void 0 && (u = !0), Array.isArray(l) || (l = [l]); for (var v = 0, p = this.cameras, c = 0; c < l.length; c++) { const m = p.indexOf(l[c]); m !== -1 && (u ? p[m].destroy() : p[m].renderList = [], p.splice(m, 1), v++) } return !this.main && p[0] && (this.main = p[0]), v }, render: function (l, u) { for (let v = this.scene, p = this.cameras, c = 0; c < this.cameras.length; c++) { const m = p[c]; if (m.visible && m.alpha > 0) { m.preRender(); const g = this.getVisibleChildren(u.getChildren(), m); l.render(v, g, m) } } }, getVisibleChildren: function (l, u) { for (var v = [], p = 0; p < l.length; p++) { const c = l[p]; c.willRender(u) && v.push(c) } return v }, resetAll: function () { for (let l = 0; l < this.cameras.length; l++) this.cameras[l].destroy(); return this.cameras = [], this.main = this.add(), this.main }, update: function (l, u) { for (let v = 0; v < this.cameras.length; v++) this.cameras[v].update(l, u) }, onResize: function (l, u, v, p, c) { for (let m = 0; m < this.cameras.length; m++) { const g = this.cameras[m]; g._x === 0 && g._y === 0 && g._width === p && g._height === c && g.setSize(u.width, u.height) } }, resize: function (l, u) { for (let v = 0; v < this.cameras.length; v++) this.cameras[v].setSize(l, u) }, shutdown: function () { this.main = void 0; for (let l = 0; l < this.cameras.length; l++) this.cameras[l].destroy(); this.cameras = []; const u = this.systems.events; u.off(a.UPDATE, this.update, this), u.off(a.SHUTDOWN, this.shutdown, this) }, destroy: function () { this.shutdown(), this.default.destroy(), this.scene.sys.events.off(a.START, this.start, this), this.scene = null, this.systems = null } }); o.register('CameraManager', f, 'cameras'), e.exports = f }, function (e, d) { e.exports = 'enterfullscreen' }, function (e, d) { e.exports = 'fullscreenfailed' }, function (e, d) { e.exports = 'fullscreenunsupported' }, function (e, d) { e.exports = 'leavefullscreen' }, function (e, d) { e.exports = 'orientationchange' }, function (e, d) { e.exports = 'resize' }, function (e, d, t) { e.exports = { Config: t(346), CreateRenderer: t(366), DebugHeader: t(384), Events: t(22), TimeStep: t(385), VisibilityHandler: t(387) } }, function (e, d) { const t = e.exports = {}; let i; let h; function n () { throw new Error('setTimeout has not been defined') } function o () { throw new Error('clearTimeout has not been defined') }(function () { try { typeof setTimeout === 'function' ? i = setTimeout : i = n } catch (g) { i = n } try { typeof clearTimeout === 'function' ? h = clearTimeout : h = o } catch (g) { h = o } })(); function r (g) { if (i === setTimeout) return setTimeout(g, 0); if ((i === n || !i) && setTimeout) return i = setTimeout, setTimeout(g, 0); try { return i(g, 0) } catch (x) { try { return i.call(null, g, 0) } catch (y) { return i.call(this, g, 0) } } } function s (g) { if (h === clearTimeout) return clearTimeout(g); if ((h === o || !h) && clearTimeout) return h = clearTimeout, clearTimeout(g); try { return h(g) } catch (x) { try { return h.call(null, g) } catch (y) { return h.call(this, g) } } } let a = []; let f = !1; let l; let u = -1; function v () { !f || !l || (f = !1, l.length ? a = l.concat(a) : u = -1, a.length && p()) } function p () { if (!f) { const g = r(v); f = !0; for (let x = a.length; x;) { for (l = a, a = []; ++u < x;)l && l[u].run(); u = -1, x = a.length }l = null, f = !1, s(g) } }t.nextTick = function (g) { const x = new Array(arguments.length - 1); if (arguments.length > 1) for (let y = 1; y < arguments.length; y++)x[y - 1] = arguments[y]; a.push(new c(g, x)), a.length === 1 && !f && r(p) }; function c (g, x) { this.fun = g, this.array = x }c.prototype.run = function () { this.fun.apply(null, this.array) }, t.title = 'browser', t.browser = !0, t.env = {}, t.argv = [], t.version = '', t.versions = {}; function m () {}t.on = m, t.addListener = m, t.once = m, t.off = m, t.removeListener = m, t.removeAllListeners = m, t.emit = m, t.prependListener = m, t.prependOnceListener = m, t.listeners = function (g) { return [] }, t.binding = function (g) { throw new Error('process.binding is not supported') }, t.cwd = function () { return '/' }, t.chdir = function (g) { throw new Error('process.chdir is not supported') }, t.umask = function () { return 0 } }, function (e, d, t) { const i = t(136); const h = { gamepads: !1, mspointer: !1, touch: !1, wheelEvent: null }; function n () { return typeof importScripts === 'function' || (('ontouchstart' in document.documentElement || navigator.maxTouchPoints && navigator.maxTouchPoints >= 1) && (h.touch = !0), (navigator.msPointerEnabled || navigator.pointerEnabled) && (h.mspointer = !0), navigator.getGamepads && (h.gamepads = !0), 'onwheel' in window || i.ie && 'WheelEvent' in window ? h.wheelEvent = 'wheel' : 'onmousewheel' in window ? h.wheelEvent = 'mousewheel' : i.firefox && 'MouseScrollEvent' in window && (h.wheelEvent = 'DOMMouseScroll')), h }e.exports = n() }, function (e, d, t) { const i = t(136); const h = { audioData: !1, dolby: !1, m4a: !1, mp3: !1, ogg: !1, opus: !1, wav: !1, webAudio: !1, webm: !1 }; function n () { if (typeof importScripts === 'function') return h; h.audioData = !!window.Audio, h.webAudio = !!(window.AudioContext || window.webkitAudioContext); const o = document.createElement('audio'); const r = !!o.canPlayType; try { if (r && (o.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, '') && (h.ogg = !0), (o.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, '') || o.canPlayType('audio/opus;').replace(/^no$/, '')) && (h.opus = !0), o.canPlayType('audio/mpeg;').replace(/^no$/, '') && (h.mp3 = !0), o.canPlayType('audio/wav').replace(/^no$/, '') && (h.wav = !0), (o.canPlayType('audio/x-m4a;') || o.canPlayType('audio/aac;').replace(/^no$/, '')) && (h.m4a = !0), o.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, '') && (h.webm = !0), o.canPlayType('audio/mp4;codecs="ec-3"') !== '')) { if (i.edge)h.dolby = !0; else if (i.safari && i.safariVersion >= 9 && /Mac OS X (\d+)_(\d+)/.test(navigator.userAgent)) { const s = parseInt(RegExp.$1, 10); const a = parseInt(RegExp.$2, 10); (s === 10 && a >= 11 || s > 10) && (h.dolby = !0) } } } catch (f) {} return h }e.exports = n() }, function (e, d) { const t = { h264: !1, hls: !1, mp4: !1, ogg: !1, vp9: !1, webm: !1 }; function i () { if (typeof importScripts === 'function') return t; const h = document.createElement('video'); const n = !!h.canPlayType; try { n && (h.canPlayType('video/ogg; codecs="theora"').replace(/^no$/, '') && (t.ogg = !0), h.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/, '') && (t.h264 = !0, t.mp4 = !0), h.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/, '') && (t.webm = !0), h.canPlayType('video/webm; codecs="vp9"').replace(/^no$/, '') && (t.vp9 = !0), h.canPlayType('application/x-mpegURL; codecs="avc1.42E01E"').replace(/^no$/, '') && (t.hls = !0)) } catch (o) {} return t }e.exports = i() }, function (e, d) { const t = { available: !1, cancel: '', keyboard: !1, request: '' }; function i () { if (typeof importScripts === 'function') return t; let h; const n = 'Fullscreen'; const o = 'FullScreen'; const r = ['request' + n, 'request' + o, 'webkitRequest' + n, 'webkitRequest' + o, 'msRequest' + n, 'msRequest' + o, 'mozRequest' + o, 'mozRequest' + n]; for (h = 0; h < r.length; h++) if (document.documentElement[r[h]]) { t.available = !0, t.request = r[h]; break } const s = ['cancel' + o, 'exit' + n, 'webkitCancel' + o, 'webkitExit' + n, 'msCancel' + o, 'msExit' + n, 'mozCancel' + o, 'mozExit' + n]; if (t.available) { for (h = 0; h < s.length; h++) if (document[s[h]]) { t.cancel = s[h]; break } } return window.Element && Element.ALLOW_KEYBOARD_INPUT && !/ Version\/5\.1(?:\.\d+)? Safari\//.test(navigator.userAgent) && (t.keyboard = !0), Object.defineProperty(t, 'active', { get: function () { return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) } }), t }e.exports = i() }, function (e, d, t) { e.exports = { Between: t(349), BetweenPoints: t(350), BetweenPointsY: t(813), BetweenY: t(814), CounterClockwise: t(815), Normalize: t(351), Random: t(816), RandomDegrees: t(817), Reverse: t(818), RotateTo: t(819), ShortestBetween: t(820), Wrap: t(269), WrapDegrees: t(270) } }, function (e, d) { const t = function (i, h) { return Math.atan2(h.x - i.x, h.y - i.y) }; e.exports = t }, function (e, d) { const t = function (i, h, n, o) { return Math.atan2(n - i, o - h) }; e.exports = t }, function (e, d, t) { const i = t(14); const h = function (n) { return n > Math.PI && (n -= i.PI2), Math.abs(((n + i.TAU) % i.PI2 - i.PI2) % i.PI2) }; e.exports = h }, function (e, d, t) { const i = t(137); const h = function () { return i(-Math.PI, Math.PI) }; e.exports = h }, function (e, d, t) { const i = t(137); const h = function () { return i(-180, 180) }; e.exports = h }, function (e, d, t) { const i = t(351); const h = function (n) { return i(n + Math.PI) }; e.exports = h }, function (e, d, t) { const i = t(14); const h = function (n, o, r) { return r === void 0 && (r = 0.05), n === o || (Math.abs(o - n) <= r || Math.abs(o - n) >= i.PI2 - r ? n = o : (Math.abs(o - n) > Math.PI && (o < n ? o += i.PI2 : o -= i.PI2), o > n ? n += r : o < n && (n -= r))), n }; e.exports = h }, function (e, d) { const t = function (i, h) { const n = h - i; if (n === 0) return 0; const o = Math.floor((n - -180) / 360); return n - o * 360 }; e.exports = t }, function (e, d, t) { e.exports = { Between: t(50), BetweenPoints: t(352), BetweenPointsSquared: t(822), Chebyshev: t(823), Power: t(824), Snake: t(825), Squared: t(353) } }, function (e, d) { const t = function (i, h) { const n = i.x - h.x; const o = i.y - h.y; return n * n + o * o }; e.exports = t }, function (e, d) { const t = function (i, h, n, o) { return Math.max(Math.abs(i - n), Math.abs(h - o)) }; e.exports = t }, function (e, d) { const t = function (i, h, n, o, r) { return r === void 0 && (r = 2), Math.sqrt(Math.pow(n - i, r) + Math.pow(o - h, r)) }; e.exports = t }, function (e, d) { const t = function (i, h, n, o) { return Math.abs(i - n) + Math.abs(h - o) }; e.exports = t }, function (e, d, t) { e.exports = { Back: t(334), Bounce: t(335), Circular: t(336), Cubic: t(337), Elastic: t(338), Expo: t(339), Linear: t(340), Quadratic: t(341), Quartic: t(342), Quintic: t(343), Sine: t(344), Stepped: t(345) } }, function (e, d, t) { e.exports = { Ceil: t(828), Equal: t(124), Floor: t(829), GreaterThan: t(354), LessThan: t(355) } }, function (e, d) { const t = function (i, h) { return h === void 0 && (h = 1e-4), Math.ceil(i - h) }; e.exports = t }, function (e, d) { const t = function (i, h) { return h === void 0 && (h = 1e-4), Math.floor(i + h) }; e.exports = t }, function (e, d, t) { e.exports = { Bezier: t(831), CatmullRom: t(832), CubicBezier: t(358), Linear: t(833), QuadraticBezier: t(359), SmoothStep: t(360), SmootherStep: t(834) } }, function (e, d, t) { const i = t(356); const h = function (n, o) { for (var r = 0, s = n.length - 1, a = 0; a <= s; a++)r += Math.pow(1 - o, s - a) * Math.pow(o, a) * n[a] * i(s, a); return r }; e.exports = h }, function (e, d, t) { const i = t(194); const h = function (n, o) { const r = n.length - 1; let s = r * o; let a = Math.floor(s); return n[0] === n[r] ? (o < 0 && (a = Math.floor(s = r * (1 + o))), i(s - a, n[(a - 1 + r) % r], n[a], n[(a + 1) % r], n[(a + 2) % r])) : o < 0 ? n[0] - (i(-s, n[0], n[0], n[1], n[1]) - n[0]) : o > 1 ? n[r] - (i(s - r, n[r], n[r], n[r - 1], n[r - 1]) - n[r]) : i(s - a, n[a ? a - 1 : 0], n[a], n[r < a + 1 ? r : a + 1], n[r < a + 2 ? r : a + 2]) }; e.exports = h }, function (e, d, t) { const i = t(135); const h = function (n, o) { const r = n.length - 1; const s = r * o; const a = Math.floor(s); return o < 0 ? i(n[0], n[1], s) : o > 1 ? i(n[r], n[r - 1], r - s) : i(n[a], n[a + 1 > r ? r : a + 1], s - a) }; e.exports = h }, function (e, d, t) { const i = t(183); const h = function (n, o, r) { return o + (r - o) * i(n, 0, 1) }; e.exports = h }, function (e, d, t) { e.exports = { GetNext: t(361), IsSize: t(138), IsValue: t(836) } }, function (e, d) { const t = function (i) { return i > 0 && (i & i - 1) == 0 }; e.exports = t }, function (e, d, t) { e.exports = { Ceil: t(139), Floor: t(76), To: t(838) } }, function (e, d) { const t = function (i, h, n, o) { return n === void 0 && (n = 0), h === 0 ? i : (i -= n, i = h * Math.round(i / h), o ? (n + i) / h : n + i) }; e.exports = t }, function (e, d, t) { const i = t(0); const h = new i({ initialize: function (o) { o === void 0 && (o = [(Date.now() * Math.random()).toString()]), this.c = 1, this.s0 = 0, this.s1 = 0, this.s2 = 0, this.n = 0, this.signs = [-1, 1], o && this.init(o) }, rnd: function () { const n = 2091639 * this.s0 + this.c * 23283064365386963e-26; return this.c = n | 0, this.s0 = this.s1, this.s1 = this.s2, this.s2 = n - this.c, this.s2 }, hash: function (n) { let o; let r = this.n; n = n.toString(); for (let s = 0; s < n.length; s++)r += n.charCodeAt(s), o = 0.02519603282416938 * r, r = o >>> 0, o -= r, o *= r, r = o >>> 0, o -= r, r += o * 4294967296; return this.n = r, (r >>> 0) * 23283064365386963e-26 }, init: function (n) { typeof n === 'string' ? this.state(n) : this.sow(n) }, sow: function (n) { if (this.n = 4022871197, this.s0 = this.hash(' '), this.s1 = this.hash(' '), this.s2 = this.hash(' '), this.c = 1, !!n) for (let o = 0; o < n.length && n[o] != null; o++) { const r = n[o]; this.s0 -= this.hash(r), this.s0 += ~~(this.s0 < 0), this.s1 -= this.hash(r), this.s1 += ~~(this.s1 < 0), this.s2 -= this.hash(r), this.s2 += ~~(this.s2 < 0) } }, integer: function () { return this.rnd() * 4294967296 }, frac: function () { return this.rnd() + (this.rnd() * 2097152 | 0) * 11102230246251565e-32 }, real: function () { return this.integer() + this.frac() }, integerInRange: function (n, o) { return Math.floor(this.realInRange(0, o - n + 1) + n) }, between: function (n, o) { return Math.floor(this.realInRange(0, o - n + 1) + n) }, realInRange: function (n, o) { return this.frac() * (o - n) + n }, normal: function () { return 1 - 2 * this.frac() }, uuid: function () { let n = ''; let o = ''; for (o = n = ''; n++ < 36; o += ~n % 5 | n * 3 & 4 ? (n ^ 15 ? 8 ^ this.frac() * (n ^ 20 ? 16 : 4) : 4).toString(16) : '-');return o }, pick: function (n) { return n[this.integerInRange(0, n.length - 1)] }, sign: function () { return this.pick(this.signs) }, weightedPick: function (n) { return n[~~(Math.pow(this.frac(), 2) * (n.length - 1) + 0.5)] }, timestamp: function (n, o) { return this.realInRange(n || 9466848e5, o || 1577862e6) }, angle: function () { return this.integerInRange(-180, 180) }, rotation: function () { return this.realInRange(-3.1415926, 3.1415926) }, state: function (n) { return typeof n === 'string' && n.match(/^!rnd/) && (n = n.split(','), this.c = parseFloat(n[1]), this.s0 = parseFloat(n[2]), this.s1 = parseFloat(n[3]), this.s2 = parseFloat(n[4])), ['!rnd', this.c, this.s0, this.s1, this.s2].join(',') }, shuffle: function (n) { for (let o = n.length - 1, r = o; r > 0; r--) { const s = Math.floor(this.frac() * (r + 1)); const a = n[s]; n[s] = n[r], n[r] = a } return n } }); e.exports = h }, function (e, d) { const t = function (i) { for (var h = 0, n = 0; n < i.length; n++)h += +i[n]; return h / i.length }; e.exports = t }, function (e, d) { const t = function (i, h, n) { h === void 0 && (h = 0), n === void 0 && (n = 10); const o = Math.pow(n, -h); return Math.ceil(i * o) / o }; e.exports = t }, function (e, d) { const t = function (i, h) { return Math.abs(i - h) }; e.exports = t }, function (e, d, t) { const i = t(18); const h = t(0); const n = t(69); const o = t(1); const r = new n(); const s = new h({ initialize: function a (f, l, u, v) { f === void 0 && (f = 0), l === void 0 && (l = 0), u === void 0 && (u = 0), v === void 0 && (v = a.DefaultOrder), this._x = f, this._y = l, this._z = u, this._order = v, this.onChangeCallback = o }, x: { get: function () { return this._x }, set: function (a) { this._x = a, this.onChangeCallback(this) } }, y: { get: function () { return this._y }, set: function (a) { this._y = a, this.onChangeCallback(this) } }, z: { get: function () { return this._z }, set: function (a) { this._z = a, this.onChangeCallback(this) } }, order: { get: function () { return this._order }, set: function (a) { this._order = a, this.onChangeCallback(this) } }, set: function (a, f, l, u) { return u === void 0 && (u = this._order), this._x = a, this._y = f, this._z = l, this._order = u, this.onChangeCallback(this), this }, copy: function (a) { return this.set(a.x, a.y, a.z, a.order) }, setFromQuaternion: function (a, f, l) { return f === void 0 && (f = this._order), l === void 0 && (l = !1), r.fromQuat(a), this.setFromRotationMatrix(r, f, l) }, setFromRotationMatrix: function (a, f, l) { f === void 0 && (f = this._order), l === void 0 && (l = !1); const u = a.val; const v = u[0]; const p = u[4]; const c = u[8]; const m = u[1]; const g = u[5]; const x = u[9]; const y = u[2]; const T = u[6]; const S = u[10]; let E = 0; let C = 0; let P = 0; const A = 0.99999; switch (f) { case 'XYZ': { C = Math.asin(i(c, -1, 1)), Math.abs(c) < A ? (E = Math.atan2(-x, S), P = Math.atan2(-p, v)) : E = Math.atan2(T, g); break } case 'YXZ': { E = Math.asin(-i(x, -1, 1)), Math.abs(x) < A ? (C = Math.atan2(c, S), P = Math.atan2(m, g)) : C = Math.atan2(-y, v); break } case 'ZXY': { E = Math.asin(i(T, -1, 1)), Math.abs(T) < A ? (C = Math.atan2(-y, S), P = Math.atan2(-p, g)) : P = Math.atan2(m, v); break } case 'ZYX': { C = Math.asin(-i(y, -1, 1)), Math.abs(y) < A ? (E = Math.atan2(T, S), P = Math.atan2(m, v)) : P = Math.atan2(-p, g); break } case 'YZX': { P = Math.asin(i(m, -1, 1)), Math.abs(m) < A ? (E = Math.atan2(-x, g), C = Math.atan2(-y, v)) : C = Math.atan2(c, S); break } case 'XZY': { P = Math.asin(-i(p, -1, 1)), Math.abs(p) < A ? (E = Math.atan2(T, g), C = Math.atan2(c, v)) : E = Math.atan2(-x, S); break } } return this._x = E, this._y = C, this._z = P, this._order = f, l && this.onChangeCallback(this), this } }); s.RotationOrders = ['XYZ', 'YXZ', 'ZXY', 'ZYX', 'YZX', 'XZY'], s.DefaultOrder = 'XYZ', e.exports = s }, function (e, d) { const t = function (i, h, n) { h === void 0 && (h = 0), n === void 0 && (n = 10); const o = Math.pow(n, -h); return Math.floor(i * o) / o }; e.exports = t }, function (e, d) { const t = function (i, h) { return i / h / 1e3 }; e.exports = t }, function (e, d) { const t = function (i) { return i == parseFloat(i) ? !(i % 2) : void 0 }; e.exports = t }, function (e, d) { const t = function (i) { return i === parseFloat(i) ? !(i % 2) : void 0 }; e.exports = t }, function (e, d) { const t = function (i, h, n) { return Math.min(i + h, n) }; e.exports = t }, function (e, d) { const t = function (i) { const h = i.length; if (h === 0) return 0; i.sort(function (o, r) { return o - r }); const n = Math.floor(h / 2); return h % 2 == 0 ? (i[n] + i[n - 1]) / 2 : i[n] }; e.exports = t }, function (e, d) { const t = function (i, h, n) { return Math.max(i - h, n) }; e.exports = t }, function (e, d) { const t = function (i, h, n, o) { n === void 0 && (n = h + 1); let r = (i - h) / (n - h); return r > 1 ? o !== void 0 ? (r = (o - i) / (o - n), r < 0 && (r = 0)) : r = 1 : r < 0 && (r = 0), r }; e.exports = t }, function (e, d) { const t = function (i, h) { h === void 0 && (h = 1); const n = Math.random() * 2 * Math.PI; return i.x = Math.cos(n) * h, i.y = Math.sin(n) * h, i }; e.exports = t }, function (e, d) { const t = function (i, h) { h === void 0 && (h = 1); const n = Math.random() * 2 * Math.PI; const o = Math.random() * 2 - 1; const r = Math.sqrt(1 - o * o) * h; return i.x = Math.cos(n) * r, i.y = Math.sin(n) * r, i.z = o * h, i }; e.exports = t }, function (e, d) { const t = function (i, h) { return h === void 0 && (h = 1), i.x = (Math.random() * 2 - 1) * h, i.y = (Math.random() * 2 - 1) * h, i.z = (Math.random() * 2 - 1) * h, i.w = (Math.random() * 2 - 1) * h, i }; e.exports = t }, function (e, d) { const t = function (i, h, n, o, r) { return i.x = h + r * Math.cos(o), i.y = n + r * Math.sin(o), i }; e.exports = t }, function (e, d) { const t = function (i, h, n) { h === void 0 && (h = 0), n === void 0 && (n = 10); const o = Math.pow(n, -h); return Math.round(i * o) / o }; e.exports = t }, function (e, d) { const t = function (i, h, n, o) { h === void 0 && (h = 1), n === void 0 && (n = 1), o === void 0 && (o = 1), o *= Math.PI / i; for (var r = [], s = [], a = 0; a < i; a++)n -= h * o, h += n * o, r[a] = n, s[a] = h; return { sin: s, cos: r, length: i } }; e.exports = t }, function (e, d, t) { const i = t(3); const h = function (n, o, r, s) { s === void 0 && (s = new i()); let a = 0; let f = 0; const l = o * r; return n > 0 && n <= l && (n > o - 1 ? (f = Math.floor(n / o), a = n - f * o) : a = n), s.set(a, f) }; e.exports = h }, function (e, d) { const t = function (i, h, n) { return Math.abs(i - h) <= n }; e.exports = t }, function (e, d, t) { const i = t(39); const h = t(69); const n = t(365); const o = new h(); const r = new n(); const s = new i(); const a = function (f, l, u) { return r.setAxisAngle(l, u), o.fromRotationTranslation(r, s.set(0, 0, 0)), f.transformMat4(o) }; e.exports = a }, function (e, d) { e.exports = 'addtexture' }, function (e, d) { e.exports = 'onerror' }, function (e, d) { e.exports = 'onload' }, function (e, d) { e.exports = 'ready' }, function (e, d) { e.exports = 'removetexture' }, function (e, d) {
        e.exports = ['#define SHADER_NAME PHASER_BITMAP_MASK_FS', '', 'precision mediump float;', '', 'uniform vec2 uResolution;', 'uniform sampler2D uMainSampler;', 'uniform sampler2D uMaskSampler;', 'uniform bool uInvertMaskAlpha;', '', 'void main ()', '{', '    vec2 uv = gl_FragCoord.xy / uResolution;', '    vec4 mainColor = texture2D(uMainSampler, uv);', '    vec4 maskColor = texture2D(uMaskSampler, uv);', '    float alpha = mainColor.a;', '', '    if (!uInvertMaskAlpha)', '    {', '        alpha *= (maskColor.a);', '    }', '    else', '    {', '        alpha *= (1.0 - maskColor.a);', '    }', '', '    gl_FragColor = vec4(mainColor.rgb * alpha, alpha);', '}', ''].join(`
`)
      }, function (e, d) {
        e.exports = ['#define SHADER_NAME PHASER_BITMAP_MASK_VS', '', 'precision mediump float;', '', 'attribute vec2 inPosition;', '', 'void main ()', '{', '    gl_Position = vec4(inPosition, 0.0, 1.0);', '}', ''].join(`
`)
      }, function (e, d) { e.exports = 'pipelineafterflush' }, function (e, d) { e.exports = 'pipelinebeforeflush' }, function (e, d) { e.exports = 'pipelinebind' }, function (e, d) { e.exports = 'pipelineboot' }, function (e, d) { e.exports = 'pipelinedestroy' }, function (e, d) { e.exports = 'pipelinerebind' }, function (e, d) { e.exports = 'pipelineresize' }, function (e, d) {
        e.exports = ['#define SHADER_NAME PHASER_GRAPHICS_FS', '', 'precision mediump float;', '', 'varying vec4 outColor;', '', 'void main ()', '{', '    gl_FragColor = vec4(outColor.bgr * outColor.a, outColor.a);', '}', ''].join(`
`)
      }, function (e, d) {
        e.exports = ['#define SHADER_NAME PHASER_GRAPHICS_VS', '', 'precision mediump float;', '', 'uniform mat4 uProjectionMatrix;', '', 'attribute vec2 inPosition;', 'attribute vec4 inColor;', '', 'varying vec4 outColor;', '', 'void main ()', '{', '    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);', '', '    outColor = inColor;', '}', ''].join(`
`)
      }, function (e, d) {
        e.exports = ['#define SHADER_NAME PHASER_LIGHT_FS', '', 'precision mediump float;', '', 'struct Light', '{', '    vec2 position;', '    vec3 color;', '    float intensity;', '    float radius;', '};', '', 'const int kMaxLights = %LIGHT_COUNT%;', '', 'uniform vec4 uCamera; /* x, y, rotation, zoom */', 'uniform vec2 uResolution;', 'uniform sampler2D uMainSampler;', 'uniform sampler2D uNormSampler;', 'uniform vec3 uAmbientLightColor;', 'uniform Light uLights[kMaxLights];', 'uniform mat3 uInverseRotationMatrix;', '', 'varying vec2 outTexCoord;', 'varying vec4 outTint;', '', 'void main()', '{', '    vec3 finalColor = vec3(0.0, 0.0, 0.0);', '    vec4 color = texture2D(uMainSampler, outTexCoord) * vec4(outTint.bgr * outTint.a, outTint.a);', '    vec3 normalMap = texture2D(uNormSampler, outTexCoord).rgb;', '    vec3 normal = normalize(uInverseRotationMatrix * vec3(normalMap * 2.0 - 1.0));', '    vec2 res = vec2(min(uResolution.x, uResolution.y)) * uCamera.w;', '', '    for (int index = 0; index < kMaxLights; ++index)', '    {', '        Light light = uLights[index];', '        vec3 lightDir = vec3((light.position.xy / res) - (gl_FragCoord.xy / res), 0.1);', '        vec3 lightNormal = normalize(lightDir);', '        float distToSurf = length(lightDir) * uCamera.w;', '        float diffuseFactor = max(dot(normal, lightNormal), 0.0);', '        float radius = (light.radius / res.x * uCamera.w) * uCamera.w;', '        float attenuation = clamp(1.0 - distToSurf * distToSurf / (radius * radius), 0.0, 1.0);', '        vec3 diffuse = light.color * diffuseFactor;', '        finalColor += (attenuation * diffuse) * light.intensity;', '    }', '', '    vec4 colorOutput = vec4(uAmbientLightColor + finalColor, 1.0);', '', '    gl_FragColor = color * vec4(colorOutput.rgb * colorOutput.a, colorOutput.a);', '}', ''].join(`
`)
      }, function (e, d) {
        e.exports = ['#define SHADER_NAME PHASER_MULTI_FS', '', 'precision mediump float;', '', 'uniform sampler2D uMainSampler[%count%];', '', 'varying vec2 outTexCoord;', 'varying float outTexId;', 'varying float outTintEffect;', 'varying vec4 outTint;', '', 'void main ()', '{', '    vec4 texture;', '', '    %forloop%', '', '    vec4 texel = vec4(outTint.bgr * outTint.a, outTint.a);', '', '    //  Multiply texture tint', '    vec4 color = texture * texel;', '', '    if (outTintEffect == 1.0)', '    {', '        //  Solid color + texture alpha', '        color.rgb = mix(texture.rgb, outTint.bgr * outTint.a, texture.a);', '    }', '    else if (outTintEffect == 2.0)', '    {', '        //  Solid color, no texture', '        color = texel;', '    }', '', '    gl_FragColor = color;', '}', ''].join(`
`)
      }, function (e, d) {
        e.exports = ['#define SHADER_NAME PHASER_MULTI_VS', '', 'precision mediump float;', '', 'uniform mat4 uProjectionMatrix;', '', 'attribute vec2 inPosition;', 'attribute vec2 inTexCoord;', 'attribute float inTexId;', 'attribute float inTintEffect;', 'attribute vec4 inTint;', '', 'varying vec2 outTexCoord;', 'varying float outTexId;', 'varying float outTintEffect;', 'varying vec4 outTint;', '', 'void main ()', '{', '    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);', '', '    outTexCoord = inTexCoord;', '    outTexId = inTexId;', '    outTint = inTint;', '    outTintEffect = inTintEffect;', '}', ''].join(`
`)
      }, function (e, d) {
        e.exports = ['#define SHADER_NAME PHASER_POINTLIGHT_FS', '', 'precision mediump float;', '', 'uniform vec2 uResolution;', 'uniform float uCameraZoom;', '', 'varying vec4 lightPosition;', 'varying vec4 lightColor;', 'varying float lightRadius;', 'varying float lightAttenuation;', '', 'void main ()', '{', '    vec2 center = (lightPosition.xy + 1.0) * (uResolution.xy * 0.5);', '', '    float distToSurf = length(center - gl_FragCoord.xy);', '', '    float radius = 1.0 - distToSurf / (lightRadius * uCameraZoom);', '', '    float intensity = smoothstep(0.0, 1.0, radius * lightAttenuation);', '', '    vec4 color = vec4(intensity, intensity, intensity, 0.0) * lightColor;', '', '    gl_FragColor = vec4(color.rgb * lightColor.a, color.a);', '}', ''].join(`
`)
      }, function (e, d) {
        e.exports = ['#define SHADER_NAME PHASER_POINTLIGHT_VS', '', 'precision mediump float;', '', 'uniform mat4 uProjectionMatrix;', '', 'attribute vec2 inPosition;', 'attribute vec2 inLightPosition;', 'attribute vec4 inLightColor;', 'attribute float inLightRadius;', 'attribute float inLightAttenuation;', '', 'varying vec4 lightPosition;', 'varying vec4 lightColor;', 'varying float lightRadius;', 'varying float lightAttenuation;', '', 'void main ()', '{', '    lightColor = inLightColor;', '    lightRadius = inLightRadius;', '    lightAttenuation = inLightAttenuation;', '    lightPosition = uProjectionMatrix * vec4(inLightPosition, 1.0, 1.0);', '', '    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);', '}', ''].join(`
`)
      }, function (e, d) {
        e.exports = ['#define SHADER_NAME PHASER_SINGLE_FS', '', 'precision mediump float;', '', 'uniform sampler2D uMainSampler;', '', 'varying vec2 outTexCoord;', 'varying float outTintEffect;', 'varying vec4 outTint;', '', 'void main ()', '{', '    vec4 texture = texture2D(uMainSampler, outTexCoord);', '    vec4 texel = vec4(outTint.bgr * outTint.a, outTint.a);', '', '    //  Multiply texture tint', '    vec4 color = texture * texel;', '', '    if (outTintEffect == 1.0)', '    {', '        //  Solid color + texture alpha', '        color.rgb = mix(texture.rgb, outTint.bgr * outTint.a, texture.a);', '    }', '    else if (outTintEffect == 2.0)', '    {', '        //  Solid color, no texture', '        color = texel;', '    }', '', '    gl_FragColor = color;', '}', ''].join(`
`)
      }, function (e, d) {
        e.exports = ['#define SHADER_NAME PHASER_SINGLE_VS', '', 'precision mediump float;', '', 'uniform mat4 uProjectionMatrix;', '', 'attribute vec2 inPosition;', 'attribute vec2 inTexCoord;', 'attribute float inTexId;', 'attribute float inTintEffect;', 'attribute vec4 inTint;', '', 'varying vec2 outTexCoord;', 'varying float outTintEffect;', 'varying vec4 outTint;', '', 'void main ()', '{', '    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);', '', '    outTexCoord = inTexCoord;', '    outTint = inTint;', '    outTintEffect = inTintEffect;', '}', ''].join(`
`)
      }, function (e, d) {
        e.exports = ['#define SHADER_NAME PHASER_ADD_BLEND_FS', '', 'precision mediump float;', '', 'uniform sampler2D uMainSampler1;', 'uniform sampler2D uMainSampler2;', 'uniform float uStrength;', '', 'varying vec2 outTexCoord;', '', 'void main ()', '{', '    vec4 frame1 = texture2D(uMainSampler1, outTexCoord);', '    vec4 frame2 = texture2D(uMainSampler2, outTexCoord);', '', '    gl_FragColor = frame1 + frame2 * uStrength;', '}', ''].join(`
`)
      }, function (e, d) {
        e.exports = ['#define SHADER_NAME PHASER_COLORMATRIX_FS', '', 'precision mediump float;', '', 'uniform sampler2D uMainSampler;', 'uniform float uColorMatrix[20];', 'uniform float uAlpha;', '', 'varying vec2 outTexCoord;', '', 'void main ()', '{', '    vec4 c = texture2D(uMainSampler, outTexCoord);', '', '    if (uAlpha == 0.0)', '    {', '        gl_FragColor = c;', '', '        return;', '    }', '', '    if (c.a > 0.0)', '    {', '        c.rgb /= c.a;', '    }', '', '    vec4 result;', '', '    result.r = (uColorMatrix[0] * c.r) + (uColorMatrix[1] * c.g) + (uColorMatrix[2] * c.b) + (uColorMatrix[3] * c.a) + uColorMatrix[4];', '    result.g = (uColorMatrix[5] * c.r) + (uColorMatrix[6] * c.g) + (uColorMatrix[7] * c.b) + (uColorMatrix[8] * c.a) + uColorMatrix[9];', '    result.b = (uColorMatrix[10] * c.r) + (uColorMatrix[11] * c.g) + (uColorMatrix[12] * c.b) + (uColorMatrix[13] * c.a) + uColorMatrix[14];', '    result.a = (uColorMatrix[15] * c.r) + (uColorMatrix[16] * c.g) + (uColorMatrix[17] * c.b) + (uColorMatrix[18] * c.a) + uColorMatrix[19];', '', '    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);', '', '    rgb *= result.a;', '', '    gl_FragColor = vec4(rgb, result.a);', '}', ''].join(`
`)
      }, function (e, d) {
        e.exports = ['#define SHADER_NAME PHASER_COPY_FS', '', 'precision mediump float;', '', 'uniform sampler2D uMainSampler;', 'uniform float uBrightness;', '', 'varying vec2 outTexCoord;', '', 'void main ()', '{', '    gl_FragColor = texture2D(uMainSampler, outTexCoord) * uBrightness;', '}', ''].join(`
`)
      }, function (e, d) {
        e.exports = ['#define SHADER_NAME PHASER_LINEAR_BLEND_FS', '', 'precision mediump float;', '', 'uniform sampler2D uMainSampler1;', 'uniform sampler2D uMainSampler2;', 'uniform float uStrength;', '', 'varying vec2 outTexCoord;', '', 'void main ()', '{', '    vec4 frame1 = texture2D(uMainSampler1, outTexCoord);', '    vec4 frame2 = texture2D(uMainSampler2, outTexCoord);', '', '    gl_FragColor = mix(frame1, frame2 * uStrength, 0.5);', '}', ''].join(`
`)
      }, function (e, d, t) { e.exports = { GenerateTexture: t(388), Palettes: t(889) } }, function (e, d, t) { e.exports = { ARNE16: t(389), C64: t(890), CGA: t(891), JMP: t(892), MSX: t(893) } }, function (e, d) { e.exports = { 0: '#000', 1: '#fff', 2: '#8b4131', 3: '#7bbdc5', 4: '#8b41ac', 5: '#6aac41', 6: '#3931a4', 7: '#d5de73', 8: '#945a20', 9: '#5a4100', A: '#bd736a', B: '#525252', C: '#838383', D: '#acee8b', E: '#7b73de', F: '#acacac' } }, function (e, d) { e.exports = { 0: '#000', 1: '#2234d1', 2: '#0c7e45', 3: '#44aacc', 4: '#8a3622', 5: '#5c2e78', 6: '#aa5c3d', 7: '#b5b5b5', 8: '#5e606e', 9: '#4c81fb', A: '#6cd947', B: '#7be2f9', C: '#eb8a60', D: '#e23d69', E: '#ffd93f', F: '#fff' } }, function (e, d) { e.exports = { 0: '#000', 1: '#191028', 2: '#46af45', 3: '#a1d685', 4: '#453e78', 5: '#7664fe', 6: '#833129', 7: '#9ec2e8', 8: '#dc534b', 9: '#e18d79', A: '#d6b97b', B: '#e9d8a1', C: '#216c4b', D: '#d365c8', E: '#afaab9', F: '#f5f4eb' } }, function (e, d) { e.exports = { 0: '#000', 1: '#191028', 2: '#46af45', 3: '#a1d685', 4: '#453e78', 5: '#7664fe', 6: '#833129', 7: '#9ec2e8', 8: '#dc534b', 9: '#e18d79', A: '#d6b97b', B: '#e9d8a1', C: '#216c4b', D: '#d365c8', E: '#afaab9', F: '#fff' } }, function (e, d, t) { e.exports = { Path: t(895), MoveTo: t(393), CubicBezier: t(390), Curve: t(94), Ellipse: t(391), Line: t(392), QuadraticBezier: t(394), Spline: t(395) } }, function (e, d, t) { const i = t(0); const h = t(390); const n = t(391); const o = t(5); const r = t(392); const s = t(393); const a = t(394); const f = t(10); const l = t(395); const u = t(3); const v = t(14); const p = new i({ initialize: function (m, g) { m === void 0 && (m = 0), g === void 0 && (g = 0), this.name = '', this.curves = [], this.cacheLengths = [], this.autoClose = !1, this.startPoint = new u(), this._tmpVec2A = new u(), this._tmpVec2B = new u(), typeof m === 'object' ? this.fromJSON(m) : this.startPoint.set(m, g) }, add: function (c) { return this.curves.push(c), this }, circleTo: function (c, m, g) { return m === void 0 && (m = !1), this.ellipseTo(c, c, 0, 360, m, g) }, closePath: function () { const c = this.curves[0].getPoint(0); const m = this.curves[this.curves.length - 1].getPoint(1); return c.equals(m) || this.curves.push(new r(m, c)), this }, cubicBezierTo: function (c, m, g, x, y, T) { const S = this.getEndPoint(); let E; let C; let P; return c instanceof u ? (E = c, C = m, P = g) : (E = new u(g, x), C = new u(y, T), P = new u(c, m)), this.add(new h(S, E, C, P)) }, quadraticBezierTo: function (c, m, g, x) { const y = this.getEndPoint(); let T; let S; return c instanceof u ? (T = c, S = m) : (T = new u(g, x), S = new u(c, m)), this.add(new a(y, T, S)) }, draw: function (c, m) { for (let g = 0; g < this.curves.length; g++) { const x = this.curves[g]; !x.active || x.draw(c, m) } return c }, ellipseTo: function (c, m, g, x, y, T) { const S = new n(0, 0, c, m, g, x, y, T); const E = this.getEndPoint(this._tmpVec2A); const C = S.getStartPoint(this._tmpVec2B); return E.subtract(C), S.x = E.x, S.y = E.y, this.add(S) }, fromJSON: function (c) { this.curves = [], this.cacheLengths = [], this.startPoint.set(c.x, c.y), this.autoClose = c.autoClose; for (let m = 0; m < c.curves.length; m++) { const g = c.curves[m]; switch (g.type) { case 'LineCurve':this.add(r.fromJSON(g)); break; case 'EllipseCurve':this.add(n.fromJSON(g)); break; case 'SplineCurve':this.add(l.fromJSON(g)); break; case 'CubicBezierCurve':this.add(h.fromJSON(g)); break; case 'QuadraticBezierCurve':this.add(a.fromJSON(g)); break } } return this }, getBounds: function (c, m) { c === void 0 && (c = new f()), m === void 0 && (m = 16), c.x = Number.MAX_VALUE, c.y = Number.MAX_VALUE; for (var g = new f(), x = v.MIN_SAFE_INTEGER, y = v.MIN_SAFE_INTEGER, T = 0; T < this.curves.length; T++) { const S = this.curves[T]; !S.active || (S.getBounds(g, m), c.x = Math.min(c.x, g.x), c.y = Math.min(c.y, g.y), x = Math.max(x, g.right), y = Math.max(y, g.bottom)) } return c.right = x, c.bottom = y, c }, getCurveLengths: function () { if (this.cacheLengths.length === this.curves.length) return this.cacheLengths; for (var c = [], m = 0, g = 0; g < this.curves.length; g++)m += this.curves[g].getLength(), c.push(m); return this.cacheLengths = c, c }, getEndPoint: function (c) { return c === void 0 && (c = new u()), this.curves.length > 0 ? this.curves[this.curves.length - 1].getPoint(1, c) : c.copy(this.startPoint), c }, getLength: function () { const c = this.getCurveLengths(); return c[c.length - 1] }, getPoint: function (c, m) { m === void 0 && (m = new u()); for (let g = c * this.getLength(), x = this.getCurveLengths(), y = 0; y < x.length;) { if (x[y] >= g) { const T = x[y] - g; const S = this.curves[y]; const E = S.getLength(); const C = E === 0 ? 0 : 1 - T / E; return S.getPointAt(C, m) }y++ } return null }, getPoints: function (c) { c === void 0 && (c = 12); for (var m = [], g, x = 0; x < this.curves.length; x++) { const y = this.curves[x]; if (y.active) for (let T = y.getResolution(c), S = y.getPoints(T), E = 0; E < S.length; E++) { const C = S[E]; g && g.equals(C) || (m.push(C), g = C) } } return this.autoClose && m.length > 1 && !m[m.length - 1].equals(m[0]) && m.push(m[0]), m }, getRandomPoint: function (c) { return c === void 0 && (c = new u()), this.getPoint(Math.random(), c) }, getSpacedPoints: function (c) { c === void 0 && (c = 40); for (var m = [], g = 0; g <= c; g++)m.push(this.getPoint(g / c)); return this.autoClose && m.push(m[0]), m }, getStartPoint: function (c) { return c === void 0 && (c = new u()), c.copy(this.startPoint) }, getTangent: function (c, m) { m === void 0 && (m = new u()); for (let g = c * this.getLength(), x = this.getCurveLengths(), y = 0; y < x.length;) { if (x[y] >= g) { const T = x[y] - g; const S = this.curves[y]; const E = S.getLength(); const C = E === 0 ? 0 : 1 - T / E; return S.getTangentAt(C, m) }y++ } return null }, lineTo: function (c, m) { c instanceof u ? this._tmpVec2B.copy(c) : this._tmpVec2B.set(c, m); const g = this.getEndPoint(this._tmpVec2A); return this.add(new r([g.x, g.y, this._tmpVec2B.x, this._tmpVec2B.y])) }, splineTo: function (c) { return c.unshift(this.getEndPoint()), this.add(new l(c)) }, moveTo: function (c, m) { return c instanceof u ? this.add(new s(c.x, c.y)) : this.add(new s(c, m)) }, toJSON: function () { for (var c = [], m = 0; m < this.curves.length; m++)c.push(this.curves[m].toJSON()); return { type: 'Path', x: this.startPoint.x, y: this.startPoint.y, autoClose: this.autoClose, curves: c } }, updateArcLengths: function () { this.cacheLengths = [], this.getCurveLengths() }, destroy: function () { this.curves.length = 0, this.cacheLengths.length = 0, this.startPoint = void 0 } }); o.register('path', function (c, m) { return new p(c, m) }), e.exports = p }, function (e, d, t) { e.exports = { DataManager: t(101), DataManagerPlugin: t(897), Events: t(315) } }, function (e, d, t) { const i = t(0); const h = t(101); const n = t(24); const o = t(20); const r = new i({ Extends: h, initialize: function (a) { h.call(this, a, a.sys.events), this.scene = a, this.systems = a.sys, a.sys.events.once(o.BOOT, this.boot, this), a.sys.events.on(o.START, this.start, this) }, boot: function () { this.events = this.systems.events, this.events.once(o.DESTROY, this.destroy, this) }, start: function () { this.events.once(o.SHUTDOWN, this.shutdown, this) }, shutdown: function () { this.systems.events.off(o.SHUTDOWN, this.shutdown, this) }, destroy: function () { h.prototype.destroy.call(this), this.events.off(o.START, this.start, this), this.scene = null, this.systems = null } }); n.register('DataManagerPlugin', r, 'data'), e.exports = r }, function (e, d, t) { e.exports = { Align: t(899), BaseShader: t(396), Bounds: t(902), Canvas: t(906), Color: t(397), ColorMatrix: t(198), Masks: t(916), RGB: t(200) } }, function (e, d, t) { const i = t(123); const h = t(17); let n = { In: t(900), To: t(901) }; n = h(!1, n, i), e.exports = n }, function (e, d, t) { e.exports = { BottomCenter: t(290), BottomLeft: t(291), BottomRight: t(292), Center: t(293), LeftCenter: t(295), QuickSet: t(289), RightCenter: t(296), TopCenter: t(297), TopLeft: t(298), TopRight: t(299) } }, function (e, d, t) { e.exports = { BottomCenter: t(277), BottomLeft: t(278), BottomRight: t(279), LeftBottom: t(280), LeftCenter: t(281), LeftTop: t(282), QuickSet: t(276), RightBottom: t(283), RightCenter: t(284), RightTop: t(285), TopCenter: t(286), TopLeft: t(287), TopRight: t(288) } }, function (e, d, t) { e.exports = { CenterOn: t(294), GetBottom: t(42), GetBounds: t(903), GetCenterX: t(87), GetCenterY: t(89), GetLeft: t(43), GetOffsetX: t(904), GetOffsetY: t(905), GetRight: t(44), GetTop: t(45), SetBottom: t(55), SetCenterX: t(88), SetCenterY: t(90), SetLeft: t(53), SetRight: t(54), SetTop: t(52) } }, function (e, d, t) { const i = t(42); const h = t(43); const n = t(44); const o = t(45); const r = function (s, a) { a === void 0 && (a = {}); const f = h(s); const l = o(s); return a.x = f, a.y = l, a.width = n(s) - f, a.height = i(s) - l, a }; e.exports = r }, function (e, d) { const t = function (i) { return i.width * i.originX }; e.exports = t }, function (e, d) { const t = function (i) { return i.height * i.originY }; e.exports = t }, function (e, d, t) { e.exports = { CanvasInterpolation: t(367), CanvasPool: t(31), Smoothing: t(192), TouchAction: t(907), UserSelect: t(908) } }, function (e, d) { const t = function (i, h) { return h === void 0 && (h = 'none'), i.style.msTouchAction = h, i.style['ms-touch-action'] = h, i.style['touch-action'] = h, i }; e.exports = t }, function (e, d) { const t = function (i, h) { h === void 0 && (h = 'none'); const n = ['-webkit-', '-khtml-', '-moz-', '-ms-', '']; return n.forEach(function (o) { i.style[o + 'user-select'] = h }), i.style['-webkit-touch-callout'] = h, i.style['-webkit-tap-highlight-color'] = 'rgba(0, 0, 0, 0)', i }; e.exports = t }, function (e, d, t) { const i = t(103); const h = function (n) { n === void 0 && (n = 1024); const o = []; const r = 255; let s; let a = 255; let f = 0; let l = 0; for (s = 0; s <= r; s++)o.push({ r: a, g: s, b: l, color: i(a, s, l) }); for (f = 255, s = r; s >= 0; s--)o.push({ r: s, g: f, b: l, color: i(s, f, l) }); for (a = 0, s = 0; s <= r; s++, f--)o.push({ r: a, g: f, b: s, color: i(a, f, s) }); for (f = 0, l = 255, s = 0; s <= r; s++, l--, a++)o.push({ r: a, g: f, b: l, color: i(a, f, l) }); if (n === 1024) return o; const u = []; let v = 0; const p = 1024 / n; for (s = 0; s < n; s++)u.push(o[Math.floor(v)]), v += p; return u }; e.exports = h }, function (e, d) { const t = function (i) { const h = { r: i >> 16 & 255, g: i >> 8 & 255, b: i & 255, a: 255 }; return i > 16777215 && (h.a = i >>> 24), h }; e.exports = t }, function (e, d, t) { const i = t(38); const h = t(399); const n = function (o, r, s) { let a = s; let f = s; let l = s; if (r !== 0) { const u = s < 0.5 ? s * (1 + r) : s + r - s * r; const v = 2 * s - u; a = h(v, u, o + 1 / 3), f = h(v, u, o), l = h(v, u, o - 1 / 3) } const p = new i(); return p.setGLTo(a, f, l, 1) }; e.exports = n }, function (e, d, t) { const i = t(188); const h = function (n, o) { n === void 0 && (n = 1), o === void 0 && (o = 1); for (var r = [], s = 0; s <= 359; s++)r.push(i(s / 359, n, o)); return r }; e.exports = h }, function (e, d, t) { const i = t(135); const h = function (r, s, a, f, l, u, v, p) { v === void 0 && (v = 100), p === void 0 && (p = 0); const c = p / v; return { r: i(r, f, c), g: i(s, l, c), b: i(a, u, c) } }; const n = function (r, s, a, f) { return a === void 0 && (a = 100), f === void 0 && (f = 0), h(r.r, r.g, r.b, s.r, s.g, s.b, a, f) }; const o = function (r, s, a, f, l, u) { return l === void 0 && (l = 100), u === void 0 && (u = 0), h(r.r, r.g, r.b, s, a, f, l, u) }; e.exports = { RGBWithRGB: h, ColorWithRGB: o, ColorWithColor: n } }, function (e, d, t) { const i = t(195); const h = t(38); const n = function (o, r) { return o === void 0 && (o = 0), r === void 0 && (r = 255), new h(i(o, r), i(o, r), i(o, r)) }; e.exports = n }, function (e, d, t) { const i = t(398); const h = function (n, o, r, s, a) { return s === void 0 && (s = 255), a === void 0 && (a = '#'), a === '#' ? '#' + ((1 << 24) + (n << 16) + (o << 8) + r).toString(16).slice(1, 7) : '0x' + i(s) + i(n) + i(o) + i(r) }; e.exports = h }, function (e, d, t) { e.exports = { BitmapMask: t(310), GeometryMask: t(311) } }, function (e, d, t) { const i = { AddToDOM: t(142), DOMContentLoaded: t(400), GetInnerHeight: t(401), GetScreenOrientation: t(402), GetTarget: t(407), ParseXML: t(408), RemoveFromDOM: t(202), RequestAnimationFrame: t(386) }; e.exports = i }, function (e, d, t) { e.exports = { EventEmitter: t(919) } }, function (e, d, t) { const i = t(0); const h = t(9); const n = t(24); const o = new i({ Extends: h, initialize: function () { h.call(this) }, shutdown: function () { this.removeAllListeners() }, destroy: function () { this.removeAllListeners() } }); n.register('EventEmitter', o, 'events'), e.exports = o }, function (e, d, t) { const i = t(142); const h = t(321); const n = t(325); const o = t(31); const r = t(0); const s = t(346); const a = t(921); const f = t(366); const l = t(101); const u = t(384); const v = t(347); const p = t(400); const c = t(9); const m = t(22); const g = t(409); const x = t(24); const y = t(414); const T = t(415); const S = t(417); const E = t(106); const C = t(422); const P = t(385); const A = t(387); const M = t(426); if (!1) var L; const F = new r({ initialize: function (G) { this.config = new s(G), this.renderer = null, this.domContainer = null, this.canvas = null, this.context = null, this.isBooted = !1, this.isRunning = !1, this.events = new c(), this.anims = new h(this), this.textures = new C(this), this.cache = new n(this), this.registry = new l(this), this.input = new g(this, this.config), this.scene = new S(this, this.config.sceneConfig), this.device = v, this.scale = new T(this, this.config), this.sound = null, this.sound = M.create(this), this.loop = new P(this, this.config.fps), this.plugins = new y(this, this.config), this.pendingDestroy = !1, this.removeCanvas = !1, this.noReturn = !1, this.hasFocus = !1, p(this.boot.bind(this)) }, boot: function () { if (!x.hasCore('EventEmitter')) { console.warn('Aborting. Core Plugins missing.'); return } this.isBooted = !0, this.config.preBoot(this), this.scale.preBoot(), f(this), a(this), u(this), i(this.canvas, this.config.parent), this.textures.once(E.READY, this.texturesReady, this), this.events.emit(m.BOOT) }, texturesReady: function () { this.events.emit(m.READY), this.start() }, start: function () { this.isRunning = !0, this.config.postBoot(this), this.renderer ? this.loop.start(this.step.bind(this)) : this.loop.start(this.headlessStep.bind(this)), A(this); const I = this.events; I.on(m.HIDDEN, this.onHidden, this), I.on(m.VISIBLE, this.onVisible, this), I.on(m.BLUR, this.onBlur, this), I.on(m.FOCUS, this.onFocus, this) }, step: function (I, G) { if (this.pendingDestroy) return this.runDestroy(); const U = this.events; U.emit(m.PRE_STEP, I, G), U.emit(m.STEP, I, G), this.scene.update(I, G), U.emit(m.POST_STEP, I, G); const Y = this.renderer; Y.preRender(), U.emit(m.PRE_RENDER, Y, I, G), this.scene.render(Y), Y.postRender(), U.emit(m.POST_RENDER, Y, I, G) }, headlessStep: function (I, G) { if (this.pendingDestroy) return this.runDestroy(); const U = this.events; U.emit(m.PRE_STEP, I, G), U.emit(m.STEP, I, G), this.scene.update(I, G), U.emit(m.POST_STEP, I, G), U.emit(m.PRE_RENDER), U.emit(m.POST_RENDER) }, onHidden: function () { this.loop.pause(), this.events.emit(m.PAUSE) }, onVisible: function () { this.loop.resume(), this.events.emit(m.RESUME) }, onBlur: function () { this.hasFocus = !1, this.loop.blur() }, onFocus: function () { this.hasFocus = !0, this.loop.focus() }, getFrame: function () { return this.loop.frame }, getTime: function () { return this.loop.now }, destroy: function (I, G) { G === void 0 && (G = !1), this.pendingDestroy = !0, this.removeCanvas = I, this.noReturn = G }, runDestroy: function () { this.scene.destroy(), this.events.emit(m.DESTROY), this.events.removeAllListeners(), this.renderer && this.renderer.destroy(), this.removeCanvas && this.canvas && (o.remove(this.canvas), this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas)), this.domContainer && this.domContainer.parentNode.removeChild(this.domContainer), this.loop.destroy(), this.pendingDestroy = !1 } }); e.exports = F }, function (e, d, t) { const i = t(142); const h = function (n) { const o = n.config; if (!(!o.parent || !o.domCreateContainer)) { const r = document.createElement('div'); r.style.cssText = ['display: block;', 'width: ' + n.scale.width + 'px;', 'height: ' + n.scale.height + 'px;', 'padding: 0; margin: 0;', 'position: absolute;', 'overflow: hidden;', 'pointer-events: ' + o.domPointerEvents + ';', 'transform: scale(1);', 'transform-origin: left top;'].join(' '), n.domContainer = r, i(r, o.parent) } }; e.exports = h }, function (e, d) { e.exports = 'boot' }, function (e, d) { e.exports = 'destroy' }, function (e, d) { e.exports = 'dragend' }, function (e, d) { e.exports = 'dragenter' }, function (e, d) { e.exports = 'drag' }, function (e, d) { e.exports = 'dragleave' }, function (e, d) { e.exports = 'dragover' }, function (e, d) { e.exports = 'dragstart' }, function (e, d) { e.exports = 'drop' }, function (e, d) { e.exports = 'gameout' }, function (e, d) { e.exports = 'gameover' }, function (e, d) { e.exports = 'gameobjectdown' }, function (e, d) { e.exports = 'dragend' }, function (e, d) { e.exports = 'dragenter' }, function (e, d) { e.exports = 'drag' }, function (e, d) { e.exports = 'dragleave' }, function (e, d) { e.exports = 'dragover' }, function (e, d) { e.exports = 'dragstart' }, function (e, d) { e.exports = 'drop' }, function (e, d) { e.exports = 'gameobjectmove' }, function (e, d) { e.exports = 'gameobjectout' }, function (e, d) { e.exports = 'gameobjectover' }, function (e, d) { e.exports = 'pointerdown' }, function (e, d) { e.exports = 'pointermove' }, function (e, d) { e.exports = 'pointerout' }, function (e, d) { e.exports = 'pointerover' }, function (e, d) { e.exports = 'pointerup' }, function (e, d) { e.exports = 'wheel' }, function (e, d) { e.exports = 'gameobjectup' }, function (e, d) { e.exports = 'gameobjectwheel' }, function (e, d) { e.exports = 'boot' }, function (e, d) { e.exports = 'process' }, function (e, d) { e.exports = 'update' }, function (e, d) { e.exports = 'pointerdown' }, function (e, d) { e.exports = 'pointerdownoutside' }, function (e, d) { e.exports = 'pointermove' }, function (e, d) { e.exports = 'pointerout' }, function (e, d) { e.exports = 'pointerover' }, function (e, d) { e.exports = 'pointerup' }, function (e, d) { e.exports = 'pointerupoutside' }, function (e, d) { e.exports = 'wheel' }, function (e, d) { e.exports = 'pointerlockchange' }, function (e, d) { e.exports = 'preupdate' }, function (e, d) { e.exports = 'shutdown' }, function (e, d) { e.exports = 'start' }, function (e, d) { e.exports = 'update' }, function (e, d) { e.exports = 'addfile' }, function (e, d) { e.exports = 'complete' }, function (e, d) { e.exports = 'filecomplete' }, function (e, d) { e.exports = 'filecomplete-' }, function (e, d) { e.exports = 'loaderror' }, function (e, d) { e.exports = 'load' }, function (e, d) { e.exports = 'fileprogress' }, function (e, d) { e.exports = 'postprocess' }, function (e, d) { e.exports = 'progress' }, function (e, d) { e.exports = 'start' }, function (e, d, t) { const i = { game: 'game', renderer: 'renderer', anims: 'anims', cache: 'cache', plugins: 'plugins', registry: 'registry', scale: 'scale', sound: 'sound', textures: 'textures', events: 'events', cameras: 'cameras', add: 'add', make: 'make', scenePlugin: 'scene', displayList: 'children', lights: 'lights', data: 'data', input: 'input', load: 'load', time: 'time', tweens: 'tweens', arcadePhysics: 'physics', impactPhysics: 'impact', matterPhysics: 'matter' }; e.exports = i }, function (e, d) { const t = function (i, h, n) { if (!n.getElementsByTagName('TextureAtlas')) { console.warn('Invalid Texture Atlas XML given'); return } const o = i.source[h]; i.add('__BASE', h, 0, 0, o.width, o.height); for (var r = n.getElementsByTagName('SubTexture'), s, a = 0; a < r.length; a++) { const f = r[a].attributes; const l = f.name.value; const u = parseInt(f.x.value, 10); const v = parseInt(f.y.value, 10); const p = parseInt(f.width.value, 10); const c = parseInt(f.height.value, 10); if (s = i.add(l, h, u, v, p, c), f.frameX) { const m = Math.abs(parseInt(f.frameX.value, 10)); const g = Math.abs(parseInt(f.frameY.value, 10)); const x = parseInt(f.frameWidth.value, 10); const y = parseInt(f.frameHeight.value, 10); s.setTrim(p, c, m, g, x, y) } } return i }; e.exports = t }, function (e, d) { const t = function (i, h) { const n = i.source[h]; return i.add('__BASE', h, 0, 0, n.width, n.height), i }; e.exports = t }, function (e, d) { const t = function (i, h) { const n = i.source[h]; return i.add('__BASE', h, 0, 0, n.width, n.height), i }; e.exports = t }, function (e, d, t) { const i = t(77); const h = function (n, o, r) { if (!r.frames && !r.textures) { console.warn('Invalid Texture Atlas JSON Array'); return } const s = n.source[o]; n.add('__BASE', o, 0, 0, s.width, s.height); for (var a = Array.isArray(r.textures) ? r.textures[o].frames : r.frames, f, l = 0; l < a.length; l++) { const u = a[l]; f = n.add(u.filename, o, u.frame.x, u.frame.y, u.frame.w, u.frame.h), u.trimmed && f.setTrim(u.sourceSize.w, u.sourceSize.h, u.spriteSourceSize.x, u.spriteSourceSize.y, u.spriteSourceSize.w, u.spriteSourceSize.h), u.rotated && (f.rotated = !0, f.updateUVsInverted()); const v = u.anchor || u.pivot; v && (f.customPivot = !0, f.pivotX = v.x, f.pivotY = v.y), f.customData = i(u) } for (const p in r)p !== 'frames' && (Array.isArray(r[p]) ? n.customData[p] = r[p].slice(0) : n.customData[p] = r[p]); return n }; e.exports = h }, function (e, d, t) { const i = t(77); const h = function (n, o, r) { if (!r.frames) { console.warn("Invalid Texture Atlas JSON Hash given, missing 'frames' Object"); return } const s = n.source[o]; n.add('__BASE', o, 0, 0, s.width, s.height); const a = r.frames; let f; for (const l in a) if (a.hasOwnProperty(l)) { const u = a[l]; f = n.add(l, o, u.frame.x, u.frame.y, u.frame.w, u.frame.h), u.trimmed && f.setTrim(u.sourceSize.w, u.sourceSize.h, u.spriteSourceSize.x, u.spriteSourceSize.y, u.spriteSourceSize.w, u.spriteSourceSize.h), u.rotated && (f.rotated = !0, f.updateUVsInverted()); const v = u.anchor || u.pivot; v && (f.customPivot = !0, f.pivotX = v.x, f.pivotY = v.y), f.customData = i(u) } for (const p in r)p !== 'frames' && (Array.isArray(r[p]) ? n.customData[p] = r[p].slice(0) : n.customData[p] = r[p]); return n }; e.exports = h }, function (e, d, t) { const i = t(2); const h = function (n, o, r, s, a, f, l) { const u = i(l, 'frameWidth', null); const v = i(l, 'frameHeight', u); if (u === null) throw new Error('TextureManager.SpriteSheet: Invalid frameWidth given.'); const p = n.source[o]; n.add('__BASE', o, 0, 0, p.width, p.height); let c = i(l, 'startFrame', 0); const m = i(l, 'endFrame', -1); const g = i(l, 'margin', 0); const x = i(l, 'spacing', 0); const y = Math.floor((a - g + x) / (u + x)); const T = Math.floor((f - g + x) / (v + x)); let S = y * T; S === 0 && console.warn('SpriteSheet frame dimensions will result in zero frames for texture:', n.key), (c > S || c < -S) && (c = 0), c < 0 && (c = S + c), m !== -1 && (S = c + (m + 1)); for (let E = g, C = g, P = 0, A = 0, M = 0; M < S; M++) { P = 0, A = 0; const L = E + u; const F = C + v; L > a && (P = L - a), F > f && (A = F - f), n.add(M, o, r + E, s + C, u - P, v - A), E += u + x, E + u > a && (E = g, C += v + x) } return n }; e.exports = h }, function (e, d, t) { const i = t(2); const h = function (n, o, r) { const s = i(r, 'frameWidth', null); const a = i(r, 'frameHeight', s); if (!s) throw new Error('TextureManager.SpriteSheetFromAtlas: Invalid frameWidth given.'); const f = n.source[0]; n.add('__BASE', 0, 0, 0, f.width, f.height); let l = i(r, 'startFrame', 0); const u = i(r, 'endFrame', -1); const v = i(r, 'margin', 0); const p = i(r, 'spacing', 0); const c = o.cutX; const m = o.cutY; const g = o.cutWidth; const x = o.cutHeight; const y = o.realWidth; const T = o.realHeight; const S = Math.floor((y - v + p) / (s + p)); const E = Math.floor((T - v + p) / (a + p)); let C = S * E; const P = o.x; const A = s - P; const M = s - (y - g - P); const L = o.y; const F = a - L; const I = a - (T - x - L); (l > C || l < -C) && (l = 0), l < 0 && (l = C + l), u !== -1 && (C = l + (u + 1)); for (var G, U = v, Y = v, X = 0, O = o.sourceIndex, R = 0; R < E; R++) { for (var D = R === 0, B = R === E - 1, N = 0; N < S; N++) { const w = N === 0; const z = N === S - 1; if (G = n.add(X, O, c + U, m + Y, s, a), w || D || z || B) { const V = w ? P : 0; const W = D ? L : 0; let H = 0; let K = 0; w && (H += s - A), z && (H += s - M), D && (K += a - F), B && (K += a - I); const Q = s - H; const J = a - K; G.cutWidth = Q, G.cutHeight = J, G.setTrim(s, a, V, W, Q, J) }U += p, w ? U += A : z ? U += M : U += s, X++ }U = v, Y += p, D ? Y += F : B ? Y += I : Y += a } return n }; e.exports = h }, function (e, d) {
        let t = 0; const i = function (n, o, r, s) { const a = t - s.y - s.height; n.add(r, o, s.x, a, s.width, s.height) }; const h = function (n, o, r) {
          const s = n.source[o]; n.add('__BASE', o, 0, 0, s.width, s.height), t = s.height; for (var a = r.split(`
`), f = /^[ ]*(- )*(\w+)+[: ]+(.*)/, l = '', u = '', v = { x: 0, y: 0, width: 0, height: 0 }, p = 0; p < a.length; p++) { const c = a[p].match(f); if (c) { const m = c[1] === '- '; const g = c[2]; const x = c[3]; if (m && (u !== l && (i(n, o, u, v), l = u), v = { x: 0, y: 0, width: 0, height: 0 }), g === 'name') { u = x; continue } switch (g) { case 'x':case 'y':case 'width':case 'height':v[g] = parseInt(x, 10); break } } } return u !== l && i(n, o, u, v), n
        }; e.exports = h
      }, function (e, d) { e.exports = 'complete' }, function (e, d) { e.exports = 'decoded' }, function (e, d) { e.exports = 'decodedall' }, function (e, d) { e.exports = 'destroy' }, function (e, d) { e.exports = 'detune' }, function (e, d) { e.exports = 'detune' }, function (e, d) { e.exports = 'mute' }, function (e, d) { e.exports = 'rate' }, function (e, d) { e.exports = 'volume' }, function (e, d) { e.exports = 'loop' }, function (e, d) { e.exports = 'looped' }, function (e, d) { e.exports = 'mute' }, function (e, d) { e.exports = 'pan' }, function (e, d) { e.exports = 'pauseall' }, function (e, d) { e.exports = 'pause' }, function (e, d) { e.exports = 'play' }, function (e, d) { e.exports = 'rate' }, function (e, d) { e.exports = 'resumeall' }, function (e, d) { e.exports = 'resume' }, function (e, d) { e.exports = 'seek' }, function (e, d) { e.exports = 'stopall' }, function (e, d) { e.exports = 'stop' }, function (e, d) { e.exports = 'unlocked' }, function (e, d) { e.exports = 'volume' }, function (e, d, t) { const i = { Events: t(75), DisplayList: t(1012), GameObjectCreator: t(16), GameObjectFactory: t(5), UpdateList: t(1040), Components: t(11), GetCalcMatrix: t(19), BuildGameObject: t(28), BuildGameObjectAnimation: t(439), GameObject: t(15), BitmapText: t(148), Blitter: t(213), Bob: t(440), Container: t(214), DOMElement: t(442), DynamicBitmapText: t(215), Extern: t(444), Graphics: t(216), Group: t(113), Image: t(125), Layer: t(219), Particles: t(1074), PathFollower: t(457), RenderTexture: t(221), RetroFont: t(1082), Rope: t(223), Sprite: t(73), Text: t(224), GetTextSize: t(458), MeasureText: t(460), TextStyle: t(459), TileSprite: t(225), Zone: t(129), Video: t(226), Shape: t(34), Arc: t(461), Curve: t(462), Ellipse: t(463), Grid: t(464), IsoBox: t(465), IsoTriangle: t(466), Line: t(467), Polygon: t(468), Rectangle: t(473), Star: t(474), Triangle: t(475), Factories: { Blitter: t(1130), Container: t(1131), DOMElement: t(1132), DynamicBitmapText: t(1133), Extern: t(1134), Graphics: t(1135), Group: t(1136), Image: t(1137), Layer: t(1138), Particles: t(1139), PathFollower: t(1140), RenderTexture: t(1141), Rope: t(1142), Sprite: t(1143), StaticBitmapText: t(1144), Text: t(1145), TileSprite: t(1146), Zone: t(1147), Video: t(1148), Arc: t(1149), Curve: t(1150), Ellipse: t(1151), Grid: t(1152), IsoBox: t(1153), IsoTriangle: t(1154), Line: t(1155), Polygon: t(1156), Rectangle: t(1157), Star: t(1158), Triangle: t(1159) }, Creators: { Blitter: t(1160), Container: t(1161), DynamicBitmapText: t(1162), Graphics: t(1163), Group: t(1164), Image: t(1165), Layer: t(1166), Particles: t(1167), RenderTexture: t(1168), Rope: t(1169), Sprite: t(1170), StaticBitmapText: t(1171), Text: t(1172), TileSprite: t(1173), Zone: t(1174), Video: t(1175) } }; i.Shader = t(229), i.Mesh = t(230), i.PointLight = t(150), i.Factories.Shader = t(1184), i.Factories.Mesh = t(1185), i.Factories.PointLight = t(1186), i.Creators.Shader = t(1187), i.Creators.Mesh = t(1188), i.Creators.PointLight = t(1189), i.Light = t(481), i.LightsManager = t(482), i.LightsPlugin = t(1190), e.exports = i }, function (e, d, t) { const i = t(0); const h = t(110); const n = t(24); const o = t(75); const r = t(20); const s = t(79); const a = new i({ Extends: h, initialize: function (l) { h.call(this, l), this.sortChildrenFlag = !1, this.scene = l, this.systems = l.sys, this.events = l.sys.events, this.addCallback = this.addChildCallback, this.removeCallback = this.removeChildCallback, this.events.once(r.BOOT, this.boot, this), this.events.on(r.START, this.start, this) }, boot: function () { this.events.once(r.DESTROY, this.destroy, this) }, addChildCallback: function (f) { f.displayList && f.displayList !== this && f.removeFromDisplayList(), f.displayList || (this.queueDepthSort(), f.displayList = this, f.emit(o.ADDED_TO_SCENE, f, this.scene), this.events.emit(r.ADDED_TO_SCENE, f, this.scene)) }, removeChildCallback: function (f) { this.queueDepthSort(), f.displayList = null, f.emit(o.REMOVED_FROM_SCENE, f, this.scene), this.events.emit(r.REMOVED_FROM_SCENE, f, this.scene) }, start: function () { this.events.once(r.SHUTDOWN, this.shutdown, this) }, queueDepthSort: function () { this.sortChildrenFlag = !0 }, depthSort: function () { this.sortChildrenFlag && (s(this.list, this.sortByDepth), this.sortChildrenFlag = !1) }, sortByDepth: function (f, l) { return f._depth - l._depth }, getChildren: function () { return this.list }, shutdown: function () { for (var f = this.list, l = f.length; l--;)f[l].destroy(!0); f.length = 0, this.events.off(r.SHUTDOWN, this.shutdown, this) }, destroy: function () { this.shutdown(), this.events.off(r.START, this.start, this), this.scene = null, this.systems = null, this.events = null } }); n.register('DisplayList', a, 'displayList'), e.exports = a }, function (e, d, t) { e.exports = { CheckMatrix: t(209), MatrixToString: t(1014), ReverseColumns: t(1015), ReverseRows: t(1016), Rotate180: t(1017), RotateLeft: t(1018), RotateMatrix: t(147), RotateRight: t(1019), Translate: t(1020), TransposeMatrix: t(435) } }, function (e, d, t) {
        const i = t(186); const h = t(209); const n = function (o) {
          let r = ''; if (!h(o)) return r; for (let s = 0; s < o.length; s++) {
            for (let a = 0; a < o[s].length; a++) { const f = o[s][a].toString(); f !== 'undefined' ? r += i(f, 2) : r += '?', a < o[s].length - 1 && (r += ' |') } if (s < o.length - 1) {
              r += `
`;for (let l = 0; l < o[s].length; l++)r += '---', l < o[s].length - 1 && (r += '+'); r += `
`
            }
          } return r
        }; e.exports = n
      }, function (e, d) { const t = function (i) { return i.reverse() }; e.exports = t }, function (e, d) { const t = function (i) { for (let h = 0; h < i.length; h++)i[h].reverse(); return i }; e.exports = t }, function (e, d, t) { const i = t(147); const h = function (n) { return i(n, 180) }; e.exports = h }, function (e, d, t) { const i = t(147); const h = function (n) { return i(n, 90) }; e.exports = h }, function (e, d, t) { const i = t(147); const h = function (n) { return i(n, -90) }; e.exports = h }, function (e, d, t) { const i = t(178); const h = t(179); const n = function (o, r, s) { if (r === void 0 && (r = 0), s === void 0 && (s = 0), s !== 0 && (s < 0 ? i(o, Math.abs(s)) : h(o, s)), r !== 0) for (let a = 0; a < o.length; a++) { const f = o[a]; r < 0 ? i(f, Math.abs(r)) : h(f, r) } return o }; e.exports = n }, function (e, d) { const t = function (i, h, n, o, r) { if (r === void 0 && (r = i), n > 0) { var s = n - i.length; if (s <= 0) return null } if (!Array.isArray(h)) return i.indexOf(h) === -1 ? (i.push(h), o && o.call(r, h), h) : null; for (var a = h.length - 1; a >= 0;)i.indexOf(h[a]) !== -1 && h.splice(a, 1), a--; if (a = h.length, a === 0) return null; n > 0 && a > s && (h.splice(s), a = s); for (let f = 0; f < a; f++) { const l = h[f]; i.push(l), o && o.call(r, l) } return h }; e.exports = t }, function (e, d) { const t = function (i, h, n, o, r, s) { if (n === void 0 && (n = 0), s === void 0 && (s = i), o > 0) { var a = o - i.length; if (a <= 0) return null } if (!Array.isArray(h)) return i.indexOf(h) === -1 ? (i.splice(n, 0, h), r && r.call(s, h), h) : null; for (var f = h.length - 1; f >= 0;)i.indexOf(h[f]) !== -1 && h.pop(), f--; if (f = h.length, f === 0) return null; o > 0 && f > a && (h.splice(a), f = a); for (let l = f - 1; l >= 0; l--) { const u = h[l]; i.splice(n, 0, u), r && r.call(s, u) } return h }; e.exports = t }, function (e, d) { const t = function (i, h) { const n = i.indexOf(h); return n !== -1 && n < i.length && (i.splice(n, 1), i.push(h)), h }; e.exports = t }, function (e, d, t) { const i = t(78); const h = function (n, o, r, s, a) { s === void 0 && (s = 0), a === void 0 && (a = n.length); let f = 0; if (i(n, s, a)) for (let l = s; l < a; l++) { const u = n[l]; u[o] === r && f++ } return f }; e.exports = h }, function (e, d) { const t = function (i, h, n) { let o; const r = [null]; for (o = 3; o < arguments.length; o++)r.push(arguments[o]); for (o = 0; o < i.length; o++)r[0] = i[o], h.apply(n, r); return i }; e.exports = t }, function (e, d, t) { const i = t(78); const h = function (n, o, r, s, a) { if (s === void 0 && (s = 0), a === void 0 && (a = n.length), i(n, s, a)) { let f; const l = [null]; for (f = 5; f < arguments.length; f++)l.push(arguments[f]); for (f = s; f < a; f++)l[0] = n[f], o.apply(r, l) } return n }; e.exports = h }, function (e, d) { const t = function (i, h) { const n = i.indexOf(h); if (n > 0) { const o = i[n - 1]; const r = i.indexOf(o); i[n] = o, i[r] = h } return i }; e.exports = t }, function (e, d) { const t = function (i, h, n) { const o = i.indexOf(h); if (o === -1 || n < 0 || n >= i.length) throw new Error('Supplied index out of bounds'); return o !== n && (i.splice(o, 1), i.splice(n, 0, h)), h }; e.exports = t }, function (e, d) { const t = function (i, h) { const n = i.indexOf(h); if (n !== -1 && n < i.length - 1) { const o = i[n + 1]; const r = i.indexOf(o); i[n] = o, i[r] = h } return i }; e.exports = t }, function (e, d) { const t = function (i, h, n) { if (h === n) return i; const o = i.indexOf(h); const r = i.indexOf(n); if (o < 0 || r < 0) throw new Error('Supplied items must be elements of the same array'); return o > r || (i.splice(o, 1), r === i.length - 1 ? i.push(h) : i.splice(r, 0, h)), i }; e.exports = t }, function (e, d) { const t = function (i, h, n) { if (h === n) return i; const o = i.indexOf(h); const r = i.indexOf(n); if (o < 0 || r < 0) throw new Error('Supplied items must be elements of the same array'); return o < r || (i.splice(o, 1), r === 0 ? i.unshift(h) : i.splice(r, 0, h)), i }; e.exports = t }, function (e, d, t) { const i = t(363); const h = function (n, o, r) { n === void 0 && (n = 0), o === void 0 && (o = null), r === void 0 && (r = 1), o === null && (o = n, n = 0); for (var s = [], a = Math.max(i((o - n) / (r || 1)), 0), f = 0; f < a; f++)s.push(n), n += r; return s }; e.exports = h }, function (e, d, t) { const i = t(74); const h = function (n, o, r, s) { if (s === void 0 && (s = n), o < 0 || o > n.length - 1) throw new Error('Index out of bounds'); const a = i(n, o); return r && r.call(s, a), a }; e.exports = h }, function (e, d, t) { const i = t(78); const h = function (n, o, r, s, a) { if (o === void 0 && (o = 0), r === void 0 && (r = n.length), a === void 0 && (a = n), i(n, o, r)) { const f = r - o; const l = n.splice(o, f); if (s) for (let u = 0; u < l.length; u++) { const v = l[u]; s.call(a, v) } return l } else return [] }; e.exports = h }, function (e, d, t) { const i = t(74); const h = function (n, o, r) { o === void 0 && (o = 0), r === void 0 && (r = n.length); const s = o + Math.floor(Math.random() * r); return i(n, s) }; e.exports = h }, function (e, d) { const t = function (i, h, n) { const o = i.indexOf(h); const r = i.indexOf(n); return o !== -1 && r === -1 ? (i[o] = n, !0) : !1 }; e.exports = t }, function (e, d) { const t = function (i, h) { const n = i.indexOf(h); return n !== -1 && n > 0 && (i.splice(n, 1), i.unshift(h)), h }; e.exports = t }, function (e, d, t) { const i = t(78); const h = function (n, o, r, s, a) { if (s === void 0 && (s = 0), a === void 0 && (a = n.length), i(n, s, a)) for (let f = s; f < a; f++) { const l = n[f]; l.hasOwnProperty(o) && (l[o] = r) } return n }; e.exports = h }, function (e, d) { const t = function (i, h, n) { if (h === n) return i; const o = i.indexOf(h); const r = i.indexOf(n); if (o < 0 || r < 0) throw new Error('Supplied items must be elements of the same array'); return i[o] = n, i[r] = h, i }; e.exports = t }, function (e, d, t) { const i = t(0); const h = t(211); const n = t(24); const o = t(20); const r = new i({ Extends: h, initialize: function (a) { h.call(this), this.checkQueue = !0, this.scene = a, this.systems = a.sys, a.sys.events.once(o.BOOT, this.boot, this), a.sys.events.on(o.START, this.start, this) }, boot: function () { this.systems.events.once(o.DESTROY, this.destroy, this) }, start: function () { const s = this.systems.events; s.on(o.PRE_UPDATE, this.update, this), s.on(o.UPDATE, this.sceneUpdate, this), s.once(o.SHUTDOWN, this.shutdown, this) }, sceneUpdate: function (s, a) { for (let f = this._active, l = f.length, u = 0; u < l; u++) { const v = f[u]; v.active && v.preUpdate.call(v, s, a) } }, shutdown: function () { for (var s = this._active.length; s--;) this._active[s].destroy(!0); for (s = this._pending.length; s--;) this._pending[s].destroy(!0); for (s = this._destroy.length; s--;) this._destroy[s].destroy(!0); this._toProcess = 0, this._pending = [], this._active = [], this._destroy = [], this.removeAllListeners(); const a = this.systems.events; a.off(o.PRE_UPDATE, this.update, this), a.off(o.UPDATE, this.sceneUpdate, this), a.off(o.SHUTDOWN, this.shutdown, this) }, destroy: function () { this.shutdown(), this.systems.events.off(o.START, this.start, this), this.scene = null, this.systems = null } }); n.register('UpdateList', r, 'updateList'), e.exports = r }, function (e, d) { e.exports = 'add' }, function (e, d) { e.exports = 'remove' }, function (e, d) {
        const t = function (i, h, n, o) {
          if (n === void 0 && (n = !1), o === void 0) return o = { local: { x: 0, y: 0, width: 0, height: 0 }, global: { x: 0, y: 0, width: 0, height: 0 }, lines: { shortest: 0, longest: 0, lengths: null, height: 0 }, wrappedText: '', words: [], characters: [], scaleX: 0, scaleY: 0 }, o; let r = i.text; let s = r.length; const a = i.maxWidth; const f = i.wordWrapCharCode; let l = Number.MAX_VALUE; let u = Number.MAX_VALUE; let v = 0; let p = 0; const c = i.fontData.chars; const m = i.fontData.lineHeight; const g = i.letterSpacing; let x = 0; let y = 0; let T = 0; let S = null; const E = i._align; let C = 0; let P = 0; const A = i.fontSize / i.fontData.size; const M = A * i.scaleX; const L = A * i.scaleY; let F = null; let I = 0; const G = []; let U = Number.MAX_VALUE; let Y = 0; let X = 0; let O = 0; let R; let D = []; const B = []; let N = null; if (a > 0) {
            for (R = 0; R < s; R++) { if (T = r.charCodeAt(R), T === 10) { N !== null && (D.push({ word: N.word, i: N.i, x: N.x * M, y: N.y * L, w: N.w * M, h: N.h * L, cr: !0 }), N = null), x = 0, y += m, F = null; continue } if (S = c[T], !!S) { if (F !== null) var w = S.kerning[I]; T === f ? N !== null && (D.push({ word: N.word, i: N.i, x: N.x * M, y: N.y * L, w: N.w * M, h: N.h * L, cr: !1 }), N = null) : (N === null && (N = { word: '', i: R, x, y, w: 0, h: m, cr: !1 }), N.word = N.word.concat(r[R]), N.w += S.xOffset + S.xAdvance + (w !== void 0 ? w : 0)), x += S.xAdvance + g, F = S, I = T } }N !== null && D.push({ word: N.word, i: N.i, x: N.x * M, y: N.y * L, w: N.w * M, h: N.h * L, cr: !1 }), x = 0, y = 0, F = null, I = 0; let z; let V = 0; const W = []; for (R = 0; R < D.length; R++) { const H = D[R]; const K = H.x; const Q = H.x + H.w; if (z) { const J = K - (z.x + z.w); V = K - (J + z.w), z = null } const q = K - V; const j = Q - V; q > a || j > a ? (W.push(H.i - 1), H.cr ? (W.push(H.i + H.word.length), V = 0, z = null) : z = H) : H.cr && (W.push(H.i + H.word.length), V = 0, z = null) } const _ = function (Ct, St, Qt) { return Ct.substr(0, St) + Qt + Ct.substr(St + 1) }; for (R = W.length - 1; R >= 0; R--) {
              r = _(r, W[R], `
`)
            }o.wrappedText = r, s = r.length, D = [], N = null
          } let rt = 0; for (R = 0; R < s; R++) { if (T = r.charCodeAt(R), T === 10) { N !== null && (D.push({ word: N.word, i: N.i, x: N.x * M, y: N.y * L, w: N.w * M, h: N.h * L }), N = null), x = 0, y += m, F = null, G[X] = O, O > Y && (Y = O), O < U && (U = O), X++, O = 0; continue } if (S = c[T], !!S) { if (C = x, P = y, F !== null) { var nt = S.kerning[I]; C += nt !== void 0 ? nt : 0 }l > C && (l = C), u > P && (u = P); const et = C + S.xAdvance; const b = P + m; v < et && (v = et), p < b && (p = b); const at = S.xOffset + S.xAdvance + (nt !== void 0 ? nt : 0); T === f ? N !== null && (D.push({ word: N.word, i: N.i, x: N.x * M, y: N.y * L, w: N.w * M, h: N.h * L }), N = null) : (N === null && (N = { word: '', i: rt, x, y, w: 0, h: m }), N.word = N.word.concat(r[R]), N.w += at), B.push({ i: rt, char: r[R], code: T, x: (S.xOffset + x) * A, y: (S.yOffset + y) * A, w: S.width * A, h: S.height * A, t: y * A, r: et * A, b: m * A, line: X, glyph: S }), x += S.xAdvance + g, F = S, I = T, O = et * A, rt++ } } if (N !== null && D.push({ word: N.word, i: N.i, x: N.x * M, y: N.y * L, w: N.w * M, h: N.h * L }), G[X] = O, O > Y && (Y = O), O < U && (U = O), E > 0) for (let it = 0; it < B.length; it++) { const st = B[it]; if (E === 1) { const Kt = (Y - G[st.line]) / 2; st.x += Kt, st.r += Kt } else if (E === 2) { const Zt = Y - G[st.line]; st.x += Zt, st.r += Zt } } const ct = o.local; const lt = o.global; const Pt = o.lines; return ct.x = l * A, ct.y = u * A, ct.width = v * A, ct.height = p * A, lt.x = i.x - i._displayOriginX + l * M, lt.y = i.y - i._displayOriginY + u * L, lt.width = v * M, lt.height = p * L, Pt.shortest = U, Pt.longest = Y, Pt.lengths = G, h && (ct.x = Math.ceil(ct.x), ct.y = Math.ceil(ct.y), ct.width = Math.ceil(ct.width), ct.height = Math.ceil(ct.height), lt.x = Math.ceil(lt.x), lt.y = Math.ceil(lt.y), lt.width = Math.ceil(lt.width), lt.height = Math.ceil(lt.height), Pt.shortest = Math.ceil(U), Pt.longest = Math.ceil(Y)), n && (i._displayOriginX = i.originX * ct.width, i._displayOriginY = i.originY * ct.height, lt.x = i.x - i._displayOriginX * i.scaleX, lt.y = i.y - i._displayOriginY * i.scaleY, h && (lt.x = Math.ceil(lt.x), lt.y = Math.ceil(lt.y))), o.words = D, o.characters = B, o.lines.height = m, o.scale = A, o.scaleX = i.scaleX, o.scaleY = i.scaleY, o
        }; e.exports = t
      }, function (e, d, t) { const i = t(212); const h = function (n, o, r, s, a, f, l) { const u = n.sys.textures.get(r); const v = u.get(s); const p = n.sys.cache.xml.get(a); if (v && p) { const c = i(p, v, f, l, u); return n.sys.cache.bitmapFont.add(o, { data: c, texture: r, frame: s, fromAtlas: !0 }), !0 } else return !1 }; e.exports = h }, function (e, d, t) { let i = t(1); let h = t(1); i = t(1046), h = t(1048), e.exports = { renderWebGL: i, renderCanvas: h } }, function (e, d, t) { const i = t(1047); const h = t(19); const n = t(12); const o = function (r, s, a, f) { const l = s._text; const u = l.length; if (u !== 0) { a.addToRenderList(s); const v = r.pipelines.set(s.pipeline, s); const p = h(s, a, f).calc; const c = a.roundPixels; const m = a.alpha; const g = s.charColors; const x = s.tintFill; const y = n.getTintAppendFloatAlpha; const T = y(s.tintTopLeft, m * s._alphaTL); const S = y(s.tintTopRight, m * s._alphaTR); const E = y(s.tintBottomLeft, m * s._alphaBL); const C = y(s.tintBottomRight, m * s._alphaBR); const P = s.frame.glTexture; const A = v.setGameObject(s); const M = s.getTextBounds(!1); let L; let F; let I; const G = M.characters; const U = s.dropShadowX; const Y = s.dropShadowY; const X = U !== 0 || Y !== 0; if (r.pipelines.preBatch(s), X) { const O = s.dropShadowColor; const R = s.dropShadowAlpha; const D = y(O, m * R * s._alphaTL); const B = y(O, m * R * s._alphaTR); const N = y(O, m * R * s._alphaBL); const w = y(O, m * R * s._alphaBR); for (L = 0; L < G.length; L++)F = G[L], I = F.glyph, !(F.code === 32 || I.width === 0 || I.height === 0) && i(v, s, F, I, U, Y, p, c, D, B, N, w, 1, P, A) } for (L = 0; L < G.length; L++) if (F = G[L], I = F.glyph, !(F.code === 32 || I.width === 0 || I.height === 0)) if (g[F.i]) { const z = g[F.i]; const V = z.tintEffect; const W = y(z.tintTL, m * s._alphaTL); const H = y(z.tintTR, m * s._alphaTR); const K = y(z.tintBL, m * s._alphaBL); const Q = y(z.tintBR, m * s._alphaBR); i(v, s, F, I, 0, 0, p, c, W, H, K, Q, V, P, A) } else i(v, s, F, I, 0, 0, p, c, T, S, E, C, x, P, A); r.pipelines.postBatch(s) } }; e.exports = o }, function (e, d) { const t = function (i, h, n, o, r, s, a, f, l, u, v, p, c, m, g) { const x = n.x - h.displayOriginX + r; const y = n.y - h.displayOriginY + s; const T = x + n.w; const S = y + n.h; const E = a.getXRound(x, y, f); const C = a.getYRound(x, y, f); const P = a.getXRound(x, S, f); const A = a.getYRound(x, S, f); const M = a.getXRound(T, S, f); const L = a.getYRound(T, S, f); const F = a.getXRound(T, y, f); const I = a.getYRound(T, y, f); i.batchQuad(h, E, C, P, A, M, L, F, I, o.u0, o.v0, o.u1, o.v1, l, u, v, p, c, m, g) }; e.exports = t }, function (e, d, t) { const i = t(30); const h = function (n, o, r, s) { let a = o._text; let f = a.length; const l = n.currentContext; if (!(f === 0 || !i(n, l, o, r, s))) { r.addToRenderList(o); const u = o.fromAtlas ? o.frame : o.texture.frames.__BASE; const v = o.fontData.chars; const p = o.fontData.lineHeight; const c = o._letterSpacing; let m = 0; let g = 0; let x = 0; let y = null; let T = 0; let S = 0; let E = 0; let C = 0; let P = 0; let A = 0; let M = null; let L = 0; const F = u.source.image; const I = u.cutX; const G = u.cutY; const U = o._fontSize / o.fontData.size; const Y = o._align; let X = 0; let O = 0; const R = o.getTextBounds(!1); o.maxWidth > 0 && (a = R.wrappedText, f = a.length); const D = o._bounds.lines; Y === 1 ? O = (D.longest - D.lengths[0]) / 2 : Y === 2 && (O = D.longest - D.lengths[0]), l.translate(-o.displayOriginX, -o.displayOriginY); for (let B = r.roundPixels, N = 0; N < f; N++) { if (x = a.charCodeAt(N), x === 10) { X++, Y === 1 ? O = (D.longest - D.lengths[X]) / 2 : Y === 2 && (O = D.longest - D.lengths[X]), m = 0, g += p, M = null; continue } if (y = v[x], !!y) { if (T = I + y.x, S = G + y.y, E = y.width, C = y.height, P = y.xOffset + m, A = y.yOffset + g, M !== null) { const w = y.kerning[L]; P += w !== void 0 ? w : 0 }P *= U, A *= U, P += O, m += y.xAdvance + c, M = y, L = x, !(E === 0 || C === 0 || x === 32) && (B && (P = Math.round(P), A = Math.round(A)), l.save(), l.translate(P, A), l.scale(U, U), l.drawImage(F, T, S, E, C, 0, 0, E, C), l.restore()) } }l.restore() } }; e.exports = h }, function (e, d, t) { let i = t(1); let h = t(1); i = t(1050), h = t(1051), e.exports = { renderWebGL: i, renderCanvas: h } }, function (e, d, t) { const i = t(25); const h = t(12); const n = new i(); const o = function (r, s, a, f) { const l = s.getRenderList(); if (l.length !== 0) { const u = a.alpha * s.alpha; if (u !== 0) { a.addToRenderList(s); const v = r.pipelines.set(this.pipeline, s); let p = a.scrollX * s.scrollFactorX; let c = a.scrollY * s.scrollFactorY; const m = n.copyFrom(a.matrix); f && (m.multiplyWithOffset(f, -p, -c), p = 0, c = 0); const g = s.x - p; const x = s.y - c; let y = -1; const T = !1; const S = a.roundPixels; r.pipelines.preBatch(s); for (let E = 0; E < l.length; E++) { const C = l[E]; const P = C.frame; const A = C.alpha * u; if (A !== 0) { let M = P.width; let L = P.height; let F = g + C.x + P.x; let I = x + C.y + P.y; C.flipX && (M *= -1, F += P.width), C.flipY && (L *= -1, I += P.height); const G = F + M; const U = I + L; let Y = m.getX(F, I); let X = m.getY(F, I); let O = m.getX(G, U); let R = m.getY(G, U); const D = h.getTintAppendFloatAlpha(C.tint, A); if (P.sourceIndex !== y) { var B = v.setGameObject(s, P); y = P.sourceIndex }S && (Y = Math.round(Y), X = Math.round(X), O = Math.round(O), R = Math.round(R)), v.batchQuad(s, Y, X, Y, R, O, R, O, X, P.u0, P.v0, P.u1, P.v1, D, D, D, D, T, P.glTexture, B) && (y = -1) } }r.pipelines.postBatch(s) } } }; e.exports = o }, function (e, d) { const t = function (i, h, n, o) { const r = h.getRenderList(); if (r.length !== 0) { const s = i.currentContext; const a = n.alpha * h.alpha; if (a !== 0) { n.addToRenderList(h), s.globalCompositeOperation = i.blendModes[h.blendMode], s.imageSmoothingEnabled = !(!i.antialias || h.frame.source.scaleMode); const f = h.x - n.scrollX * h.scrollFactorX; const l = h.y - n.scrollY * h.scrollFactorY; s.save(), o && o.copyToContext(s); for (let u = n.roundPixels, v = 0; v < r.length; v++) { const p = r[v]; const c = p.flipX || p.flipY; const m = p.frame; const g = m.canvasData; let x = m.x; let y = m.y; let T = 1; let S = 1; const E = p.alpha * a; E !== 0 && (s.globalAlpha = E, c ? (p.flipX && (T = -1, x -= g.width), p.flipY && (S = -1, y -= g.height), s.save(), s.translate(p.x + f, p.y + l), s.scale(T, S), s.drawImage(m.source.image, g.x, g.y, g.width, g.height, x, y, g.width, g.height), s.restore()) : (u && (x = Math.round(x), y = Math.round(y)), s.drawImage(m.source.image, g.x, g.y, g.width, g.height, x + p.x + f, y + p.y + l, g.width, g.height))) }s.restore() } } }; e.exports = t }, function (e, d, t) { let i = t(1); let h = t(1); i = t(1053), h = t(1054), e.exports = { renderWebGL: i, renderCanvas: h } }, function (e, d) { const t = function (i, h, n, o) { n.addToRenderList(h); const r = h.list; const s = r.length; if (s !== 0) { const a = h.localTransform; o ? (a.loadIdentity(), a.multiply(o), a.translate(h.x, h.y), a.rotate(h.rotation), a.scale(h.scaleX, h.scaleY)) : a.applyITRS(h.x, h.y, h.rotation, h.scaleX, h.scaleY), i.pipelines.preBatch(h); const f = h.blendMode !== -1; f || i.setBlendMode(0); for (let l = h.alpha, u = h.scrollFactorX, v = h.scrollFactorY, p = 0; p < s; p++) { const c = r[p]; if (c.willRender(n)) { var m, g, x, y; if (c.alphaTopLeft !== void 0)m = c.alphaTopLeft, g = c.alphaTopRight, x = c.alphaBottomLeft, y = c.alphaBottomRight; else { const T = c.alpha; m = T, g = T, x = T, y = T } const S = c.scrollFactorX; const E = c.scrollFactorY; !f && c.blendMode !== i.currentBlendMode && i.setBlendMode(c.blendMode); const C = c.mask; C && C.preRenderWebGL(i, c, n); const P = c.type; P !== i.currentType && (i.newType = !0, i.currentType = P), i.nextTypeMatch = p < s - 1 ? r[p + 1].type === i.currentType : !1, c.setScrollFactor(S * u, E * v), c.setAlpha(m * l, g * l, x * l, y * l), c.renderWebGL(i, c, n, a), c.setAlpha(m, g, x, y), c.setScrollFactor(S, E), C && C.postRenderWebGL(i, n), i.newType = !1 } }i.pipelines.postBatch(h) } }; e.exports = t }, function (e, d) { const t = function (i, h, n, o) { n.addToRenderList(h); const r = h.list; if (r.length !== 0) { const s = h.localTransform; o ? (s.loadIdentity(), s.multiply(o), s.translate(h.x, h.y), s.rotate(h.rotation), s.scale(h.scaleX, h.scaleY)) : s.applyITRS(h.x, h.y, h.rotation, h.scaleX, h.scaleY); const a = h.blendMode !== -1; a || i.setBlendMode(0); const f = h._alpha; const l = h.scrollFactorX; const u = h.scrollFactorY; h.mask && h.mask.preRenderCanvas(i, null, n); for (let v = 0; v < r.length; v++) { const p = r[v]; if (p.willRender(n)) { const c = p.alpha; const m = p.scrollFactorX; const g = p.scrollFactorY; !a && p.blendMode !== i.currentBlendMode && i.setBlendMode(p.blendMode), p.setScrollFactor(m * l, g * u), p.setAlpha(c * f), p.renderCanvas(i, p, n, s), p.setAlpha(c), p.setScrollFactor(m, g) } }h.mask && h.mask.postRenderCanvas(i) } }; e.exports = t }, function (e, d, t) { let i = t(1); let h = t(1); i = t(443), h = t(443), e.exports = { renderWebGL: i, renderCanvas: h } }, function (e, d) { e.exports = ['normal', 'multiply', 'multiply', 'screen', 'overlay', 'darken', 'lighten', 'color-dodge', 'color-burn', 'hard-light', 'soft-light', 'difference', 'exclusion', 'hue', 'saturation', 'color', 'luminosity'] }, function (e, d, t) { let i = t(1); let h = t(1); i = t(1058), h = t(1059), e.exports = { renderWebGL: i, renderCanvas: h } }, function (e, d, t) { const i = t(19); const h = t(25); const n = t(12); const o = new h(); const r = function (s, a, f, l) { let u = a.text; let v = u.length; if (v !== 0) { f.addToRenderList(a); const p = s.pipelines.set(a.pipeline, a); const c = i(a, f, l); const m = c.sprite; const g = c.calc; const x = o; const y = a.cropWidth > 0 || a.cropHeight > 0; y && (p.flush(), s.pushScissor(g.tx, g.ty, a.cropWidth * g.scaleX, a.cropHeight * g.scaleY)); const T = a.frame; const S = T.glTexture; const E = a.tintFill; let C = n.getTintAppendFloatAlpha(a.tintTopLeft, f.alpha * a._alphaTL); let P = n.getTintAppendFloatAlpha(a.tintTopRight, f.alpha * a._alphaTR); let A = n.getTintAppendFloatAlpha(a.tintBottomLeft, f.alpha * a._alphaBL); let M = n.getTintAppendFloatAlpha(a.tintBottomRight, f.alpha * a._alphaBR); const L = p.setGameObject(a); let F = 0; let I = 0; let G = 0; let U = 0; const Y = a.letterSpacing; let X; let O = 0; let R = 0; let D; const B = a.scrollX; const N = a.scrollY; const w = a.fontData; const z = w.chars; const V = w.lineHeight; let W = a.fontSize / w.size; let H = 0; const K = a._align; let Q = 0; let J = 0; const q = a.getTextBounds(!1); a.maxWidth > 0 && (u = q.wrappedText, v = u.length); const j = a._bounds.lines; K === 1 ? J = (j.longest - j.lengths[0]) / 2 : K === 2 && (J = j.longest - j.lengths[0]); const _ = f.roundPixels; const rt = a.displayCallback; const nt = a.callbackData; s.pipelines.preBatch(a); for (let et = 0; et < v; et++) { if (G = u.charCodeAt(et), G === 10) { Q++, K === 1 ? J = (j.longest - j.lengths[Q]) / 2 : K === 2 && (J = j.longest - j.lengths[Q]), F = 0, I += V, D = null; continue } if (X = z[G], !!X) { O = X.width, R = X.height; let b = X.xOffset + F - B; let at = X.yOffset + I - N; if (D !== null) { const it = X.kerning[U]; b += it !== void 0 ? it : 0 } if (F += X.xAdvance + Y, D = X, U = G, !(O === 0 || R === 0 || G === 32)) { if (W = a.fontSize / a.fontData.size, H = 0, rt) { nt.color = 0, nt.tint.topLeft = C, nt.tint.topRight = P, nt.tint.bottomLeft = A, nt.tint.bottomRight = M, nt.index = et, nt.charCode = G, nt.x = b, nt.y = at, nt.scale = W, nt.rotation = H, nt.data = X.data; const st = rt(nt); b = st.x, at = st.y, W = st.scale, H = st.rotation, st.color ? (C = st.color, P = st.color, A = st.color, M = st.color) : (C = st.tint.topLeft, P = st.tint.topRight, A = st.tint.bottomLeft, M = st.tint.bottomRight), C = n.getTintAppendFloatAlpha(C, f.alpha * a._alphaTL), P = n.getTintAppendFloatAlpha(P, f.alpha * a._alphaTR), A = n.getTintAppendFloatAlpha(A, f.alpha * a._alphaBL), M = n.getTintAppendFloatAlpha(M, f.alpha * a._alphaBR) }b *= W, at *= W, b -= a.displayOriginX, at -= a.displayOriginY, b += J, x.applyITRS(b, at, H, W, W), g.multiply(x, m); const Kt = X.u0; const Zt = X.v0; const ct = X.u1; const lt = X.v1; const Pt = O; const Ct = R; let St = m.e; let Qt = m.f; let Oe = Ct * m.c + m.e; let Fe = Ct * m.d + m.f; let De = Pt * m.a + Ct * m.c + m.e; let Ie = Pt * m.b + Ct * m.d + m.f; let Be = Pt * m.a + m.e; let Ne = Pt * m.b + m.f; _ && (St = Math.round(St), Qt = Math.round(Qt), Oe = Math.round(Oe), Fe = Math.round(Fe), De = Math.round(De), Ie = Math.round(Ie), Be = Math.round(Be), Ne = Math.round(Ne)), p.batchQuad(a, St, Qt, Oe, Fe, De, Ie, Be, Ne, Kt, Zt, ct, lt, C, P, A, M, E, S, L) } } }y && (p.flush(), s.popScissor()), s.pipelines.postBatch(a) } }; e.exports = r }, function (e, d, t) { const i = t(30); const h = function (n, o, r, s) { const a = o._text; const f = a.length; const l = n.currentContext; if (!(f === 0 || !i(n, l, o, r, s))) { r.addToRenderList(o); const u = o.fromAtlas ? o.frame : o.texture.frames.__BASE; const v = o.displayCallback; const p = o.callbackData; const c = o.fontData.chars; const m = o.fontData.lineHeight; const g = o._letterSpacing; let x = 0; let y = 0; let T = 0; let S = null; let E = 0; let C = 0; let P = 0; let A = 0; let M = 0; let L = 0; let F = null; let I = 0; const G = o.frame.source.image; const U = u.cutX; const Y = u.cutY; let X = 0; let O = 0; const R = o._fontSize / o.fontData.size; const D = o._align; let B = 0; let N = 0; o.getTextBounds(!1); const w = o._bounds.lines; D === 1 ? N = (w.longest - w.lengths[0]) / 2 : D === 2 && (N = w.longest - w.lengths[0]), l.translate(-o.displayOriginX, -o.displayOriginY); const z = r.roundPixels; o.cropWidth > 0 && o.cropHeight > 0 && (l.beginPath(), l.rect(0, 0, o.cropWidth, o.cropHeight), l.clip()); for (let V = 0; V < f; V++) { if (O = R, X = 0, T = a.charCodeAt(V), T === 10) { B++, D === 1 ? N = (w.longest - w.lengths[B]) / 2 : D === 2 && (N = w.longest - w.lengths[B]), x = 0, y += m, F = null; continue } if (S = c[T], !!S) { if (E = U + S.x, C = Y + S.y, P = S.width, A = S.height, M = S.xOffset + x - o.scrollX, L = S.yOffset + y - o.scrollY, F !== null) { const W = S.kerning[I]; M += W !== void 0 ? W : 0 } if (v) { p.index = V, p.charCode = T, p.x = M, p.y = L, p.scale = O, p.rotation = X, p.data = S.data; const H = v(p); M = H.x, L = H.y, O = H.scale, X = H.rotation }M *= O, L *= O, M += N, x += S.xAdvance + g, F = S, I = T, !(P === 0 || A === 0 || T === 32) && (z && (M = Math.round(M), L = Math.round(L)), l.save(), l.translate(M, L), l.rotate(X), l.scale(O, O), l.drawImage(G, E, C, P, A, 0, 0, P, A), l.restore()) } }l.restore() } }; e.exports = h }, function (e, d, t) { let i = t(1); let h = t(1); i = t(1061), h = t(1062), e.exports = { renderWebGL: i, renderCanvas: h } }, function (e, d, t) { const i = t(19); const h = function (n, o, r, s) { n.pipelines.clear(); const a = i(o, r, s).calc; o.render.call(o, n, r, a), n.pipelines.rebind() }; e.exports = h }, function (e, d) {}, function (e, d, t) { let i = t(1); let h = t(1); i = t(1064), h = t(448), h = t(448), e.exports = { renderWebGL: i, renderCanvas: h } }, function (e, d, t) { const i = t(217); const h = t(19); const n = t(25); const o = t(12); const r = function (u, v, p) { this.x = u, this.y = v, this.width = p }; const s = function (u, v, p) { this.points = [], this.pointsLength = 1, this.points[0] = new r(u, v, p) }; const a = []; const f = new n(); const l = function (u, v, p, c) { if (v.commandBuffer.length !== 0) { p.addToRenderList(v); const m = u.pipelines.set(v.pipeline, v); u.pipelines.preBatch(v); for (var g = h(v, p, c).calc, x = f.loadIdentity(), y = v.commandBuffer, T = p.alpha * v.alpha, S = 1, E = m.fillTint, C = m.strokeTint, P = 0, A = 0, M = 0, L = 0.01, F = Math.PI * 2, I, G = [], U = 0, Y = !0, X = null, O = o.getTintAppendFloatAlpha, R = 0; R < y.length; R++) switch (I = y[R], I) { case i.BEGIN_PATH: { G.length = 0, X = null, Y = !0; break } case i.CLOSE_PATH: { Y = !1, X && X.points.length && X.points.push(X.points[0]); break } case i.FILL_PATH: { for (U = 0; U < G.length; U++)m.batchFillPath(G[U].points, x, g); break } case i.STROKE_PATH: { for (U = 0; U < G.length; U++)m.batchStrokePath(G[U].points, S, Y, x, g); break } case i.LINE_STYLE: { S = y[++R]; const D = y[++R]; const B = y[++R] * T; const N = O(D, B); C.TL = N, C.TR = N, C.BL = N, C.BR = N; break } case i.FILL_STYLE: { const w = y[++R]; const z = y[++R] * T; const V = O(w, z); E.TL = V, E.TR = V, E.BL = V, E.BR = V; break } case i.GRADIENT_FILL_STYLE: { const W = y[++R] * T; const H = y[++R] * T; const K = y[++R] * T; const Q = y[++R] * T; E.TL = O(y[++R], W), E.TR = O(y[++R], H), E.BL = O(y[++R], K), E.BR = O(y[++R], Q); break } case i.GRADIENT_LINE_STYLE: { S = y[++R]; const J = y[++R] * T; C.TL = O(y[++R], J), C.TR = O(y[++R], J), C.BL = O(y[++R], J), C.BR = O(y[++R], J); break } case i.ARC: { let q = 0; var j = y[++R]; var _ = y[++R]; const rt = y[++R]; const nt = y[++R]; let et = y[++R]; const b = y[++R]; const at = y[++R]; for (et -= nt, b ? et < -F ? et = -F : et > 0 && (et = -F + et % F) : et > F ? et = F : et < 0 && (et = F + et % F), X === null && (X = new s(j + Math.cos(nt) * rt, _ + Math.sin(nt) * rt, S), G.push(X), q += L); q < 1 + at;)M = et * q + nt, P = j + Math.cos(M) * rt, A = _ + Math.sin(M) * rt, X.points.push(new r(P, A, S)), q += L; M = et + nt, P = j + Math.cos(M) * rt, A = _ + Math.sin(M) * rt, X.points.push(new r(P, A, S)); break } case i.FILL_RECT: { m.batchFillRect(y[++R], y[++R], y[++R], y[++R], x, g); break } case i.FILL_TRIANGLE: { m.batchFillTriangle(y[++R], y[++R], y[++R], y[++R], y[++R], y[++R], x, g); break } case i.STROKE_TRIANGLE: { m.batchStrokeTriangle(y[++R], y[++R], y[++R], y[++R], y[++R], y[++R], S, x, g); break } case i.LINE_TO: { X !== null ? X.points.push(new r(y[++R], y[++R], S)) : (X = new s(y[++R], y[++R], S), G.push(X)); break } case i.MOVE_TO: { X = new s(y[++R], y[++R], S), G.push(X); break } case i.SAVE: { a.push(x.copyToArray()); break } case i.RESTORE: { x.copyFromArray(a.pop()); break } case i.TRANSLATE: { j = y[++R], _ = y[++R], x.translate(j, _); break } case i.SCALE: { j = y[++R], _ = y[++R], x.scale(j, _); break } case i.ROTATE: { x.rotate(y[++R]); break } }u.pipelines.postBatch(v) } }; e.exports = l }, function (e, d, t) { let i = t(1); let h = t(1); i = t(1066), h = t(1067), e.exports = { renderWebGL: i, renderCanvas: h } }, function (e, d) { const t = function (i, h, n, o) { n.addToRenderList(h), h.pipeline.batchSprite(h, n, o) }; e.exports = t }, function (e, d) { const t = function (i, h, n, o) { n.addToRenderList(h), i.batchSprite(h, h.frame, n, o) }; e.exports = t }, function (e, d, t) { let i = t(1); let h = t(1); i = t(1069), h = t(1070), e.exports = { renderWebGL: i, renderCanvas: h } }, function (e, d) { const t = function (i, h, n, o) { n.addToRenderList(h), this.pipeline.batchSprite(h, n, o) }; e.exports = t }, function (e, d) { const t = function (i, h, n, o) { n.addToRenderList(h), i.batchSprite(h, h.frame, n, o) }; e.exports = t }, function (e, d, t) { let i = t(1); let h = t(1); i = t(1072), h = t(1073), e.exports = { renderWebGL: i, renderCanvas: h } }, function (e, d) { const t = function (i, h, n) { const o = h.list; const r = o.length; if (r !== 0) { h.depthSort(), i.pipelines.preBatch(h); const s = h.blendMode !== -1; s || i.setBlendMode(0); for (let a = h.alpha, f = 0; f < r; f++) { const l = o[f]; if (l.willRender(n)) { var u, v, p, c; if (l.alphaTopLeft !== void 0)u = l.alphaTopLeft, v = l.alphaTopRight, p = l.alphaBottomLeft, c = l.alphaBottomRight; else { const m = l.alpha; u = m, v = m, p = m, c = m }!s && l.blendMode !== i.currentBlendMode && i.setBlendMode(l.blendMode); const g = l.mask; g && g.preRenderWebGL(i, l, n); const x = l.type; x !== i.currentType && (i.newType = !0, i.currentType = x), i.nextTypeMatch = f < r - 1 ? o[f + 1].type === i.currentType : !1, l.setAlpha(u * a, v * a, p * a, c * a), l.renderWebGL(i, l, n), l.setAlpha(u, v, p, c), g && g.postRenderWebGL(i, n), i.newType = !1 } }i.pipelines.postBatch(h) } }; e.exports = t }, function (e, d) { const t = function (i, h, n) { const o = h.list; if (o.length !== 0) { h.depthSort(); const r = h.blendMode !== -1; r || i.setBlendMode(0); const s = h._alpha; h.mask && h.mask.preRenderCanvas(i, null, n); for (let a = 0; a < o.length; a++) { const f = o[a]; if (f.willRender(n)) { const l = f.alpha; !r && f.blendMode !== i.currentBlendMode && i.setBlendMode(f.blendMode), f.setAlpha(l * s), f.renderCanvas(i, f, n), f.setAlpha(l) } }h.mask && h.mask.postRenderCanvas(i) } }; e.exports = t }, function (e, d, t) { e.exports = { EmitterOp: t(449), GravityWell: t(450), Particle: t(451), ParticleEmitter: t(452), ParticleEmitterManager: t(220), Zones: t(1078) } }, function (e, d, t) { let i = t(1); let h = t(1); i = t(1076), h = t(1077), e.exports = { renderWebGL: i, renderCanvas: h } }, function (e, d, t) { const i = t(25); const h = t(12); const n = new i(); const o = new i(); const r = new i(); const s = new i(); const a = function (f, l, u, v) { const p = l.emitters.list; const c = p.length; if (c !== 0) { const m = f.pipelines.set(l.pipeline); const g = n; const x = o; const y = r; const T = s; v ? (T.loadIdentity(), T.multiply(v), T.translate(l.x, l.y), T.rotate(l.rotation), T.scale(l.scaleX, l.scaleY)) : T.applyITRS(l.x, l.y, l.rotation, l.scaleX, l.scaleY); const S = u.roundPixels; const E = l.defaultFrame.glTexture; const C = h.getTintAppendFloatAlpha; const P = m.setGameObject(l, l.defaultFrame); f.pipelines.preBatch(l); for (let A = 0; A < c; A++) { const M = p[A]; const L = M.alive; const F = L.length; if (!(!M.visible || F === 0)) { u.addToRenderList(M); const I = M.scrollFactorX; const G = M.scrollFactorY; f.setBlendMode(M.blendMode), M.mask && (M.mask.preRenderWebGL(f, M, u), f.pipelines.set(l.pipeline)); for (let U = 0, Y = 0; Y < F; Y++) { const X = L[Y]; const O = X.alpha * u.alpha; if (!(O <= 0)) { y.applyITRS(X.x, X.y, X.rotation, X.scaleX, X.scaleY), g.copyFrom(u.matrix), g.multiplyWithOffset(T, -u.scrollX * I, -u.scrollY * G), y.e = X.x, y.f = X.y, g.multiply(y, x); const R = X.frame; const D = -R.halfWidth; const B = -R.halfHeight; const N = D + R.width; const w = B + R.height; const z = x.getXRound(D, B, S); const V = x.getYRound(D, B, S); const W = x.getXRound(D, w, S); const H = x.getYRound(D, w, S); const K = x.getXRound(N, w, S); const Q = x.getYRound(N, w, S); const J = x.getXRound(N, B, S); const q = x.getYRound(N, B, S); const j = C(X.tint, O); m.batchQuad(M, z, V, W, H, K, Q, J, q, R.u0, R.v0, R.u1, R.v1, j, j, j, j, U, E, P) } }M.mask && M.mask.postRenderWebGL(f, u) } }f.pipelines.postBatch(l) } }; e.exports = a }, function (e, d, t) { const i = t(25); const h = new i(); const n = new i(); const o = new i(); const r = new i(); const s = function (a, f, l, u) { const v = f.emitters.list; const p = v.length; if (p !== 0) { const c = h.copyFrom(l.matrix); const m = n; const g = o; const x = r; u ? (x.loadIdentity(), x.multiply(u), x.translate(f.x, f.y), x.rotate(f.rotation), x.scale(f.scaleX, f.scaleY)) : x.applyITRS(f.x, f.y, f.rotation, f.scaleX, f.scaleY); for (let y = a.currentContext, T = l.roundPixels, S = 0; S < p; S++) { const E = v[S]; const C = E.alive; const P = C.length; if (!(!E.visible || P === 0)) { l.addToRenderList(E); const A = E.scrollFactorX; const M = E.scrollFactorY; y.save(), y.globalCompositeOperation = a.blendModes[E.blendMode]; for (let L = 0; L < P; L++) { const F = C[L]; const I = F.alpha * l.alpha; if (!(I <= 0)) { g.applyITRS(F.x, F.y, F.rotation, F.scaleX, F.scaleY), c.copyFrom(l.matrix), c.multiplyWithOffset(x, -l.scrollX * A, -l.scrollY * M), g.e = F.x, g.f = F.y, c.multiply(g, m); const G = F.frame; const U = G.canvasData; let Y = -G.halfWidth; let X = -G.halfHeight; y.globalAlpha = I, y.save(), m.setToContext(y), T && (Y = Math.round(Y), X = Math.round(X)), y.imageSmoothingEnabled = !(!a.antialias || G.source.scaleMode), y.drawImage(G.source.image, U.x, U.y, U.width, U.height, Y, X, U.width, U.height), y.restore() } }y.restore() } } } }; e.exports = s }, function (e, d, t) { e.exports = { DeathZone: t(453), EdgeZone: t(454), RandomZone: t(456) } }, function (e, d, t) { let i = t(1); let h = t(1); i = t(1080), h = t(1081), e.exports = { renderWebGL: i, renderCanvas: h } }, function (e, d, t) { const i = t(12); const h = function (n, o, r, s) { r.addToRenderList(o); const a = r.alpha; const f = o.renderTarget; const l = f.width; const u = f.height; const v = i.getTintAppendFloatAlpha; const p = n.pipelines.set(o.pipeline); const c = p.setTexture2D(f.texture); n.pipelines.preBatch(o), p.batchTexture(o, f.texture, l, u, o.x, o.y, l, u, o.scaleX, o.scaleY, o.rotation, o.flipX, !o.flipY, o.scrollFactorX, o.scrollFactorY, o.displayOriginX, o.displayOriginY, 0, 0, l, u, v(o.tintTopLeft, a * o._alphaTL), v(o.tintTopRight, a * o._alphaTR), v(o.tintBottomLeft, a * o._alphaBL), v(o.tintBottomRight, a * o._alphaBR), o.tintFill, 0, 0, r, s, !0, c), n.resetTextures(), n.pipelines.postBatch(o) }; e.exports = h }, function (e, d) { const t = function (i, h, n, o) { n.addToRenderList(h), i.batchSprite(h, h.frame, n, o) }; e.exports = t }, function (e, d, t) { const i = t(1083); const h = t(17); let n = { Parse: t(1084) }; n = h(!1, n, i), e.exports = n }, function (e, d) { const t = { TEXT_SET1: " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~", TEXT_SET2: ' !"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ', TEXT_SET3: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ', TEXT_SET4: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789', TEXT_SET5: "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789", TEXT_SET6: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789"(),-.\' ', TEXT_SET7: 'AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW")28FLRX-\'39', TEXT_SET8: '0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ', TEXT_SET9: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,\'"?!', TEXT_SET10: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', TEXT_SET11: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ.,"-+!?()\':;0123456789' }; e.exports = t }, function (e, d, t) { const i = t(6); const h = function (n, o) { const r = o.width; const s = o.height; const a = Math.floor(r / 2); const f = Math.floor(s / 2); const l = i(o, 'chars', ''); if (l !== '') { const u = i(o, 'image', ''); const v = n.sys.textures.getFrame(u); const p = v.cutX; const c = v.cutY; const m = v.source.width; const g = v.source.height; const x = i(o, 'offset.x', 0); const y = i(o, 'offset.y', 0); const T = i(o, 'spacing.x', 0); const S = i(o, 'spacing.y', 0); const E = i(o, 'lineSpacing', 0); let C = i(o, 'charsPerRow', null); C === null && (C = m / r, C > l.length && (C = l.length)); for (var P = x, A = y, M = { retroFont: !0, font: u, size: r, lineHeight: s + E, chars: {} }, L = 0, F = 0; F < l.length; F++) { const I = l.charCodeAt(F); const G = (p + P) / m; const U = (c + A) / g; const Y = (p + P + r) / m; const X = (c + A + s) / g; M.chars[I] = { x: P, y: A, width: r, height: s, centerX: a, centerY: f, xOffset: 0, yOffset: 0, xAdvance: r, data: {}, kerning: {}, u0: G, v0: U, u1: Y, v1: X }, L++, L === C ? (L = 0, P = x, A += s + S) : P += r + T } const O = { data: M, frame: null, texture: u }; return O } }; e.exports = h }, function (e, d, t) { let i = t(1); let h = t(1); i = t(1086), h = t(1087), e.exports = { renderWebGL: i, renderCanvas: h } }, function (e, d, t) { const i = t(19); const h = t(12); const n = function (o, r, s, a) { s.addToRenderList(r); const f = o.pipelines.set(r.pipeline, r); const l = i(r, s, a).calc; const u = r.vertices; const v = r.uv; const p = r.colors; const c = r.alphas; const m = r.alpha; const g = h.getTintAppendFloatAlpha; const x = s.roundPixels; const y = u.length; const T = Math.floor(y * 0.5); f.flush(), o.pipelines.preBatch(r); const S = f.setGameObject(r); const E = f.vertexViewF32; const C = f.vertexViewU32; let P = f.vertexCount * f.currentShader.vertexComponentCount - 1; let A = 0; const M = r.tintFill; r.dirty && r.updateVertices(); for (var L = r.debugCallback, F = [], I = 0; I < y; I += 2) { const G = u[I + 0]; const U = u[I + 1]; let Y = G * l.a + U * l.c + l.e; let X = G * l.b + U * l.d + l.f; x && (Y = Math.round(Y), X = Math.round(X)), E[++P] = Y, E[++P] = X, E[++P] = v[I + 0], E[++P] = v[I + 1], E[++P] = S, E[++P] = M, C[++P] = g(p[A], s.alpha * (c[A] * m)), A++, L && (F[I + 0] = Y, F[I + 1] = X) }L && L.call(r, r, y, F), f.vertexCount += T, o.pipelines.postBatch(r) }; e.exports = n }, function (e, d) { const t = function () {}; e.exports = t }, function (e, d, t) { let i = t(1); let h = t(1); i = t(1089), h = t(1090), e.exports = { renderWebGL: i, renderCanvas: h } }, function (e, d, t) { const i = t(12); const h = function (n, o, r, s) { if (!(o.width === 0 || o.height === 0)) { r.addToRenderList(o); const a = o.frame; const f = a.width; const l = a.height; const u = i.getTintAppendFloatAlpha; const v = n.pipelines.set(o.pipeline, o); const p = v.setTexture2D(a.glTexture, o); n.pipelines.preBatch(o), v.batchTexture(o, a.glTexture, f, l, o.x, o.y, f / o.style.resolution, l / o.style.resolution, o.scaleX, o.scaleY, o.rotation, o.flipX, o.flipY, o.scrollFactorX, o.scrollFactorY, o.displayOriginX, o.displayOriginY, 0, 0, f, l, u(o.tintTopLeft, r.alpha * o._alphaTL), u(o.tintTopRight, r.alpha * o._alphaTR), u(o.tintBottomLeft, r.alpha * o._alphaBL), u(o.tintBottomRight, r.alpha * o._alphaBR), o.tintFill, 0, 0, r, s, !1, p), n.pipelines.postBatch(o) } }; e.exports = h }, function (e, d) { const t = function (i, h, n, o) { h.width === 0 || h.height === 0 || (n.addToRenderList(h), i.batchSprite(h, h.frame, n, o)) }; e.exports = t }, function (e, d, t) { let i = t(1); let h = t(1); i = t(1092), h = t(1093), e.exports = { renderWebGL: i, renderCanvas: h } }, function (e, d, t) { const i = t(12); const h = function (n, o, r, s) { o.updateCanvas(); const a = o.width; const f = o.height; if (!(a === 0 || f === 0)) { r.addToRenderList(o), n.pipelines.preBatch(o); const l = i.getTintAppendFloatAlpha; const u = n.pipelines.set(o.pipeline, o); const v = u.setTexture2D(o.fillPattern, o); u.batchTexture(o, o.fillPattern, o.displayFrame.width * o.tileScaleX, o.displayFrame.height * o.tileScaleY, o.x, o.y, a, f, o.scaleX, o.scaleY, o.rotation, o.flipX, o.flipY, o.scrollFactorX, o.scrollFactorY, o.originX * a, o.originY * f, 0, 0, a, f, l(o.tintTopLeft, r.alpha * o._alphaTL), l(o.tintTopRight, r.alpha * o._alphaTR), l(o.tintBottomLeft, r.alpha * o._alphaBL), l(o.tintBottomRight, r.alpha * o._alphaBR), o.tintFill, o.tilePositionX % o.displayFrame.width / o.displayFrame.width, o.tilePositionY % o.displayFrame.height / o.displayFrame.height, r, s, !1, v), n.pipelines.postBatch(o) } }; e.exports = h }, function (e, d) { const t = function (i, h, n, o) { h.updateCanvas(), n.addToRenderList(h), i.batchSprite(h, h.frame, n, o) }; e.exports = t }, function (e, d, t) { let i = t(1); let h = t(1); i = t(1095), h = t(1096), e.exports = { renderWebGL: i, renderCanvas: h } }, function (e, d) { const t = function (i, h, n, o) { h.videoTexture && (n.addToRenderList(h), h.pipeline.batchSprite(h, n, o)) }; e.exports = t }, function (e, d) { const t = function (i, h, n, o) { h.videoTexture && (n.addToRenderList(h), i.batchSprite(h, h.frame, n, o)) }; e.exports = t }, function (e, d, t) { let i = t(1); let h = t(1); i = t(1098), h = t(1099), e.exports = { renderWebGL: i, renderCanvas: h } }, function (e, d, t) { const i = t(19); const h = t(114); const n = t(81); const o = function (r, s, a, f) { a.addToRenderList(s); const l = r.pipelines.set(s.pipeline); const u = i(s, a, f); const v = l.calcMatrix.copyFrom(u.calc); const p = s._displayOriginX; const c = s._displayOriginY; const m = a.alpha * s.alpha; r.pipelines.preBatch(s), s.isFilled && h(l, v, s, m, p, c), s.isStroked && n(l, s, m, p, c), r.pipelines.postBatch(s) }; e.exports = o }, function (e, d, t) { const i = t(36); const h = t(48); const n = t(60); const o = t(30); const r = function (s, a, f, l) { f.addToRenderList(a); const u = s.currentContext; if (o(s, u, a, f, l)) { const v = a.radius; u.beginPath(), u.arc(v - a.originX * (v * 2), v - a.originY * (v * 2), v, i(a._startAngle), i(a._endAngle), a.anticlockwise), a.closePath && u.closePath(), a.isFilled && (h(u, a), u.fill()), a.isStroked && (n(u, a), u.stroke()), u.restore() } }; e.exports = r }, function (e, d, t) { let i = t(1); let h = t(1); i = t(1101), h = t(1102), e.exports = { renderWebGL: i, renderCanvas: h } }, function (e, d, t) { const i = t(114); const h = t(19); const n = t(81); const o = function (r, s, a, f) { a.addToRenderList(s); const l = r.pipelines.set(s.pipeline); const u = h(s, a, f); const v = l.calcMatrix.copyFrom(u.calc); const p = s._displayOriginX + s._curveBounds.x; const c = s._displayOriginY + s._curveBounds.y; const m = a.alpha * s.alpha; r.pipelines.preBatch(s), s.isFilled && i(l, v, s, m, p, c), s.isStroked && n(l, s, m, p, c), r.pipelines.postBatch(s) }; e.exports = o }, function (e, d, t) { const i = t(48); const h = t(60); const n = t(30); const o = function (r, s, a, f) { a.addToRenderList(s); const l = r.currentContext; if (n(r, l, s, a, f)) { const u = s._displayOriginX + s._curveBounds.x; const v = s._displayOriginY + s._curveBounds.y; const p = s.pathData; let c = p.length - 1; const m = p[0] - u; const g = p[1] - v; l.beginPath(), l.moveTo(m, g), s.closePath || (c -= 2); for (let x = 2; x < c; x += 2) { const y = p[x] - u; const T = p[x + 1] - v; l.lineTo(y, T) }s.closePath && l.closePath(), s.isFilled && (i(l, s), l.fill()), s.isStroked && (h(l, s), l.stroke()), l.restore() } }; e.exports = o }, function (e, d, t) { let i = t(1); let h = t(1); i = t(1104), h = t(1105), e.exports = { renderWebGL: i, renderCanvas: h } }, function (e, d, t) { const i = t(114); const h = t(19); const n = t(81); const o = function (r, s, a, f) { a.addToRenderList(s); const l = r.pipelines.set(s.pipeline); const u = h(s, a, f); const v = l.calcMatrix.copyFrom(u.calc); const p = s._displayOriginX; const c = s._displayOriginY; const m = a.alpha * s.alpha; r.pipelines.preBatch(s), s.isFilled && i(l, v, s, m, p, c), s.isStroked && n(l, s, m, p, c), r.pipelines.postBatch(s) }; e.exports = o }, function (e, d, t) { const i = t(48); const h = t(60); const n = t(30); const o = function (r, s, a, f) { a.addToRenderList(s); const l = r.currentContext; if (n(r, l, s, a, f)) { const u = s._displayOriginX; const v = s._displayOriginY; const p = s.pathData; let c = p.length - 1; const m = p[0] - u; const g = p[1] - v; l.beginPath(), l.moveTo(m, g), s.closePath || (c -= 2); for (let x = 2; x < c; x += 2) { const y = p[x] - u; const T = p[x + 1] - v; l.lineTo(y, T) }l.closePath(), s.isFilled && (i(l, s), l.fill()), s.isStroked && (h(l, s), l.stroke()), l.restore() } }; e.exports = o }, function (e, d, t) { let i = t(1); let h = t(1); i = t(1107), h = t(1108), e.exports = { renderWebGL: i, renderCanvas: h } }, function (e, d, t) { const i = t(19); const h = t(12); const n = function (o, r, s, a) { s.addToRenderList(r); const f = o.pipelines.set(r.pipeline); const l = i(r, s, a); const u = f.calcMatrix.copyFrom(l.calc); u.translate(-r._displayOriginX, -r._displayOriginY); const v = s.alpha * r.alpha; const p = r.width; const c = r.height; const m = r.cellWidth; const g = r.cellHeight; const x = Math.ceil(p / m); const y = Math.ceil(c / g); let T = m; let S = g; let E = m - (x * m - p); let C = g - (y * g - c); let P; let A; const M = r.showCells; const L = r.showAltCells; const F = r.showOutline; let I = 0; let G = 0; let U = 0; let Y = 0; let X = 0; if (F && (T--, S--, E === m && E--, C === g && C--), o.pipelines.preBatch(r), M && r.fillAlpha > 0) for (P = f.fillTint, A = h.getTintAppendFloatAlpha(r.fillColor, r.fillAlpha * v), P.TL = A, P.TR = A, P.BL = A, P.BR = A, G = 0; G < y; G++) for (L && (U = G % 2), I = 0; I < x; I++) { if (L && U) { U = 0; continue }U++, Y = I < x - 1 ? T : E, X = G < y - 1 ? S : C, f.batchFillRect(I * m, G * g, Y, X) } if (L && r.altFillAlpha > 0) for (P = f.fillTint, A = h.getTintAppendFloatAlpha(r.altFillColor, r.altFillAlpha * v), P.TL = A, P.TR = A, P.BL = A, P.BR = A, G = 0; G < y; G++) for (L && (U = G % 2), I = 0; I < x; I++) { if (L && !U) { U = 1; continue }U = 0, Y = I < x - 1 ? T : E, X = G < y - 1 ? S : C, f.batchFillRect(I * m, G * g, Y, X) } if (F && r.outlineFillAlpha > 0) { const O = f.strokeTint; const R = h.getTintAppendFloatAlpha(r.outlineFillColor, r.outlineFillAlpha * v); for (O.TL = R, O.TR = R, O.BL = R, O.BR = R, I = 1; I < x; I++) { const D = I * m; f.batchLine(D, 0, D, c, 1, 1, 1, 0, !1) } for (G = 1; G < y; G++) { const B = G * g; f.batchLine(0, B, p, B, 1, 1, 1, 0, !1) } }o.pipelines.postBatch(r) }; e.exports = n }, function (e, d, t) { const i = t(48); const h = t(60); const n = t(30); const o = function (r, s, a, f) { a.addToRenderList(s); const l = r.currentContext; if (n(r, l, s, a, f)) { const u = -s._displayOriginX; const v = -s._displayOriginY; const p = a.alpha * s.alpha; const c = s.width; const m = s.height; const g = s.cellWidth; const x = s.cellHeight; const y = Math.ceil(c / g); const T = Math.ceil(m / x); let S = g; let E = x; let C = g - (y * g - c); let P = x - (T * x - m); const A = s.showCells; const M = s.showAltCells; const L = s.showOutline; let F = 0; let I = 0; let G = 0; let U = 0; let Y = 0; if (L && (S--, E--, C === g && C--, P === x && P--), A && s.fillAlpha > 0) for (i(l, s), I = 0; I < T; I++) for (M && (G = I % 2), F = 0; F < y; F++) { if (M && G) { G = 0; continue }G++, U = F < y - 1 ? S : C, Y = I < T - 1 ? E : P, l.fillRect(u + F * g, v + I * x, U, Y) } if (M && s.altFillAlpha > 0) for (i(l, s, s.altFillColor, s.altFillAlpha * p), I = 0; I < T; I++) for (M && (G = I % 2), F = 0; F < y; F++) { if (M && !G) { G = 1; continue }G = 0, U = F < y - 1 ? S : C, Y = I < T - 1 ? E : P, l.fillRect(u + F * g, v + I * x, U, Y) } if (L && s.outlineFillAlpha > 0) { for (h(l, s, s.outlineFillColor, s.outlineFillAlpha * p), F = 1; F < y; F++) { const X = F * g; l.beginPath(), l.moveTo(X + u, v), l.lineTo(X + u, m + v), l.stroke() } for (I = 1; I < T; I++) { const O = I * x; l.beginPath(), l.moveTo(u, O + v), l.lineTo(u + c, O + v), l.stroke() } }l.restore() } }; e.exports = o }, function (e, d, t) { let i = t(1); let h = t(1); i = t(1110), h = t(1111), e.exports = { renderWebGL: i, renderCanvas: h } }, function (e, d, t) { const i = t(19); const h = t(12); const n = function (o, r, s, a) { s.addToRenderList(r); const f = o.pipelines.set(r.pipeline); const l = i(r, s, a); const u = f.calcMatrix.copyFrom(l.calc); const v = r.width; const p = r.height; const c = v / 2; const m = v / r.projection; const g = s.alpha * r.alpha; if (r.isFilled) { let x, y, T, S, E, C, P, A, M; o.pipelines.preBatch(r), r.showTop && (x = h.getTintAppendFloatAlpha(r.fillTop, g), y = u.getX(-c, -p), T = u.getY(-c, -p), S = u.getX(0, -m - p), E = u.getY(0, -m - p), C = u.getX(c, -p), P = u.getY(c, -p), A = u.getX(0, m - p), M = u.getY(0, m - p), f.batchQuad(r, y, T, S, E, C, P, A, M, 0, 0, 1, 1, x, x, x, x, 2)), r.showLeft && (x = h.getTintAppendFloatAlpha(r.fillLeft, g), y = u.getX(-c, 0), T = u.getY(-c, 0), S = u.getX(0, m), E = u.getY(0, m), C = u.getX(0, m - p), P = u.getY(0, m - p), A = u.getX(-c, -p), M = u.getY(-c, -p), f.batchQuad(r, y, T, S, E, C, P, A, M, 0, 0, 1, 1, x, x, x, x, 2)), r.showRight && (x = h.getTintAppendFloatAlpha(r.fillRight, g), y = u.getX(c, 0), T = u.getY(c, 0), S = u.getX(0, m), E = u.getY(0, m), C = u.getX(0, m - p), P = u.getY(0, m - p), A = u.getX(c, -p), M = u.getY(c, -p), f.batchQuad(r, y, T, S, E, C, P, A, M, 0, 0, 1, 1, x, x, x, x, 2)), o.pipelines.postBatch(r) } }; e.exports = n }, function (e, d, t) { const i = t(48); const h = t(30); const n = function (o, r, s, a) { s.addToRenderList(r); const f = o.currentContext; if (h(o, f, r, s, a) && r.isFilled) { const l = r.width; const u = r.height; const v = l / 2; const p = l / r.projection; r.showTop && (i(f, r, r.fillTop), f.beginPath(), f.moveTo(-v, -u), f.lineTo(0, -p - u), f.lineTo(v, -u), f.lineTo(v, -1), f.lineTo(0, p - 1), f.lineTo(-v, -1), f.lineTo(-v, -u), f.fill()), r.showLeft && (i(f, r, r.fillLeft), f.beginPath(), f.moveTo(-v, 0), f.lineTo(0, p), f.lineTo(0, p - u), f.lineTo(-v, -u), f.lineTo(-v, 0), f.fill()), r.showRight && (i(f, r, r.fillRight), f.beginPath(), f.moveTo(v, 0), f.lineTo(0, p), f.lineTo(0, p - u), f.lineTo(v, -u), f.lineTo(v, 0), f.fill()), f.restore() } }; e.exports = n }, function (e, d, t) { let i = t(1); let h = t(1); i = t(1113), h = t(1114), e.exports = { renderWebGL: i, renderCanvas: h } }, function (e, d, t) { const i = t(19); const h = t(12); const n = function (o, r, s, a) { s.addToRenderList(r); const f = o.pipelines.set(r.pipeline); const l = i(r, s, a); const u = f.calcMatrix.copyFrom(l.calc); const v = r.width; const p = r.height; const c = v / 2; const m = v / r.projection; const g = r.isReversed; const x = s.alpha * r.alpha; if (r.isFilled) { o.pipelines.preBatch(r); let y, T, S, E, C, P, A; if (r.showTop && g) { y = h.getTintAppendFloatAlpha(r.fillTop, x), T = u.getX(-c, -p), S = u.getY(-c, -p), E = u.getX(0, -m - p), C = u.getY(0, -m - p), P = u.getX(c, -p), A = u.getY(c, -p); const M = u.getX(0, m - p); const L = u.getY(0, m - p); f.batchQuad(r, T, S, E, C, P, A, M, L, 0, 0, 1, 1, y, y, y, y, 2) }r.showLeft && (y = h.getTintAppendFloatAlpha(r.fillLeft, x), g ? (T = u.getX(-c, -p), S = u.getY(-c, -p), E = u.getX(0, m), C = u.getY(0, m), P = u.getX(0, m - p), A = u.getY(0, m - p)) : (T = u.getX(-c, 0), S = u.getY(-c, 0), E = u.getX(0, m), C = u.getY(0, m), P = u.getX(0, m - p), A = u.getY(0, m - p)), f.batchTri(r, T, S, E, C, P, A, 0, 0, 1, 1, y, y, y, 2)), r.showRight && (y = h.getTintAppendFloatAlpha(r.fillRight, x), g ? (T = u.getX(c, -p), S = u.getY(c, -p), E = u.getX(0, m), C = u.getY(0, m), P = u.getX(0, m - p), A = u.getY(0, m - p)) : (T = u.getX(c, 0), S = u.getY(c, 0), E = u.getX(0, m), C = u.getY(0, m), P = u.getX(0, m - p), A = u.getY(0, m - p)), f.batchTri(r, T, S, E, C, P, A, 0, 0, 1, 1, y, y, y, 2)), o.pipelines.postBatch(r) } }; e.exports = n }, function (e, d, t) { const i = t(48); const h = t(30); const n = function (o, r, s, a) { s.addToRenderList(r); const f = o.currentContext; if (h(o, f, r, s, a) && r.isFilled) { const l = r.width; const u = r.height; const v = l / 2; const p = l / r.projection; const c = r.isReversed; r.showTop && c && (i(f, r, r.fillTop), f.beginPath(), f.moveTo(-v, -u), f.lineTo(0, -p - u), f.lineTo(v, -u), f.lineTo(0, p - u), f.fill()), r.showLeft && (i(f, r, r.fillLeft), f.beginPath(), c ? (f.moveTo(-v, -u), f.lineTo(0, p), f.lineTo(0, p - u)) : (f.moveTo(-v, 0), f.lineTo(0, p), f.lineTo(0, p - u)), f.fill()), r.showRight && (i(f, r, r.fillRight), f.beginPath(), c ? (f.moveTo(v, -u), f.lineTo(0, p), f.lineTo(0, p - u)) : (f.moveTo(v, 0), f.lineTo(0, p), f.lineTo(0, p - u)), f.fill()), f.restore() } }; e.exports = n }, function (e, d, t) { let i = t(1); let h = t(1); i = t(1116), h = t(1117), e.exports = { renderWebGL: i, renderCanvas: h } }, function (e, d, t) { const i = t(19); const h = t(12); const n = function (o, r, s, a) { s.addToRenderList(r); const f = o.pipelines.set(r.pipeline); const l = i(r, s, a); f.calcMatrix.copyFrom(l.calc); const u = r._displayOriginX; const v = r._displayOriginY; const p = s.alpha * r.alpha; if (o.pipelines.preBatch(r), r.isStroked) { const c = f.strokeTint; const m = h.getTintAppendFloatAlpha(r.strokeColor, r.strokeAlpha * p); c.TL = m, c.TR = m, c.BL = m, c.BR = m; const g = r._startWidth; const x = r._endWidth; f.batchLine(r.geom.x1 - u, r.geom.y1 - v, r.geom.x2 - u, r.geom.y2 - v, g, x, 1, 0, !1, l.sprite, l.camera) }o.pipelines.postBatch(r) }; e.exports = n }, function (e, d, t) { const i = t(60); const h = t(30); const n = function (o, r, s, a) { s.addToRenderList(r); const f = o.currentContext; if (h(o, f, r, s, a)) { const l = r._displayOriginX; const u = r._displayOriginY; r.isStroked && (i(f, r), f.beginPath(), f.moveTo(r.geom.x1 - l, r.geom.y1 - u), f.lineTo(r.geom.x2 - l, r.geom.y2 - u), f.stroke()), f.restore() } }; e.exports = n }, function (e, d, t) { let i = t(1); let h = t(1); i = t(1119), h = t(1120), e.exports = { renderWebGL: i, renderCanvas: h } }, function (e, d, t) { const i = t(114); const h = t(19); const n = t(81); const o = function (r, s, a, f) { a.addToRenderList(s); const l = r.pipelines.set(s.pipeline); const u = h(s, a, f); const v = l.calcMatrix.copyFrom(u.calc); const p = s._displayOriginX; const c = s._displayOriginY; const m = a.alpha * s.alpha; r.pipelines.preBatch(s), s.isFilled && i(l, v, s, m, p, c), s.isStroked && n(l, s, m, p, c), r.pipelines.postBatch(s) }; e.exports = o }, function (e, d, t) { const i = t(48); const h = t(60); const n = t(30); const o = function (r, s, a, f) { a.addToRenderList(s); const l = r.currentContext; if (n(r, l, s, a, f)) { const u = s._displayOriginX; const v = s._displayOriginY; const p = s.pathData; let c = p.length - 1; const m = p[0] - u; const g = p[1] - v; l.beginPath(), l.moveTo(m, g), s.closePath || (c -= 2); for (let x = 2; x < c; x += 2) { const y = p[x] - u; const T = p[x + 1] - v; l.lineTo(y, T) }l.closePath(), s.isFilled && (i(l, s), l.fill()), s.isStroked && (h(l, s), l.stroke()), l.restore() } }; e.exports = o }, function (e, d, t) { let i = t(1); let h = t(1); i = t(1122), h = t(1123), e.exports = { renderWebGL: i, renderCanvas: h } }, function (e, d, t) { const i = t(19); const h = t(81); const n = t(12); const o = function (r, s, a, f) { a.addToRenderList(s); const l = r.pipelines.set(s.pipeline); const u = i(s, a, f); l.calcMatrix.copyFrom(u.calc); const v = s._displayOriginX; const p = s._displayOriginY; const c = a.alpha * s.alpha; if (r.pipelines.preBatch(s), s.isFilled) { const m = l.fillTint; const g = n.getTintAppendFloatAlpha(s.fillColor, s.fillAlpha * c); m.TL = g, m.TR = g, m.BL = g, m.BR = g, l.batchFillRect(-v, -p, s.width, s.height) }s.isStroked && h(l, s, c, v, p), r.pipelines.postBatch(s) }; e.exports = o }, function (e, d, t) { const i = t(48); const h = t(60); const n = t(30); const o = function (r, s, a, f) { a.addToRenderList(s); const l = r.currentContext; if (n(r, l, s, a, f)) { const u = s._displayOriginX; const v = s._displayOriginY; s.isFilled && (i(l, s), l.fillRect(-u, -v, s.width, s.height)), s.isStroked && (h(l, s), l.beginPath(), l.rect(-u, -v, s.width, s.height), l.stroke()), l.restore() } }; e.exports = o }, function (e, d, t) { let i = t(1); let h = t(1); i = t(1125), h = t(1126), e.exports = { renderWebGL: i, renderCanvas: h } }, function (e, d, t) { const i = t(114); const h = t(19); const n = t(81); const o = function (r, s, a, f) { a.addToRenderList(s); const l = r.pipelines.set(s.pipeline); const u = h(s, a, f); const v = l.calcMatrix.copyFrom(u.calc); const p = s._displayOriginX; const c = s._displayOriginY; const m = a.alpha * s.alpha; r.pipelines.preBatch(s), s.isFilled && i(l, v, s, m, p, c), s.isStroked && n(l, s, m, p, c), r.pipelines.postBatch(s) }; e.exports = o }, function (e, d, t) { const i = t(48); const h = t(60); const n = t(30); const o = function (r, s, a, f) { a.addToRenderList(s); const l = r.currentContext; if (n(r, l, s, a, f)) { const u = s._displayOriginX; const v = s._displayOriginY; const p = s.pathData; let c = p.length - 1; const m = p[0] - u; const g = p[1] - v; l.beginPath(), l.moveTo(m, g), s.closePath || (c -= 2); for (let x = 2; x < c; x += 2) { const y = p[x] - u; const T = p[x + 1] - v; l.lineTo(y, T) }l.closePath(), s.isFilled && (i(l, s), l.fill()), s.isStroked && (h(l, s), l.stroke()), l.restore() } }; e.exports = o }, function (e, d, t) { let i = t(1); let h = t(1); i = t(1128), h = t(1129), e.exports = { renderWebGL: i, renderCanvas: h } }, function (e, d, t) { const i = t(19); const h = t(81); const n = t(12); const o = function (r, s, a, f) { a.addToRenderList(s); const l = r.pipelines.set(s.pipeline); const u = i(s, a, f); l.calcMatrix.copyFrom(u.calc); const v = s._displayOriginX; const p = s._displayOriginY; const c = a.alpha * s.alpha; if (r.pipelines.preBatch(s), s.isFilled) { const m = l.fillTint; const g = n.getTintAppendFloatAlpha(s.fillColor, s.fillAlpha * c); m.TL = g, m.TR = g, m.BL = g, m.BR = g; const x = s.geom.x1 - v; const y = s.geom.y1 - p; const T = s.geom.x2 - v; const S = s.geom.y2 - p; const E = s.geom.x3 - v; const C = s.geom.y3 - p; l.batchFillTriangle(x, y, T, S, E, C, u.sprite, u.camera) }s.isStroked && h(l, s, c, v, p), r.pipelines.postBatch(s) }; e.exports = o }, function (e, d, t) { const i = t(48); const h = t(60); const n = t(30); const o = function (r, s, a, f) { a.addToRenderList(s); const l = r.currentContext; if (n(r, l, s, a, f)) { const u = s._displayOriginX; const v = s._displayOriginY; const p = s.geom.x1 - u; const c = s.geom.y1 - v; const m = s.geom.x2 - u; const g = s.geom.y2 - v; const x = s.geom.x3 - u; const y = s.geom.y3 - v; l.beginPath(), l.moveTo(p, c), l.lineTo(m, g), l.lineTo(x, y), l.closePath(), s.isFilled && (i(l, s), l.fill()), s.isStroked && (h(l, s), l.stroke()), l.restore() } }; e.exports = o }, function (e, d, t) { const i = t(213); const h = t(5); h.register('blitter', function (n, o, r, s) { return this.displayList.add(new i(this.scene, n, o, r, s)) }) }, function (e, d, t) { const i = t(214); const h = t(5); h.register('container', function (n, o, r) { return this.displayList.add(new i(this.scene, n, o, r)) }) }, function (e, d, t) { const i = t(442); const h = t(5); h.register('dom', function (n, o, r, s, a) { const f = new i(this.scene, n, o, r, s, a); return this.displayList.add(f), f }) }, function (e, d, t) { const i = t(215); const h = t(5); h.register('dynamicBitmapText', function (n, o, r, s, a) { return this.displayList.add(new i(this.scene, n, o, r, s, a)) }) }, function (e, d, t) { const i = t(444); const h = t(5); h.register('extern', function () { const n = new i(this.scene); return this.displayList.add(n), n }) }, function (e, d, t) { const i = t(216); const h = t(5); h.register('graphics', function (n) { return this.displayList.add(new i(this.scene, n)) }) }, function (e, d, t) { const i = t(113); const h = t(5); h.register('group', function (n, o) { return this.updateList.add(new i(this.scene, n, o)) }) }, function (e, d, t) { const i = t(125); const h = t(5); h.register('image', function (n, o, r, s) { return this.displayList.add(new i(this.scene, n, o, r, s)) }) }, function (e, d, t) { const i = t(219); const h = t(5); h.register('layer', function (n) { return this.displayList.add(new i(this.scene, n)) }) }, function (e, d, t) { const i = t(5); const h = t(220); i.register('particles', function (n, o, r) { return this.displayList.add(new h(this.scene, n, o, r)) }) }, function (e, d, t) { const i = t(5); const h = t(457); i.register('follower', function (n, o, r, s, a) { const f = new h(this.scene, n, o, r, s, a); return this.displayList.add(f), this.updateList.add(f), f }) }, function (e, d, t) { const i = t(5); const h = t(221); i.register('renderTexture', function (n, o, r, s, a, f) { return this.displayList.add(new h(this.scene, n, o, r, s, a, f)) }) }, function (e, d, t) { const i = t(223); const h = t(5); h.register('rope', function (n, o, r, s, a, f, l, u) { return this.displayList.add(new i(this.scene, n, o, r, s, a, f, l, u)) }) }, function (e, d, t) { const i = t(5); const h = t(73); i.register('sprite', function (n, o, r, s) { const a = new h(this.scene, n, o, r, s); return this.displayList.add(a), a }) }, function (e, d, t) { const i = t(148); const h = t(5); h.register('bitmapText', function (n, o, r, s, a, f) { return this.displayList.add(new i(this.scene, n, o, r, s, a, f)) }) }, function (e, d, t) { const i = t(224); const h = t(5); h.register('text', function (n, o, r, s) { return this.displayList.add(new i(this.scene, n, o, r, s)) }) }, function (e, d, t) { const i = t(225); const h = t(5); h.register('tileSprite', function (n, o, r, s, a, f) { return this.displayList.add(new i(this.scene, n, o, r, s, a, f)) }) }, function (e, d, t) { const i = t(129); const h = t(5); h.register('zone', function (n, o, r, s) { return this.displayList.add(new i(this.scene, n, o, r, s)) }) }, function (e, d, t) { const i = t(226); const h = t(5); h.register('video', function (n, o, r) { return this.displayList.add(new i(this.scene, n, o, r)) }) }, function (e, d, t) { const i = t(461); const h = t(5); h.register('arc', function (n, o, r, s, a, f, l, u) { return this.displayList.add(new i(this.scene, n, o, r, s, a, f, l, u)) }), h.register('circle', function (n, o, r, s, a) { return this.displayList.add(new i(this.scene, n, o, r, 0, 360, !1, s, a)) }) }, function (e, d, t) { const i = t(5); const h = t(462); i.register('curve', function (n, o, r, s, a) { return this.displayList.add(new h(this.scene, n, o, r, s, a)) }) }, function (e, d, t) { const i = t(463); const h = t(5); h.register('ellipse', function (n, o, r, s, a, f) { return this.displayList.add(new i(this.scene, n, o, r, s, a, f)) }) }, function (e, d, t) { const i = t(5); const h = t(464); i.register('grid', function (n, o, r, s, a, f, l, u, v, p) { return this.displayList.add(new h(this.scene, n, o, r, s, a, f, l, u, v, p)) }) }, function (e, d, t) { const i = t(5); const h = t(465); i.register('isobox', function (n, o, r, s, a, f, l) { return this.displayList.add(new h(this.scene, n, o, r, s, a, f, l)) }) }, function (e, d, t) { const i = t(5); const h = t(466); i.register('isotriangle', function (n, o, r, s, a, f, l, u) { return this.displayList.add(new h(this.scene, n, o, r, s, a, f, l, u)) }) }, function (e, d, t) { const i = t(5); const h = t(467); i.register('line', function (n, o, r, s, a, f, l, u) { return this.displayList.add(new h(this.scene, n, o, r, s, a, f, l, u)) }) }, function (e, d, t) { const i = t(5); const h = t(468); i.register('polygon', function (n, o, r, s, a) { return this.displayList.add(new h(this.scene, n, o, r, s, a)) }) }, function (e, d, t) { const i = t(5); const h = t(473); i.register('rectangle', function (n, o, r, s, a, f) { return this.displayList.add(new h(this.scene, n, o, r, s, a, f)) }) }, function (e, d, t) { const i = t(474); const h = t(5); h.register('star', function (n, o, r, s, a, f, l) { return this.displayList.add(new i(this.scene, n, o, r, s, a, f, l)) }) }, function (e, d, t) { const i = t(5); const h = t(475); i.register('triangle', function (n, o, r, s, a, f, l, u, v, p) { return this.displayList.add(new h(this.scene, n, o, r, s, a, f, l, u, v, p)) }) }, function (e, d, t) { const i = t(213); const h = t(28); const n = t(16); const o = t(13); n.register('blitter', function (r, s) { r === void 0 && (r = {}); const a = o(r, 'key', null); const f = o(r, 'frame', null); const l = new i(this.scene, 0, 0, a, f); return s !== void 0 && (r.add = s), h(this.scene, l, r), l }) }, function (e, d, t) { const i = t(28); const h = t(214); const n = t(16); const o = t(13); n.register('container', function (r, s) { r === void 0 && (r = {}); const a = o(r, 'x', 0); const f = o(r, 'y', 0); const l = o(r, 'children', null); const u = new h(this.scene, a, f, l); return s !== void 0 && (r.add = s), i(this.scene, u, r), u }) }, function (e, d, t) { const i = t(215); const h = t(28); const n = t(16); const o = t(13); n.register('dynamicBitmapText', function (r, s) { r === void 0 && (r = {}); const a = o(r, 'font', ''); const f = o(r, 'text', ''); const l = o(r, 'size', !1); const u = new i(this.scene, 0, 0, a, f, l); return s !== void 0 && (r.add = s), h(this.scene, u, r), u }) }, function (e, d, t) { const i = t(16); const h = t(216); i.register('graphics', function (n, o) { n === void 0 && (n = {}), o !== void 0 && (n.add = o); const r = new h(this.scene, n); return n.add && this.scene.sys.displayList.add(r), r }) }, function (e, d, t) { const i = t(16); const h = t(113); i.register('group', function (n) { return new h(this.scene, null, n) }) }, function (e, d, t) { const i = t(28); const h = t(16); const n = t(13); const o = t(125); h.register('image', function (r, s) { r === void 0 && (r = {}); const a = n(r, 'key', null); const f = n(r, 'frame', null); const l = new o(this.scene, 0, 0, a, f); return s !== void 0 && (r.add = s), i(this.scene, l, r), l }) }, function (e, d, t) { const i = t(28); const h = t(219); const n = t(16); const o = t(13); n.register('layer', function (r, s) { r === void 0 && (r = {}); const a = o(r, 'children', null); const f = new h(this.scene, a); return s !== void 0 && (r.add = s), i(this.scene, f, r), f }) }, function (e, d, t) { const i = t(16); const h = t(13); const n = t(2); const o = t(220); i.register('particles', function (r, s) { r === void 0 && (r = {}); const a = h(r, 'key', null); const f = h(r, 'frame', null); const l = n(r, 'emitters', null); const u = new o(this.scene, a, f, l); s !== void 0 && (r.add = s); const v = n(r, 'add', !1); return v ? this.displayList.add(u) : this.updateList.add(u), u }) }, function (e, d, t) { const i = t(28); const h = t(16); const n = t(13); const o = t(221); h.register('renderTexture', function (r, s) { r === void 0 && (r = {}); const a = n(r, 'x', 0); const f = n(r, 'y', 0); const l = n(r, 'width', 32); const u = n(r, 'height', 32); const v = n(r, 'key', void 0); const p = n(r, 'frame', void 0); const c = new o(this.scene, a, f, l, u, v, p); return s !== void 0 && (r.add = s), i(this.scene, c, r), c }) }, function (e, d, t) { const i = t(28); const h = t(16); const n = t(13); const o = t(6); const r = t(223); h.register('rope', function (s, a) { s === void 0 && (s = {}); const f = n(s, 'key', null); const l = n(s, 'frame', null); const u = n(s, 'horizontal', !0); const v = o(s, 'points', void 0); const p = o(s, 'colors', void 0); const c = o(s, 'alphas', void 0); const m = new r(this.scene, 0, 0, f, l, v, u, p, c); return a !== void 0 && (s.add = a), i(this.scene, m, s), s.add || this.updateList.add(m), m }) }, function (e, d, t) { const i = t(28); const h = t(439); const n = t(16); const o = t(13); const r = t(73); n.register('sprite', function (s, a) { s === void 0 && (s = {}); const f = o(s, 'key', null); const l = o(s, 'frame', null); const u = new r(this.scene, 0, 0, f, l); return a !== void 0 && (s.add = a), i(this.scene, u, s), h(u, s), u }) }, function (e, d, t) { const i = t(148); const h = t(28); const n = t(16); const o = t(13); const r = t(6); n.register('bitmapText', function (s, a) { s === void 0 && (s = {}); const f = r(s, 'font', ''); const l = o(s, 'text', ''); const u = o(s, 'size', !1); const v = r(s, 'align', 0); const p = new i(this.scene, 0, 0, f, l, u, v); return a !== void 0 && (s.add = a), h(this.scene, p, s), p }) }, function (e, d, t) { const i = t(28); const h = t(16); const n = t(13); const o = t(224); h.register('text', function (r, s) { r === void 0 && (r = {}); const a = n(r, 'text', ''); const f = n(r, 'style', null); const l = n(r, 'padding', null); l !== null && (f.padding = l); const u = new o(this.scene, 0, 0, a, f); return s !== void 0 && (r.add = s), i(this.scene, u, r), u.autoRound = n(r, 'autoRound', !0), u.resolution = n(r, 'resolution', 1), u }) }, function (e, d, t) { const i = t(28); const h = t(16); const n = t(13); const o = t(225); h.register('tileSprite', function (r, s) { r === void 0 && (r = {}); const a = n(r, 'x', 0); const f = n(r, 'y', 0); const l = n(r, 'width', 512); const u = n(r, 'height', 512); const v = n(r, 'key', ''); const p = n(r, 'frame', ''); const c = new o(this.scene, a, f, l, u, v, p); return s !== void 0 && (r.add = s), i(this.scene, c, r), c }) }, function (e, d, t) { const i = t(16); const h = t(13); const n = t(129); i.register('zone', function (o) { const r = h(o, 'x', 0); const s = h(o, 'y', 0); const a = h(o, 'width', 1); const f = h(o, 'height', a); return new n(this.scene, r, s, a, f) }) }, function (e, d, t) { const i = t(28); const h = t(16); const n = t(13); const o = t(226); h.register('video', function (r, s) { r === void 0 && (r = {}); const a = n(r, 'key', null); const f = new o(this.scene, 0, 0, a); return s !== void 0 && (r.add = s), i(this.scene, f, r), r.add || this.updateList.add(f), f }) }, function (e, d, t) { let i = t(1); let h = t(1); i = t(1177), h = t(1178), e.exports = { renderWebGL: i, renderCanvas: h } }, function (e, d, t) { const i = t(19); const h = function (n, o, r, s) { if (o.shader) { if (r.addToRenderList(o), n.pipelines.clear(), o.renderToTexture)o.load(), o.flush(); else { const a = i(o, r, s).calc; (n.width !== o._rendererWidth || n.height !== o._rendererHeight) && o.projOrtho(0, n.width, n.height, 0), o.load(a.matrix), o.flush() }n.pipelines.rebind() } }; e.exports = h }, function (e, d) { const t = function () {}; e.exports = t }, function (e, d, t) { let i = t(1); let h = t(1); i = t(1180), h = t(1181), e.exports = { renderWebGL: i, renderCanvas: h } }, function (e, d, t) { const i = t(19); const h = function (n, o, r, s) { const a = o.faces; const f = a.length; if (f !== 0) { r.addToRenderList(o); const l = n.pipelines.set(o.pipeline, o); const u = i(o, r, s).calc; const v = l.setGameObject(o); const p = l.vertexViewF32; const c = l.vertexViewU32; let m = l.vertexCount * l.currentShader.vertexComponentCount - 1; const g = o.tintFill; const x = []; const y = o.debugCallback; const T = u.a; const S = u.b; const E = u.c; const C = u.d; const P = u.e; const A = u.f; const M = o.viewPosition.z; const L = o.hideCCW; const F = r.roundPixels; const I = r.alpha * o.alpha; let G = 0; n.pipelines.preBatch(o); for (let U = 0; U < f; U++) { const Y = a[U]; !Y.isInView(r, L, M, I, T, S, E, C, P, A, F) || (l.shouldFlush(3) && (l.flush(), m = 0), m = Y.load(p, c, m, v, g), G++, l.vertexCount += 3, y && x.push(Y)) }o.totalFrame += G, y && y.call(o, o, x), n.pipelines.postBatch(o) } }; e.exports = h }, function (e, d) { const t = function () {}; e.exports = t }, function (e, d, t) { let i = t(1); const h = t(1); i = t(1183), e.exports = { renderWebGL: i, renderCanvas: h } }, function (e, d, t) { const i = t(19); const h = function (n, o, r, s) { r.addToRenderList(o); const a = n.pipelines.set(o.pipeline); const f = i(o, r, s).calc; const l = o.width; const u = o.height; const v = -o._radius; const p = -o._radius; const c = v + l; const m = p + u; const g = f.getX(0, 0); const x = f.getY(0, 0); const y = f.getX(v, p); const T = f.getY(v, p); const S = f.getX(v, m); const E = f.getY(v, m); const C = f.getX(c, m); const P = f.getY(c, m); const A = f.getX(c, p); const M = f.getY(c, p); n.pipelines.preBatch(o), a.batchPointLight(o, r, y, T, S, E, C, P, A, M, g, x), n.pipelines.postBatch(o) }; e.exports = h }, function (e, d, t) { const i = t(229); const h = t(5); h.register('shader', function (n, o, r, s, a, f, l) { return this.displayList.add(new i(this.scene, n, o, r, s, a, f, l)) }) }, function (e, d, t) { const i = t(230); const h = t(5); h.register('mesh', function (n, o, r, s, a, f, l, u, v, p, c) { return this.displayList.add(new i(this.scene, n, o, r, s, a, f, l, u, v, p, c)) }) }, function (e, d, t) { const i = t(5); const h = t(150); i.register('pointlight', function (n, o, r, s, a, f) { return this.displayList.add(new h(this.scene, n, o, r, s, a, f)) }) }, function (e, d, t) { const i = t(28); const h = t(16); const n = t(13); const o = t(229); h.register('shader', function (r, s) { r === void 0 && (r = {}); const a = n(r, 'key', null); const f = n(r, 'x', 0); const l = n(r, 'y', 0); const u = n(r, 'width', 128); const v = n(r, 'height', 128); const p = new o(this.scene, a, f, l, u, v); return s !== void 0 && (r.add = s), i(this.scene, p, r), p }) }, function (e, d, t) { const i = t(28); const h = t(16); const n = t(13); const o = t(6); const r = t(230); h.register('mesh', function (s, a) { s === void 0 && (s = {}); const f = n(s, 'key', null); const l = n(s, 'frame', null); const u = o(s, 'vertices', []); const v = o(s, 'uvs', []); const p = o(s, 'indicies', []); const c = o(s, 'containsZ', !1); const m = o(s, 'normals', []); const g = o(s, 'colors', 16777215); const x = o(s, 'alphas', 1); const y = new r(this.scene, 0, 0, f, l, u, v, p, c, m, g, x); return a !== void 0 && (s.add = a), i(this.scene, y, s), y }) }, function (e, d, t) { const i = t(28); const h = t(16); const n = t(13); const o = t(150); h.register('pointlight', function (r, s) { r === void 0 && (r = {}); const a = n(r, 'color', 16777215); const f = n(r, 'radius', 128); const l = n(r, 'intensity', 1); const u = n(r, 'attenuation', 0.1); const v = new o(this.scene, 0, 0, a, f, l, u); return s !== void 0 && (r.add = s), i(this.scene, v, r), v }) }, function (e, d, t) { const i = t(0); const h = t(482); const n = t(24); const o = t(20); const r = new i({ Extends: h, initialize: function (a) { this.scene = a, this.systems = a.sys, a.sys.settings.isBooted || a.sys.events.once(o.BOOT, this.boot, this), h.call(this) }, boot: function () { const s = this.systems.events; s.on(o.SHUTDOWN, this.shutdown, this), s.on(o.DESTROY, this.destroy, this) }, destroy: function () { this.shutdown(), this.scene = void 0, this.systems = void 0 } }); n.register('LightsPlugin', r, 'lights'), e.exports = r }, function (e, d, t) { const i = t(65); i.Area = t(1192), i.Circumference = t(302), i.CircumferencePoint = t(169), i.Clone = t(1193), i.Contains = t(66), i.ContainsPoint = t(1194), i.ContainsRect = t(1195), i.CopyFrom = t(1196), i.Equals = t(1197), i.GetBounds = t(1198), i.GetPoint = t(300), i.GetPoints = t(301), i.Offset = t(1199), i.OffsetPoint = t(1200), i.Random = t(170), e.exports = i }, function (e, d) { const t = function (i) { return i.radius > 0 ? Math.PI * i.radius * i.radius : 0 }; e.exports = t }, function (e, d, t) { const i = t(65); const h = function (n) { return new i(n.x, n.y, n.radius) }; e.exports = h }, function (e, d, t) { const i = t(66); const h = function (n, o) { return i(n, o.x, o.y) }; e.exports = h }, function (e, d, t) { const i = t(66); const h = function (n, o) { return i(n, o.x, o.y) && i(n, o.right, o.y) && i(n, o.x, o.bottom) && i(n, o.right, o.bottom) }; e.exports = h }, function (e, d) { const t = function (i, h) { return h.setTo(i.x, i.y, i.radius) }; e.exports = t }, function (e, d) { const t = function (i, h) { return i.x === h.x && i.y === h.y && i.radius === h.radius }; e.exports = t }, function (e, d, t) { const i = t(10); const h = function (n, o) { return o === void 0 && (o = new i()), o.x = n.left, o.y = n.top, o.width = n.diameter, o.height = n.diameter, o }; e.exports = h }, function (e, d) { const t = function (i, h, n) { return i.x += h, i.y += n, i }; e.exports = t }, function (e, d) { const t = function (i, h) { return i.x += h.x, i.y += h.y, i }; e.exports = t }, function (e, d, t) { const i = t(111); i.Area = t(1202), i.Circumference = t(447), i.CircumferencePoint = t(218), i.Clone = t(1203), i.Contains = t(112), i.ContainsPoint = t(1204), i.ContainsRect = t(1205), i.CopyFrom = t(1206), i.Equals = t(1207), i.GetBounds = t(1208), i.GetPoint = t(445), i.GetPoints = t(446), i.Offset = t(1209), i.OffsetPoint = t(1210), i.Random = t(180), e.exports = i }, function (e, d) { const t = function (i) { return i.isEmpty() ? 0 : i.getMajorRadius() * i.getMinorRadius() * Math.PI }; e.exports = t }, function (e, d, t) { const i = t(111); const h = function (n) { return new i(n.x, n.y, n.width, n.height) }; e.exports = h }, function (e, d, t) { const i = t(112); const h = function (n, o) { return i(n, o.x, o.y) }; e.exports = h }, function (e, d, t) { const i = t(112); const h = function (n, o) { return i(n, o.x, o.y) && i(n, o.right, o.y) && i(n, o.x, o.bottom) && i(n, o.right, o.bottom) }; e.exports = h }, function (e, d) { const t = function (i, h) { return h.setTo(i.x, i.y, i.width, i.height) }; e.exports = t }, function (e, d) { const t = function (i, h) { return i.x === h.x && i.y === h.y && i.width === h.width && i.height === h.height }; e.exports = t }, function (e, d, t) { const i = t(10); const h = function (n, o) { return o === void 0 && (o = new i()), o.x = n.left, o.y = n.top, o.width = n.width, o.height = n.height, o }; e.exports = h }, function (e, d) { const t = function (i, h, n) { return i.x += h, i.y += n, i }; e.exports = t }, function (e, d) { const t = function (i, h) { return i.x += h.x, i.y += h.y, i }; e.exports = t }, function (e, d, t) { const i = t(4); const h = t(231); const n = function (o, r, s) { if (s === void 0 && (s = []), h(o, r)) { const a = o.x; const f = o.y; const l = o.radius; const u = r.x; const v = r.y; const p = r.radius; let c; let m; let g; let x; let y; if (f === v)y = (p * p - l * l - u * u + a * a) / (2 * (a - u)), c = 1, m = -2 * v, g = u * u + y * y - 2 * u * y + v * v - p * p, x = m * m - 4 * c * g, x === 0 ? s.push(new i(y, -m / (2 * c))) : x > 0 && (s.push(new i(y, (-m + Math.sqrt(x)) / (2 * c))), s.push(new i(y, (-m - Math.sqrt(x)) / (2 * c)))); else { const T = (a - u) / (f - v); const S = (p * p - l * l - u * u + a * a - v * v + f * f) / (2 * (f - v)); c = T * T + 1, m = 2 * f * T - 2 * S * T - 2 * a, g = a * a + f * f + S * S - l * l - 2 * f * S, x = m * m - 4 * c * g, x === 0 ? (y = -m / (2 * c), s.push(new i(y, S - y * T))) : x > 0 && (y = (-m + Math.sqrt(x)) / (2 * c), s.push(new i(y, S - y * T)), y = (-m - Math.sqrt(x)) / (2 * c), s.push(new i(y, S - y * T))) } } return s }; e.exports = n }, function (e, d, t) { const i = t(232); const h = t(151); const n = function (o, r, s) { if (s === void 0 && (s = []), h(o, r)) { const a = r.getLineA(); const f = r.getLineB(); const l = r.getLineC(); const u = r.getLineD(); i(a, o, s), i(f, o, s), i(l, o, s), i(u, o, s) } return s }; e.exports = n }, function (e, d, t) { const i = t(140); const h = t(487); const n = t(47); const o = new n(); function r (f, l, u, v, p) { const c = Math.cos(f); const m = Math.sin(f); o.setTo(l, u, l + c, u + m); const g = h(o, v); g && p.push(new i(g.x, g.y, f, g.w)) } function s (f, l) { return f.z - l.z } const a = function (f, l, u) { Array.isArray(u) || (u = [u]); for (var v = [], p = [], c = 0; c < u.length; c++) for (let m = u[c].points, g = 0; g < m.length; g++) { const x = Math.atan2(m[g].y - l, m[g].x - f); p.indexOf(x) === -1 && (r(x, f, l, u, v), r(x - 1e-5, f, l, u, v), r(x + 1e-5, f, l, u, v), p.push(x)) } return v.sort(s) }; e.exports = a }, function (e, d, t) { const i = t(10); const h = t(152); const n = function (o, r, s) { return s === void 0 && (s = new i()), h(o, r) && (s.x = Math.max(o.x, r.x), s.y = Math.max(o.y, r.y), s.width = Math.min(o.right, r.right) - s.x, s.height = Math.min(o.bottom, r.bottom) - s.y), s }; e.exports = n }, function (e, d, t) { const i = t(234); const h = t(152); const n = function (o, r, s) { if (s === void 0 && (s = []), h(o, r)) { const a = o.getLineA(); const f = o.getLineB(); const l = o.getLineC(); const u = o.getLineD(); i(a, r, s), i(f, r, s), i(l, r, s), i(u, r, s) } return s }; e.exports = n }, function (e, d, t) { const i = t(489); const h = t(234); const n = function (o, r, s) { if (s === void 0 && (s = []), i(o, r)) { const a = r.getLineA(); const f = r.getLineB(); const l = r.getLineC(); h(a, o, s), h(f, o, s), h(l, o, s) } return s }; e.exports = n }, function (e, d, t) { const i = t(232); const h = t(491); const n = function (o, r, s) { if (s === void 0 && (s = []), h(o, r)) { const a = o.getLineA(); const f = o.getLineB(); const l = o.getLineC(); i(a, r, s), i(f, r, s), i(l, r, s) } return s }; e.exports = n }, function (e, d, t) { const i = t(494); const h = t(492); const n = function (o, r, s) { if (s === void 0 && (s = []), i(o, r)) { const a = r.getLineA(); const f = r.getLineB(); const l = r.getLineC(); h(o, a, s), h(o, f, s), h(o, l, s) } return s }; e.exports = n }, function (e, d, t) { const i = t(496); const h = function (n, o) { if (!i(n, o)) return !1; const r = Math.min(o.x1, o.x2); const s = Math.max(o.x1, o.x2); const a = Math.min(o.y1, o.y2); const f = Math.max(o.y1, o.y2); return n.x >= r && n.x <= s && n.y >= a && n.y <= f }; e.exports = h }, function (e, d) { const t = function (i, h, n, o, r, s) { return s === void 0 && (s = 0), !(h > i.right + s || n < i.left - s || o > i.bottom + s || r < i.top - s) }; e.exports = t }, function (e, d, t) { const i = t(47); i.Angle = t(97), i.BresenhamPoints = t(317), i.CenterOn = t(1222), i.Clone = t(1223), i.CopyFrom = t(1224), i.Equals = t(1225), i.Extend = t(1226), i.GetEasedPoints = t(1227), i.GetMidPoint = t(1228), i.GetNearestPoint = t(1229), i.GetNormal = t(1230), i.GetPoint = t(307), i.GetPoints = t(172), i.GetShortestDistance = t(1231), i.Height = t(1232), i.Length = t(67), i.NormalAngle = t(497), i.NormalX = t(1233), i.NormalY = t(1234), i.Offset = t(1235), i.PerpSlope = t(1236), i.Random = t(173), i.ReflectAngle = t(1237), i.Rotate = t(1238), i.RotateAroundPoint = t(1239), i.RotateAroundXY = t(236), i.SetToAngle = t(1240), i.Slope = t(1241), i.Width = t(1242), e.exports = i }, function (e, d) { const t = function (i, h, n) { const o = h - (i.x1 + i.x2) / 2; const r = n - (i.y1 + i.y2) / 2; return i.x1 += o, i.y1 += r, i.x2 += o, i.y2 += r, i }; e.exports = t }, function (e, d, t) { const i = t(47); const h = function (n) { return new i(n.x1, n.y1, n.x2, n.y2) }; e.exports = h }, function (e, d) { const t = function (i, h) { return h.setTo(i.x1, i.y1, i.x2, i.y2) }; e.exports = t }, function (e, d) { const t = function (i, h) { return i.x1 === h.x1 && i.y1 === h.y1 && i.x2 === h.x2 && i.y2 === h.y2 }; e.exports = t }, function (e, d, t) { const i = t(67); const h = function (n, o, r) { r === void 0 && (r = o); const s = i(n); const a = n.x2 - n.x1; const f = n.y2 - n.y1; return o && (n.x1 = n.x1 - a / s * o, n.y1 = n.y1 - f / s * o), r && (n.x2 = n.x2 + a / s * r, n.y2 = n.y2 + f / s * r), n }; e.exports = h }, function (e, d, t) { const i = t(352); const h = t(80); const n = t(4); const o = function (r, s, a, f, l) { f === void 0 && (f = 0), l === void 0 && (l = []); const u = []; const v = r.x1; const p = r.y1; const c = r.x2 - v; const m = r.y2 - p; const g = h(s, l); let x; let y; const T = a - 1; for (x = 0; x < T; x++)y = g(x / T), u.push(new n(v + c * y, p + m * y)); if (y = g(1), u.push(new n(v + c * y, p + m * y)), f > 0) { let S = u[0]; const E = [S]; for (x = 1; x < u.length - 1; x++) { const C = u[x]; i(S, C) >= f && (E.push(C), S = C) } const P = u[u.length - 1]; return i(S, P) < f && E.pop(), E.push(P), E } else return u }; e.exports = o }, function (e, d, t) { const i = t(4); const h = function (n, o) { return o === void 0 && (o = new i()), o.x = (n.x1 + n.x2) / 2, o.y = (n.y1 + n.y2) / 2, o }; e.exports = h }, function (e, d, t) { const i = t(4); const h = function (n, o, r) { r === void 0 && (r = new i()); const s = n.x1; const a = n.y1; const f = n.x2; const l = n.y2; const u = (f - s) * (f - s) + (l - a) * (l - a); if (u === 0) return r; const v = ((o.x - s) * (f - s) + (o.y - a) * (l - a)) / u; return r.x = s + v * (f - s), r.y = a + v * (l - a), r }; e.exports = h }, function (e, d, t) { const i = t(14); const h = t(97); const n = t(4); const o = function (r, s) { s === void 0 && (s = new n()); const a = h(r) - i.TAU; return s.x = Math.cos(a), s.y = Math.sin(a), s }; e.exports = o }, function (e, d) { const t = function (i, h) { const n = i.x1; const o = i.y1; const r = i.x2; const s = i.y2; const a = (r - n) * (r - n) + (s - o) * (s - o); if (a === 0) return !1; const f = ((o - h.y) * (r - n) - (n - h.x) * (s - o)) / a; return Math.abs(f) * Math.sqrt(a) }; e.exports = t }, function (e, d) { const t = function (i) { return Math.abs(i.y1 - i.y2) }; e.exports = t }, function (e, d, t) { const i = t(14); const h = t(97); const n = function (o) { return Math.cos(h(o) - i.TAU) }; e.exports = n }, function (e, d, t) { const i = t(14); const h = t(97); const n = function (o) { return Math.sin(h(o) - i.TAU) }; e.exports = n }, function (e, d) { const t = function (i, h, n) { return i.x1 += h, i.y1 += n, i.x2 += h, i.y2 += n, i }; e.exports = t }, function (e, d) { const t = function (i) { return -((i.x2 - i.x1) / (i.y2 - i.y1)) }; e.exports = t }, function (e, d, t) { const i = t(97); const h = t(497); const n = function (o, r) { return 2 * h(r) - Math.PI - i(o) }; e.exports = n }, function (e, d, t) { const i = t(236); const h = function (n, o) { const r = (n.x1 + n.x2) / 2; const s = (n.y1 + n.y2) / 2; return i(n, r, s, o) }; e.exports = h }, function (e, d, t) { const i = t(236); const h = function (n, o, r) { return i(n, o.x, o.y, r) }; e.exports = h }, function (e, d) { const t = function (i, h, n, o, r) { return i.x1 = h, i.y1 = n, i.x2 = h + Math.cos(o) * r, i.y2 = n + Math.sin(o) * r, i }; e.exports = t }, function (e, d) { const t = function (i) { return (i.y2 - i.y1) / (i.x2 - i.x1) }; e.exports = t }, function (e, d) { const t = function (i) { return Math.abs(i.x1 - i.x2) }; e.exports = t }, function (e, d, t) { const i = { Face: t(116), GenerateGridVerts: t(1244), GenerateObjVerts: t(480), GenerateVerts: t(479), ParseObj: t(498), ParseObjMaterial: t(499), RotateFace: t(1245), Vertex: t(117) }; e.exports = i }, function (e, d, t) { const i = t(116); const h = t(2); const n = t(69); const o = t(39); const r = t(117); const s = new o(); const a = new o(); const f = new n(); const l = function (u) { const v = h(u, 'mesh'); let p = h(u, 'texture', null); const c = h(u, 'frame'); let m = h(u, 'width', 1); let g = h(u, 'height', m); const x = h(u, 'widthSegments', 1); const y = h(u, 'heightSegments', x); const T = h(u, 'x', 0); const S = h(u, 'y', 0); const E = h(u, 'z', 0); const C = h(u, 'rotateX', 0); const P = h(u, 'rotateY', 0); const A = h(u, 'rotateZ', 0); const M = h(u, 'zIsUp', !0); const L = h(u, 'isOrtho', v ? v.dirtyCache[11] : !1); let F = h(u, 'colors', [16777215]); let I = h(u, 'alphas', [1]); const G = h(u, 'tile', !1); const U = h(u, 'flipY', !1); const Y = h(u, 'width', null); const X = { faces: [], verts: [] }; if (s.set(T, S, E), a.set(C, P, A), f.fromRotationXYTranslation(a, s, M), !p && v)p = v.texture; else if (v && typeof p === 'string')p = v.scene.sys.textures.get(p); else return X; const O = p.get(c); !Y && L && p && v && (m = O.width / v.height, g = O.height / v.height); const R = m / 2; const D = g / 2; const B = Math.floor(x); const N = Math.floor(y); const w = B + 1; const z = N + 1; const V = m / B; const W = g / N; const H = []; const K = []; let Q; let J; let q = 0; let j = 1; let _ = 0; let rt = 1; O && (q = O.u0, j = O.u1, U ? (_ = O.v1, rt = O.v0) : (_ = O.v0, rt = O.v1)); const nt = j - q; const et = rt - _; for (J = 0; J < z; J++) { const b = J * W - D; for (Q = 0; Q < w; Q++) { const at = Q * V - R; K.push(at, -b); const it = q + nt * (Q / B); const st = _ + et * (J / N); H.push(it, st) } }Array.isArray(F) || (F = [F]), Array.isArray(I) || (I = [I]); let Kt = 0; let Zt = 0; for (J = 0; J < N; J++) for (Q = 0; Q < B; Q++) { const ct = (Q + w * J) * 2; const lt = (Q + w * (J + 1)) * 2; const Pt = (Q + 1 + w * (J + 1)) * 2; const Ct = (Q + 1 + w * J) * 2; const St = F[Zt]; const Qt = I[Kt]; const Oe = new r(K[ct], K[ct + 1], 0, H[ct], H[ct + 1], St, Qt).transformMat4(f); const Fe = new r(K[lt], K[lt + 1], 0, H[lt], H[lt + 1], St, Qt).transformMat4(f); const De = new r(K[Ct], K[Ct + 1], 0, H[Ct], H[Ct + 1], St, Qt).transformMat4(f); const Ie = new r(K[lt], K[lt + 1], 0, H[lt], H[lt + 1], St, Qt).transformMat4(f); const Be = new r(K[Pt], K[Pt + 1], 0, H[Pt], H[Pt + 1], St, Qt).transformMat4(f); const Ne = new r(K[Ct], K[Ct + 1], 0, H[Ct], H[Ct + 1], St, Qt).transformMat4(f); G && (Oe.setUVs(q, rt), Fe.setUVs(q, _), De.setUVs(j, rt), Ie.setUVs(q, _), Be.setUVs(j, _), Ne.setUVs(j, rt)), Zt++, Zt === F.length && (Zt = 0), Kt++, Kt === I.length && (Kt = 0), X.verts.push(Oe, Fe, De, Ie, Be, Ne), X.faces.push(new i(Oe, Fe, De), new i(Ie, Be, Ne)) } return v && (v.faces = v.faces.concat(X.faces), v.vertices = v.vertices.concat(X.verts)), X }; e.exports = l }, function (e, d) { const t = function (i, h, n, o) { let r, s; if (n === void 0 && o === void 0) { const a = i.getInCenter(); r = a.x, s = a.y } const f = Math.cos(h); const l = Math.sin(h); const u = i.vertex1; const v = i.vertex2; const p = i.vertex3; let c = u.x - r; let m = u.y - s; u.set(c * f - m * l + r, c * l + m * f + s), c = v.x - r, m = v.y - s, v.set(c * f - m * l + r, c * l + m * f + s), c = p.x - r, m = p.y - s, p.set(c * f - m * l + r, c * l + m * f + s) }; e.exports = t }, function (e, d, t) { const i = t(4); i.Ceil = t(1247), i.Clone = t(1248), i.CopyFrom = t(1249), i.Equals = t(1250), i.Floor = t(1251), i.GetCentroid = t(1252), i.GetMagnitude = t(500), i.GetMagnitudeSq = t(501), i.GetRectangleFromPoints = t(1253), i.Interpolate = t(1254), i.Invert = t(1255), i.Negative = t(1256), i.Project = t(1257), i.ProjectUnit = t(1258), i.SetMagnitude = t(1259), e.exports = i }, function (e, d) { const t = function (i) { return i.setTo(Math.ceil(i.x), Math.ceil(i.y)) }; e.exports = t }, function (e, d, t) { const i = t(4); const h = function (n) { return new i(n.x, n.y) }; e.exports = h }, function (e, d) { const t = function (i, h) { return h.setTo(i.x, i.y) }; e.exports = t }, function (e, d) { const t = function (i, h) { return i.x === h.x && i.y === h.y }; e.exports = t }, function (e, d) { const t = function (i) { return i.setTo(Math.floor(i.x), Math.floor(i.y)) }; e.exports = t }, function (e, d, t) { const i = t(4); const h = function (n, o) { if (o === void 0 && (o = new i()), !Array.isArray(n)) throw new Error('GetCentroid points argument must be an array'); const r = n.length; if (r < 1) throw new Error('GetCentroid points array must not be empty'); if (r === 1)o.x = n[0].x, o.y = n[0].y; else { for (let s = 0; s < r; s++)o.x += n[s].x, o.y += n[s].y; o.x /= r, o.y /= r } return o }; e.exports = h }, function (e, d, t) { const i = t(10); const h = function (n, o) { o === void 0 && (o = new i()); for (var r = Number.NEGATIVE_INFINITY, s = Number.POSITIVE_INFINITY, a = Number.NEGATIVE_INFINITY, f = Number.POSITIVE_INFINITY, l = 0; l < n.length; l++) { const u = n[l]; u.x > r && (r = u.x), u.x < s && (s = u.x), u.y > a && (a = u.y), u.y < f && (f = u.y) } return o.x = s, o.y = f, o.width = r - s, o.height = a - f, o }; e.exports = h }, function (e, d, t) { const i = t(4); const h = function (n, o, r, s) { return r === void 0 && (r = 0), s === void 0 && (s = new i()), s.x = n.x + (o.x - n.x) * r, s.y = n.y + (o.y - n.y) * r, s }; e.exports = h }, function (e, d) { const t = function (i) { return i.setTo(i.y, i.x) }; e.exports = t }, function (e, d, t) { const i = t(4); const h = function (n, o) { return o === void 0 && (o = new i()), o.setTo(-n.x, -n.y) }; e.exports = h }, function (e, d, t) { const i = t(4); const h = t(501); const n = function (o, r, s) { s === void 0 && (s = new i()); const a = o.x * r.x + o.y * r.y; const f = a / h(r); return f !== 0 && (s.x = f * r.x, s.y = f * r.y), s }; e.exports = n }, function (e, d, t) { const i = t(4); const h = function (n, o, r) { r === void 0 && (r = new i()); const s = n.x * o.x + n.y * o.y; return s !== 0 && (r.x = s * o.x, r.y = s * o.y), r }; e.exports = h }, function (e, d, t) { const i = t(500); const h = function (n, o) { if (n.x !== 0 || n.y !== 0) { const r = i(n); n.x /= r, n.y /= r } return n.x *= o, n.y *= o, n }; e.exports = h }, function (e, d, t) { const i = t(227); i.Clone = t(1261), i.Contains = t(228), i.ContainsPoint = t(1262), i.Earcut = t(59), i.GetAABB = t(469), i.GetNumberArray = t(1263), i.GetPoints = t(470), i.Perimeter = t(471), i.Reverse = t(1264), i.Simplify = t(1265), i.Smooth = t(472), i.Translate = t(1266), e.exports = i }, function (e, d, t) { const i = t(227); const h = function (n) { return new i(n.points) }; e.exports = h }, function (e, d, t) { const i = t(228); const h = function (n, o) { return i(n, o.x, o.y) }; e.exports = h }, function (e, d) { const t = function (i, h) { h === void 0 && (h = []); for (let n = 0; n < i.points.length; n++)h.push(i.points[n].x), h.push(i.points[n].y); return h }; e.exports = t }, function (e, d) { const t = function (i) { return i.points.reverse(), i }; e.exports = t }, function (e, d) { function t (s, a) { const f = s.x - a.x; const l = s.y - a.y; return f * f + l * l } function i (s, a, f) { let l = a.x; let u = a.y; let v = f.x - l; let p = f.y - u; if (v !== 0 || p !== 0) { const c = ((s.x - l) * v + (s.y - u) * p) / (v * v + p * p); c > 1 ? (l = f.x, u = f.y) : c > 0 && (l += v * c, u += p * c) } return v = s.x - l, p = s.y - u, v * v + p * p } function h (s, a) { for (var f = s[0], l = [f], u, v = 1, p = s.length; v < p; v++)u = s[v], t(u, f) > a && (l.push(u), f = u); return f !== u && l.push(u), l } function n (s, a, f, l, u) { for (var v = l, p, c = a + 1; c < f; c++) { const m = i(s[c], s[a], s[f]); m > v && (p = c, v = m) }v > l && (p - a > 1 && n(s, a, p, l, u), u.push(s[p]), f - p > 1 && n(s, p, f, l, u)) } function o (s, a) { const f = s.length - 1; const l = [s[0]]; return n(s, 0, f, a, l), l.push(s[f]), l } const r = function (s, a, f) { a === void 0 && (a = 1), f === void 0 && (f = !1); let l = s.points; if (l.length > 2) { const u = a * a; f || (l = h(l, u)), s.setTo(o(l, u)) } return s }; e.exports = r }, function (e, d) { const t = function (i, h, n) { for (let o = i.points, r = 0; r < o.length; r++)o[r].x += h, o[r].y += n; return i }; e.exports = t }, function (e, d) { const t = function (i) { return i.width * i.height }; e.exports = t }, function (e, d) { const t = function (i) { return i.x = Math.ceil(i.x), i.y = Math.ceil(i.y), i }; e.exports = t }, function (e, d) { const t = function (i) { return i.x = Math.ceil(i.x), i.y = Math.ceil(i.y), i.width = Math.ceil(i.width), i.height = Math.ceil(i.height), i }; e.exports = t }, function (e, d, t) { const i = t(10); const h = function (n) { return new i(n.x, n.y, n.width, n.height) }; e.exports = h }, function (e, d, t) { const i = t(57); const h = function (n, o) { return i(n, o.x, o.y) }; e.exports = h }, function (e, d) { const t = function (i, h) { return h.setTo(i.x, i.y, i.width, i.height) }; e.exports = t }, function (e, d) { const t = function (i, h) { return i.x === h.x && i.y === h.y && i.width === h.width && i.height === h.height }; e.exports = t }, function (e, d, t) { const i = t(237); const h = function (n, o) { const r = i(n); return r < i(o) ? n.setSize(o.height * r, o.height) : n.setSize(o.width, o.width / r), n.setPosition(o.centerX - n.width / 2, o.centerY - n.height / 2) }; e.exports = h }, function (e, d, t) { const i = t(237); const h = function (n, o) { const r = i(n); return r > i(o) ? n.setSize(o.height * r, o.height) : n.setSize(o.width, o.width / r), n.setPosition(o.centerX - n.width / 2, o.centerY - n.height / 2) }; e.exports = h }, function (e, d) { const t = function (i) { return i.x = Math.floor(i.x), i.y = Math.floor(i.y), i }; e.exports = t }, function (e, d) { const t = function (i) { return i.x = Math.floor(i.x), i.y = Math.floor(i.y), i.width = Math.floor(i.width), i.height = Math.floor(i.height), i }; e.exports = t }, function (e, d, t) { const i = t(10); const h = function (n, o, r, s, a) { return a === void 0 && (a = new i()), a.setTo(Math.min(n, r), Math.min(o, s), Math.abs(n - r), Math.abs(o - s)) }; e.exports = h }, function (e, d, t) { const i = t(4); const h = function (n, o) { return o === void 0 && (o = new i()), o.x = n.centerX, o.y = n.centerY, o }; e.exports = h }, function (e, d, t) { const i = t(4); const h = function (n, o) { return o === void 0 && (o = new i()), o.x = n.width, o.y = n.height, o }; e.exports = h }, function (e, d, t) { const i = t(190); const h = function (n, o, r) { const s = n.centerX; const a = n.centerY; return n.setSize(n.width + o * 2, n.height + r * 2), i(n, s, a) }; e.exports = h }, function (e, d, t) { const i = t(10); const h = t(152); const n = function (o, r, s) { return s === void 0 && (s = new i()), h(o, r) ? (s.x = Math.max(o.x, r.x), s.y = Math.max(o.y, r.y), s.width = Math.min(o.right, r.right) - s.x, s.height = Math.min(o.bottom, r.bottom) - s.y) : s.setEmpty(), s }; e.exports = n }, function (e, d) { const t = function (i, h) { for (var n = i.x, o = i.right, r = i.y, s = i.bottom, a = 0; a < h.length; a++)n = Math.min(n, h[a].x), o = Math.max(o, h[a].x), r = Math.min(r, h[a].y), s = Math.max(s, h[a].y); return i.x = n, i.y = r, i.width = o - n, i.height = s - r, i }; e.exports = t }, function (e, d) { const t = function (i, h) { const n = Math.min(i.x, h.x); const o = Math.max(i.right, h.right); i.x = n, i.width = o - n; const r = Math.min(i.y, h.y); const s = Math.max(i.bottom, h.bottom); return i.y = r, i.height = s - r, i }; e.exports = t }, function (e, d) { const t = function (i, h, n) { const o = Math.min(i.x, h); const r = Math.max(i.right, h); i.x = o, i.width = r - o; const s = Math.min(i.y, n); const a = Math.max(i.bottom, n); return i.y = s, i.height = a - s, i }; e.exports = t }, function (e, d) { const t = function (i, h, n) { return i.x += h, i.y += n, i }; e.exports = t }, function (e, d) { const t = function (i, h) { return i.x += h.x, i.y += h.y, i }; e.exports = t }, function (e, d) { const t = function (i, h) { return i.x < h.right && i.right > h.x && i.y < h.bottom && i.bottom > h.y }; e.exports = t }, function (e, d, t) { const i = t(4); const h = t(36); const n = function (o, r, s) { s === void 0 && (s = new i()), r = h(r); const a = Math.sin(r); const f = Math.cos(r); let l = f > 0 ? o.width / 2 : o.width / -2; let u = a > 0 ? o.height / 2 : o.height / -2; return Math.abs(l * a) < Math.abs(u * f) ? u = l * a / f : l = u * f / a, s.x = l + o.centerX, s.y = u + o.centerY, s }; e.exports = n }, function (e, d, t) { const i = t(195); const h = t(503); const n = t(4); const o = function (r, s, a) { if (a === void 0 && (a = new n()), h(r, s)) switch (i(0, 3)) { case 0:a.x = r.x + Math.random() * (s.right - r.x), a.y = r.y + Math.random() * (s.top - r.y); break; case 1:a.x = s.x + Math.random() * (r.right - s.x), a.y = s.bottom + Math.random() * (r.bottom - s.bottom); break; case 2:a.x = r.x + Math.random() * (s.x - r.x), a.y = s.y + Math.random() * (r.bottom - s.y); break; case 3:a.x = s.right + Math.random() * (r.right - s.right), a.y = r.y + Math.random() * (s.bottom - r.y); break } return a }; e.exports = o }, function (e, d) { const t = function (i, h) { return i.width === h.width && i.height === h.height }; e.exports = t }, function (e, d) { const t = function (i, h, n) { return n === void 0 && (n = h), i.width *= h, i.height *= n, i }; e.exports = t }, function (e, d, t) { const i = t(82); i.Area = t(1294), i.BuildEquilateral = t(1295), i.BuildFromPolygon = t(1296), i.BuildRight = t(1297), i.CenterOn = t(1298), i.Centroid = t(504), i.CircumCenter = t(1299), i.CircumCircle = t(1300), i.Clone = t(1301), i.Contains = t(115), i.ContainsArray = t(235), i.ContainsPoint = t(1302), i.CopyFrom = t(1303), i.Decompose = t(495), i.Equals = t(1304), i.GetPoint = t(476), i.GetPoints = t(477), i.InCenter = t(506), i.Perimeter = t(1305), i.Offset = t(505), i.Random = t(181), i.Rotate = t(1306), i.RotateAroundPoint = t(1307), i.RotateAroundXY = t(238), e.exports = i }, function (e, d) { const t = function (i) { const h = i.x1; const n = i.y1; const o = i.x2; const r = i.y2; const s = i.x3; const a = i.y3; return Math.abs(((s - h) * (r - n) - (o - h) * (a - n)) / 2) }; e.exports = t }, function (e, d, t) { const i = t(82); const h = function (n, o, r) { const s = r * (Math.sqrt(3) / 2); const a = n; const f = o; const l = n + r / 2; const u = o + s; const v = n - r / 2; const p = o + s; return new i(a, f, l, u, v, p) }; e.exports = h }, function (e, d, t) { const i = t(59); const h = t(82); const n = function (o, r, s, a, f) { r === void 0 && (r = null), s === void 0 && (s = 1), a === void 0 && (a = 1), f === void 0 && (f = []); for (var l = i(o, r), u, v, p, c, m, g, x, y, T, S = 0; S < l.length; S += 3)u = l[S], v = l[S + 1], p = l[S + 2], c = o[u * 2] * s, m = o[u * 2 + 1] * a, g = o[v * 2] * s, x = o[v * 2 + 1] * a, y = o[p * 2] * s, T = o[p * 2 + 1] * a, f.push(new h(c, m, g, x, y, T)); return f }; e.exports = n }, function (e, d, t) { const i = t(82); const h = function (n, o, r, s) { s === void 0 && (s = r); const a = n; const f = o; const l = n; const u = o - s; const v = n + r; const p = o; return new i(a, f, l, u, v, p) }; e.exports = h }, function (e, d, t) { const i = t(504); const h = t(505); const n = function (o, r, s, a) { a === void 0 && (a = i); const f = a(o); const l = r - f.x; const u = s - f.y; return h(o, l, u) }; e.exports = n }, function (e, d, t) { const i = t(3); function h (o, r, s, a) { return o * a - r * s } const n = function (o, r) { r === void 0 && (r = new i()); const s = o.x3; const a = o.y3; const f = o.x1 - s; const l = o.y1 - a; const u = o.x2 - s; const v = o.y2 - a; const p = 2 * h(f, l, u, v); const c = h(l, f * f + l * l, v, u * u + v * v); const m = h(f, f * f + l * l, u, u * u + v * v); return r.x = s - c / p, r.y = a + m / p, r }; e.exports = n }, function (e, d, t) { const i = t(65); const h = function (n, o) { o === void 0 && (o = new i()); const r = n.x1; const s = n.y1; const a = n.x2; const f = n.y2; const l = n.x3; const u = n.y3; const v = a - r; const p = f - s; const c = l - r; const m = u - s; const g = v * (r + a) + p * (s + f); const x = c * (r + l) + m * (s + u); const y = 2 * (v * (u - f) - p * (l - a)); let T; let S; if (Math.abs(y) < 1e-6) { const E = Math.min(r, a, l); const C = Math.min(s, f, u); T = (Math.max(r, a, l) - E) * 0.5, S = (Math.max(s, f, u) - C) * 0.5, o.x = E + T, o.y = C + S, o.radius = Math.sqrt(T * T + S * S) } else o.x = (m * g - p * x) / y, o.y = (v * x - c * g) / y, T = o.x - r, S = o.y - s, o.radius = Math.sqrt(T * T + S * S); return o }; e.exports = h }, function (e, d, t) { const i = t(82); const h = function (n) { return new i(n.x1, n.y1, n.x2, n.y2, n.x3, n.y3) }; e.exports = h }, function (e, d, t) { const i = t(115); const h = function (n, o) { return i(n, o.x, o.y) }; e.exports = h }, function (e, d) { const t = function (i, h) { return h.setTo(i.x1, i.y1, i.x2, i.y2, i.x3, i.y3) }; e.exports = t }, function (e, d) { const t = function (i, h) { return i.x1 === h.x1 && i.y1 === h.y1 && i.x2 === h.x2 && i.y2 === h.y2 && i.x3 === h.x3 && i.y3 === h.y3 }; e.exports = t }, function (e, d, t) { const i = t(67); const h = function (n) { const o = n.getLineA(); const r = n.getLineB(); const s = n.getLineC(); return i(o) + i(r) + i(s) }; e.exports = h }, function (e, d, t) { const i = t(238); const h = t(506); const n = function (o, r) { const s = h(o); return i(o, s.x, s.y, r) }; e.exports = n }, function (e, d, t) { const i = t(238); const h = function (n, o, r) { return i(n, o.x, o.y, r) }; e.exports = h }, function (e, d, t) { const i = t(203); const h = t(17); let n = { CreatePixelPerfectHandler: t(507), CreateInteractiveObject: t(508), Events: t(51), Gamepad: t(1309), InputManager: t(409), InputPlugin: t(1321), InputPluginCache: t(153), Keyboard: t(1322), Mouse: t(1336), Pointer: t(412), Touch: t(1337) }; n = h(!1, n, i), e.exports = n }, function (e, d, t) { e.exports = { Axis: t(509), Button: t(510), Events: t(239), Gamepad: t(511), GamepadPlugin: t(1316), Configs: t(1317) } }, function (e, d) { e.exports = 'down' }, function (e, d) { e.exports = 'up' }, function (e, d) { e.exports = 'connected' }, function (e, d) { e.exports = 'disconnected' }, function (e, d) { e.exports = 'down' }, function (e, d) { e.exports = 'up' }, function (e, d, t) { const i = t(0); const h = t(9); const n = t(239); const o = t(511); const r = t(6); const s = t(153); const a = t(51); const f = new i({ Extends: h, initialize: function (u) { h.call(this), this.scene = u.scene, this.settings = this.scene.sys.settings, this.sceneInputPlugin = u, this.enabled = !0, this.target, this.gamepads = [], this.queue = [], this.onGamepadHandler, this._pad1, this._pad2, this._pad3, this._pad4, u.pluginEvents.once(a.BOOT, this.boot, this), u.pluginEvents.on(a.START, this.start, this) }, boot: function () { const l = this.scene.sys.game; const u = this.settings.input; const v = l.config; this.enabled = r(u, 'gamepad', v.inputGamepad) && l.device.input.gamepads, this.target = r(u, 'gamepad.target', v.inputGamepadEventTarget), this.sceneInputPlugin.pluginEvents.once(a.DESTROY, this.destroy, this) }, start: function () { this.enabled && (this.startListeners(), this.refreshPads()), this.sceneInputPlugin.pluginEvents.once(a.SHUTDOWN, this.shutdown, this) }, isActive: function () { return this.enabled && this.scene.sys.isActive() }, startListeners: function () { const l = this; const u = this.target; const v = function (p) { p.defaultPrevented || !l.isActive() || (l.refreshPads(), l.queue.push(p)) }; this.onGamepadHandler = v, u.addEventListener('gamepadconnected', v, !1), u.addEventListener('gamepaddisconnected', v, !1), this.sceneInputPlugin.pluginEvents.on(a.UPDATE, this.update, this) }, stopListeners: function () { this.target.removeEventListener('gamepadconnected', this.onGamepadHandler), this.target.removeEventListener('gamepaddisconnected', this.onGamepadHandler), this.sceneInputPlugin.pluginEvents.off(a.UPDATE, this.update); for (let l = 0; l < this.gamepads.length; l++) this.gamepads[l].removeAllListeners() }, disconnectAll: function () { for (let l = 0; l < this.gamepads.length; l++) this.gamepads[l].pad.connected = !1 }, refreshPads: function () { const l = navigator.getGamepads(); if (!l) this.disconnectAll(); else for (let u = this.gamepads, v = 0; v < l.length; v++) { const p = l[v]; if (p) { const c = p.id; const m = p.index; const g = u[m]; if (g)g.id !== c ? (g.destroy(), u[m] = new o(this, p)) : g.update(p); else { const x = new o(this, p); u[m] = x, this._pad1 ? this._pad2 ? this._pad3 ? this._pad4 || (this._pad4 = x) : this._pad3 = x : this._pad2 = x : this._pad1 = x } } } }, getAll: function () { for (var l = [], u = this.gamepads, v = 0; v < u.length; v++)u[v] && l.push(u[v]); return l }, getPad: function (l) { for (let u = this.gamepads, v = 0; v < u.length; v++) if (u[v] && u[v].index === l) return u[v] }, update: function () { if (this.enabled) { this.refreshPads(); const l = this.queue.length; if (l !== 0) for (let u = this.queue.splice(0, l), v = 0; v < l; v++) { const p = u[v]; const c = this.getPad(p.gamepad.index); p.type === 'gamepadconnected' ? this.emit(n.CONNECTED, c, p) : p.type === 'gamepaddisconnected' && this.emit(n.DISCONNECTED, c, p) } } }, shutdown: function () { this.stopListeners(), this.removeAllListeners() }, destroy: function () { this.shutdown(); for (let l = 0; l < this.gamepads.length; l++) this.gamepads[l] && this.gamepads[l].destroy(); this.gamepads = [], this.scene = null, this.settings = null, this.sceneInputPlugin = null, this.target = null }, total: { get: function () { return this.gamepads.length } }, pad1: { get: function () { return this._pad1 } }, pad2: { get: function () { return this._pad2 } }, pad3: { get: function () { return this._pad3 } }, pad4: { get: function () { return this._pad4 } } }); s.register('GamepadPlugin', f, 'gamepad', 'gamepad', 'inputGamepad'), e.exports = f }, function (e, d, t) { e.exports = { DUALSHOCK_4: t(1318), SNES_USB: t(1319), XBOX_360: t(1320) } }, function (e, d) { e.exports = { UP: 12, DOWN: 13, LEFT: 14, RIGHT: 15, SHARE: 8, OPTIONS: 9, PS: 16, TOUCHBAR: 17, X: 0, CIRCLE: 1, SQUARE: 2, TRIANGLE: 3, L1: 4, R1: 5, L2: 6, R2: 7, L3: 10, R3: 11, LEFT_STICK_H: 0, LEFT_STICK_V: 1, RIGHT_STICK_H: 2, RIGHT_STICK_V: 3 } }, function (e, d) { e.exports = { UP: 12, DOWN: 13, LEFT: 14, RIGHT: 15, SELECT: 8, START: 9, B: 0, A: 1, Y: 2, X: 3, LEFT_SHOULDER: 4, RIGHT_SHOULDER: 5 } }, function (e, d) { e.exports = { UP: 12, DOWN: 13, LEFT: 14, RIGHT: 15, MENU: 16, A: 0, B: 1, X: 2, Y: 3, LB: 4, RB: 5, LT: 6, RT: 7, BACK: 8, START: 9, LS: 10, RS: 11, LEFT_STICK_H: 0, LEFT_STICK_V: 1, RIGHT_STICK_H: 2, RIGHT_STICK_V: 3 } }, function (e, d, t) { const i = t(65); const h = t(66); const n = t(0); const o = t(203); const r = t(508); const s = t(507); const a = t(50); const f = t(111); const l = t(112); const u = t(51); const v = t(9); const p = t(2); const c = t(56); const m = t(153); const g = t(7); const x = t(24); const y = t(10); const T = t(57); const S = t(20); const E = t(82); const C = t(115); const P = new n({ Extends: v, initialize: function (M) { v.call(this), this.scene = M, this.systems = M.sys, this.settings = M.sys.settings, this.manager = M.sys.game.input, this.pluginEvents = new v(), this.enabled = !0, this.displayList, this.cameras, m.install(this), this.mouse = this.manager.mouse, this.topOnly = !0, this.pollRate = -1, this._pollTimer = 0; const L = { cancelled: !1 }; this._eventContainer = { stopPropagation: function () { L.cancelled = !0 } }, this._eventData = L, this.dragDistanceThreshold = 0, this.dragTimeThreshold = 0, this._temp = [], this._tempZones = [], this._list = [], this._pendingInsertion = [], this._pendingRemoval = [], this._draggable = [], this._drag = { 0: [], 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [], 8: [], 9: [], 10: [] }, this._dragState = [], this._over = { 0: [], 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [], 8: [], 9: [], 10: [] }, this._validTypes = ['onDown', 'onUp', 'onOver', 'onOut', 'onMove', 'onDragStart', 'onDrag', 'onDragEnd', 'onDragEnter', 'onDragLeave', 'onDragOver', 'onDrop'], this._updatedThisFrame = !1, M.sys.events.once(S.BOOT, this.boot, this), M.sys.events.on(S.START, this.start, this) }, boot: function () { this.cameras = this.systems.cameras, this.displayList = this.systems.displayList, this.systems.events.once(S.DESTROY, this.destroy, this), this.pluginEvents.emit(u.BOOT) }, start: function () { const A = this.systems.events; A.on(S.TRANSITION_START, this.transitionIn, this), A.on(S.TRANSITION_OUT, this.transitionOut, this), A.on(S.TRANSITION_COMPLETE, this.transitionComplete, this), A.on(S.PRE_UPDATE, this.preUpdate, this), A.once(S.SHUTDOWN, this.shutdown, this), this.manager.events.on(u.GAME_OUT, this.onGameOut, this), this.manager.events.on(u.GAME_OVER, this.onGameOver, this), this.enabled = !0, this._dragState = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], this.pluginEvents.emit(u.START) }, onGameOver: function (A) { this.isActive() && this.emit(u.GAME_OVER, A.timeStamp, A) }, onGameOut: function (A) { this.isActive() && this.emit(u.GAME_OUT, A.timeStamp, A) }, preUpdate: function () { this.pluginEvents.emit(u.PRE_UPDATE); const A = this._pendingRemoval; const M = this._pendingInsertion; const L = A.length; const F = M.length; if (!(L === 0 && F === 0)) { for (var I = this._list, G = 0; G < L; G++) { const U = A[G]; const Y = I.indexOf(U); Y > -1 && (I.splice(Y, 1), this.clear(U, !0)) }A.length = 0, this._pendingRemoval.length = 0, this._list = I.concat(M.splice(0)) } }, isActive: function () { return this.enabled && this.scene.sys.isActive() }, updatePoll: function (A, M) { if (!this.isActive()) return !1; if (this.pluginEvents.emit(u.UPDATE, A, M), this._updatedThisFrame) return this._updatedThisFrame = !1, !1; let L; const F = this.manager; const I = F.pointers; const G = F.pointersTotal; for (L = 0; L < G; L++)I[L].updateMotion(); if (this._list.length === 0) return !1; const U = this.pollRate; if (U === -1) return !1; if (U > 0) if (this._pollTimer -= M, this._pollTimer < 0) this._pollTimer = this.pollRate; else return !1; let Y = !1; for (L = 0; L < G; L++) { let X = 0; const O = I[L]; this._tempZones = [], this._temp = this.hitTestPointer(O), this.sortGameObjects(this._temp, O), this.sortDropZones(this._tempZones), this.topOnly && (this._temp.length && this._temp.splice(1), this._tempZones.length && this._tempZones.splice(1)), X += this.processOverOutEvents(O), this.getDragState(O) === 2 && this.processDragThresholdEvent(O, A), X > 0 && (Y = !0) } return Y }, update: function (A, M) { if (!this.isActive()) return !1; for (var L = M.length, F = !1, I = 0; I < L; I++) { let G = 0; const U = M[I]; switch (this._tempZones = [], this._temp = this.hitTestPointer(U), this.sortGameObjects(this._temp, U), this.sortDropZones(this._tempZones), this.topOnly && (this._temp.length && this._temp.splice(1), this._tempZones.length && this._tempZones.splice(1)), A) { case o.MOUSE_DOWN:G += this.processDragDownEvent(U), G += this.processDownEvents(U), G += this.processOverOutEvents(U); break; case o.MOUSE_UP:G += this.processDragUpEvent(U), G += this.processUpEvents(U), G += this.processOverOutEvents(U); break; case o.TOUCH_START:G += this.processDragDownEvent(U), G += this.processDownEvents(U), G += this.processOverEvents(U); break; case o.TOUCH_END:case o.TOUCH_CANCEL:G += this.processDragUpEvent(U), G += this.processUpEvents(U), G += this.processOutEvents(U); break; case o.MOUSE_MOVE:case o.TOUCH_MOVE:G += this.processDragMoveEvent(U), G += this.processMoveEvents(U), G += this.processOverOutEvents(U); break; case o.MOUSE_WHEEL:G += this.processWheelEvent(U); break }G > 0 && (F = !0) } return this._updatedThisFrame = !0, F }, clear: function (A, M) { M === void 0 && (M = !1); const L = A.input; if (L) { M || this.queueForRemoval(A), L.gameObject = void 0, L.target = void 0, L.hitArea = void 0, L.hitAreaCallback = void 0, L.callbackContext = void 0, A.input = null; let F = this._draggable.indexOf(A); return F > -1 && this._draggable.splice(F, 1), F = this._drag[0].indexOf(A), F > -1 && this._drag[0].splice(F, 1), F = this._over[0].indexOf(A), F > -1 && (this._over[0].splice(F, 1), this.manager.resetCursor(L)), A } }, disable: function (A) { A.input.enabled = !1 }, enable: function (A, M, L, F) { return F === void 0 && (F = !1), A.input ? A.input.enabled = !0 : this.setHitArea(A, M, L), A.input && F && !A.input.dropZone && (A.input.dropZone = F), this }, hitTestPointer: function (A) { for (var M = this.cameras.getCamerasBelowPointer(A), L = 0; L < M.length; L++) { for (var F = M[L], I = this.manager.hitTest(A, this._list, F), G = 0; G < I.length; G++) { const U = I[G]; U.input.dropZone && this._tempZones.push(U) } if (I.length > 0) return A.camera = F, I } return A.camera = M[0], [] }, processDownEvents: function (A) { let M = 0; const L = this._temp; const F = this._eventData; const I = this._eventContainer; F.cancelled = !1; for (var G = !1, U = 0; U < L.length; U++) { const Y = L[U]; if (Y.input) { if (M++, Y.emit(u.GAMEOBJECT_POINTER_DOWN, A, Y.input.localX, Y.input.localY, I), F.cancelled || !Y.input) { G = !0; break } if (this.emit(u.GAMEOBJECT_DOWN, A, Y, I), F.cancelled || !Y.input) { G = !0; break } } } return !G && this.manager && (A.downElement === this.manager.game.canvas ? this.emit(u.POINTER_DOWN, A, L) : this.emit(u.POINTER_DOWN_OUTSIDE, A)), M }, getDragState: function (A) { return this._dragState[A.id] }, setDragState: function (A, M) { this._dragState[A.id] = M }, processDragThresholdEvent: function (A, M) { let L = !1; const F = this.dragTimeThreshold; const I = this.dragDistanceThreshold; if ((I > 0 && a(A.x, A.y, A.downX, A.downY) >= I || F > 0 && M >= A.downTime + F) && (L = !0), L) return this.setDragState(A, 3), this.processDragStartList(A) }, processDragStartList: function (A) { if (this.getDragState(A) !== 3) return 0; for (var M = this._drag[A.id], L = 0; L < M.length; L++) { const F = M[L]; const I = F.input; I.dragState = 2, I.dragStartX = F.x, I.dragStartY = F.y, I.dragStartXGlobal = A.worldX, I.dragStartYGlobal = A.worldY, I.dragX = I.dragStartXGlobal - I.dragStartX, I.dragY = I.dragStartYGlobal - I.dragStartY, F.emit(u.GAMEOBJECT_DRAG_START, A, I.dragX, I.dragY), this.emit(u.DRAG_START, A, F) } return this.setDragState(A, 4), M.length }, processDragDownEvent: function (A) { const M = this._temp; if (this._draggable.length === 0 || M.length === 0 || !A.primaryDown || this.getDragState(A) !== 0) return 0; this.setDragState(A, 1); for (var L = [], F = 0; F < M.length; F++) { const I = M[F]; I.input.draggable && I.input.dragState === 0 && L.push(I) } return L.length === 0 ? (this.setDragState(A, 0), 0) : (L.length > 1 && (this.sortGameObjects(L, A), this.topOnly && L.splice(1)), this._drag[A.id] = L, this.dragDistanceThreshold === 0 && this.dragTimeThreshold === 0 ? (this.setDragState(A, 3), this.processDragStartList(A)) : (this.setDragState(A, 2), 0)) }, processDragMoveEvent: function (A) { if (this.getDragState(A) === 2 && this.processDragThresholdEvent(A, this.manager.game.loop.now), this.getDragState(A) !== 4) return 0; for (var M = this._tempZones, L = this._drag[A.id], F = 0; F < L.length; F++) { const I = L[F]; const G = I.input; let U = G.target; if (U) { const Y = M.indexOf(U); Y === 0 ? (I.emit(u.GAMEOBJECT_DRAG_OVER, A, U), this.emit(u.DRAG_OVER, A, I, U)) : Y > 0 ? (I.emit(u.GAMEOBJECT_DRAG_LEAVE, A, U), this.emit(u.DRAG_LEAVE, A, I, U), G.target = M[0], U = G.target, I.emit(u.GAMEOBJECT_DRAG_ENTER, A, U), this.emit(u.DRAG_ENTER, A, I, U)) : (I.emit(u.GAMEOBJECT_DRAG_LEAVE, A, U), this.emit(u.DRAG_LEAVE, A, I, U), M[0] ? (G.target = M[0], U = G.target, I.emit(u.GAMEOBJECT_DRAG_ENTER, A, U), this.emit(u.DRAG_ENTER, A, I, U)) : G.target = null) } else !U && M[0] && (G.target = M[0], U = G.target, I.emit(u.GAMEOBJECT_DRAG_ENTER, A, U), this.emit(u.DRAG_ENTER, A, I, U)); var X, O; if (!I.parentContainer)X = A.worldX - G.dragX, O = A.worldY - G.dragY; else { const R = A.worldX - G.dragStartXGlobal; const D = A.worldY - G.dragStartYGlobal; const B = I.getParentRotation(); let N = R * Math.cos(B) + D * Math.sin(B); let w = D * Math.cos(B) - R * Math.sin(B); N *= 1 / I.parentContainer.scaleX, w *= 1 / I.parentContainer.scaleY, X = N + G.dragStartX, O = w + G.dragStartY }I.emit(u.GAMEOBJECT_DRAG, A, X, O), this.emit(u.DRAG, A, I, X, O) } return L.length }, processDragUpEvent: function (A) { for (var M = this._drag[A.id], L = 0; L < M.length; L++) { const F = M[L]; const I = F.input; if (I && I.dragState === 2) { I.dragState = 0, I.dragX = I.localX - F.displayOriginX, I.dragY = I.localY - F.displayOriginY; let G = !1; const U = I.target; U && (F.emit(u.GAMEOBJECT_DROP, A, U), this.emit(u.DROP, A, F, U), I.target = null, G = !0), F.input && (F.emit(u.GAMEOBJECT_DRAG_END, A, I.dragX, I.dragY, G), this.emit(u.DRAG_END, A, F, G)) } } return this.setDragState(A, 0), M.splice(0), 0 }, processMoveEvents: function (A) { let M = 0; const L = this._temp; const F = this._eventData; const I = this._eventContainer; F.cancelled = !1; for (var G = !1, U = 0; U < L.length; U++) { const Y = L[U]; if (Y.input) { if (M++, Y.emit(u.GAMEOBJECT_POINTER_MOVE, A, Y.input.localX, Y.input.localY, I), F.cancelled || !Y.input) { G = !0; break } if (this.emit(u.GAMEOBJECT_MOVE, A, Y, I), F.cancelled || !Y.input) { G = !0; break } if (this.topOnly) break } } return G || this.emit(u.POINTER_MOVE, A, L), M }, processWheelEvent: function (A) { let M = 0; const L = this._temp; const F = this._eventData; const I = this._eventContainer; F.cancelled = !1; for (var G = !1, U = A.deltaX, Y = A.deltaY, X = A.deltaZ, O = 0; O < L.length; O++) { const R = L[O]; if (R.input) { if (M++, R.emit(u.GAMEOBJECT_POINTER_WHEEL, A, U, Y, X, I), F.cancelled || !R.input) { G = !0; break } if (this.emit(u.GAMEOBJECT_WHEEL, A, R, U, Y, X, I), F.cancelled || !R.input) { G = !0; break } } } return G || this.emit(u.POINTER_WHEEL, A, L, U, Y, X), M }, processOverEvents: function (A) { const M = this._temp; let L = 0; const F = M.length; const I = []; if (F > 0) { const G = this.manager; const U = this._eventData; const Y = this._eventContainer; U.cancelled = !1; for (var X = !1, O = 0; O < F; O++) { const R = M[O]; if (R.input) { if (I.push(R), G.setCursor(R.input), R.emit(u.GAMEOBJECT_POINTER_OVER, A, R.input.localX, R.input.localY, Y), L++, U.cancelled || !R.input) { X = !0; break } if (this.emit(u.GAMEOBJECT_OVER, A, R, Y), U.cancelled || !R.input) { X = !0; break } } }X || this.emit(u.POINTER_OVER, A, I) } return this._over[A.id] = I, L }, processOutEvents: function (A) { const M = this._over[A.id]; let L = 0; const F = M.length; if (F > 0) { const I = this.manager; const G = this._eventData; const U = this._eventContainer; G.cancelled = !1; let Y = !1; this.sortGameObjects(M, A); for (let X = 0; X < F; X++) { let O = M[X]; if (O = M[X], !!O.input) { if (I.resetCursor(O.input), O.emit(u.GAMEOBJECT_POINTER_OUT, A, U), L++, G.cancelled || !O.input) { Y = !0; break } if (this.emit(u.GAMEOBJECT_OUT, A, O, U), G.cancelled || !O.input) { Y = !0; break }Y || this.emit(u.POINTER_OUT, A, M) } } this._over[A.id] = [] } return L }, processOverOutEvents: function (A) { const M = this._temp; let L; let F; const I = []; const G = []; const U = []; let Y = this._over[A.id]; const X = this._drag[A.id]; const O = this.manager; for (L = 0; L < Y.length; L++)F = Y[L], M.indexOf(F) === -1 && X.indexOf(F) === -1 ? I.push(F) : U.push(F); for (L = 0; L < M.length; L++)F = M[L], Y.indexOf(F) === -1 && G.push(F); let R = I.length; let D = 0; const B = this._eventData; const N = this._eventContainer; B.cancelled = !1; let w = !1; if (R > 0) { for (this.sortGameObjects(I, A), L = 0; L < R; L++) if (F = I[L], !!F.input) { if (O.resetCursor(F.input), F.emit(u.GAMEOBJECT_POINTER_OUT, A, N), D++, B.cancelled || !F.input) { w = !0; break } if (this.emit(u.GAMEOBJECT_OUT, A, F, N), B.cancelled || !F.input) { w = !0; break } }w || this.emit(u.POINTER_OUT, A, I) } if (R = G.length, B.cancelled = !1, w = !1, R > 0) { for (this.sortGameObjects(G, A), L = 0; L < R; L++) if (F = G[L], !!F.input) { if (O.setCursor(F.input), F.emit(u.GAMEOBJECT_POINTER_OVER, A, F.input.localX, F.input.localY, N), D++, B.cancelled || !F.input) { w = !0; break } if (this.emit(u.GAMEOBJECT_OVER, A, F, N), B.cancelled || !F.input) { w = !0; break } }w || this.emit(u.POINTER_OVER, A, G) } return Y = U.concat(G), this._over[A.id] = this.sortGameObjects(Y, A), D }, processUpEvents: function (A) { const M = this._temp; const L = this._eventData; const F = this._eventContainer; L.cancelled = !1; for (var I = !1, G = 0; G < M.length; G++) { const U = M[G]; if (U.input) { if (U.emit(u.GAMEOBJECT_POINTER_UP, A, U.input.localX, U.input.localY, F), L.cancelled || !U.input) { I = !0; break } if (this.emit(u.GAMEOBJECT_UP, A, U, F), L.cancelled || !U.input) { I = !0; break } } } return !I && this.manager && (A.upElement === this.manager.game.canvas ? this.emit(u.POINTER_UP, A, M) : this.emit(u.POINTER_UP_OUTSIDE, A)), M.length }, queueForInsertion: function (A) { return this._pendingInsertion.indexOf(A) === -1 && this._list.indexOf(A) === -1 && this._pendingInsertion.push(A), this }, queueForRemoval: function (A) { return this._pendingRemoval.push(A), this }, setDraggable: function (A, M) { M === void 0 && (M = !0), Array.isArray(A) || (A = [A]); for (let L = 0; L < A.length; L++) { const F = A[L]; F.input.draggable = M; const I = this._draggable.indexOf(F); M && I === -1 ? this._draggable.push(F) : !M && I > -1 && this._draggable.splice(I, 1) } return this }, makePixelPerfect: function (A) { A === void 0 && (A = 1); const M = this.systems.textures; return s(M, A) }, setHitArea: function (A, M, L) { if (M === void 0) return this.setHitAreaFromTexture(A); Array.isArray(A) || (A = [A]); let F = !1; let I = !1; let G = !1; let U = !1; let Y = !1; let X = !0; if (g(M)) { const O = M; M = p(O, 'hitArea', null), L = p(O, 'hitAreaCallback', null), F = p(O, 'draggable', !1), I = p(O, 'dropZone', !1), G = p(O, 'cursor', !1), U = p(O, 'useHandCursor', !1), Y = p(O, 'pixelPerfect', !1); const R = p(O, 'alphaTolerance', 1); Y && (M = {}, L = this.makePixelPerfect(R)), (!M || !L) && (this.setHitAreaFromTexture(A), X = !1) } else typeof M === 'function' && !L && (L = M, M = {}); for (let D = 0; D < A.length; D++) { const B = A[D]; if (Y && B.type === 'Container') { console.warn('Cannot pixelPerfect test a Container. Use a custom callback.'); continue } const N = B.input ? B.input : r(B, M, L); N.customHitArea = X, N.dropZone = I, N.cursor = U ? 'pointer' : G, B.input = N, F && this.setDraggable(B), this.queueForInsertion(B) } return this }, setHitAreaCircle: function (A, M, L, F, I) { I === void 0 && (I = h); const G = new i(M, L, F); return this.setHitArea(A, G, I) }, setHitAreaEllipse: function (A, M, L, F, I, G) { G === void 0 && (G = l); const U = new f(M, L, F, I); return this.setHitArea(A, U, G) }, setHitAreaFromTexture: function (A, M) { M === void 0 && (M = T), Array.isArray(A) || (A = [A]); for (let L = 0; L < A.length; L++) { const F = A[L]; const I = F.frame; let G = 0; let U = 0; if (F.width ? (G = F.width, U = F.height) : I && (G = I.realWidth, U = I.realHeight), F.type === 'Container' && (G === 0 || U === 0)) { console.warn('Container.setInteractive must specify a Shape or call setSize() first'); continue }G !== 0 && U !== 0 && (F.input = r(F, new y(0, 0, G, U), M), this.queueForInsertion(F)) } return this }, setHitAreaRectangle: function (A, M, L, F, I, G) { G === void 0 && (G = T); const U = new y(M, L, F, I); return this.setHitArea(A, U, G) }, setHitAreaTriangle: function (A, M, L, F, I, G, U, Y) { Y === void 0 && (Y = C); const X = new E(M, L, F, I, G, U); return this.setHitArea(A, X, Y) }, enableDebug: function (A, M) { M === void 0 && (M = 65280); const L = A.input; if (!L || !L.hitArea) return this; const F = L.hitArea; const I = F.type; let G = L.hitAreaDebug; const U = this.systems.add; const Y = this.systems.updateList; G && (Y.remove(G), G.destroy(), G = null); let X = 0; let O = 0; switch (I) { case c.CIRCLE:G = U.arc(0, 0, F.radius), X = F.x - F.radius, O = F.y - F.radius; break; case c.ELLIPSE:G = U.ellipse(0, 0, F.width, F.height), X = F.x - F.width / 2, O = F.y - F.height / 2; break; case c.LINE:G = U.line(0, 0, F.x1, F.y1, F.x2, F.y2); break; case c.POLYGON:G = U.polygon(0, 0, F.points); break; case c.RECTANGLE:G = U.rectangle(0, 0, F.width, F.height), X = F.x, O = F.y; break; case c.TRIANGLE:G = U.triangle(0, 0, F.x1, F.y1, F.x2, F.y2, F.x3, F.y3); break } return G && (G.isFilled = !1, G.preUpdate = function () { G.setStrokeStyle(1 / A.scale, M), G.setDisplayOrigin(A.displayOriginX, A.displayOriginY); let R = A.x; let D = A.y; let B = A.rotation; let N = A.scaleX; let w = A.scaleY; if (A.parentContainer) { const z = A.getWorldTransformMatrix(); R = z.tx, D = z.ty, B = z.rotation, N = z.scaleX, w = z.scaleY }G.setRotation(B), G.setScale(N, w), G.setPosition(R + X, D + O), G.setScrollFactor(A.scrollFactorX, A.scrollFactorY), G.setDepth(A.depth) }, Y.add(G), L.hitAreaDebug = G), this }, removeDebug: function (A) { const M = A.input; if (M && M.hitAreaDebug) { const L = M.hitAreaDebug; this.systems.updateList.remove(L), L.destroy(), M.hitAreaDebug = null } return this }, setPollAlways: function () { return this.setPollRate(0) }, setPollOnMove: function () { return this.setPollRate(-1) }, setPollRate: function (A) { return this.pollRate = A, this._pollTimer = 0, this }, setGlobalTopOnly: function (A) { return this.manager.globalTopOnly = A, this }, setTopOnly: function (A) { return this.topOnly = A, this }, sortGameObjects: function (A, M) { if (A.length < 2) return A; const L = M.camera.renderList; return A.sort(function (F, I) { return L.indexOf(I) - L.indexOf(F) }) }, sortDropZones: function (A) { return A.length < 2 ? A : (this.scene.sys.depthSort(), A.sort(this.sortDropZoneHandler.bind(this))) }, sortDropZoneHandler: function (A, M) { if (!A.parentContainer && !M.parentContainer) return this.displayList.getIndex(M) - this.displayList.getIndex(A); if (A.parentContainer === M.parentContainer) return M.parentContainer.getIndex(M) - A.parentContainer.getIndex(A); if (A.parentContainer === M) return -1; if (M.parentContainer === A) return 1; for (var L = A.getIndexList(), F = M.getIndexList(), I = Math.min(L.length, F.length), G = 0; G < I; G++) { const U = L[G]; const Y = F[G]; if (U !== Y) return Y - U } return F.length - L.length; return 0 }, stopPropagation: function () { return this.manager._tempSkip = !0, this }, addPointer: function (A) { return this.manager.addPointer(A) }, setDefaultCursor: function (A) { return this.manager.setDefaultCursor(A), this }, transitionIn: function () { this.enabled = this.settings.transitionAllowInput }, transitionComplete: function () { this.settings.transitionAllowInput || (this.enabled = !0) }, transitionOut: function () { this.enabled = this.settings.transitionAllowInput }, shutdown: function () { this.pluginEvents.emit(u.SHUTDOWN), this._temp.length = 0, this._list.length = 0, this._draggable.length = 0, this._pendingRemoval.length = 0, this._pendingInsertion.length = 0, this._dragState.length = 0; for (let A = 0; A < 10; A++) this._drag[A] = [], this._over[A] = []; this.removeAllListeners(); const M = this.manager; M.canvas.style.cursor = M.defaultCursor; const L = this.systems.events; L.off(S.TRANSITION_START, this.transitionIn, this), L.off(S.TRANSITION_OUT, this.transitionOut, this), L.off(S.TRANSITION_COMPLETE, this.transitionComplete, this), L.off(S.PRE_UPDATE, this.preUpdate, this), M.events.off(u.GAME_OUT, this.onGameOut, this), M.events.off(u.GAME_OVER, this.onGameOver, this), L.off(S.SHUTDOWN, this.shutdown, this) }, destroy: function () { this.shutdown(), this.pluginEvents.emit(u.DESTROY), this.pluginEvents.removeAllListeners(), this.scene.sys.events.off(S.START, this.start, this), this.scene = null, this.cameras = null, this.manager = null, this.events = null, this.mouse = null }, x: { get: function () { return this.manager.activePointer.x } }, y: { get: function () { return this.manager.activePointer.y } }, isOver: { get: function () { return this.manager.isOver } }, mousePointer: { get: function () { return this.manager.mousePointer } }, activePointer: { get: function () { return this.manager.activePointer } }, pointer1: { get: function () { return this.manager.pointers[1] } }, pointer2: { get: function () { return this.manager.pointers[2] } }, pointer3: { get: function () { return this.manager.pointers[3] } }, pointer4: { get: function () { return this.manager.pointers[4] } }, pointer5: { get: function () { return this.manager.pointers[5] } }, pointer6: { get: function () { return this.manager.pointers[6] } }, pointer7: { get: function () { return this.manager.pointers[7] } }, pointer8: { get: function () { return this.manager.pointers[8] } }, pointer9: { get: function () { return this.manager.pointers[9] } }, pointer10: { get: function () { return this.manager.pointers[10] } } }); x.register('InputPlugin', P, 'input'), e.exports = P }, function (e, d, t) { e.exports = { Events: t(154), KeyboardManager: t(410), KeyboardPlugin: t(1330), Key: t(512), KeyCodes: t(143), KeyCombo: t(513), AdvanceKeyCombo: t(515), ProcessKeyCombo: t(514), ResetKeyCombo: t(516), JustDown: t(1332), JustUp: t(1333), DownDuration: t(1334), UpDuration: t(1335) } }, function (e, d) { e.exports = 'keydown' }, function (e, d) { e.exports = 'keyup' }, function (e, d) { e.exports = 'keycombomatch' }, function (e, d) { e.exports = 'down' }, function (e, d) { e.exports = 'keydown-' }, function (e, d) { e.exports = 'keyup-' }, function (e, d) { e.exports = 'up' }, function (e, d, t) { const i = t(0); const h = t(9); const n = t(154); const o = t(22); const r = t(6); const s = t(51); const a = t(153); const f = t(512); const l = t(143); const u = t(513); const v = t(1331); const p = t(20); const c = t(76); const m = new i({ Extends: h, initialize: function (x) { h.call(this), this.game = x.systems.game, this.scene = x.scene, this.settings = this.scene.sys.settings, this.sceneInputPlugin = x, this.manager = x.manager.keyboard, this.enabled = !0, this.keys = [], this.combos = [], this.prevCode = null, this.prevTime = 0, this.prevType = null, x.pluginEvents.once(s.BOOT, this.boot, this), x.pluginEvents.on(s.START, this.start, this) }, boot: function () { const g = this.settings.input; this.enabled = r(g, 'keyboard', !0); const x = r(g, 'keyboard.capture', null); x && this.addCaptures(x), this.sceneInputPlugin.pluginEvents.once(s.DESTROY, this.destroy, this) }, start: function () { this.sceneInputPlugin.manager.events.on(s.MANAGER_PROCESS, this.update, this), this.sceneInputPlugin.pluginEvents.once(s.SHUTDOWN, this.shutdown, this), this.game.events.on(o.BLUR, this.resetKeys, this), this.scene.sys.events.on(p.PAUSE, this.resetKeys, this), this.scene.sys.events.on(p.SLEEP, this.resetKeys, this) }, isActive: function () { return this.enabled && this.scene.sys.isActive() }, addCapture: function (g) { return this.manager.addCapture(g), this }, removeCapture: function (g) { return this.manager.removeCapture(g), this }, getCaptures: function () { return this.manager.captures }, enableGlobalCapture: function () { return this.manager.preventDefault = !0, this }, disableGlobalCapture: function () { return this.manager.preventDefault = !1, this }, clearCaptures: function () { return this.manager.clearCaptures(), this }, createCursorKeys: function () { return this.addKeys({ up: l.UP, down: l.DOWN, left: l.LEFT, right: l.RIGHT, space: l.SPACE, shift: l.SHIFT }) }, addKeys: function (g, x, y) { x === void 0 && (x = !0), y === void 0 && (y = !1); const T = {}; if (typeof g === 'string') { g = g.split(','); for (let S = 0; S < g.length; S++) { const E = g[S].trim(); E && (T[E] = this.addKey(E, x, y)) } } else for (const C in g)T[C] = this.addKey(g[C], x, y); return T }, addKey: function (g, x, y) { x === void 0 && (x = !0), y === void 0 && (y = !1); const T = this.keys; if (g instanceof f) { const S = T.indexOf(g); return S > -1 ? T[S] = g : T[g.keyCode] = g, x && this.addCapture(g.keyCode), g.setEmitOnRepeat(y), g } return typeof g === 'string' && (g = l[g.toUpperCase()]), T[g] || (T[g] = new f(this, g), x && this.addCapture(g), T[g].setEmitOnRepeat(y)), T[g] }, removeKey: function (g, x) { x === void 0 && (x = !1); const y = this.keys; let T; if (g instanceof f) { const S = y.indexOf(g); S > -1 && (T = this.keys[S], this.keys[S] = void 0) } else typeof g === 'string' && (g = l[g.toUpperCase()]); return y[g] && (T = y[g], y[g] = void 0), T && (T.plugin = null, x && T.destroy()), this }, removeAllKeys: function (g) { for (let x = this.keys, y = 0; y < x.length; y++) { const T = x[y]; T && (x[y] = void 0, g && T.destroy()) } return this }, createCombo: function (g, x) { return new u(this, g, x) }, checkDown: function (g, x) { if (x === void 0 && (x = 0), this.enabled && g.isDown) { const y = c(this.time - g.timeDown, x); if (y > g._tick) return g._tick = y, !0 } return !1 }, update: function () { const g = this.manager.queue; const x = g.length; if (!(!this.isActive() || x === 0)) for (let y = this.keys, T = 0; T < x; T++) { var S = g[T]; const E = S.keyCode; const C = y[E]; let P = !1; S.cancelled === void 0 && (S.cancelled = 0, S.stopImmediatePropagation = function () { S.cancelled = 1 }, S.stopPropagation = function () { S.cancelled = -1 }), S.cancelled !== -1 && (E === this.prevCode && S.timeStamp === this.prevTime && S.type === this.prevType || (this.prevCode = E, this.prevTime = S.timeStamp, this.prevType = S.type, S.type === 'keydown' ? (C && (P = C.isDown, C.onDown(S)), !S.cancelled && (!C || !P) && (v[E] && this.emit(n.KEY_DOWN + v[E], S), S.cancelled || this.emit(n.ANY_KEY_DOWN, S))) : (C && C.onUp(S), S.cancelled || (v[E] && this.emit(n.KEY_UP + v[E], S), S.cancelled || this.emit(n.ANY_KEY_UP, S))), S.cancelled === 1 && (S.cancelled = 0))) } }, resetKeys: function () { for (let g = this.keys, x = 0; x < g.length; x++)g[x] && g[x].reset(); return this }, shutdown: function () { this.removeAllKeys(!0), this.removeAllListeners(), this.sceneInputPlugin.manager.events.off(s.MANAGER_PROCESS, this.update, this), this.game.events.off(o.BLUR, this.resetKeys), this.scene.sys.events.off(p.PAUSE, this.resetKeys, this), this.scene.sys.events.off(p.SLEEP, this.resetKeys, this), this.queue = [] }, destroy: function () { this.shutdown(); for (let g = this.keys, x = 0; x < g.length; x++)g[x] && g[x].destroy(); this.keys = [], this.combos = [], this.queue = [], this.scene = null, this.settings = null, this.sceneInputPlugin = null, this.manager = null }, time: { get: function () { return this.sceneInputPlugin.manager.time } } }); a.register('KeyboardPlugin', m, 'keyboard', 'keyboard', 'inputKeyboard'), e.exports = m }, function (e, d, t) { const i = t(143); const h = {}; for (const n in i)h[i[n]] = n; e.exports = h }, function (e, d) { const t = function (i) { return i._justDown ? (i._justDown = !1, !0) : !1 }; e.exports = t }, function (e, d) { const t = function (i) { return i._justUp ? (i._justUp = !1, !0) : !1 }; e.exports = t }, function (e, d) { const t = function (i, h) { h === void 0 && (h = 50); const n = i.plugin.game.loop.time - i.timeDown; return i.isDown && n < h }; e.exports = t }, function (e, d) { const t = function (i, h) { h === void 0 && (h = 50); const n = i.plugin.game.loop.time - i.timeUp; return i.isUp && n < h }; e.exports = t }, function (e, d, t) { e.exports = { MouseManager: t(411) } }, function (e, d, t) { e.exports = { TouchManager: t(413) } }, function (e, d, t) { const i = t(21); const h = t(17); let n = { Events: t(95), FileTypes: t(1339), File: t(23), FileTypesManager: t(8), GetURL: t(155), LoaderPlugin: t(1365), MergeXHRSettings: t(240), MultiFile: t(49), XHRLoader: t(517), XHRSettings: t(156) }; n = h(!1, n, i), e.exports = n }, function (e, d, t) { e.exports = { AnimationJSONFile: t(1340), AsepriteFile: t(1341), AtlasJSONFile: t(1342), AtlasXMLFile: t(1343), AudioFile: t(518), AudioSpriteFile: t(1344), BinaryFile: t(1345), BitmapFontFile: t(1346), CSSFile: t(1347), GLSLFile: t(1348), HTML5AudioFile: t(519), HTMLFile: t(1349), HTMLTextureFile: t(1350), ImageFile: t(71), JSONFile: t(61), MultiAtlasFile: t(1351), MultiScriptFile: t(1352), OBJFile: t(1353), PackFile: t(1354), PluginFile: t(1355), SceneFile: t(1356), ScenePluginFile: t(1357), ScriptFile: t(520), SpriteSheetFile: t(1358), SVGFile: t(1359), TextFile: t(242), TilemapCSVFile: t(1360), TilemapImpactFile: t(1361), TilemapJSONFile: t(1362), UnityAtlasFile: t(1363), VideoFile: t(1364), XMLFile: t(241) } }, function (e, d, t) { const i = t(0); const h = t(8); const n = t(61); const o = t(95); const r = new i({ Extends: n, initialize: function (a, f, l, u, v) { n.call(this, a, f, l, u, v), this.type = 'animationJSON' }, onProcess: function () { this.loader.once(o.POST_PROCESS, this.onLoadComplete, this), n.prototype.onProcess.call(this) }, onLoadComplete: function () { this.loader.systems.anims.fromJSON(this.data) } }); h.register('animation', function (s, a, f, l) { if (Array.isArray(s)) for (let u = 0; u < s.length; u++) this.addFile(new r(this, s[u])); else this.addFile(new r(this, s, a, l, f)); return this }), e.exports = r }, function (e, d, t) { const i = t(0); const h = t(8); const n = t(2); const o = t(71); const r = t(7); const s = t(61); const a = t(49); const f = new i({ Extends: a, initialize: function (u, v, p, c, m, g) { let x, y; if (r(v)) { const T = v; v = n(T, 'key'), x = new o(u, { key: v, url: n(T, 'textureURL'), extension: n(T, 'textureExtension', 'png'), normalMap: n(T, 'normalMap'), xhrSettings: n(T, 'textureXhrSettings') }), y = new s(u, { key: v, url: n(T, 'atlasURL'), extension: n(T, 'atlasExtension', 'json'), xhrSettings: n(T, 'atlasXhrSettings') }) } else x = new o(u, v, p, m), y = new s(u, v, c, g); x.linkFile ? a.call(this, u, 'atlasjson', v, [x, y, x.linkFile]) : a.call(this, u, 'atlasjson', v, [x, y]) }, addToCache: function () { if (this.isReadyToProcess()) { const l = this.files[0]; const u = this.files[1]; const v = this.files[2] ? this.files[2].data : null; this.loader.textureManager.addAtlas(l.key, l.data, u.data, v), u.addToCache(), this.complete = !0 } } }); h.register('aseprite', function (l, u, v, p, c) { let m; if (Array.isArray(l)) for (let g = 0; g < l.length; g++)m = new f(this, l[g]), this.addFile(m.files); else m = new f(this, l, u, v, p, c), this.addFile(m.files); return this }), e.exports = f }, function (e, d, t) { const i = t(0); const h = t(8); const n = t(2); const o = t(71); const r = t(7); const s = t(61); const a = t(49); const f = new i({ Extends: a, initialize: function (u, v, p, c, m, g) { let x, y; if (r(v)) { const T = v; v = n(T, 'key'), x = new o(u, { key: v, url: n(T, 'textureURL'), extension: n(T, 'textureExtension', 'png'), normalMap: n(T, 'normalMap'), xhrSettings: n(T, 'textureXhrSettings') }), y = new s(u, { key: v, url: n(T, 'atlasURL'), extension: n(T, 'atlasExtension', 'json'), xhrSettings: n(T, 'atlasXhrSettings') }) } else x = new o(u, v, p, m), y = new s(u, v, c, g); x.linkFile ? a.call(this, u, 'atlasjson', v, [x, y, x.linkFile]) : a.call(this, u, 'atlasjson', v, [x, y]) }, addToCache: function () { if (this.isReadyToProcess()) { const l = this.files[0]; const u = this.files[1]; const v = this.files[2] ? this.files[2].data : null; this.loader.textureManager.addAtlas(l.key, l.data, u.data, v), u.pendingDestroy(), this.complete = !0 } } }); h.register('atlas', function (l, u, v, p, c) { let m; if (Array.isArray(l)) for (let g = 0; g < l.length; g++)m = new f(this, l[g]), this.addFile(m.files); else m = new f(this, l, u, v, p, c), this.addFile(m.files); return this }), e.exports = f }, function (e, d, t) { const i = t(0); const h = t(8); const n = t(2); const o = t(71); const r = t(7); const s = t(49); const a = t(241); const f = new i({ Extends: s, initialize: function (u, v, p, c, m, g) { let x, y; if (r(v)) { const T = v; v = n(T, 'key'), x = new o(u, { key: v, url: n(T, 'textureURL'), extension: n(T, 'textureExtension', 'png'), normalMap: n(T, 'normalMap'), xhrSettings: n(T, 'textureXhrSettings') }), y = new a(u, { key: v, url: n(T, 'atlasURL'), extension: n(T, 'atlasExtension', 'xml'), xhrSettings: n(T, 'atlasXhrSettings') }) } else x = new o(u, v, p, m), y = new a(u, v, c, g); x.linkFile ? s.call(this, u, 'atlasxml', v, [x, y, x.linkFile]) : s.call(this, u, 'atlasxml', v, [x, y]) }, addToCache: function () { if (this.isReadyToProcess()) { const l = this.files[0]; const u = this.files[1]; const v = this.files[2] ? this.files[2].data : null; this.loader.textureManager.addAtlasXML(l.key, l.data, u.data, v), u.pendingDestroy(), this.complete = !0 } } }); h.register('atlasXML', function (l, u, v, p, c) { let m; if (Array.isArray(l)) for (let g = 0; g < l.length; g++)m = new f(this, l[g]), this.addFile(m.files); else m = new f(this, l, u, v, p, c), this.addFile(m.files); return this }), e.exports = f }, function (e, d, t) { const i = t(518); const h = t(0); const n = t(8); const o = t(2); const r = t(7); const s = t(61); const a = t(49); const f = new h({ Extends: a, initialize: function (u, v, p, c, m, g, x) { if (r(v)) { const y = v; v = o(y, 'key'), p = o(y, 'jsonURL'), c = o(y, 'audioURL'), m = o(y, 'audioConfig'), g = o(y, 'audioXhrSettings'), x = o(y, 'jsonXhrSettings') } let T; if (!c)T = new s(u, v, p, x), a.call(this, u, 'audiosprite', v, [T]), this.config.resourceLoad = !0, this.config.audioConfig = m, this.config.audioXhrSettings = g; else { const S = i.create(u, v, c, m, g); S && (T = new s(u, v, p, x), a.call(this, u, 'audiosprite', v, [S, T]), this.config.resourceLoad = !1) } }, onFileComplete: function (l) { const u = this.files.indexOf(l); if (u !== -1 && (this.pending--, this.config.resourceLoad && l.type === 'json' && l.data.hasOwnProperty('resources'))) { const v = l.data.resources; const p = o(this.config, 'audioConfig'); const c = o(this.config, 'audioXhrSettings'); const m = i.create(this.loader, l.key, v, p, c); m && (this.addToMultiFile(m), this.loader.addFile(m)) } }, addToCache: function () { if (this.isReadyToProcess()) { const l = this.files[0]; const u = this.files[1]; l.addToCache(), u.addToCache(), this.complete = !0 } } }); n.register('audioSprite', function (l, u, v, p, c, m) { const g = this.systems.game; const x = g.config.audio; const y = g.device.audio; if (x && x.noAudio || !y.webAudio && !y.audioData) return this; let T; if (Array.isArray(l)) for (let S = 0; S < l.length; S++)T = new f(this, l[S]), T.files && this.addFile(T.files); else T = new f(this, l, u, v, p, c, m), T.files && this.addFile(T.files); return this }) }, function (e, d, t) { const i = t(0); const h = t(21); const n = t(23); const o = t(8); const r = t(2); const s = t(7); const a = new i({ Extends: n, initialize: function (l, u, v, p, c) { let m = 'bin'; if (s(u)) { const g = u; u = r(g, 'key'), v = r(g, 'url'), p = r(g, 'xhrSettings'), m = r(g, 'extension', m), c = r(g, 'dataType', c) } const x = { type: 'binary', cache: l.cacheManager.binary, extension: m, responseType: 'arraybuffer', key: u, url: v, xhrSettings: p, config: { dataType: c } }; n.call(this, l, x) }, onProcess: function () { this.state = h.FILE_PROCESSING; const f = this.config.dataType; this.data = f ? new f(this.xhrLoader.response) : this.xhrLoader.response, this.onProcessComplete() } }); o.register('binary', function (f, l, u, v) { if (Array.isArray(f)) for (let p = 0; p < f.length; p++) this.addFile(new a(this, f[p])); else this.addFile(new a(this, f, l, v, u)); return this }), e.exports = a }, function (e, d, t) { const i = t(0); const h = t(8); const n = t(2); const o = t(71); const r = t(7); const s = t(49); const a = t(212); const f = t(241); const l = new i({ Extends: s, initialize: function (v, p, c, m, g, x) { let y, T; if (r(p)) { const S = p; p = n(S, 'key'), y = new o(v, { key: p, url: n(S, 'textureURL'), extension: n(S, 'textureExtension', 'png'), normalMap: n(S, 'normalMap'), xhrSettings: n(S, 'textureXhrSettings') }), T = new f(v, { key: p, url: n(S, 'fontDataURL'), extension: n(S, 'fontDataExtension', 'xml'), xhrSettings: n(S, 'fontDataXhrSettings') }) } else y = new o(v, p, c, g), T = new f(v, p, m, x); y.linkFile ? s.call(this, v, 'bitmapfont', p, [y, T, y.linkFile]) : s.call(this, v, 'bitmapfont', p, [y, T]) }, addToCache: function () { if (this.isReadyToProcess()) { const u = this.files[0]; const v = this.files[1]; u.addToCache(), v.pendingDestroy(); const p = u.cache.get(u.key); const c = a(v.data, u.cache.getFrame(u.key), 0, 0, p); this.loader.cacheManager.bitmapFont.add(u.key, { data: c, texture: u.key, frame: null }), this.complete = !0 } } }); h.register('bitmapFont', function (u, v, p, c, m) { let g; if (Array.isArray(u)) for (let x = 0; x < u.length; x++)g = new l(this, u[x]), this.addFile(g.files); else g = new l(this, u, v, p, c, m), this.addFile(g.files); return this }), e.exports = l }, function (e, d, t) { const i = t(0); const h = t(21); const n = t(23); const o = t(8); const r = t(2); const s = t(7); const a = new i({ Extends: n, initialize: function (l, u, v, p) { let c = 'css'; if (s(u)) { const m = u; u = r(m, 'key'), v = r(m, 'url'), p = r(m, 'xhrSettings'), c = r(m, 'extension', c) } const g = { type: 'script', cache: !1, extension: c, responseType: 'text', key: u, url: v, xhrSettings: p }; n.call(this, l, g) }, onProcess: function () { this.state = h.FILE_PROCESSING, this.data = document.createElement('style'), this.data.defer = !1, this.data.innerHTML = this.xhrLoader.responseText, document.head.appendChild(this.data), this.onProcessComplete() } }); o.register('css', function (f, l, u) { if (Array.isArray(f)) for (let v = 0; v < f.length; v++) this.addFile(new a(this, f[v])); else this.addFile(new a(this, f, l, u)); return this }), e.exports = a }, function (e, d, t) {
        const i = t(0); const h = t(21); const n = t(23); const o = t(8); const r = t(2); const s = t(7); const a = t(396); const f = new i({
          Extends: n,
          initialize: function (u, v, p, c, m) { let g = 'glsl'; if (s(v)) { const x = v; v = r(x, 'key'), p = r(x, 'url'), c = r(x, 'shaderType', 'fragment'), m = r(x, 'xhrSettings'), g = r(x, 'extension', g) } else c === void 0 && (c = 'fragment'); const y = { type: 'glsl', cache: u.cacheManager.shader, extension: g, responseType: 'text', key: v, url: p, config: { shaderType: c }, xhrSettings: m }; n.call(this, u, y) },
          onProcess: function () { this.state = h.FILE_PROCESSING, this.data = this.xhrLoader.responseText, this.onProcessComplete() },
          addToCache: function () {
            const l = this.data.split(`
`); let u = this.extractBlock(l, 0); if (u) for (;u;) { const v = this.getShaderName(u.header); const p = this.getShaderType(u.header); const c = this.getShaderUniforms(u.header); const m = u.shader; if (this.cache.has(v)) { const g = this.cache.get(v); p === 'fragment' ? g.fragmentSrc = m : g.vertexSrc = m, g.uniforms || (g.uniforms = c) } else p === 'fragment' ? this.cache.add(v, new a(v, m, '', c)) : this.cache.add(v, new a(v, '', m, c)); u = this.extractBlock(l, u.offset) } else this.config.shaderType === 'fragment' ? this.cache.add(this.key, new a(this.key, this.data)) : this.cache.add(this.key, new a(this.key, '', this.data)); this.pendingDestroy()
          },
          getShaderName: function (l) { for (let u = 0; u < l.length; u++) { const v = l[u].trim(); if (v.substring(0, 5) === 'name:') return v.substring(5).trim() } return this.key },
          getShaderType: function (l) { for (let u = 0; u < l.length; u++) { const v = l[u].trim(); if (v.substring(0, 5) === 'type:') return v.substring(5).trim() } return this.config.shaderType },
          getShaderUniforms: function (l) { for (var u = {}, v = 0; v < l.length; v++) { const p = l[v].trim(); if (p.substring(0, 8) === 'uniform.') { const c = p.indexOf(':'); if (c) { const m = p.substring(8, c); try { u[m] = JSON.parse(p.substring(c + 1)) } catch (g) { console.warn('Invalid uniform JSON: ' + m) } } } } return u },
          extractBlock: function (l, u) {
            for (var v = -1, p = -1, c = -1, m = !1, g = !1, x = [], y = [], T = u; T < l.length; T++) { const S = l[T].trim(); if (S === '---') if (v === -1)v = T, m = !0; else if (m)p = T, m = !1, g = !0; else { g = !1; break } else m ? x.push(S) : g && (y.push(S), c = T) } return !m && p !== -1
              ? {
                  header: x,
                  shader: y.join(`
`),
                  offset: c
                }
              : null
          }
        }); o.register('glsl', function (l, u, v, p) { if (Array.isArray(l)) for (let c = 0; c < l.length; c++) this.addFile(new f(this, l[c])); else this.addFile(new f(this, l, u, v, p)); return this }), e.exports = f
      }, function (e, d, t) { const i = t(0); const h = t(21); const n = t(23); const o = t(8); const r = t(2); const s = t(7); const a = new i({ Extends: n, initialize: function (l, u, v, p) { let c = 'html'; if (s(u)) { const m = u; u = r(m, 'key'), v = r(m, 'url'), p = r(m, 'xhrSettings'), c = r(m, 'extension', c) } const g = { type: 'text', cache: l.cacheManager.html, extension: c, responseType: 'text', key: u, url: v, xhrSettings: p }; n.call(this, l, g) }, onProcess: function () { this.state = h.FILE_PROCESSING, this.data = this.xhrLoader.responseText, this.onProcessComplete() } }); o.register('html', function (f, l, u) { if (Array.isArray(f)) for (let v = 0; v < f.length; v++) this.addFile(new a(this, f[v])); else this.addFile(new a(this, f, l, u)); return this }), e.exports = a }, function (e, d, t) {
        const i = t(0); const h = t(21); const n = t(23); const o = t(8); const r = t(2); const s = t(7); const a = new i({
          Extends: n,
          initialize: function (l, u, v, p, c, m) { p === void 0 && (p = 512), c === void 0 && (c = 512); let g = 'html'; if (s(u)) { const x = u; u = r(x, 'key'), v = r(x, 'url'), m = r(x, 'xhrSettings'), g = r(x, 'extension', g), p = r(x, 'width', p), c = r(x, 'height', c) } const y = { type: 'html', cache: l.textureManager, extension: g, responseType: 'text', key: u, url: v, xhrSettings: m, config: { width: p, height: c } }; n.call(this, l, y) },
          onProcess: function () {
            this.state = h.FILE_PROCESSING; const f = this.config.width; const l = this.config.height; const u = []; u.push('<svg width="' + f + 'px" height="' + l + 'px" viewBox="0 0 ' + f + ' ' + l + '" xmlns="http://www.w3.org/2000/svg">'), u.push('<foreignObject width="100%" height="100%">'), u.push('<body xmlns="http://www.w3.org/1999/xhtml">'), u.push(this.xhrLoader.responseText), u.push('</body>'), u.push('</foreignObject>'), u.push('</svg>'); const v = [u.join(`
`)]; const p = this; try { var c = new window.Blob(v, { type: 'image/svg+xml;charset=utf-8' }) } catch (m) { p.state = h.FILE_ERRORED, p.onProcessComplete(); return } this.data = new Image(), this.data.crossOrigin = this.crossOrigin, this.data.onload = function () { n.revokeObjectURL(p.data), p.onProcessComplete() }, this.data.onerror = function () { n.revokeObjectURL(p.data), p.onProcessError() }, n.createObjectURL(this.data, c, 'image/svg+xml')
          },
          addToCache: function () { const f = this.cache.addImage(this.key, this.data); this.pendingDestroy(f) }
        }); o.register('htmlTexture', function (f, l, u, v, p) { if (Array.isArray(f)) for (let c = 0; c < f.length; c++) this.addFile(new a(this, f[c])); else this.addFile(new a(this, f, l, u, v, p)); return this }), e.exports = a
      }, function (e, d, t) { const i = t(0); const h = t(8); const n = t(2); const o = t(71); const r = t(7); const s = t(61); const a = t(49); const f = new i({ Extends: a, initialize: function (u, v, p, c, m, g, x) { if (r(v)) { const y = v; v = n(y, 'key'), n(y, 'url', !1) ? p = n(y, 'url') : p = n(y, 'atlasURL'), g = n(y, 'xhrSettings'), c = n(y, 'path'), m = n(y, 'baseURL'), x = n(y, 'textureXhrSettings') } const T = new s(u, v, p, g); a.call(this, u, 'multiatlas', v, [T]), this.config.path = c, this.config.baseURL = m, this.config.textureXhrSettings = x }, onFileComplete: function (l) { const u = this.files.indexOf(l); if (u !== -1 && (this.pending--, l.type === 'json' && l.data.hasOwnProperty('textures'))) { const v = l.data.textures; const p = this.config; const c = this.loader; const m = c.baseURL; const g = c.path; const x = c.prefix; const y = n(p, 'baseURL', this.baseURL); const T = n(p, 'path', this.path); const S = n(p, 'prefix', this.prefix); const E = n(p, 'textureXhrSettings'); c.setBaseURL(y), c.setPath(T), c.setPrefix(S); for (let C = 0; C < v.length; C++) { const P = v[C].image; const A = 'MA' + this.multiKeyIndex + '_' + P; const M = new o(c, A, P, E); if (this.addToMultiFile(M), c.addFile(M), v[C].normalMap) { const L = new o(c, A, v[C].normalMap, E); L.type = 'normalMap', M.setLink(L), this.addToMultiFile(L), c.addFile(L) } }c.setBaseURL(m), c.setPath(g), c.setPrefix(x) } }, addToCache: function () { if (this.isReadyToProcess()) { for (var l = this.files[0], u = [], v = [], p = [], c = 1; c < this.files.length; c++) { const m = this.files[c]; if (m.type !== 'normalMap') for (let g = m.key.indexOf('_'), x = m.key.substr(g + 1), y = m.data, T = 0; T < l.data.textures.length; T++) { const S = l.data.textures[T]; if (S.image === x) { v.push(y), u.push(S), m.linkFile && p.push(m.linkFile.data); break } } } for (p.length === 0 && (p = void 0), this.loader.textureManager.addAtlasJSONArray(this.key, v, u, p), this.complete = !0, c = 0; c < this.files.length; c++) this.files[c].pendingDestroy() } } }); h.register('multiatlas', function (l, u, v, p, c) { let m; if (Array.isArray(l)) for (let g = 0; g < l.length; g++)m = new f(this, l[g]), this.addFile(m.files); else m = new f(this, l, u, v, p, c), this.addFile(m.files); return this }), e.exports = f }, function (e, d, t) { const i = t(0); const h = t(8); const n = t(2); const o = t(7); const r = t(49); const s = t(520); const a = new i({ Extends: r, initialize: function (l, u, v, p) { let c = 'js'; const m = []; if (o(u)) { const g = u; u = n(g, 'key'), v = n(g, 'url'), p = n(g, 'xhrSettings'), c = n(g, 'extension', c) }Array.isArray(v) || (v = [v]); for (let x = 0; x < v.length; x++) { const y = new s(l, { key: u + '_' + x.toString(), url: v[x], extension: c, xhrSettings: p }); y.onProcess = function () { this.onProcessComplete() }, m.push(y) }r.call(this, l, 'scripts', u, m) }, addToCache: function () { if (this.isReadyToProcess()) { for (let f = 0; f < this.files.length; f++) { const l = this.files[f]; l.data = document.createElement('script'), l.data.language = 'javascript', l.data.type = 'text/javascript', l.data.defer = !1, l.data.text = l.xhrLoader.responseText, document.head.appendChild(l.data) } this.complete = !0 } } }); h.register('scripts', function (f, l, u) { let v; if (Array.isArray(f)) for (let p = 0; p < f.length; p++)v = new a(this, f[p]), this.addFile(v.files); else v = new a(this, f, l, u), this.addFile(v.files); return this }), e.exports = a }, function (e, d, t) { const i = t(0); const h = t(8); const n = t(2); const o = t(7); const r = t(49); const s = t(498); const a = t(499); const f = t(242); const l = new i({ Extends: r, initialize: function (v, p, c, m, g, x) { let y; let T; const S = v.cacheManager.obj; if (o(p)) { const E = p; p = n(E, 'key'), y = new f(v, { key: p, type: 'obj', cache: S, url: n(E, 'url'), extension: n(E, 'extension', 'obj'), xhrSettings: n(E, 'xhrSettings'), config: { flipUV: n(E, 'flipUV', g) } }), m = n(E, 'matURL'), m && (T = new f(v, { key: p, type: 'mat', cache: S, url: m, extension: n(E, 'matExtension', 'mat'), xhrSettings: n(E, 'xhrSettings') })) } else y = new f(v, { key: p, url: c, type: 'obj', cache: S, extension: 'obj', xhrSettings: x, config: { flipUV: g } }), m && (T = new f(v, { key: p, url: m, type: 'mat', cache: S, extension: 'mat', xhrSettings: x })); r.call(this, v, 'obj', p, [y, T]) }, addToCache: function () { if (this.isReadyToProcess()) { const u = this.files[0]; const v = this.files[1]; const p = s(u.data, u.config.flipUV); v && (p.materials = a(v.data)), u.cache.add(u.key, p), this.complete = !0 } } }); h.register('obj', function (u, v, p, c, m) { let g; if (Array.isArray(u)) for (let x = 0; x < u.length; x++)g = new l(this, u[x]), this.addFile(g.files); else g = new l(this, u, v, p, c, m), this.addFile(g.files); return this }), e.exports = l }, function (e, d, t) { const i = t(0); const h = t(21); const n = t(8); const o = t(61); const r = new i({ Extends: o, initialize: function (a, f, l, u, v) { o.call(this, a, f, l, u, v), this.type = 'packfile' }, onProcess: function () { this.state !== h.FILE_POPULATED && (this.state = h.FILE_PROCESSING, this.data = JSON.parse(this.xhrLoader.responseText)), this.loader.addPack(this.data, this.config), this.onProcessComplete() } }); n.register('pack', function (s, a, f, l) { if (Array.isArray(s)) for (let u = 0; u < s.length; u++) this.addFile(new r(this, s[u])); else this.addFile(new r(this, s, a, l, f)); return this }), e.exports = r }, function (e, d, t) { const i = t(0); const h = t(21); const n = t(23); const o = t(8); const r = t(2); const s = t(7); const a = new i({ Extends: n, initialize: function (l, u, v, p, c, m) { let g = 'js'; if (s(u)) { const x = u; u = r(x, 'key'), v = r(x, 'url'), m = r(x, 'xhrSettings'), g = r(x, 'extension', g), p = r(x, 'start'), c = r(x, 'mapping') } const y = { type: 'plugin', cache: !1, extension: g, responseType: 'text', key: u, url: v, xhrSettings: m, config: { start: p, mapping: c } }; n.call(this, l, y), typeof v === 'function' && (this.data = v, this.state = h.FILE_POPULATED) }, onProcess: function () { const f = this.loader.systems.plugins; const l = this.config; const u = r(l, 'start', !1); const v = r(l, 'mapping', null); if (this.state === h.FILE_POPULATED)f.install(this.key, this.data, u, v); else { this.state = h.FILE_PROCESSING, this.data = document.createElement('script'), this.data.language = 'javascript', this.data.type = 'text/javascript', this.data.defer = !1, this.data.text = this.xhrLoader.responseText, document.head.appendChild(this.data); const p = f.install(this.key, window[this.key], u, v); (u || v) && (this.loader.systems[v] = p, this.loader.scene[v] = p) } this.onProcessComplete() } }); o.register('plugin', function (f, l, u, v, p) { if (Array.isArray(f)) for (let c = 0; c < f.length; c++) this.addFile(new a(this, f[c])); else this.addFile(new a(this, f, l, u, v, p)); return this }), e.exports = a }, function (e, d, t) {
        const i = t(0); const h = t(21); const n = t(23); const o = t(8); const r = t(2); const s = t(7); const a = new i({
          Extends: n,
          initialize: function (l, u, v, p) { let c = 'js'; if (s(u)) { const m = u; u = r(m, 'key'), v = r(m, 'url'), p = r(m, 'xhrSettings'), c = r(m, 'extension', c) } const g = { type: 'text', extension: c, responseType: 'text', key: u, url: v, xhrSettings: p }; n.call(this, l, g) },
          onProcess: function () { this.state = h.FILE_PROCESSING, this.data = this.xhrLoader.responseText, this.onProcessComplete() },
          addToCache: function () {
            const f = this.data.concat(`(function(){
return new ` + this.key + `();
}).call(this);`); const l = eval; this.loader.sceneManager.add(this.key, l(f)), this.complete = !0
          }
        }); o.register('sceneFile', function (f, l, u) { if (Array.isArray(f)) for (let v = 0; v < f.length; v++) this.addFile(new a(this, f[v])); else this.addFile(new a(this, f, l, u)); return this }), e.exports = a
      }, function (e, d, t) { const i = t(0); const h = t(21); const n = t(23); const o = t(8); const r = t(2); const s = t(7); const a = new i({ Extends: n, initialize: function (l, u, v, p, c, m) { let g = 'js'; if (s(u)) { const x = u; u = r(x, 'key'), v = r(x, 'url'), m = r(x, 'xhrSettings'), g = r(x, 'extension', g), p = r(x, 'systemKey'), c = r(x, 'sceneKey') } const y = { type: 'scenePlugin', cache: !1, extension: g, responseType: 'text', key: u, url: v, xhrSettings: m, config: { systemKey: p, sceneKey: c } }; n.call(this, l, y), typeof v === 'function' && (this.data = v, this.state = h.FILE_POPULATED) }, onProcess: function () { const f = this.loader.systems.plugins; const l = this.config; const u = this.key; const v = r(l, 'systemKey', u); const p = r(l, 'sceneKey', u); this.state === h.FILE_POPULATED ? f.installScenePlugin(v, this.data, p, this.loader.scene, !0) : (this.state = h.FILE_PROCESSING, this.data = document.createElement('script'), this.data.language = 'javascript', this.data.type = 'text/javascript', this.data.defer = !1, this.data.text = this.xhrLoader.responseText, document.head.appendChild(this.data), f.installScenePlugin(v, window[this.key], p, this.loader.scene, !0)), this.onProcessComplete() } }); o.register('scenePlugin', function (f, l, u, v, p) { if (Array.isArray(f)) for (let c = 0; c < f.length; c++) this.addFile(new a(this, f[c])); else this.addFile(new a(this, f, l, u, v, p)); return this }), e.exports = a }, function (e, d, t) { const i = t(0); const h = t(8); const n = t(71); const o = new i({ Extends: n, initialize: function (s, a, f, l, u) { n.call(this, s, a, f, u, l), this.type = 'spritesheet' }, addToCache: function () { const r = this.cache.addSpriteSheet(this.key, this.data, this.config); this.pendingDestroy(r) } }); h.register('spritesheet', function (r, s, a, f) { if (Array.isArray(r)) for (let l = 0; l < r.length; l++) this.addFile(new o(this, r[l])); else this.addFile(new o(this, r, s, a, f)); return this }), e.exports = o }, function (e, d, t) { const i = t(0); const h = t(21); const n = t(23); const o = t(8); const r = t(2); const s = t(7); const a = new i({ Extends: n, initialize: function (l, u, v, p, c) { let m = 'svg'; if (s(u)) { const g = u; u = r(g, 'key'), v = r(g, 'url'), p = r(g, 'svgConfig', {}), c = r(g, 'xhrSettings'), m = r(g, 'extension', m) } const x = { type: 'svg', cache: l.textureManager, extension: m, responseType: 'text', key: u, url: v, xhrSettings: c, config: { width: r(p, 'width'), height: r(p, 'height'), scale: r(p, 'scale') } }; n.call(this, l, x) }, onProcess: function () { this.state = h.FILE_PROCESSING; const f = this.xhrLoader.responseText; let l = [f]; let u = this.config.width; let v = this.config.height; const p = this.config.scale; t:if (u && v || p) { let c = null; const m = new DOMParser(); c = m.parseFromString(f, 'text/xml'); const g = c.getElementsByTagName('svg')[0]; const x = g.hasAttribute('viewBox'); let y = parseFloat(g.getAttribute('width')); let T = parseFloat(g.getAttribute('height')); if (!x && y && T)g.setAttribute('viewBox', '0  0 ' + y + ' ' + T); else if (x && !y && !T) { const S = g.getAttribute('viewBox').split(/\s+|,/); y = S[2], T = S[3] } if (p) if (y && T)u = y * p, v = T * p; else break t; g.setAttribute('width', u.toString() + 'px'), g.setAttribute('height', v.toString() + 'px'), l = [new XMLSerializer().serializeToString(g)] } try { var E = new window.Blob(l, { type: 'image/svg+xml;charset=utf-8' }) } catch (A) { this.onProcessError(); return } this.data = new Image(), this.data.crossOrigin = this.crossOrigin; const C = this; let P = !1; this.data.onload = function () { P || n.revokeObjectURL(C.data), C.onProcessComplete() }, this.data.onerror = function () { P ? C.onProcessError() : (P = !0, n.revokeObjectURL(C.data), C.data.src = 'data:image/svg+xml,' + encodeURIComponent(l.join(''))) }, n.createObjectURL(this.data, E, 'image/svg+xml') }, addToCache: function () { const f = this.cache.addImage(this.key, this.data); this.pendingDestroy(f) } }); o.register('svg', function (f, l, u, v) { if (Array.isArray(f)) for (let p = 0; p < f.length; p++) this.addFile(new a(this, f[p])); else this.addFile(new a(this, f, l, u, v)); return this }), e.exports = a }, function (e, d, t) { const i = t(0); const h = t(21); const n = t(23); const o = t(8); const r = t(2); const s = t(7); const a = t(40); const f = new i({ Extends: n, initialize: function (u, v, p, c) { let m = 'csv'; if (s(v)) { const g = v; v = r(g, 'key'), p = r(g, 'url'), c = r(g, 'xhrSettings'), m = r(g, 'extension', m) } const x = { type: 'tilemapCSV', cache: u.cacheManager.tilemap, extension: m, responseType: 'text', key: v, url: p, xhrSettings: c }; n.call(this, u, x), this.tilemapFormat = a.CSV }, onProcess: function () { this.state = h.FILE_PROCESSING, this.data = this.xhrLoader.responseText, this.onProcessComplete() }, addToCache: function () { const l = { format: this.tilemapFormat, data: this.data }; this.cache.add(this.key, l), this.pendingDestroy(l) } }); o.register('tilemapCSV', function (l, u, v) { if (Array.isArray(l)) for (let p = 0; p < l.length; p++) this.addFile(new f(this, l[p])); else this.addFile(new f(this, l, u, v)); return this }), e.exports = f }, function (e, d, t) { const i = t(0); const h = t(8); const n = t(61); const o = t(40); const r = new i({ Extends: n, initialize: function (a, f, l, u) { n.call(this, a, f, l, u), this.type = 'tilemapJSON', this.cache = a.cacheManager.tilemap }, addToCache: function () { const s = { format: o.WELTMEISTER, data: this.data }; this.cache.add(this.key, s), this.pendingDestroy(s) } }); h.register('tilemapImpact', function (s, a, f) { if (Array.isArray(s)) for (let l = 0; l < s.length; l++) this.addFile(new r(this, s[l])); else this.addFile(new r(this, s, a, f)); return this }), e.exports = r }, function (e, d, t) { const i = t(0); const h = t(8); const n = t(61); const o = t(40); const r = new i({ Extends: n, initialize: function (a, f, l, u) { n.call(this, a, f, l, u), this.type = 'tilemapJSON', this.cache = a.cacheManager.tilemap }, addToCache: function () { const s = { format: o.TILED_JSON, data: this.data }; this.cache.add(this.key, s), this.pendingDestroy(s) } }); h.register('tilemapTiledJSON', function (s, a, f) { if (Array.isArray(s)) for (let l = 0; l < s.length; l++) this.addFile(new r(this, s[l])); else this.addFile(new r(this, s, a, f)); return this }), e.exports = r }, function (e, d, t) { const i = t(0); const h = t(8); const n = t(2); const o = t(71); const r = t(7); const s = t(49); const a = t(242); const f = new i({ Extends: s, initialize: function (u, v, p, c, m, g) { let x, y; if (r(v)) { const T = v; v = n(T, 'key'), x = new o(u, { key: v, url: n(T, 'textureURL'), extension: n(T, 'textureExtension', 'png'), normalMap: n(T, 'normalMap'), xhrSettings: n(T, 'textureXhrSettings') }), y = new a(u, { key: v, url: n(T, 'atlasURL'), extension: n(T, 'atlasExtension', 'txt'), xhrSettings: n(T, 'atlasXhrSettings') }) } else x = new o(u, v, p, m), y = new a(u, v, c, g); x.linkFile ? s.call(this, u, 'unityatlas', v, [x, y, x.linkFile]) : s.call(this, u, 'unityatlas', v, [x, y]) }, addToCache: function () { if (this.isReadyToProcess()) { const l = this.files[0]; const u = this.files[1]; const v = this.files[2] ? this.files[2].data : null; this.loader.textureManager.addUnityAtlas(l.key, l.data, u.data, v), u.pendingDestroy(), this.complete = !0 } } }); h.register('unityAtlas', function (l, u, v, p, c) { let m; if (Array.isArray(l)) for (let g = 0; g < l.length; g++)m = new f(this, l[g]), this.addFile(m.files); else m = new f(this, l, u, v, p, c), this.addFile(m.files); return this }), e.exports = f }, function (e, d, t) { const i = t(0); const h = t(21); const n = t(23); const o = t(8); const r = t(155); const s = t(2); const a = t(7); const f = new i({ Extends: n, initialize: function (u, v, p, c, m, g, x) { c === void 0 && (c = 'loadeddata'), m === void 0 && (m = !1), g === void 0 && (g = !1), c !== 'loadeddata' && c !== 'canplay' && c !== 'canplaythrough' && (c = 'loadeddata'); const y = { type: 'video', cache: u.cacheManager.video, extension: p.type, responseType: 'blob', key: v, url: p.url, xhrSettings: x, config: { loadEvent: c, asBlob: m, noAudio: g } }; this.onLoadCallback = this.onVideoLoadHandler.bind(this), this.onErrorCallback = this.onVideoErrorHandler.bind(this), n.call(this, u, y) }, onProcess: function () { if (this.state = h.FILE_PROCESSING, !this.config.asBlob) { this.onProcessComplete(); return } const l = this.createVideoElement(); this.data = l; const u = this; this.data.onloadeddata = function () { u.onProcessComplete() }, this.data.onerror = function () { n.revokeObjectURL(u.data), u.onProcessError() }, n.createObjectURL(l, this.xhrLoader.response, ''), l.load() }, createVideoElement: function () { const l = document.createElement('video'); return l.controls = !1, l.crossOrigin = this.loader.crossOrigin, this.config.noAudio && (l.muted = !0, l.defaultMuted = !0, l.setAttribute('autoplay', 'autoplay')), l.setAttribute('playsinline', 'playsinline'), l.setAttribute('preload', 'auto'), l }, onVideoLoadHandler: function (l) { const u = l.target; u.removeEventListener(this.config.loadEvent, this.onLoadCallback, !0), u.removeEventListener('error', this.onErrorCallback, !0), this.data = u, this.resetXHR(), this.loader.nextFile(this, !0) }, onVideoErrorHandler: function (l) { const u = l.target; u && (u.removeEventListener(this.config.loadEvent, this.onLoadCallback, !0), u.removeEventListener('error', this.onErrorCallback, !0)), this.resetXHR(), this.loader.nextFile(this, !1) }, load: function () { const l = this.config.loadEvent; if (this.config.asBlob)n.prototype.load.call(this); else { this.percentComplete = 0; const u = this.createVideoElement(); u.addEventListener(l, this.onLoadCallback, !0), u.addEventListener('error', this.onErrorCallback, !0), u.src = r(this, this.loader.baseURL), u.load() } } }); f.create = function (l, u, v, p, c, m, g) { const x = l.systems.game; a(u) && (v = s(u, 'url', []), p = s(u, 'loadEvent', 'loadeddata'), c = s(u, 'asBlob', !1), m = s(u, 'noAudio', !1), g = s(u, 'xhrSettings'), u = s(u, 'key')); const y = f.getVideoURL(x, v); if (y) return new f(l, u, y, p, c, m, g) }, f.getVideoURL = function (l, u) { Array.isArray(u) || (u = [u]); for (let v = 0; v < u.length; v++) { const p = s(u[v], 'url', u[v]); if (p.indexOf('blob:') === 0) return { url: p, type: '' }; var c; if (p.indexOf('data:') === 0 ? c = p.split(',')[0].match(/\/(.*?);/) : c = p.match(/\.([a-zA-Z0-9]+)($|\?)/), c = s(u[v], 'type', c ? c[1] : '').toLowerCase(), l.device.video[c]) return { url: p, type: c } } return null }, o.register('video', function (l, u, v, p, c, m) { let g; if (Array.isArray(l)) for (let x = 0; x < l.length; x++)g = f.create(this, l[x]), g && this.addFile(g); else g = f.create(this, l, u, v, p, c, m), g && this.addFile(g); return this }), e.exports = f }, function (e, d, t) { const i = t(0); const h = t(21); const n = t(149); const o = t(9); const r = t(95); const s = t(8); const a = t(2); const f = t(24); const l = t(20); const u = t(156); const v = new i({ Extends: o, initialize: function (c) { o.call(this); const m = c.sys.game.config; const g = c.sys.settings.loader; this.scene = c, this.systems = c.sys, this.cacheManager = c.sys.cache, this.textureManager = c.sys.textures, this.sceneManager = c.sys.game.scene, s.install(this), this.prefix = '', this.path = '', this.baseURL = '', this.setBaseURL(a(g, 'baseURL', m.loaderBaseURL)), this.setPath(a(g, 'path', m.loaderPath)), this.setPrefix(a(g, 'prefix', m.loaderPrefix)), this.maxParallelDownloads = a(g, 'maxParallelDownloads', m.loaderMaxParallelDownloads), this.xhr = u(a(g, 'responseType', m.loaderResponseType), a(g, 'async', m.loaderAsync), a(g, 'user', m.loaderUser), a(g, 'password', m.loaderPassword), a(g, 'timeout', m.loaderTimeout), a(g, 'withCredentials', m.loaderWithCredentials)), this.crossOrigin = a(g, 'crossOrigin', m.loaderCrossOrigin), this.totalToLoad = 0, this.progress = 0, this.list = new n(), this.inflight = new n(), this.queue = new n(), this._deleteQueue = new n(), this.totalFailed = 0, this.totalComplete = 0, this.state = h.LOADER_IDLE, this.multiKeyIndex = 0, c.sys.events.once(l.BOOT, this.boot, this), c.sys.events.on(l.START, this.pluginStart, this) }, boot: function () { this.systems.events.once(l.DESTROY, this.destroy, this) }, pluginStart: function () { this.systems.events.once(l.SHUTDOWN, this.shutdown, this) }, setBaseURL: function (p) { return p === void 0 && (p = ''), p !== '' && p.substr(-1) !== '/' && (p = p.concat('/')), this.baseURL = p, this }, setPath: function (p) { return p === void 0 && (p = ''), p !== '' && p.substr(-1) !== '/' && (p = p.concat('/')), this.path = p, this }, setPrefix: function (p) { return p === void 0 && (p = ''), this.prefix = p, this }, setCORS: function (p) { return this.crossOrigin = p, this }, addFile: function (p) { Array.isArray(p) || (p = [p]); for (let c = 0; c < p.length; c++) { const m = p[c]; this.keyExists(m) || (this.list.set(m), this.emit(r.ADD, m.key, m.type, this, m), this.isLoading() && (this.totalToLoad++, this.updateProgress())) } }, keyExists: function (p) { let c = p.hasCacheConflict(); return c || this.list.iterate(function (m) { if (m.type === p.type && m.key === p.key) return c = !0, !1 }), !c && this.isLoading() && (this.inflight.iterate(function (m) { if (m.type === p.type && m.key === p.key) return c = !0, !1 }), this.queue.iterate(function (m) { if (m.type === p.type && m.key === p.key) return c = !0, !1 })), c }, addPack: function (p, c) { c && p.hasOwnProperty(c) && (p = { packKey: p[c] }); let m = 0; const g = this.baseURL; const x = this.path; const y = this.prefix; for (const T in p) if (Object.prototype.hasOwnProperty.call(p, T)) { const S = p[T]; const E = a(S, 'baseURL', g); const C = a(S, 'path', x); const P = a(S, 'prefix', y); const A = a(S, 'files', null); const M = a(S, 'defaultType', 'void'); if (Array.isArray(A)) { this.setBaseURL(E), this.setPath(C), this.setPrefix(P); for (let L = 0; L < A.length; L++) { const F = A[L]; const I = F.hasOwnProperty('type') ? F.type : M; this[I] && (this[I](F), m++) } } } return this.setBaseURL(g), this.setPath(x), this.setPrefix(y), m > 0 }, isLoading: function () { return this.state === h.LOADER_LOADING || this.state === h.LOADER_PROCESSING }, isReady: function () { return this.state === h.LOADER_IDLE || this.state === h.LOADER_COMPLETE }, start: function () { !this.isReady() || (this.progress = 0, this.totalFailed = 0, this.totalComplete = 0, this.totalToLoad = this.list.size, this.emit(r.START, this), this.list.size === 0 ? this.loadComplete() : (this.state = h.LOADER_LOADING, this.inflight.clear(), this.queue.clear(), this.updateProgress(), this.checkLoadQueue(), this.systems.events.on(l.UPDATE, this.update, this))) }, updateProgress: function () { this.progress = 1 - (this.list.size + this.inflight.size) / this.totalToLoad, this.emit(r.PROGRESS, this.progress) }, update: function () { this.state === h.LOADER_LOADING && this.list.size > 0 && this.inflight.size < this.maxParallelDownloads && this.checkLoadQueue() }, checkLoadQueue: function () { this.list.each(function (p) { if ((p.state === h.FILE_POPULATED || p.state === h.FILE_PENDING && this.inflight.size < this.maxParallelDownloads) && (this.inflight.set(p), this.list.delete(p), p.crossOrigin || (p.crossOrigin = this.crossOrigin), p.load()), this.inflight.size === this.maxParallelDownloads) return !1 }, this) }, nextFile: function (p, c) { !this.inflight || (this.inflight.delete(p), this.updateProgress(), c ? (this.totalComplete++, this.queue.set(p), this.emit(r.FILE_LOAD, p), p.onProcess()) : (this.totalFailed++, this._deleteQueue.set(p), this.emit(r.FILE_LOAD_ERROR, p), this.fileProcessComplete(p))) }, fileProcessComplete: function (p) { !this.scene || !this.systems || !this.systems.game || this.systems.game.pendingDestroy || (p.state === h.FILE_ERRORED ? p.multiFile && p.multiFile.onFileFailed(p) : p.state === h.FILE_COMPLETE && (p.multiFile ? p.multiFile.isReadyToProcess() && p.multiFile.addToCache() : p.addToCache()), this.queue.delete(p), this.list.size === 0 && this.inflight.size === 0 && this.queue.size === 0 && this.loadComplete()) }, loadComplete: function () { this.emit(r.POST_PROCESS, this), this.list.clear(), this.inflight.clear(), this.queue.clear(), this.progress = 1, this.state = h.LOADER_COMPLETE, this.systems.events.off(l.UPDATE, this.update, this), this._deleteQueue.iterateLocal('destroy'), this._deleteQueue.clear(), this.emit(r.COMPLETE, this, this.totalComplete, this.totalFailed) }, flagForRemoval: function (p) { this._deleteQueue.set(p) }, saveJSON: function (p, c) { return this.save(JSON.stringify(p), c) }, save: function (p, c, m) { c === void 0 && (c = 'file.json'), m === void 0 && (m = 'application/json'); const g = new Blob([p], { type: m }); const x = URL.createObjectURL(g); const y = document.createElement('a'); return y.download = c, y.textContent = 'Download ' + c, y.href = x, y.click(), this }, reset: function () { this.list.clear(), this.inflight.clear(), this.queue.clear(); const p = this.systems.game.config; const c = this.systems.settings.loader; this.setBaseURL(a(c, 'baseURL', p.loaderBaseURL)), this.setPath(a(c, 'path', p.loaderPath)), this.setPrefix(a(c, 'prefix', p.loaderPrefix)), this.state = h.LOADER_IDLE }, shutdown: function () { this.reset(), this.state = h.LOADER_SHUTDOWN, this.systems.events.off(l.UPDATE, this.update, this), this.systems.events.off(l.SHUTDOWN, this.shutdown, this) }, destroy: function () { this.shutdown(), this.state = h.LOADER_DESTROYED, this.systems.events.off(l.UPDATE, this.update, this), this.systems.events.off(l.START, this.pluginStart, this), this.list = null, this.inflight = null, this.queue = null, this.scene = null, this.systems = null, this.textureManager = null, this.cacheManager = null, this.sceneManager = null } }); f.register('Loader', v, 'load'), e.exports = v }, function (e, d, t) { const i = t(62); const h = t(17); let n = { ArcadePhysics: t(1367), Body: t(527), Collider: t(528), Components: t(243), Events: t(245), Factory: t(521), GetOverlapX: t(246), GetOverlapY: t(247), SeparateX: t(537), SeparateY: t(538), Group: t(524), Image: t(522), Sprite: t(157), StaticBody: t(539), StaticGroup: t(525), Tilemap: t(1391), World: t(526) }; n = h(!1, n, i), e.exports = n }, function (e, d, t) { const i = t(0); const h = t(36); const n = t(50); const o = t(353); const r = t(521); const s = t(2); const a = t(127); const f = t(523); const l = t(244); const u = t(24); const v = t(20); const p = t(3); const c = t(526); const m = new i({ initialize: function (x) { this.scene = x, this.systems = x.sys, this.config = this.getConfig(), this.world, this.add, x.sys.events.once(v.BOOT, this.boot, this), x.sys.events.on(v.START, this.start, this) }, boot: function () { this.world = new c(this.scene, this.config), this.add = new r(this.world), this.systems.events.once(v.DESTROY, this.destroy, this) }, start: function () { this.world || (this.world = new c(this.scene, this.config), this.add = new r(this.world)); const g = this.systems.events; s(this.config, 'customUpdate', !1) || g.on(v.UPDATE, this.world.update, this.world), g.on(v.POST_UPDATE, this.world.postUpdate, this.world), g.once(v.SHUTDOWN, this.shutdown, this) }, enableUpdate: function () { this.systems.events.on(v.UPDATE, this.world.update, this.world) }, disableUpdate: function () { this.systems.events.off(v.UPDATE, this.world.update, this.world) }, getConfig: function () { const g = this.systems.game.config.physics; const x = this.systems.settings.physics; const y = a(s(x, 'arcade', {}), s(g, 'arcade', {})); return y }, overlap: function (g, x, y, T, S) { return y === void 0 && (y = null), T === void 0 && (T = null), S === void 0 && (S = y), this.world.collideObjects(g, x, y, T, S, !0) }, collide: function (g, x, y, T, S) { return y === void 0 && (y = null), T === void 0 && (T = null), S === void 0 && (S = y), this.world.collideObjects(g, x, y, T, S, !1) }, collideTiles: function (g, x, y, T, S) { return this.world.collideTiles(g, x, y, T, S) }, overlapTiles: function (g, x, y, T, S) { return this.world.overlapTiles(g, x, y, T, S) }, pause: function () { return this.world.pause() }, resume: function () { return this.world.resume() }, accelerateTo: function (g, x, y, T, S, E) { T === void 0 && (T = 60); const C = Math.atan2(y - g.y, x - g.x); return g.body.acceleration.setToPolar(C, T), S !== void 0 && E !== void 0 && g.body.maxVelocity.set(S, E), C }, accelerateToObject: function (g, x, y, T, S) { return this.accelerateTo(g, x.x, x.y, y, T, S) }, closest: function (g, x) { x || (x = this.world.bodies.entries); for (var y = Number.MAX_VALUE, T = null, S = g.x, E = g.y, C = x.length, P = 0; P < C; P++) { const A = x[P]; const M = A.body || A; if (!(g === A || g === M || g === M.gameObject || g === M.center)) { const L = o(S, E, M.center.x, M.center.y); L < y && (T = A, y = L) } } return T }, furthest: function (g, x) { x || (x = this.world.bodies.entries); for (var y = -1, T = null, S = g.x, E = g.y, C = x.length, P = 0; P < C; P++) { const A = x[P]; const M = A.body || A; if (!(g === A || g === M || g === M.gameObject || g === M.center)) { const L = o(S, E, M.center.x, M.center.y); L > y && (T = A, y = L) } } return T }, moveTo: function (g, x, y, T, S) { T === void 0 && (T = 60), S === void 0 && (S = 0); const E = Math.atan2(y - g.y, x - g.x); return S > 0 && (T = n(g.x, g.y, x, y) / (S / 1e3)), g.body.velocity.setToPolar(E, T), E }, moveToObject: function (g, x, y, T) { return this.moveTo(g, x.x, x.y, y, T) }, velocityFromAngle: function (g, x, y) { return x === void 0 && (x = 60), y === void 0 && (y = new p()), y.setToPolar(h(g), x) }, velocityFromRotation: function (g, x, y) { return x === void 0 && (x = 60), y === void 0 && (y = new p()), y.setToPolar(g, x) }, overlapRect: function (g, x, y, T, S, E) { return l(this.world, g, x, y, T, S, E) }, overlapCirc: function (g, x, y, T, S) { return f(this.world, g, x, y, T, S) }, shutdown: function () { if (this.world) { const g = this.systems.events; g.off(v.UPDATE, this.world.update, this.world), g.off(v.POST_UPDATE, this.world.postUpdate, this.world), g.off(v.SHUTDOWN, this.shutdown, this), this.add.destroy(), this.world.destroy(), this.add = null, this.world = null } }, destroy: function () { this.shutdown(), this.scene.sys.events.off(v.START, this.start, this), this.scene = null, this.systems = null } }); u.register('ArcadePhysics', m, 'arcadePhysics'), e.exports = m }, function (e, d) { const t = { setAcceleration: function (i, h) { return this.body.acceleration.set(i, h), this }, setAccelerationX: function (i) { return this.body.acceleration.x = i, this }, setAccelerationY: function (i) { return this.body.acceleration.y = i, this } }; e.exports = t }, function (e, d) { const t = { setAngularVelocity: function (i) { return this.body.angularVelocity = i, this }, setAngularAcceleration: function (i) { return this.body.angularAcceleration = i, this }, setAngularDrag: function (i) { return this.body.angularDrag = i, this } }; e.exports = t }, function (e, d) { const t = { setBounce: function (i, h) { return this.body.bounce.set(i, h), this }, setBounceX: function (i) { return this.body.bounce.x = i, this }, setBounceY: function (i) { return this.body.bounce.y = i, this }, setCollideWorldBounds: function (i, h, n) { return this.body.setCollideWorldBounds(i, h, n), this } }; e.exports = t }, function (e, d) { const t = { setDebug: function (i, h, n) { return this.debugShowBody = i, this.debugShowVelocity = h, this.debugBodyColor = n, this }, setDebugBodyColor: function (i) { return this.body.debugBodyColor = i, this }, debugShowBody: { get: function () { return this.body.debugShowBody }, set: function (i) { this.body.debugShowBody = i } }, debugShowVelocity: { get: function () { return this.body.debugShowVelocity }, set: function (i) { this.body.debugShowVelocity = i } }, debugBodyColor: { get: function () { return this.body.debugBodyColor }, set: function (i) { this.body.debugBodyColor = i } } }; e.exports = t }, function (e, d) { const t = { setDrag: function (i, h) { return this.body.drag.set(i, h), this }, setDragX: function (i) { return this.body.drag.x = i, this }, setDragY: function (i) { return this.body.drag.y = i, this }, setDamping: function (i) { return this.body.useDamping = i, this } }; e.exports = t }, function (e, d) { const t = { enableBody: function (i, h, n, o, r) { return i && this.body.reset(h, n), o && (this.body.gameObject.active = !0), r && (this.body.gameObject.visible = !0), this.body.enable = !0, this }, disableBody: function (i, h) { return i === void 0 && (i = !1), h === void 0 && (h = !1), this.body.stop(), this.body.enable = !1, i && (this.body.gameObject.active = !1), h && (this.body.gameObject.visible = !1), this }, refreshBody: function () { return this.body.updateFromGameObject(), this } }; e.exports = t }, function (e, d) { const t = { setFriction: function (i, h) { return this.body.friction.set(i, h), this }, setFrictionX: function (i) { return this.body.friction.x = i, this }, setFrictionY: function (i) { return this.body.friction.y = i, this } }; e.exports = t }, function (e, d) { const t = { setGravity: function (i, h) { return this.body.gravity.set(i, h), this }, setGravityX: function (i) { return this.body.gravity.x = i, this }, setGravityY: function (i) { return this.body.gravity.y = i, this } }; e.exports = t }, function (e, d) { const t = { setImmovable: function (i) { return i === void 0 && (i = !0), this.body.immovable = i, this } }; e.exports = t }, function (e, d) { const t = { setMass: function (i) { return this.body.mass = i, this } }; e.exports = t }, function (e, d) { const t = { setPushable: function (i) { return i === void 0 && (i = !0), this.body.pushable = i, this } }; e.exports = t }, function (e, d) { const t = { setOffset: function (i, h) { return this.body.setOffset(i, h), this }, setSize: function (i, h, n) { return this.body.setSize(i, h, n), this }, setBodySize: function (i, h, n) { return this.body.setSize(i, h, n), this }, setCircle: function (i, h, n) { return this.body.setCircle(i, h, n), this } }; e.exports = t }, function (e, d) { const t = { setVelocity: function (i, h) { return this.body.setVelocity(i, h), this }, setVelocityX: function (i) { return this.body.setVelocityX(i), this }, setVelocityY: function (i) { return this.body.setVelocityY(i), this }, setMaxVelocity: function (i, h) { return this.body.maxVelocity.set(i, h), this } }; e.exports = t }, function (e, d) { e.exports = 'collide' }, function (e, d) { e.exports = 'overlap' }, function (e, d) { e.exports = 'pause' }, function (e, d) { e.exports = 'resume' }, function (e, d) { e.exports = 'tilecollide' }, function (e, d) { e.exports = 'tileoverlap' }, function (e, d) { e.exports = 'worldbounds' }, function (e, d) { e.exports = 'worldstep' }, function (e, d) { let t; let i; let h; let n; let o; let r; let s; let a; let f; let l; let u; let v; let p; let c; let m; let g; let x; const y = function (A, M, L) { t = A, i = M; const F = t.velocity.x; const I = i.velocity.x; return h = t.pushable, f = t._dx < 0, l = t._dx > 0, u = t._dx === 0, m = Math.abs(t.right - i.x) <= Math.abs(i.right - t.x), s = I - F * t.bounce.x, n = i.pushable, v = i._dx < 0, p = i._dx > 0, c = i._dx === 0, g = !m, a = F - I * i.bounce.x, x = Math.abs(L), T() }; var T = function () { return l && m && i.blocked.right ? (t.processX(-x, s, !1, !0), 1) : f && g && i.blocked.left ? (t.processX(x, s, !0), 1) : p && g && t.blocked.right ? (i.processX(-x, a, !1, !0), 2) : v && m && t.blocked.left ? (i.processX(x, a, !0), 2) : 0 }; const S = function () { const A = t.velocity.x; const M = i.velocity.x; let L = Math.sqrt(M * M * i.mass / t.mass) * (M > 0 ? 1 : -1); let F = Math.sqrt(A * A * t.mass / i.mass) * (A > 0 ? 1 : -1); const I = (L + F) * 0.5; return L -= I, F -= I, o = I + L * t.bounce.x, r = I + F * i.bounce.x, f && g ? E(0) : v && m ? E(1) : l && m ? E(2) : p && g ? E(3) : !1 }; var E = function (A) { if (h && n)x *= 0.5, A === 0 || A === 3 ? (t.processX(x, o), i.processX(-x, r)) : (t.processX(-x, o), i.processX(x, r)); else if (h && !n)A === 0 || A === 3 ? t.processX(x, s, !0) : t.processX(-x, s, !1, !0); else if (!h && n)A === 0 || A === 3 ? i.processX(-x, a, !1, !0) : i.processX(x, a, !0); else { const M = x * 0.5; A === 0 ? c ? (t.processX(x, 0, !0), i.processX(0, null, !1, !0)) : p ? (t.processX(M, 0, !0), i.processX(-M, 0, !1, !0)) : (t.processX(M, i.velocity.x, !0), i.processX(-M, null, !1, !0)) : A === 1 ? u ? (t.processX(0, null, !1, !0), i.processX(x, 0, !0)) : l ? (t.processX(-M, 0, !1, !0), i.processX(M, 0, !0)) : (t.processX(-M, null, !1, !0), i.processX(M, t.velocity.x, !0)) : A === 2 ? c ? (t.processX(-x, 0, !1, !0), i.processX(0, null, !0)) : v ? (t.processX(-M, 0, !1, !0), i.processX(M, 0, !0)) : (t.processX(-M, i.velocity.x, !1, !0), i.processX(M, null, !0)) : A === 3 && (u ? (t.processX(0, null, !0), i.processX(-x, 0, !1, !0)) : f ? (t.processX(M, 0, !0), i.processX(-M, 0, !1, !0)) : (t.processX(M, i.velocity.y, !0), i.processX(-M, null, !1, !0))) } return !0 }; const C = function (A) { A === 1 ? i.velocity.x = 0 : m ? i.processX(x, a, !0) : i.processX(-x, a, !1, !0), t.moves && (i.y += (t.y - t.prev.y) * t.friction.y, i._dy = i.y - i.prev.y) }; const P = function (A) { A === 2 ? t.velocity.x = 0 : g ? t.processX(x, s, !0) : t.processX(-x, s, !1, !0), i.moves && (t.y += (i.y - i.prev.y) * i.friction.y, t._dy = t.y - t.prev.y) }; e.exports = { BlockCheck: T, Check: S, Set: y, Run: E, RunImmovableBody1: C, RunImmovableBody2: P } }, function (e, d) { let t; let i; let h; let n; let o; let r; let s; let a; let f; let l; let u; let v; let p; let c; let m; let g; let x; const y = function (A, M, L) { t = A, i = M; const F = t.velocity.y; const I = i.velocity.y; return h = t.pushable, f = t._dy < 0, l = t._dy > 0, u = t._dy === 0, m = Math.abs(t.bottom - i.y) <= Math.abs(i.bottom - t.y), s = I - F * t.bounce.y, n = i.pushable, v = i._dy < 0, p = i._dy > 0, c = i._dy === 0, g = !m, a = F - I * i.bounce.y, x = Math.abs(L), T() }; var T = function () { return l && m && i.blocked.down ? (t.processY(-x, s, !1, !0), 1) : f && g && i.blocked.up ? (t.processY(x, s, !0), 1) : p && g && t.blocked.down ? (i.processY(-x, a, !1, !0), 2) : v && m && t.blocked.up ? (i.processY(x, a, !0), 2) : 0 }; const S = function () { const A = t.velocity.y; const M = i.velocity.y; let L = Math.sqrt(M * M * i.mass / t.mass) * (M > 0 ? 1 : -1); let F = Math.sqrt(A * A * t.mass / i.mass) * (A > 0 ? 1 : -1); const I = (L + F) * 0.5; return L -= I, F -= I, o = I + L * t.bounce.y, r = I + F * i.bounce.y, f && g ? E(0) : v && m ? E(1) : l && m ? E(2) : p && g ? E(3) : !1 }; var E = function (A) { if (h && n)x *= 0.5, A === 0 || A === 3 ? (t.processY(x, o), i.processY(-x, r)) : (t.processY(-x, o), i.processY(x, r)); else if (h && !n)A === 0 || A === 3 ? t.processY(x, s, !0) : t.processY(-x, s, !1, !0); else if (!h && n)A === 0 || A === 3 ? i.processY(-x, a, !1, !0) : i.processY(x, a, !0); else { const M = x * 0.5; A === 0 ? c ? (t.processY(x, 0, !0), i.processY(0, null, !1, !0)) : p ? (t.processY(M, 0, !0), i.processY(-M, 0, !1, !0)) : (t.processY(M, i.velocity.y, !0), i.processY(-M, null, !1, !0)) : A === 1 ? u ? (t.processY(0, null, !1, !0), i.processY(x, 0, !0)) : l ? (t.processY(-M, 0, !1, !0), i.processY(M, 0, !0)) : (t.processY(-M, null, !1, !0), i.processY(M, t.velocity.y, !0)) : A === 2 ? c ? (t.processY(-x, 0, !1, !0), i.processY(0, null, !0)) : v ? (t.processY(-M, 0, !1, !0), i.processY(M, 0, !0)) : (t.processY(-M, i.velocity.y, !1, !0), i.processY(M, null, !0)) : A === 3 && (u ? (t.processY(0, null, !0), i.processY(-x, 0, !1, !0)) : f ? (t.processY(M, 0, !0), i.processY(-M, 0, !1, !0)) : (t.processY(M, i.velocity.y, !0), i.processY(-M, null, !1, !0))) } return !0 }; const C = function (A) { A === 1 ? i.velocity.y = 0 : m ? i.processY(x, a, !0) : i.processY(-x, a, !1, !0), t.moves && (i.x += (t.x - t.prev.x) * t.friction.x, i._dx = i.x - i.prev.x) }; const P = function (A) { A === 2 ? t.velocity.y = 0 : g ? t.processY(x, s, !0) : t.processY(-x, s, !1, !0), i.moves && (t.x += (i.x - i.prev.x) * i.friction.x, t._dx = t.x - t.prev.x) }; e.exports = { BlockCheck: T, Check: S, Set: y, Run: E, RunImmovableBody1: C, RunImmovableBody2: P } }, function (e, d, t) { const i = { ProcessTileCallbacks: t(530), ProcessTileSeparationX: t(534), ProcessTileSeparationY: t(536), SeparateTile: t(532), TileCheckX: t(533), TileCheckY: t(535), TileIntersectsBody: t(248) }; e.exports = i }, function (e, d, t) { const i = t(0); const h = t(3); const n = new i({ initialize: function () { this.boundsCenter = new h(), this.centerDiff = new h() }, parseBody: function (o) { if (o = o.hasOwnProperty('body') ? o.body : o, !o.hasOwnProperty('bounds') || !o.hasOwnProperty('centerOfMass')) return !1; const r = this.boundsCenter; const s = this.centerDiff; const a = o.bounds.max.x - o.bounds.min.x; const f = o.bounds.max.y - o.bounds.min.y; const l = a * o.centerOfMass.x; const u = f * o.centerOfMass.y; return r.set(a / 2, f / 2), s.set(l - r.x, u - r.y), !0 }, getTopLeft: function (o, r, s) { if (r === void 0 && (r = 0), s === void 0 && (s = 0), this.parseBody(o)) { const a = this.boundsCenter; const f = this.centerDiff; return new h(r + a.x + f.x, s + a.y + f.y) } return !1 }, getTopCenter: function (o, r, s) { if (r === void 0 && (r = 0), s === void 0 && (s = 0), this.parseBody(o)) { const a = this.boundsCenter; const f = this.centerDiff; return new h(r + f.x, s + a.y + f.y) } return !1 }, getTopRight: function (o, r, s) { if (r === void 0 && (r = 0), s === void 0 && (s = 0), this.parseBody(o)) { const a = this.boundsCenter; const f = this.centerDiff; return new h(r - (a.x - f.x), s + a.y + f.y) } return !1 }, getLeftCenter: function (o, r, s) { if (r === void 0 && (r = 0), s === void 0 && (s = 0), this.parseBody(o)) { const a = this.boundsCenter; const f = this.centerDiff; return new h(r + a.x + f.x, s + f.y) } return !1 }, getCenter: function (o, r, s) { if (r === void 0 && (r = 0), s === void 0 && (s = 0), this.parseBody(o)) { const a = this.centerDiff; return new h(r + a.x, s + a.y) } return !1 }, getRightCenter: function (o, r, s) { if (r === void 0 && (r = 0), s === void 0 && (s = 0), this.parseBody(o)) { const a = this.boundsCenter; const f = this.centerDiff; return new h(r - (a.x - f.x), s + f.y) } return !1 }, getBottomLeft: function (o, r, s) { if (r === void 0 && (r = 0), s === void 0 && (s = 0), this.parseBody(o)) { const a = this.boundsCenter; const f = this.centerDiff; return new h(r + a.x + f.x, s - (a.y - f.y)) } return !1 }, getBottomCenter: function (o, r, s) { if (r === void 0 && (r = 0), s === void 0 && (s = 0), this.parseBody(o)) { const a = this.boundsCenter; const f = this.centerDiff; return new h(r + f.x, s - (a.y - f.y)) } return !1 }, getBottomRight: function (o, r, s) { if (r === void 0 && (r = 0), s === void 0 && (s = 0), this.parseBody(o)) { const a = this.boundsCenter; const f = this.centerDiff; return new h(r - (a.x - f.x), s - (a.y - f.y)) } return !1 } }); e.exports = n }, function (e, d) { e.exports = { decomp: A, quickDecomp: I, isSimple: L, removeCollinearPoints: G, removeDuplicatePoints: U, makeCCW: m }; function t (O, R, D) { D = D || 0; const B = [0, 0]; let N; let w; let z; let V; let W; let H; let K; return N = O[1][1] - O[0][1], w = O[0][0] - O[1][0], z = N * O[0][0] + w * O[0][1], V = R[1][1] - R[0][1], W = R[0][0] - R[1][0], H = V * R[0][0] + W * R[0][1], K = N * W - V * w, Y(K, 0, D) || (B[0] = (W * z - w * H) / K, B[1] = (N * H - V * z) / K), B } function i (O, R, D, B) { const N = R[0] - O[0]; const w = R[1] - O[1]; const z = B[0] - D[0]; const V = B[1] - D[1]; if (z * w - V * N == 0) return !1; const W = (N * (D[1] - O[1]) + w * (O[0] - D[0])) / (z * w - V * N); const H = (z * (O[1] - D[1]) + V * (D[0] - O[0])) / (V * N - z * w); return W >= 0 && W <= 1 && H >= 0 && H <= 1 } function h (O, R, D) { return (R[0] - O[0]) * (D[1] - O[1]) - (D[0] - O[0]) * (R[1] - O[1]) } function n (O, R, D) { return h(O, R, D) > 0 } function o (O, R, D) { return h(O, R, D) >= 0 } function r (O, R, D) { return h(O, R, D) < 0 } function s (O, R, D) { return h(O, R, D) <= 0 } const a = []; const f = []; function l (O, R, D, B) { if (B) { const N = a; const w = f; N[0] = R[0] - O[0], N[1] = R[1] - O[1], w[0] = D[0] - R[0], w[1] = D[1] - R[1]; const z = N[0] * w[0] + N[1] * w[1]; const V = Math.sqrt(N[0] * N[0] + N[1] * N[1]); const W = Math.sqrt(w[0] * w[0] + w[1] * w[1]); const H = Math.acos(z / (V * W)); return H < B } else return h(O, R, D) === 0 } function u (O, R) { const D = R[0] - O[0]; const B = R[1] - O[1]; return D * D + B * B } function v (O, R) { const D = O.length; return O[R < 0 ? R % D + D : R % D] } function p (O) { O.length = 0 } function c (O, R, D, B) { for (let N = D; N < B; N++)O.push(R[N]) } function m (O) { for (var R = 0, D = O, B = 1; B < O.length; ++B)(D[B][1] < D[R][1] || D[B][1] === D[R][1] && D[B][0] > D[R][0]) && (R = B); return n(v(O, R - 1), v(O, R), v(O, R + 1)) ? !1 : (g(O), !0) } function g (O) { for (var R = [], D = O.length, B = 0; B !== D; B++)R.push(O.pop()); for (var B = 0; B !== D; B++)O[B] = R[B] } function x (O, R) { return r(v(O, R - 1), v(O, R), v(O, R + 1)) } const y = []; const T = []; function S (O, R, D) { let B; let N; const w = y; const z = T; if (o(v(O, R + 1), v(O, R), v(O, D)) && s(v(O, R - 1), v(O, R), v(O, D))) return !1; N = u(v(O, R), v(O, D)); for (let V = 0; V !== O.length; ++V) if (!((V + 1) % O.length === R || V === R) && o(v(O, R), v(O, D), v(O, V + 1)) && s(v(O, R), v(O, D), v(O, V)) && (w[0] = v(O, R), w[1] = v(O, D), z[0] = v(O, V), z[1] = v(O, V + 1), B = t(w, z), u(v(O, R), B) < N)) return !1; return !0 } function E (O, R, D) { for (let B = 0; B !== O.length; ++B) if (!(B === R || B === D || (B + 1) % O.length === R || (B + 1) % O.length === D) && i(v(O, R), v(O, D), v(O, B), v(O, B + 1))) return !1; return !0 } function C (O, R, D, B) { const N = B || []; if (p(N), R < D) for (var w = R; w <= D; w++)N.push(O[w]); else { for (var w = 0; w <= D; w++)N.push(O[w]); for (var w = R; w < O.length; w++)N.push(O[w]) } return N } function P (O) { for (var R = [], D = [], B = [], N = [], w = Number.MAX_VALUE, z = 0; z < O.length; ++z) if (x(O, z)) { for (let V = 0; V < O.length; ++V) if (S(O, z, V)) { D = P(C(O, z, V, N)), B = P(C(O, V, z, N)); for (let W = 0; W < B.length; W++)D.push(B[W]); D.length < w && (R = D, w = D.length, R.push([v(O, z), v(O, V)])) } } return R } function A (O) { const R = P(O); return R.length > 0 ? M(O, R) : [O] } function M (O, R) { if (R.length === 0) return [O]; if (R instanceof Array && R.length && R[0] instanceof Array && R[0].length === 2 && R[0][0] instanceof Array) { for (var D = [O], B = 0; B < R.length; B++) for (var N = R[B], w = 0; w < D.length; w++) { const z = D[w]; const V = M(z, N); if (V) { D.splice(w, 1), D.push(V[0], V[1]); break } } return D } else { var N = R; var B = O.indexOf(N[0]); var w = O.indexOf(N[1]); return B !== -1 && w !== -1 ? [C(O, B, w), C(O, w, B)] : !1 } } function L (O) { const R = O; let D; for (D = 0; D < R.length - 1; D++) for (let B = 0; B < D - 1; B++) if (i(R[D], R[D + 1], R[B], R[B + 1])) return !1; for (D = 1; D < R.length - 2; D++) if (i(R[0], R[R.length - 1], R[D], R[D + 1])) return !1; return !0 } function F (O, R, D, B, N) { N = N || 0; const w = R[1] - O[1]; const z = O[0] - R[0]; const V = w * O[0] + z * O[1]; const W = B[1] - D[1]; const H = D[0] - B[0]; const K = W * D[0] + H * D[1]; const Q = w * H - W * z; return Y(Q, 0, N) ? [0, 0] : [(H * V - z * K) / Q, (w * K - W * V) / Q] } function I (O, R, D, B, N, w, z) { w = w || 100, z = z || 0, N = N || 25, R = typeof R !== 'undefined' ? R : [], D = D || [], B = B || []; let V = [0, 0]; let W = [0, 0]; let H = [0, 0]; let K = 0; let Q = 0; let J = 0; let q = 0; let j = 0; let _ = 0; let rt = 0; const nt = []; const et = []; const b = O; const at = O; if (at.length < 3) return R; if (z++, z > w) return console.warn('quickDecomp: max level (' + w + ') reached.'), R; for (let it = 0; it < O.length; ++it) if (x(b, it)) { D.push(b[it]), K = Q = Number.MAX_VALUE; for (var st = 0; st < O.length; ++st)n(v(b, it - 1), v(b, it), v(b, st)) && s(v(b, it - 1), v(b, it), v(b, st - 1)) && (H = F(v(b, it - 1), v(b, it), v(b, st), v(b, st - 1)), r(v(b, it + 1), v(b, it), H) && (J = u(b[it], H), J < Q && (Q = J, W = H, _ = st))), n(v(b, it + 1), v(b, it), v(b, st + 1)) && s(v(b, it + 1), v(b, it), v(b, st)) && (H = F(v(b, it + 1), v(b, it), v(b, st), v(b, st + 1)), n(v(b, it - 1), v(b, it), H) && (J = u(b[it], H), J < K && (K = J, V = H, j = st))); if (_ === (j + 1) % O.length)H[0] = (W[0] + V[0]) / 2, H[1] = (W[1] + V[1]) / 2, B.push(H), it < j ? (c(nt, b, it, j + 1), nt.push(H), et.push(H), _ !== 0 && c(et, b, _, b.length), c(et, b, 0, it + 1)) : (it !== 0 && c(nt, b, it, b.length), c(nt, b, 0, j + 1), nt.push(H), et.push(H), c(et, b, _, it + 1)); else { if (_ > j && (j += O.length), q = Number.MAX_VALUE, j < _) return R; for (var st = _; st <= j; ++st)o(v(b, it - 1), v(b, it), v(b, st)) && s(v(b, it + 1), v(b, it), v(b, st)) && (J = u(v(b, it), v(b, st)), J < q && E(b, it, st) && (q = J, rt = st % O.length)); it < rt ? (c(nt, b, it, rt + 1), rt !== 0 && c(et, b, rt, at.length), c(et, b, 0, it + 1)) : (it !== 0 && c(nt, b, it, at.length), c(nt, b, 0, rt + 1), c(et, b, rt, it + 1)) } return nt.length < et.length ? (I(nt, R, D, B, N, w, z), I(et, R, D, B, N, w, z)) : (I(et, R, D, B, N, w, z), I(nt, R, D, B, N, w, z)), R } return R.push(O), R } function G (O, R) { for (var D = 0, B = O.length - 1; O.length > 3 && B >= 0; --B)l(v(O, B - 1), v(O, B), v(O, B + 1), R) && (O.splice(B % O.length, 1), D++); return D } function U (O, R) { for (let D = O.length - 1; D >= 1; --D) for (let B = O[D], N = D - 1; N >= 0; --N) if (X(B, O[N], R)) { O.splice(D, 1); continue } } function Y (O, R, D) { return D = D || 0, Math.abs(O - R) <= D } function X (O, R, D) { return Y(O[0], R[0], D) && Y(O[1], R[1], D) } }, function (e, d, t) { const i = t(86); const h = t(0); const n = t(591); const o = t(128); const r = t(592); const s = t(1395); const a = t(1396); const f = t(1397); const l = t(593); const u = t(589); const v = t(590); const p = t(1398); const c = t(64); const m = new h({ initialize: function (x) { this.world = x, this.scene = x.scene, this.sys = x.scene.sys }, rectangle: function (g, x, y, T, S) { const E = i.rectangle(g, x, y, T, S); return this.world.add(E), E }, trapezoid: function (g, x, y, T, S, E) { const C = i.trapezoid(g, x, y, T, S, E); return this.world.add(C), C }, circle: function (g, x, y, T, S) { const E = i.circle(g, x, y, T, S); return this.world.add(E), E }, polygon: function (g, x, y, T, S) { const E = i.polygon(g, x, y, T, S); return this.world.add(E), E }, fromVertices: function (g, x, y, T, S, E, C) { typeof y === 'string' && (y = c.fromPath(y)); const P = i.fromVertices(g, x, y, T, S, E, C); return this.world.add(P), P }, fromPhysicsEditor: function (g, x, y, T, S) { S === void 0 && (S = !0); const E = u.parseBody(g, x, y, T); return S && !this.world.has(E) && this.world.add(E), E }, fromSVG: function (g, x, y, T, S, E) { T === void 0 && (T = 1), S === void 0 && (S = {}), E === void 0 && (E = !0); for (var C = y.getElementsByTagName('path'), P = [], A = 0; A < C.length; A++) { const M = r.pathToVertices(C[A], 30); T !== 1 && c.scale(M, T, T), P.push(M) } const L = i.fromVertices(g, x, P, S); return E && this.world.add(L), L }, fromJSON: function (g, x, y, T, S) { T === void 0 && (T = {}), S === void 0 && (S = !0); const E = v.parseBody(g, x, y, T); return E && S && this.world.add(E), E }, imageStack: function (g, x, y, T, S, E, C, P, A) { C === void 0 && (C = 0), P === void 0 && (P = 0), A === void 0 && (A = {}); const M = this.world; const L = this.sys.displayList; A.addToWorld = !1; const F = n.stack(y, T, S, E, C, P, function (I, G) { const U = new a(M, I, G, g, x, A); return L.add(U), U.body }); return M.add(F), F }, stack: function (g, x, y, T, S, E, C) { const P = n.stack(g, x, y, T, S, E, C); return this.world.add(P), P }, pyramid: function (g, x, y, T, S, E, C) { const P = n.pyramid(g, x, y, T, S, E, C); return this.world.add(P), P }, chain: function (g, x, y, T, S, E) { return n.chain(g, x, y, T, S, E) }, mesh: function (g, x, y, T, S) { return n.mesh(g, x, y, T, S) }, newtonsCradle: function (g, x, y, T, S) { const E = n.newtonsCradle(g, x, y, T, S); return this.world.add(E), E }, car: function (g, x, y, T, S) { const E = n.car(g, x, y, T, S); return this.world.add(E), E }, softBody: function (g, x, y, T, S, E, C, P, A, M) { const L = n.softBody(g, x, y, T, S, E, C, P, A, M); return this.world.add(L), L }, joint: function (g, x, y, T, S) { return this.constraint(g, x, y, T, S) }, spring: function (g, x, y, T, S) { return this.constraint(g, x, y, T, S) }, constraint: function (g, x, y, T, S) { T === void 0 && (T = 1), S === void 0 && (S = {}), S.bodyA = g.type === 'body' ? g : g.body, S.bodyB = x.type === 'body' ? x : x.body, isNaN(y) || (S.length = y), S.stiffness = T; const E = o.create(S); return this.world.add(E), E }, worldConstraint: function (g, x, y, T) { y === void 0 && (y = 1), T === void 0 && (T = {}), T.bodyB = g.type === 'body' ? g : g.body, isNaN(x) || (T.length = x), T.stiffness = y; const S = o.create(T); return this.world.add(S), S }, mouseSpring: function (g) { return this.pointerConstraint(g) }, pointerConstraint: function (g) { g === void 0 && (g = {}), g.hasOwnProperty('render') || (g.render = { visible: !1 }); const x = new p(this.scene, this.world, g); return this.world.add(x.constraint), x }, image: function (g, x, y, T, S) { const E = new a(this.world, g, x, y, T, S); return this.sys.displayList.add(E), E }, tileBody: function (g, x) { return new l(this.world, g, x) }, sprite: function (g, x, y, T, S) { const E = new f(this.world, g, x, y, T, S); return this.sys.displayList.add(E), this.sys.updateList.add(E), E }, gameObject: function (g, x, y) { return s(this.world, g, x, y) }, destroy: function () { this.world = null, this.scene = null, this.sys = null } }); e.exports = m }, function (e, d, t) { const i = t(249); const h = t(2); const n = t(3); function o (s) { return !!s.get && typeof s.get === 'function' || !!s.set && typeof s.set === 'function' } const r = function (s, a, f, l) { f === void 0 && (f = {}), l === void 0 && (l = !0); const u = a.x; const v = a.y; a.body = { temp: !0, position: { x: u, y: v } }; const p = [i.Bounce, i.Collision, i.Force, i.Friction, i.Gravity, i.Mass, i.Sensor, i.SetBody, i.Sleep, i.Static, i.Transform, i.Velocity]; if (p.forEach(function (m) { for (const g in m)o(m[g]) ? Object.defineProperty(a, g, { get: m[g].get, set: m[g].set }) : Object.defineProperty(a, g, { value: m[g] }) }), a.world = s, a._tempVec2 = new n(u, v), f.hasOwnProperty('type') && f.type === 'body')a.setExistingBody(f, l); else { let c = h(f, 'shape', null); c || (c = 'rectangle'), f.addToWorld = l, a.setBody(c, f) } return a }; e.exports = r }, function (e, d, t) { const i = t(0); const h = t(249); const n = t(15); const o = t(2); const r = t(125); const s = t(167); const a = t(3); const f = new i({ Extends: r, Mixins: [h.Bounce, h.Collision, h.Force, h.Friction, h.Gravity, h.Mass, h.Sensor, h.SetBody, h.Sleep, h.Static, h.Transform, h.Velocity, s], initialize: function (u, v, p, c, m, g) { n.call(this, u.scene, 'Image'), this._crop = this.resetCropObject(), this.setTexture(c, m), this.setSizeToFrame(), this.setOrigin(), this.world = u, this._tempVec2 = new a(v, p); const x = o(g, 'shape', null); x ? this.setBody(x, g) : this.setRectangle(this.width, this.height, g), this.setPosition(v, p), this.initPipeline() } }); e.exports = f }, function (e, d, t) { const i = t(164); const h = t(0); const n = t(249); const o = t(15); const r = t(2); const s = t(167); const a = t(73); const f = t(3); const l = new h({ Extends: a, Mixins: [n.Bounce, n.Collision, n.Force, n.Friction, n.Gravity, n.Mass, n.Sensor, n.SetBody, n.Sleep, n.Static, n.Transform, n.Velocity, s], initialize: function (v, p, c, m, g, x) { o.call(this, v.scene, 'Sprite'), this._crop = this.resetCropObject(), this.anims = new i(this), this.setTexture(m, g), this.setSizeToFrame(), this.setOrigin(), this.world = v, this._tempVec2 = new f(p, c); const y = r(x, 'shape', null); y ? this.setBody(y, x) : this.setRectangle(this.width, this.height, x), this.setPosition(p, c), this.initPipeline() } }); e.exports = l }, function (e, d, t) { const i = t(84); const h = t(0); const n = t(118); const o = t(128); const r = t(273); const s = t(272); const a = t(51); const f = t(127); const l = t(165); const u = t(3); const v = t(64); const p = new h({ initialize: function (m, g, x) { x === void 0 && (x = {}); const y = { label: 'Pointer Constraint', pointA: { x: 0, y: 0 }, pointB: { x: 0, y: 0 }, length: 0.01, stiffness: 0.1, angularStiffness: 1, collisionFilter: { category: 1, mask: 4294967295, group: 0 } }; this.scene = m, this.world = g, this.camera = null, this.pointer = null, this.active = !0, this.position = new u(), this.body = null, this.part = null, this.constraint = o.create(f(x, y)), this.world.on(s.BEFORE_UPDATE, this.update, this), m.sys.input.on(a.POINTER_DOWN, this.onDown, this), m.sys.input.on(a.POINTER_UP, this.onUp, this) }, onDown: function (c) { this.pointer || (this.pointer = c, this.camera = c.camera) }, onUp: function (c) { c === this.pointer && (this.pointer = null) }, getBody: function (c) { const m = this.position; const g = this.constraint; this.camera.getWorldPoint(c.x, c.y, m); for (let x = n.allBodies(this.world.localWorld), y = 0; y < x.length; y++) { const T = x[y]; if (!T.ignorePointer && i.contains(T.bounds, m) && r.canCollide(T.collisionFilter, g.collisionFilter) && this.hitTestBody(T, m)) return this.world.emit(s.DRAG_START, T, this.part, this), !0 } return !1 }, hitTestBody: function (c, m) { for (let g = this.constraint, x = c.parts.length, y = x > 1 ? 1 : 0, T = y; T < x; T++) { const S = c.parts[T]; if (v.contains(S.vertices, m)) return g.pointA = m, g.pointB = { x: m.x - c.position.x, y: m.y - c.position.y }, g.bodyB = c, g.angleB = c.angle, l.set(c, !1), this.part = S, this.body = c, !0 } return !1 }, update: function () { const c = this.pointer; let m = this.body; if (!this.active || !c) { m && this.stopDrag(); return } if (!c.isDown && m) { this.stopDrag() } else if (c.isDown) { if (!m && !this.getBody(c)) return; m = this.body; const g = this.position; const x = this.constraint; this.camera.getWorldPoint(c.x, c.y, g), x.pointA.x = g.x, x.pointA.y = g.y, l.set(m, !1), this.world.emit(s.DRAG, m, this) } }, stopDrag: function () { const c = this.body; const m = this.constraint; m.bodyB = null, m.pointB = null, this.pointer = null, this.body = null, this.part = null, c && this.world.emit(s.DRAG_END, c, this) }, destroy: function () { this.world.removeConstraint(this.constraint), this.pointer = null, this.constraint = null, this.body = null, this.part = null, this.world.off(s.BEFORE_UPDATE, this.update), this.scene.sys.input.off(a.POINTER_DOWN, this.onDown, this), this.scene.sys.input.off(a.POINTER_UP, this.onUp, this) } }); e.exports = p }, function (e, d, t) { const i = {}; e.exports = i; const h = t(595); const n = t(32); (function () { i.name = 'matter-js', i.version = '0.14.2', i.uses = [], i.used = [], i.use = function () { h.use(i, Array.prototype.slice.call(arguments)) }, i.before = function (o, r) { return o = o.replace(/^Matter./, ''), n.chainPathBefore(i, o, r) }, i.after = function (o, r) { return o = o.replace(/^Matter./, ''), n.chainPathAfter(i, o, r) } })() }, function (e, d, t) { const i = {}; e.exports = i; const h = t(83); const n = t(274); const o = t(84); const r = t(86); const s = t(64); (function () { i.collides = function (a, f) { for (var l = [], u = 0; u < f.length; u++) { const v = f[u]; if (a !== v && o.overlaps(v.bounds, a.bounds)) for (let p = v.parts.length === 1 ? 0 : 1; p < v.parts.length; p++) { const c = v.parts[p]; if (o.overlaps(c.bounds, a.bounds)) { const m = n.collides(c, a); if (m.collided) { l.push(m); break } } } } return l }, i.ray = function (a, f, l, u) { u = u || 1e-100; for (var v = h.angle(f, l), p = h.magnitude(h.sub(f, l)), c = (l.x + f.x) * 0.5, m = (l.y + f.y) * 0.5, g = r.rectangle(c, m, p, u, { angle: v }), x = i.collides(g, a), y = 0; y < x.length; y += 1) { const T = x[y]; T.body = T.bodyB = T.bodyA } return x }, i.region = function (a, f, l) { for (var u = [], v = 0; v < a.length; v++) { const p = a[v]; const c = o.overlaps(p.bounds, f); (c && !l || !c && l) && u.push(p) } return u }, i.point = function (a, f) { for (var l = [], u = 0; u < a.length; u++) { const v = a[u]; if (o.contains(v.bounds, f)) for (let p = v.parts.length === 1 ? 0 : 1; p < v.parts.length; p++) { const c = v.parts[p]; if (o.contains(c.bounds, f) && s.contains(c.vertices, f)) { l.push(v); break } } } return l } })() }, function (e, d, t) { const i = {}; e.exports = i; const h = t(596); const n = t(165); const o = t(599); const r = t(598); const s = t(1523); const a = t(597); const f = t(166); const l = t(118); const u = t(128); const v = t(32); const p = t(41); (function () { i.create = function (c, m) { m = v.isElement(c) ? m : c, c = v.isElement(c) ? c : null, m = m || {}, (c || m.render) && v.warn('Engine.create: engine.render is deprecated (see docs)'); const g = { positionIterations: 6, velocityIterations: 4, constraintIterations: 2, enableSleeping: !1, events: [], plugin: {}, timing: { timestamp: 0, timeScale: 1 }, broadphase: { controller: a } }; const x = v.extend(g, m); return x.world = m.world || h.create(x.world), x.pairs = r.create(), x.broadphase = x.broadphase.controller.create(x.broadphase), x.metrics = x.metrics || { extended: !1 }, x.metrics = s.create(x.metrics), x }, i.update = function (c, m, g) { m = m || 1e3 / 60, g = g || 1; const x = c.world; const y = c.timing; const T = c.broadphase; let S = []; let E; y.timestamp += m * y.timeScale; const C = { timestamp: y.timestamp }; f.trigger(c, 'beforeUpdate', C); const P = l.allBodies(x); const A = l.allConstraints(x); for (s.reset(c.metrics), c.enableSleeping && n.update(P, y.timeScale), i._bodiesApplyGravity(P, x.gravity), i._bodiesUpdate(P, m, y.timeScale, g, x.bounds), u.preSolveAll(P), E = 0; E < c.constraintIterations; E++)u.solveAll(A, y.timeScale); u.postSolveAll(P), T.controller ? (x.isModified && T.controller.clear(T), T.controller.update(T, P, c, x.isModified), S = T.pairsList) : S = P, x.isModified && l.setModified(x, !1, !1, !0); const M = T.detector(S, c); const L = c.pairs; const F = y.timestamp; for (r.update(L, M, F), r.removeOld(L, F), c.enableSleeping && n.afterCollisions(L.list, y.timeScale), L.collisionStart.length > 0 && f.trigger(c, 'collisionStart', { pairs: L.collisionStart }), o.preSolvePosition(L.list), E = 0; E < c.positionIterations; E++)o.solvePosition(L.list, P, y.timeScale); for (o.postSolvePosition(P), u.preSolveAll(P), E = 0; E < c.constraintIterations; E++)u.solveAll(A, y.timeScale); for (u.postSolveAll(P), o.preSolveVelocity(L.list), E = 0; E < c.velocityIterations; E++)o.solveVelocity(L.list, y.timeScale); return L.collisionActive.length > 0 && f.trigger(c, 'collisionActive', { pairs: L.collisionActive }), L.collisionEnd.length > 0 && f.trigger(c, 'collisionEnd', { pairs: L.collisionEnd }), s.update(c.metrics, c), i._bodiesClearForces(P), f.trigger(c, 'afterUpdate', C), c }, i.merge = function (c, m) { if (v.extend(c, m), m.world) { c.world = m.world, i.clear(c); for (let g = l.allBodies(c.world), x = 0; x < g.length; x++) { const y = g[x]; n.set(y, !1), y.id = v.nextId() } } }, i.clear = function (c) { const m = c.world; r.clear(c.pairs); const g = c.broadphase; if (g.controller) { const x = l.allBodies(m); g.controller.clear(g), g.controller.update(g, x, c, !0) } }, i._bodiesClearForces = function (c) { for (let m = 0; m < c.length; m++) { const g = c[m]; g.force.x = 0, g.force.y = 0, g.torque = 0 } }, i._bodiesApplyGravity = function (c, m) { const g = typeof m.scale !== 'undefined' ? m.scale : 0.001; if (!(m.x === 0 && m.y === 0 || g === 0)) for (let x = 0; x < c.length; x++) { const y = c[x]; y.ignoreGravity || y.isStatic || y.isSleeping || (y.force.x += y.mass * m.x * g * y.gravityScale.x, y.force.y += y.mass * m.y * g * y.gravityScale.y) } }, i._bodiesUpdate = function (c, m, g, x, y) { for (let T = 0; T < c.length; T++) { const S = c[T]; S.isStatic || S.isSleeping || p.update(S, m, g, x) } } })() }, function (e, d, t) { const i = t(86); const h = t(41); const n = t(0); const o = t(32); const r = t(118); const s = t(1401); const a = t(9); const f = t(272); const l = t(2); const u = t(6); const v = t(41); const p = t(166); const c = t(593); const m = t(596); const g = t(83); const x = new n({ Extends: a, initialize: function (T, S) { a.call(this), this.scene = T, this.engine = s.create(S), this.localWorld = this.engine.world; const E = u(S, 'gravity', null); E ? this.setGravity(E.x, E.y, E.scale) : E === !1 && this.setGravity(0, 0, 0), this.walls = { left: null, right: null, top: null, bottom: null }, this.enabled = u(S, 'enabled', !0), this.correction = u(S, 'correction', 1), this.getDelta = u(S, 'getDelta', this.update60Hz); const C = l(S, 'runner', {}); const P = l(C, 'fps', !1); let A = l(C, 'fps', 60); const M = l(C, 'delta', 1e3 / A); const L = l(C, 'deltaMin', 1e3 / A); const F = l(C, 'deltaMax', 1e3 / (A * 0.5)); P || (A = 1e3 / M), this.runner = { fps: A, correction: l(C, 'correction', 1), deltaSampleSize: l(C, 'deltaSampleSize', 60), counterTimestamp: 0, frameCounter: 0, deltaHistory: [], timePrev: null, timeScalePrev: 1, frameRequestId: null, isFixed: l(C, 'isFixed', !1), delta: M, deltaMin: L, deltaMax: F }, this.autoUpdate = u(S, 'autoUpdate', !0); const I = u(S, 'debug', !1); if (this.drawDebug = typeof I === 'object' ? !0 : I, this.debugGraphic, this.debugConfig = { showAxes: l(I, 'showAxes', !1), showAngleIndicator: l(I, 'showAngleIndicator', !1), angleColor: l(I, 'angleColor', 15208787), showBroadphase: l(I, 'showBroadphase', !1), broadphaseColor: l(I, 'broadphaseColor', 16757760), showBounds: l(I, 'showBounds', !1), boundsColor: l(I, 'boundsColor', 16777215), showVelocity: l(I, 'showVelocity', !1), velocityColor: l(I, 'velocityColor', 44783), showCollisions: l(I, 'showCollisions', !1), collisionColor: l(I, 'collisionColor', 16094476), showSeparations: l(I, 'showSeparations', !1), separationColor: l(I, 'separationColor', 16753920), showBody: l(I, 'showBody', !0), showStaticBody: l(I, 'showStaticBody', !0), showInternalEdges: l(I, 'showInternalEdges', !1), renderFill: l(I, 'renderFill', !1), renderLine: l(I, 'renderLine', !0), fillColor: l(I, 'fillColor', 1075465), fillOpacity: l(I, 'fillOpacity', 1), lineColor: l(I, 'lineColor', 2678297), lineOpacity: l(I, 'lineOpacity', 1), lineThickness: l(I, 'lineThickness', 1), staticFillColor: l(I, 'staticFillColor', 857979), staticLineColor: l(I, 'staticLineColor', 1255396), showSleeping: l(I, 'showSleeping', !1), staticBodySleepOpacity: l(I, 'staticBodySleepOpacity', 0.7), sleepFillColor: l(I, 'sleepFillColor', 4605510), sleepLineColor: l(I, 'sleepLineColor', 10066585), showSensors: l(I, 'showSensors', !0), sensorFillColor: l(I, 'sensorFillColor', 857979), sensorLineColor: l(I, 'sensorLineColor', 1255396), showPositions: l(I, 'showPositions', !0), positionSize: l(I, 'positionSize', 4), positionColor: l(I, 'positionColor', 14697178), showJoint: l(I, 'showJoint', !0), jointColor: l(I, 'jointColor', 14737474), jointLineOpacity: l(I, 'jointLineOpacity', 1), jointLineThickness: l(I, 'jointLineThickness', 2), pinSize: l(I, 'pinSize', 4), pinColor: l(I, 'pinColor', 4382944), springColor: l(I, 'springColor', 14697184), anchorColor: l(I, 'anchorColor', 15724527), anchorSize: l(I, 'anchorSize', 4), showConvexHulls: l(I, 'showConvexHulls', !1), hullColor: l(I, 'hullColor', 14091216) }, this.drawDebug && this.createDebugGraphic(), this.setEventsProxy(), l(S, 'setBounds', !1)) { const G = S.setBounds; if (typeof G === 'boolean') this.setBounds(); else { const U = l(G, 'x', 0); const Y = l(G, 'y', 0); const X = l(G, 'width', T.sys.scale.width); const O = l(G, 'height', T.sys.scale.height); const R = l(G, 'thickness', 64); const D = l(G, 'left', !0); const B = l(G, 'right', !0); const N = l(G, 'top', !0); const w = l(G, 'bottom', !0); this.setBounds(U, Y, X, O, R, D, B, N, w) } } }, setCompositeRenderStyle: function (y) { const T = y.bodies; const S = y.constraints; const E = y.composites; let C; let P; let A; for (C = 0; C < T.length; C++)P = T[C], A = P.render, this.setBodyRenderStyle(P, A.lineColor, A.lineOpacity, A.lineThickness, A.fillColor, A.fillOpacity); for (C = 0; C < S.length; C++)P = S[C], A = P.render, this.setConstraintRenderStyle(P, A.lineColor, A.lineOpacity, A.lineThickness, A.pinSize, A.anchorColor, A.anchorSize); for (C = 0; C < E.length; C++)P = E[C], this.setCompositeRenderStyle(P); return this }, setBodyRenderStyle: function (y, T, S, E, C, P) { const A = y.render; const M = this.debugConfig; return A ? (T == null && (T = y.isStatic ? M.staticLineColor : M.lineColor), S == null && (S = M.lineOpacity), E == null && (E = M.lineThickness), C == null && (C = y.isStatic ? M.staticFillColor : M.fillColor), P == null && (P = M.fillOpacity), T !== !1 && (A.lineColor = T), S !== !1 && (A.lineOpacity = S), E !== !1 && (A.lineThickness = E), C !== !1 && (A.fillColor = C), P !== !1 && (A.fillOpacity = P), this) : this }, setConstraintRenderStyle: function (y, T, S, E, C, P, A) { const M = y.render; const L = this.debugConfig; if (!M) return this; if (T == null) { const F = M.type; F === 'line' ? T = L.jointColor : F === 'pin' ? T = L.pinColor : F === 'spring' && (T = L.springColor) } return S == null && (S = L.jointLineOpacity), E == null && (E = L.jointLineThickness), C == null && (C = L.pinSize), P == null && (P = L.anchorColor), A == null && (A = L.anchorSize), T !== !1 && (M.lineColor = T), S !== !1 && (M.lineOpacity = S), E !== !1 && (M.lineThickness = E), C !== !1 && (M.pinSize = C), P !== !1 && (M.anchorColor = P), A !== !1 && (M.anchorSize = A), this }, setEventsProxy: function () { const y = this; const T = this.engine; const S = this.localWorld; this.drawDebug && (p.on(S, 'compositeModified', function (E) { y.setCompositeRenderStyle(E) }), p.on(S, 'beforeAdd', function (E) { for (let C = [].concat(E.object), P = 0; P < C.length; P++) { const A = C[P]; const M = A.render; A.type === 'body' ? y.setBodyRenderStyle(A, M.lineColor, M.lineOpacity, M.lineThickness, M.fillColor, M.fillOpacity) : A.type === 'composite' ? y.setCompositeRenderStyle(A) : A.type === 'constraint' && y.setConstraintRenderStyle(A, M.lineColor, M.lineOpacity, M.lineThickness, M.pinSize, M.anchorColor, M.anchorSize) } })), p.on(S, 'beforeAdd', function (E) { y.emit(f.BEFORE_ADD, E) }), p.on(S, 'afterAdd', function (E) { y.emit(f.AFTER_ADD, E) }), p.on(S, 'beforeRemove', function (E) { y.emit(f.BEFORE_REMOVE, E) }), p.on(S, 'afterRemove', function (E) { y.emit(f.AFTER_REMOVE, E) }), p.on(T, 'beforeUpdate', function (E) { y.emit(f.BEFORE_UPDATE, E) }), p.on(T, 'afterUpdate', function (E) { y.emit(f.AFTER_UPDATE, E) }), p.on(T, 'collisionStart', function (E) { const C = E.pairs; let P; let A; C.length > 0 && (P = C[0].bodyA, A = C[0].bodyB), y.emit(f.COLLISION_START, E, P, A) }), p.on(T, 'collisionActive', function (E) { const C = E.pairs; let P; let A; C.length > 0 && (P = C[0].bodyA, A = C[0].bodyB), y.emit(f.COLLISION_ACTIVE, E, P, A) }), p.on(T, 'collisionEnd', function (E) { const C = E.pairs; let P; let A; C.length > 0 && (P = C[0].bodyA, A = C[0].bodyB), y.emit(f.COLLISION_END, E, P, A) }) }, setBounds: function (y, T, S, E, C, P, A, M, L) { return y === void 0 && (y = 0), T === void 0 && (T = 0), S === void 0 && (S = this.scene.sys.scale.width), E === void 0 && (E = this.scene.sys.scale.height), C === void 0 && (C = 64), P === void 0 && (P = !0), A === void 0 && (A = !0), M === void 0 && (M = !0), L === void 0 && (L = !0), this.updateWall(P, 'left', y - C, T - C, C, E + C * 2), this.updateWall(A, 'right', y + S, T - C, C, E + C * 2), this.updateWall(M, 'top', y, T - C, S, C), this.updateWall(L, 'bottom', y, T + E, S, C), this }, updateWall: function (y, T, S, E, C, P) { const A = this.walls[T]; y ? (A && m.remove(this.localWorld, A), S += C / 2, E += P / 2, this.walls[T] = this.create(S, E, C, P, { isStatic: !0, friction: 0, frictionStatic: 0 })) : (A && m.remove(this.localWorld, A), this.walls[T] = null) }, createDebugGraphic: function () { const y = this.scene.sys.add.graphics({ x: 0, y: 0 }); return y.setDepth(Number.MAX_VALUE), this.debugGraphic = y, this.drawDebug = !0, y }, disableGravity: function () { return this.localWorld.gravity.x = 0, this.localWorld.gravity.y = 0, this.localWorld.gravity.scale = 0, this }, setGravity: function (y, T, S) { return y === void 0 && (y = 0), T === void 0 && (T = 1), this.localWorld.gravity.x = y, this.localWorld.gravity.y = T, S !== void 0 && (this.localWorld.gravity.scale = S), this }, create: function (y, T, S, E, C) { const P = i.rectangle(y, T, S, E, C); return m.add(this.localWorld, P), P }, add: function (y) { return m.add(this.localWorld, y), this }, remove: function (y, T) { Array.isArray(y) || (y = [y]); for (let S = 0; S < y.length; S++) { const E = y[S]; const C = E.body ? E.body : E; r.remove(this.localWorld, C, T) } return this }, removeConstraint: function (y, T) { return r.remove(this.localWorld, y, T), this }, convertTilemapLayer: function (y, T) { const S = y.layer; const E = y.getTilesWithin(0, 0, S.width, S.height, { isColliding: !0 }); return this.convertTiles(E, T), this }, convertTiles: function (y, T) { if (y.length === 0) return this; for (let S = 0; S < y.length; S++) new c(this, y[S], T); return this }, nextGroup: function (y) { return v.nextGroup(y) }, nextCategory: function () { return v.nextCategory() }, pause: function () { return this.enabled = !1, this.emit(f.PAUSE), this }, resume: function () { return this.enabled = !0, this.emit(f.RESUME), this }, update: function (y, T) { if (!(!this.enabled || !this.autoUpdate)) { const S = this.engine; const E = this.runner; const C = S.timing; let P = this.correction; E.isFixed ? T = this.getDelta(y, T) : (T = y - E.timePrev || E.delta, E.timePrev = y, E.deltaHistory.push(T), E.deltaHistory = E.deltaHistory.slice(-E.deltaSampleSize), T = Math.min.apply(null, E.deltaHistory), T = T < E.deltaMin ? E.deltaMin : T, T = T > E.deltaMax ? E.deltaMax : T, P = T / E.delta, E.delta = T), E.timeScalePrev !== 0 && (P *= C.timeScale / E.timeScalePrev), C.timeScale === 0 && (P = 0), E.timeScalePrev = C.timeScale, E.correction = P, E.frameCounter += 1, y - E.counterTimestamp >= 1e3 && (E.fps = E.frameCounter * ((y - E.counterTimestamp) / 1e3), E.counterTimestamp = y, E.frameCounter = 0), s.update(S, T, P) } }, step: function (y, T) { s.update(this.engine, y, T) }, update60Hz: function () { return 1e3 / 60 }, update30Hz: function () { return 1e3 / 30 }, has: function (y) { const T = y.hasOwnProperty('body') ? y.body : y; return r.get(this.localWorld, T.id, T.type) !== null }, getAllBodies: function () { return r.allBodies(this.localWorld) }, getAllConstraints: function () { return r.allConstraints(this.localWorld) }, getAllComposites: function () { return r.allComposites(this.localWorld) }, postUpdate: function () { if (this.drawDebug) { const y = this.debugConfig; const T = this.engine; const S = this.debugGraphic; const E = r.allBodies(this.localWorld); this.debugGraphic.clear(), y.showBroadphase && T.broadphase.controller && this.renderGrid(T.broadphase, S, y.broadphaseColor, 0.5), y.showBounds && this.renderBodyBounds(E, S, y.boundsColor, 0.5), (y.showBody || y.showStaticBody) && this.renderBodies(E), y.showJoint && this.renderJoints(), (y.showAxes || y.showAngleIndicator) && this.renderBodyAxes(E, S, y.showAxes, y.angleColor, 0.5), y.showVelocity && this.renderBodyVelocity(E, S, y.velocityColor, 1, 2), y.showSeparations && this.renderSeparations(T.pairs.list, S, y.separationColor), y.showCollisions && this.renderCollisions(T.pairs.list, S, y.collisionColor) } }, renderGrid: function (y, T, S, E) { T.lineStyle(1, S, E); for (let C = o.keys(y.buckets), P = 0; P < C.length; P++) { const A = C[P]; if (!(y.buckets[A].length < 2)) { const M = A.split(/C|R/); T.strokeRect(parseInt(M[1], 10) * y.bucketWidth, parseInt(M[2], 10) * y.bucketHeight, y.bucketWidth, y.bucketHeight) } } return this }, renderSeparations: function (y, T, S) { T.lineStyle(1, S, 1); for (let E = 0; E < y.length; E++) { const C = y[E]; if (C.isActive) { const P = C.collision; const A = P.bodyA; const M = P.bodyB; const L = A.position; const F = M.position; const I = P.penetration; let G = !A.isStatic && !M.isStatic ? 4 : 1; M.isStatic && (G = 0), T.lineBetween(F.x, F.y, F.x - I.x * G, F.y - I.y * G), G = !A.isStatic && !M.isStatic ? 4 : 1, A.isStatic && (G = 0), T.lineBetween(L.x, L.y, L.x - I.x * G, L.y - I.y * G) } } return this }, renderCollisions: function (y, T, S) { T.lineStyle(1, S, 0.5), T.fillStyle(S, 1); let E, C; for (E = 0; E < y.length; E++) if (C = y[E], !!C.isActive) for (let P = 0; P < C.activeContacts.length; P++) { const A = C.activeContacts[P]; const M = A.vertex; T.fillRect(M.x - 2, M.y - 2, 5, 5) } for (E = 0; E < y.length; E++) if (C = y[E], !!C.isActive) { const L = C.collision; const F = C.activeContacts; if (F.length > 0) { let I = F[0].vertex.x; let G = F[0].vertex.y; F.length === 2 && (I = (F[0].vertex.x + F[1].vertex.x) / 2, G = (F[0].vertex.y + F[1].vertex.y) / 2), L.bodyB === L.supports[0].body || L.bodyA.isStatic ? T.lineBetween(I - L.normal.x * 8, G - L.normal.y * 8, I, G) : T.lineBetween(I + L.normal.x * 8, G + L.normal.y * 8, I, G) } } return this }, renderBodyBounds: function (y, T, S, E) { T.lineStyle(1, S, E); for (let C = 0; C < y.length; C++) { const P = y[C]; if (P.render.visible) { const A = P.bounds; if (A)T.strokeRect(A.min.x, A.min.y, A.max.x - A.min.x, A.max.y - A.min.y); else for (let M = P.parts, L = M.length > 1 ? 1 : 0; L < M.length; L++) { const F = M[L]; T.strokeRect(F.bounds.min.x, F.bounds.min.y, F.bounds.max.x - F.bounds.min.x, F.bounds.max.y - F.bounds.min.y) } } } return this }, renderBodyAxes: function (y, T, S, E, C) { T.lineStyle(1, E, C); for (let P = 0; P < y.length; P++) { const A = y[P]; const M = A.parts; if (A.render.visible) { var L, F, I; if (S) for (F = M.length > 1 ? 1 : 0; F < M.length; F++) for (L = M[F], I = 0; I < L.axes.length; I++) { const G = L.axes[I]; T.lineBetween(L.position.x, L.position.y, L.position.x + G.x * 20, L.position.y + G.y * 20) } else for (F = M.length > 1 ? 1 : 0; F < M.length; F++) for (L = M[F], I = 0; I < L.axes.length; I++)T.lineBetween(L.position.x, L.position.y, (L.vertices[0].x + L.vertices[L.vertices.length - 1].x) / 2, (L.vertices[0].y + L.vertices[L.vertices.length - 1].y) / 2) } } return this }, renderBodyVelocity: function (y, T, S, E, C) { T.lineStyle(C, S, E); for (let P = 0; P < y.length; P++) { const A = y[P]; !A.render.visible || T.lineBetween(A.position.x, A.position.y, A.position.x + (A.position.x - A.positionPrev.x) * 2, A.position.y + (A.position.y - A.positionPrev.y) * 2) } return this }, renderBodies: function (y) { for (let T = this.debugGraphic, S = this.debugConfig, E = S.showBody, C = S.showStaticBody, P = S.showSleeping, A = S.showInternalEdges, M = S.showConvexHulls, L = S.renderFill, F = S.renderLine, I = S.staticBodySleepOpacity, G = S.sleepFillColor, U = S.sleepLineColor, Y = S.hullColor, X = 0; X < y.length; X++) { const O = y[X]; if (!!O.render.visible && !(!C && O.isStatic || !E && !O.isStatic)) { let R = O.render.lineColor; let D = O.render.lineOpacity; const B = O.render.lineThickness; let N = O.render.fillColor; let w = O.render.fillOpacity; P && O.isSleeping && (O.isStatic ? (D *= I, w *= I) : (R = U, N = G)), L || (N = null), F || (R = null), this.renderBody(O, T, A, R, D, B, N, w); const z = O.parts.length; M && z > 1 && this.renderConvexHull(O, T, Y, B) } } }, renderBody: function (y, T, S, E, C, P, A, M) { E === void 0 && (E = null), C === void 0 && (C = null), P === void 0 && (P = 1), A === void 0 && (A = null), M === void 0 && (M = null); for (var L = this.debugConfig, F = L.sensorFillColor, I = L.sensorLineColor, G = y.parts, U = G.length, Y = U > 1 ? 1 : 0; Y < U; Y++) { const X = G[Y]; const O = X.render; const R = O.opacity; if (!(!O.visible || R === 0 || X.isSensor && !L.showSensors)) { const D = X.circleRadius; if (T.beginPath(), X.isSensor ? (A !== null && T.fillStyle(F, M * R), E !== null && T.lineStyle(P, I, C * R)) : (A !== null && T.fillStyle(A, M * R), E !== null && T.lineStyle(P, E, C * R)), D)T.arc(X.position.x, X.position.y, D, 0, 2 * Math.PI); else { const B = X.vertices; const N = B.length; T.moveTo(B[0].x, B[0].y); for (let w = 1; w < N; w++) { const z = B[w]; if (!B[w - 1].isInternal || S ? T.lineTo(z.x, z.y) : T.moveTo(z.x, z.y), w < N && z.isInternal && !S) { const V = (w + 1) % N; T.moveTo(B[V].x, B[V].y) } }T.closePath() }A !== null && T.fillPath(), E !== null && T.strokePath() } } if (L.showPositions && !y.isStatic) { const W = y.position.x; const H = y.position.y; const K = Math.ceil(L.positionSize / 2); T.fillStyle(L.positionColor, 1), T.fillRect(W - K, H - K, L.positionSize, L.positionSize) } return this }, renderConvexHull: function (y, T, S, E) { E === void 0 && (E = 1); const C = y.parts; const P = C.length; if (P > 1) { const A = y.vertices; T.lineStyle(E, S), T.beginPath(), T.moveTo(A[0].x, A[0].y); for (let M = 1; M < A.length; M++)T.lineTo(A[M].x, A[M].y); T.lineTo(A[0].x, A[0].y), T.strokePath() } return this }, renderJoints: function () { for (let y = this.debugGraphic, T = r.allConstraints(this.localWorld), S = 0; S < T.length; S++) { const E = T[S].render; const C = E.lineColor; const P = E.lineOpacity; const A = E.lineThickness; const M = E.pinSize; const L = E.anchorColor; const F = E.anchorSize; this.renderConstraint(T[S], y, C, P, A, M, L, F) } }, renderConstraint: function (y, T, S, E, C, P, A, M) { const L = y.render; if (!L.visible || !y.pointA || !y.pointB) return this; T.lineStyle(C, S, E); const F = y.bodyA; const I = y.bodyB; let G; let U; if (F ? G = g.add(F.position, y.pointA) : G = y.pointA, L.type === 'pin')T.strokeCircle(G.x, G.y, P); else { if (I ? U = g.add(I.position, y.pointB) : U = y.pointB, T.beginPath(), T.moveTo(G.x, G.y), L.type === 'spring') for (var Y = g.sub(U, G), X = g.perp(g.normalise(Y)), O = Math.ceil(o.clamp(y.length / 5, 12, 20)), R, D = 1; D < O; D += 1)R = D % 2 == 0 ? 1 : -1, T.lineTo(G.x + Y.x * (D / O) + X.x * R * 4, G.y + Y.y * (D / O) + X.y * R * 4); T.lineTo(U.x, U.y) } return T.strokePath(), L.anchors && M > 0 && (T.fillStyle(A), T.fillCircle(G.x, G.y, M), T.fillCircle(U.x, U.y, M)), this }, resetCollisionIDs: function () { return h._nextCollidingGroupId = 1, h._nextNonCollidingGroupId = -1, h._nextCategory = 1, this }, shutdown: function () { p.off(this.engine), this.removeAllListeners(), m.clear(this.localWorld, !1), s.clear(this.engine), this.drawDebug && this.debugGraphic.destroy() }, destroy: function () { this.shutdown() } }); e.exports = x }, function (e, d, t) { e.exports = { BasePlugin: t(540), DefaultPlugins: t(197), PluginCache: t(24), PluginManager: t(414), ScenePlugin: t(1404) } }, function (e, d, t) { const i = t(540); const h = t(0); const n = t(20); const o = new h({ Extends: i, initialize: function (s, a, f) { i.call(this, a), this.scene = s, this.systems = s.sys, this.pluginKey = f, s.sys.events.once(n.BOOT, this.boot, this) }, boot: function () {}, destroy: function () { this.pluginManager = null, this.game = null, this.scene = null, this.systems = null } }); e.exports = o }, function (e, d, t) { e.exports = { Canvas: t(1406), Events: t(91), Snapshot: t(1407), WebGL: t(1408) } }, function (e, d, t) { e.exports = { CanvasRenderer: t(368), GetBlendModes: t(370), SetTransform: t(30) } }, function (e, d, t) { e.exports = { Canvas: t(369), WebGL: t(383) } }, function (e, d, t) { const i = t(107); const h = t(17); let n = { PipelineManager: t(372), Pipelines: t(1409), RenderTarget: t(141), Utils: t(12), WebGLPipeline: t(58), WebGLRenderer: t(371), WebGLShader: t(375) }; n = h(!1, n, i), e.exports = n }, function (e, d, t) { const i = t(92); const h = t(17); let n = { BitmapMaskPipeline: t(373), Events: t(374), GraphicsPipeline: t(376), LightPipeline: t(377), MultiPipeline: t(108), PointLightPipeline: t(378), PostFXPipeline: t(1410), RopePipeline: t(379), SinglePipeline: t(380), UtilityPipeline: t(381) }; n = h(!1, n, i), e.exports = n }, function (e, d, t) { const i = t(0); const h = t(198); const n = t(2); const o = t(1411); const r = t(382); const s = t(58); const a = new i({ Extends: s, initialize: function (l) { l.renderTarget = n(l, 'renderTarget', 1), l.fragShader = n(l, 'fragShader', o), l.vertShader = n(l, 'vertShader', r), l.attributes = n(l, 'attributes', [{ name: 'inPosition', size: 2 }, { name: 'inTexCoord', size: 2 }]), l.batchSize = 1, l.vertices = [-1, -1, 0, 0, -1, 1, 0, 1, 1, 1, 1, 1, -1, -1, 0, 0, 1, 1, 1, 1, 1, -1, 1, 0], s.call(this, l), this.isPostFX = !0, this.gameObject, this.colorMatrix = new h(), this.fullFrame1, this.fullFrame2, this.halfFrame1, this.halfFrame2, this.renderer.isBooted && (this.manager = this.renderer.pipelines, this.boot()) }, boot: function () { s.prototype.boot.call(this); const f = this.manager.UTILITY_PIPELINE; this.fullFrame1 = f.fullFrame1, this.fullFrame2 = f.fullFrame2, this.halfFrame1 = f.halfFrame1, this.halfFrame2 = f.halfFrame2, this.set1i('uMainSampler', 0) }, onDraw: function (f) { this.bindAndDraw(f) }, copyFrame: function (f, l, u, v, p) { this.manager.copyFrame(f, l, u, v, p) }, copyToGame: function (f) { this.manager.copyToGame(f) }, drawFrame: function (f, l, u) { this.manager.drawFrame(f, l, u, this.colorMatrix) }, blendFrames: function (f, l, u, v, p) { this.manager.blendFrames(f, l, u, v, p) }, blendFramesAdditive: function (f, l, u, v, p) { this.manager.blendFramesAdditive(f, l, u, v, p) }, clearFrame: function (f, l) { this.manager.clearFrame(f, l) }, blitFrame: function (f, l, u, v, p, c) { this.manager.blitFrame(f, l, u, v, p, c) }, copyFrameRect: function (f, l, u, v, p, c, m, g) { this.manager.copyFrameRect(f, l, u, v, p, c, m, g) }, bindAndDraw: function (f, l, u, v, p) { u === void 0 && (u = !0), v === void 0 && (v = !0); const c = this.gl; const m = this.renderer; this.bind(p), this.set1i('uMainSampler', 0), l ? (c.viewport(0, 0, l.width, l.height), c.bindFramebuffer(c.FRAMEBUFFER, l.framebuffer), c.framebufferTexture2D(c.FRAMEBUFFER, c.COLOR_ATTACHMENT0, c.TEXTURE_2D, l.texture, 0), u && (v ? c.clearColor(0, 0, 0, 0) : c.clearColor(0, 0, 0, 1), c.clear(c.COLOR_BUFFER_BIT))) : (m.popFramebuffer(!1, !1, !1), m.currentFramebuffer || c.viewport(0, 0, m.width, m.height)), c.activeTexture(c.TEXTURE0), c.bindTexture(c.TEXTURE_2D, f.texture), c.bufferData(c.ARRAY_BUFFER, this.vertexData, c.STATIC_DRAW), c.drawArrays(c.TRIANGLES, 0, 6), l ? (c.bindTexture(c.TEXTURE_2D, null), c.bindFramebuffer(c.FRAMEBUFFER, null)) : m.resetTextures() } }); e.exports = a }, function (e, d) {
        e.exports = ['#define SHADER_NAME PHASER_POSTFX_FS', '', 'precision mediump float;', '', 'uniform sampler2D uMainSampler;', '', 'varying vec2 outTexCoord;', '', 'void main ()', '{', '    gl_FragColor = texture2D(uMainSampler, outTexCoord);', '}', ''].join(`
`)
      }, function (e, d, t) { const i = t(17); const h = t(201); let n = { Center: t(403), Events: t(104), Orientation: t(404), ScaleManager: t(415), ScaleModes: t(405), Zoom: t(406) }; n = i(!1, n, h.CENTER), n = i(!1, n, h.ORIENTATION), n = i(!1, n, h.SCALE_MODE), n = i(!1, n, h.ZOOM), e.exports = n }, function (e, d, t) { const i = t(144); const h = t(17); let n = { Events: t(20), GetPhysicsPlugins: t(419), GetScenePlugins: t(420), SceneManager: t(417), ScenePlugin: t(1414), Settings: t(421), Systems: t(204) }; n = h(!1, n, i), e.exports = n }, function (e, d, t) { const i = t(18); const h = t(0); const n = t(20); const o = t(2); const r = t(24); const s = new h({ initialize: function (f) { this.scene = f, this.systems = f.sys, this.settings = f.sys.settings, this.key = f.sys.settings.key, this.manager = f.sys.game.scene, this.transitionProgress = 0, this._elapsed = 0, this._target = null, this._duration = 0, this._onUpdate, this._onUpdateScope, this._willSleep = !1, this._willRemove = !1, f.sys.events.once(n.BOOT, this.boot, this), f.sys.events.on(n.START, this.pluginStart, this) }, boot: function () { this.systems.events.once(n.DESTROY, this.destroy, this) }, pluginStart: function () { this._target = null, this.systems.events.once(n.SHUTDOWN, this.shutdown, this) }, start: function (a, f) { return a === void 0 && (a = this.key), this.manager.queueOp('stop', this.key), this.manager.queueOp('start', a, f), this }, restart: function (a) { const f = this.key; return this.manager.queueOp('stop', f), this.manager.queueOp('start', f, a), this }, transition: function (a) { a === void 0 && (a = {}); const f = o(a, 'target', !1); const l = this.manager.getScene(f); if (!f || !this.checkValidTransition(l)) return !1; const u = o(a, 'duration', 1e3); this._elapsed = 0, this._target = l, this._duration = u, this._willSleep = o(a, 'sleep', !1), this._willRemove = o(a, 'remove', !1); const v = o(a, 'onUpdate', null); v && (this._onUpdate = v, this._onUpdateScope = o(a, 'onUpdateScope', this.scene)); const p = o(a, 'allowInput', !1); this.settings.transitionAllowInput = p; const c = l.sys.settings; return c.isTransition = !0, c.transitionFrom = this.scene, c.transitionDuration = u, c.transitionAllowInput = p, o(a, 'moveAbove', !1) ? this.manager.moveAbove(this.key, f) : o(a, 'moveBelow', !1) && this.manager.moveBelow(this.key, f), l.sys.isSleeping() ? l.sys.wake(o(a, 'data')) : this.manager.start(f, o(a, 'data')), this.systems.events.emit(n.TRANSITION_OUT, l, u), this.systems.events.on(n.UPDATE, this.step, this), !0 }, checkValidTransition: function (a) { return !(!a || a.sys.isActive() || a.sys.isTransitioning() || a === this.scene || this.systems.isTransitioning()) }, step: function (a, f) { this._elapsed += f, this.transitionProgress = i(this._elapsed / this._duration, 0, 1), this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.transitionProgress), this._elapsed >= this._duration && this.transitionComplete() }, transitionComplete: function () { const a = this._target.sys; const f = this._target.sys.settings; this.systems.events.off(n.UPDATE, this.step, this), a.events.emit(n.TRANSITION_COMPLETE, this.scene), f.isTransition = !1, f.transitionFrom = null, this._duration = 0, this._target = null, this._onUpdate = null, this._onUpdateScope = null, this._willRemove ? this.manager.remove(this.key) : this._willSleep ? this.systems.sleep() : this.manager.stop(this.key) }, add: function (a, f, l, u) { return this.manager.add(a, f, l, u) }, launch: function (a, f) { return a && a !== this.key && this.manager.queueOp('start', a, f), this }, run: function (a, f) { return a && a !== this.key && this.manager.queueOp('run', a, f), this }, pause: function (a, f) { return a === void 0 && (a = this.key), this.manager.queueOp('pause', a, f), this }, resume: function (a, f) { return a === void 0 && (a = this.key), this.manager.queueOp('resume', a, f), this }, sleep: function (a, f) { return a === void 0 && (a = this.key), this.manager.queueOp('sleep', a, f), this }, wake: function (a, f) { return a === void 0 && (a = this.key), this.manager.queueOp('wake', a, f), this }, switch: function (a) { return a !== this.key && this.manager.queueOp('switch', this.key, a), this }, stop: function (a, f) { return a === void 0 && (a = this.key), this.manager.queueOp('stop', a, f), this }, setActive: function (a, f, l) { f === void 0 && (f = this.key); const u = this.manager.getScene(f); return u && u.sys.setActive(a, l), this }, setVisible: function (a, f) { f === void 0 && (f = this.key); const l = this.manager.getScene(f); return l && l.sys.setVisible(a), this }, isSleeping: function (a) { return a === void 0 && (a = this.key), this.manager.isSleeping(a) }, isActive: function (a) { return a === void 0 && (a = this.key), this.manager.isActive(a) }, isPaused: function (a) { return a === void 0 && (a = this.key), this.manager.isPaused(a) }, isVisible: function (a) { return a === void 0 && (a = this.key), this.manager.isVisible(a) }, swapPosition: function (a, f) { return f === void 0 && (f = this.key), a !== f && this.manager.swapPosition(a, f), this }, moveAbove: function (a, f) { return f === void 0 && (f = this.key), a !== f && this.manager.moveAbove(a, f), this }, moveBelow: function (a, f) { return f === void 0 && (f = this.key), a !== f && this.manager.moveBelow(a, f), this }, remove: function (a) { return a === void 0 && (a = this.key), this.manager.remove(a), this }, moveUp: function (a) { return a === void 0 && (a = this.key), this.manager.moveUp(a), this }, moveDown: function (a) { return a === void 0 && (a = this.key), this.manager.moveDown(a), this }, bringToTop: function (a) { return a === void 0 && (a = this.key), this.manager.bringToTop(a), this }, sendToBack: function (a) { return a === void 0 && (a = this.key), this.manager.sendToBack(a), this }, get: function (a) { return this.manager.getScene(a) }, getIndex: function (a) { return a === void 0 && (a = this.key), this.manager.getIndex(a) }, shutdown: function () { const a = this.systems.events; a.off(n.SHUTDOWN, this.shutdown, this), a.off(n.POST_UPDATE, this.step, this), a.off(n.TRANSITION_OUT) }, destroy: function () { this.shutdown(), this.scene.sys.events.off(n.START, this.start, this), this.scene = null, this.systems = null, this.settings = null, this.manager = null } }); r.register('ScenePlugin', s, 'scenePlugin'), e.exports = s }, function (e, d, t) { e.exports = { Events: t(438), List: t(110), Map: t(102), ProcessQueue: t(211), RTree: t(531), Set: t(149), Size: t(416) } }, function (e, d, t) { const i = t(17); const h = t(1417); let n = { CanvasTexture: t(423), Events: t(106), FilterMode: h, Frame: t(109), Parsers: t(425), Texture: t(206), TextureManager: t(422), TextureSource: t(424) }; n = i(!1, n, h), e.exports = n }, function (e, d) { const t = { LINEAR: 0, NEAREST: 1 }; e.exports = t }, function (e, d, t) { const i = t(17); const h = t(1419); let n = { Components: t(251), Parsers: t(1452), Formats: t(40), ImageCollection: t(576), ParseToTilemap: t(262), Tile: t(85), Tilemap: t(580), TilemapCreator: t(1459), TilemapFactory: t(1460), Tileset: t(122), TilemapLayer: t(581), Orientation: t(29), LayerData: t(120), MapData: t(121), ObjectLayer: t(572) }; n = i(!1, n, h.ORIENTATION), e.exports = n }, function (e, d, t) { const i = { ORIENTATION: t(29) }; e.exports = i }, function (e, d, t) { const i = t(26); const h = t(63); const n = function (o, r, s, a, f, l, u, v) { u === void 0 && (u = !0), o < 0 && (o = 0), r < 0 && (r = 0); for (let p = i(o, r, s, a, null, v), c = f - o, m = l - r, g = 0; g < p.length; g++) { const x = p[g].x + c; const y = p[g].y + m; x >= 0 && x < v.width && y >= 0 && y < v.height && v.data[y][x] && v.data[y][x].copy(p[g]) }u && h(f - 1, l - 1, s + 2, a + 2, v) }; e.exports = n }, function (e, d, t) { const i = t(26); const h = t(542); const n = function (o, r, s, a, f, l) { s || (s = {}), Array.isArray(o) || (o = [o]); const u = l.tilemapLayer; a || (a = u.scene), f || (f = a.cameras.main); const v = i(0, 0, l.width, l.height, null, l); const p = []; let c; for (c = 0; c < v.length; c++) { const m = v[c]; if (o.indexOf(m.index) !== -1) { const g = u.tileToWorldXY(m.x, m.y, void 0, f, l); s.x = g.x, s.y = g.y, p.push(a.make.sprite(s)) } } if (typeof r === 'number') for (c = 0; c < o.length; c++)h(o[c], r, 0, 0, l.width, l.height, l); else if (Array.isArray(r)) for (c = 0; c < o.length; c++)h(o[c], r[c], 0, 0, l.width, l.height, l); return p }; e.exports = n }, function (e, d, t) { const i = t(26); const h = t(63); const n = t(72); const o = function (r, s, a, f, l, u, v) { for (let p = v.collideIndexes.indexOf(r) !== -1, c = i(s, a, f, l, null, v), m = 0; m < c.length; m++)c[m].index = r, n(c[m], p); u && h(s - 1, a - 1, f + 2, l + 2, v) }; e.exports = o }, function (e, d, t) { const i = t(26); const h = function (n, o, r, s, a, f, l, u) { const v = i(r, s, a, f, l, u); return v.filter(n, o) }; e.exports = h }, function (e, d) { const t = function (i, h, n, o) { h === void 0 && (h = 0), n === void 0 && (n = !1); let r = 0; let s; let a; let f; if (n) { for (a = o.height - 1; a >= 0; a--) for (s = o.width - 1; s >= 0; s--) if (f = o.data[a][s], f && f.index === i) { if (r === h) return f; r += 1 } } else for (a = 0; a < o.height; a++) for (s = 0; s < o.width; s++) if (f = o.data[a][s], f && f.index === i) { if (r === h) return f; r += 1 } return null }; e.exports = t }, function (e, d, t) { const i = t(26); const h = function (n, o, r, s, a, f, l, u) { const v = i(r, s, a, f, l, u); return v.find(n, o) || null }; e.exports = h }, function (e, d, t) { const i = t(26); const h = function (n, o, r, s, a, f, l, u) { const v = i(r, s, a, f, l, u); v.forEach(n, o) }; e.exports = h }, function (e, d, t) { const i = t(29); const h = t(544); const n = t(545); const o = t(547); const r = t(1); const s = t(548); const a = function (f) { return f === i.ORTHOGONAL ? h : f === i.HEXAGONAL ? n : f === i.STAGGERED ? s : f === i.ISOMETRIC ? o : r }; e.exports = a }, function (e, d, t) { const i = t(158); const h = t(3); const n = new h(); const o = function (r, s, a, f, l) { return l.tilemapLayer.worldToTileXY(r, s, !0, n, f), i(n.x, n.y, a, l) }; e.exports = o }, function (e, d, t) { const i = t(483); const h = t(26); const n = t(484); const o = t(1); const r = t(3); const s = function (v, p) { return n.RectangleToTriangle(p, v) }; const a = new r(); const f = new r(); const l = new r(); const u = function (v, p, c, m) { if (v === void 0) return []; let g = o; v instanceof i.Circle ? g = n.CircleToRectangle : v instanceof i.Rectangle ? g = n.RectangleToRectangle : v instanceof i.Triangle ? g = s : v instanceof i.Line && (g = n.LineToRectangle), m.tilemapLayer.worldToTileXY(v.left, v.top, !0, f, c); const x = f.x; const y = f.y; m.tilemapLayer.worldToTileXY(v.right, v.bottom, !0, l, c); const T = Math.ceil(l.x); const S = Math.ceil(l.y); const E = Math.max(T - x, 1); const C = Math.max(S - y, 1); const P = h(x, y, E, C, p, m); let A = m.tileWidth; let M = m.tileHeight; m.tilemapLayer && (A *= m.tilemapLayer.scaleX, M *= m.tilemapLayer.scaleY); for (var L = [], F = new i.Rectangle(0, 0, A, M), I = 0; I < P.length; I++) { const G = P[I]; m.tilemapLayer.tileToWorldXY(G.x, G.y, a, c), F.x = a.x, F.y = a.y, g(v, F) && L.push(G) } return L }; e.exports = u }, function (e, d, t) { const i = t(29); const h = t(1); const n = t(253); const o = function (r) { return r === i.ORTHOGONAL ? n : h }; e.exports = o }, function (e, d, t) { const i = t(29); const h = t(550); const n = t(551); const o = t(1); const r = t(552); const s = t(553); const a = function (f) { return f === i.ORTHOGONAL ? s : f === i.ISOMETRIC ? n : f === i.HEXAGONAL ? h : f === i.STAGGERED ? r : o }; e.exports = a }, function (e, d, t) { const i = t(29); const h = t(554); const n = t(1); const o = t(555); const r = t(254); const s = function (a) { return a === i.ORTHOGONAL ? r : a === i.HEXAGONAL ? h : a === i.STAGGERED ? o : n }; e.exports = s }, function (e, d, t) { const i = t(29); const h = t(1); const n = t(255); const o = function (r) { return r === i.ORTHOGONAL ? n : h }; e.exports = o }, function (e, d, t) { const i = t(29); const h = t(556); const n = t(557); const o = t(1); const r = t(558); const s = t(559); const a = function (f) { return f === i.ORTHOGONAL ? s : f === i.ISOMETRIC ? n : f === i.HEXAGONAL ? h : f === i.STAGGERED ? r : o }; e.exports = a }, function (e, d, t) { const i = t(29); const h = t(560); const n = t(1); const o = t(561); const r = t(256); const s = function (a) { return a === i.ORTHOGONAL ? r : a === i.HEXAGONAL ? h : a === i.STAGGERED ? o : n }; e.exports = s }, function (e, d, t) { const i = t(562); const h = t(3); const n = new h(); const o = function (r, s, a, f) { f.tilemapLayer.worldToTileXY(r, s, !0, n, a); const l = n.x; const u = n.y; return i(l, u, f) }; e.exports = o }, function (e, d, t) { const i = t(257); const h = t(3); const n = new h(); const o = function (r, s, a, f, l, u) { return u.tilemapLayer.worldToTileXY(s, a, !0, n, l, u), i(r, n.x, n.y, f, u) }; e.exports = o }, function (e, d, t) { const i = t(63); const h = t(257); const n = function (o, r, s, a, f) { if (a === void 0 && (a = !0), !Array.isArray(o)) return null; Array.isArray(o[0]) || (o = [o]); for (var l = o.length, u = o[0].length, v = 0; v < l; v++) for (let p = 0; p < u; p++) { const c = o[v][p]; h(c, r + p, s + v, !1, f) }a && i(r - 1, s - 1, u + 2, l + 2, f) }; e.exports = n }, function (e, d, t) { const i = t(26); const h = t(210); const n = function (o, r, s, a, f, l) { let u; const v = i(o, r, s, a, {}, l); if (!f) for (f = [], u = 0; u < v.length; u++)f.indexOf(v[u].index) === -1 && f.push(v[u].index); for (u = 0; u < v.length; u++)v[u].index = h(f) }; e.exports = n }, function (e, d, t) { const i = t(563); const h = t(3); const n = new h(); const o = function (r, s, a, f, l, u) { return u.tilemapLayer.worldToTileXY(r, s, !0, n, l, u), i(n.x, n.y, a, f, u) }; e.exports = o }, function (e, d, t) { const i = t(26); const h = t(397); const n = new h(105, 210, 231, 150); const o = new h(243, 134, 48, 200); const r = new h(40, 39, 37, 150); const s = function (a, f, l) { f === void 0 && (f = {}); const u = f.tileColor !== void 0 ? f.tileColor : n; const v = f.collidingTileColor !== void 0 ? f.collidingTileColor : o; const p = f.faceColor !== void 0 ? f.faceColor : r; const c = i(0, 0, l.width, l.height, null, l); a.translateCanvas(l.tilemapLayer.x, l.tilemapLayer.y), a.scaleCanvas(l.tilemapLayer.scaleX, l.tilemapLayer.scaleY); for (let m = 0; m < c.length; m++) { const g = c[m]; let x = g.width; let y = g.height; let T = g.pixelX; let S = g.pixelY; const E = g.collides ? v : u; E !== null && (a.fillStyle(E.color, E.alpha / 255), a.fillRect(T, S, x, y)), T += 1, S += 1, x -= 2, y -= 2, p !== null && (a.lineStyle(1, p.color, p.alpha / 255), g.faceTop && a.lineBetween(T, S, T + x, S), g.faceRight && a.lineBetween(T + x, S, T + x, S + y), g.faceBottom && a.lineBetween(T, S + y, T + x, S + y), g.faceLeft && a.lineBetween(T, S, T, S + y)) } }; e.exports = s }, function (e, d, t) { const i = t(72); const h = t(63); const n = t(160); const o = function (r, s, a, f, l) { s === void 0 && (s = !0), a === void 0 && (a = !0), l === void 0 && (l = !0), Array.isArray(r) || (r = [r]); for (let u = 0; u < r.length; u++)n(r[u], s, f); if (l) for (let v = 0; v < f.height; v++) for (let p = 0; p < f.width; p++) { const c = f.data[v][p]; c && r.indexOf(c.index) !== -1 && i(c, s) }a && h(0, 0, f.width, f.height, f) }; e.exports = o }, function (e, d, t) { const i = t(72); const h = t(63); const n = t(160); const o = function (r, s, a, f, l, u) { if (a === void 0 && (a = !0), f === void 0 && (f = !0), u === void 0 && (u = !0), !(r > s)) { for (let v = r; v <= s; v++)n(v, a, l); if (u) for (let p = 0; p < l.height; p++) for (let c = 0; c < l.width; c++) { const m = l.data[p][c]; m && m.index >= r && m.index <= s && i(m, a) }f && h(0, 0, l.width, l.height, l) } }; e.exports = o }, function (e, d, t) { const i = t(72); const h = t(63); const n = t(160); const o = function (r, s, a, f) { s === void 0 && (s = !0), a === void 0 && (a = !0), Array.isArray(r) || (r = [r]); for (let l = 0; l < f.height; l++) for (let u = 0; u < f.width; u++) { const v = f.data[l][u]; v && r.indexOf(v.index) === -1 && (i(v, s), n(v.index, s, f)) }a && h(0, 0, f.width, f.height, f) }; e.exports = o }, function (e, d, t) { const i = t(72); const h = t(63); const n = t(126); const o = function (r, s, a, f) { s === void 0 && (s = !0), a === void 0 && (a = !0); for (let l = 0; l < f.height; l++) for (let u = 0; u < f.width; u++) { const v = f.data[l][u]; if (v) { for (const p in r) if (n(v.properties, p)) { let c = r[p]; Array.isArray(c) || (c = [c]); for (let m = 0; m < c.length; m++)v.properties[p] === c[m] && i(v, s) } } }a && h(0, 0, f.width, f.height, f) }; e.exports = o }, function (e, d, t) { const i = t(72); const h = t(63); const n = function (o, r, s) { o === void 0 && (o = !0), r === void 0 && (r = !0); for (let a = 0; a < s.height; a++) for (let f = 0; f < s.width; f++) { const l = s.data[a][f]; if (l) { const u = l.getCollisionGroup(); u && u.objects && u.objects.length > 0 && i(l, o) } }r && h(0, 0, s.width, s.height, s) }; e.exports = n }, function (e, d) { const t = function (i, h, n, o) { if (typeof i === 'number')o.callbacks[i] = h !== null ? { callback: h, callbackContext: n } : void 0; else for (let r = 0, s = i.length; r < s; r++)o.callbacks[i[r]] = h !== null ? { callback: h, callbackContext: n } : void 0 }; e.exports = t }, function (e, d, t) { const i = t(26); const h = function (n, o, r, s, a, f, l) { for (let u = i(n, o, r, s, null, l), v = 0; v < u.length; v++)u[v].setCollisionCallback(a, f) }; e.exports = h }, function (e, d, t) { const i = t(26); const h = t(131); const n = function (o, r, s, a, f) { const l = i(o, r, s, a, null, f); const u = l.map(function (p) { return p.index }); h(u); for (let v = 0; v < l.length; v++)l[v].index = u[v] }; e.exports = n }, function (e, d, t) { const i = t(26); const h = function (n, o, r, s, a, f, l) { for (let u = i(r, s, a, f, null, l), v = 0; v < u.length; v++)u[v] && (u[v].index === n ? u[v].index = o : u[v].index === o && (u[v].index = n)) }; e.exports = h }, function (e, d, t) { const i = t(26); const h = function (n, o, r, s, a, f) { if (a) { let l; const u = i(n, o, r, s, null, f); let v = 0; for (l = 0; l < a.length; l++)v += a[l].weight; if (!(v <= 0)) for (l = 0; l < u.length; l++) { for (var p = Math.random() * v, c = 0, m = -1, g = 0; g < a.length; g++) if (c += a[g].weight, p <= c) { const x = a[g].index; m = Array.isArray(x) ? x[Math.floor(Math.random() * x.length)] : x; break }u[l].index = m } } }; e.exports = h }, function (e, d, t) { e.exports = { FromOrientationString: t(258), Parse: t(564), Parse2DArray: t(259), ParseCSV: t(565), Impact: t(1454), Tiled: t(1455) } }, function (e, d) { const t = function (i, h) { for (let n = 0; n < i.length; n++) { const o = i[n]; let r = n; if (o.name && o.name !== '' && (r = o.name), Array.isArray(o.wangtiles) && o.wangtiles.length > 0) { const s = {}; const a = {}; var f; var l; var u; if (Array.isArray(o.edgecolors)) for (f = 0; f < o.edgecolors.length; f++)u = 1 + f, l = o.edgecolors[f], l.name !== '' && (s[u] = l.name); if (Array.isArray(o.cornercolors)) for (f = 0; f < o.cornercolors.length; f++)u = 1 + f, l = o.cornercolors[f], l.name !== '' && (a[u] = l.name); if (Array.isArray(o.colors)) for (f = 0; f < o.colors.length; f++)l = o.colors[f], u = 1 + f, l.name !== '' && (s[u] = a[u] = l.name); for (let v = [s, a, s, a, s, a, s, a], p = 0; p < o.wangtiles.length; p++) { const c = o.wangtiles[p]; let m = h[c.tileid] || (h[c.tileid] = {}); m = m.wangid || (m.wangid = {}); for (var g = [], x = 0; x < Math.min(v.length, c.wangid.length); x++) { if (l = c.wangid[x], l === 0) { g.push(void 0); continue } const y = v[x][l]; if (y !== void 0) { g.push(y); continue }g.push(l) }m[r] = g } } } }; e.exports = t }, function (e, d, t) { e.exports = { ParseTileLayers: t(578), ParseTilesets: t(579), ParseWeltmeister: t(577) } }, function (e, d, t) { e.exports = { AssignTileProperties: t(567), Base64Decode: t(574), BuildTilesetIndex: t(568), CreateGroupLayer: t(161), ParseGID: t(261), ParseImageLayers: t(569), ParseJSONTiled: t(566), ParseObject: t(260), ParseObjectLayers: t(570), ParseTileLayers: t(573), ParseTilesets: t(575) } }, function (e, d, t) { let i = t(1); let h = t(1); i = t(1457), h = t(1458), e.exports = { renderWebGL: i, renderCanvas: h } }, function (e, d, t) { const i = t(12); const h = function (n, o, r) { const s = o.cull(r); const a = s.length; const f = r.alpha * o.alpha; if (!(a === 0 || f <= 0)) { const l = o.gidMap; const u = n.pipelines.set(o.pipeline, o); const v = i.getTintAppendFloatAlpha; const p = o.scrollFactorX; const c = o.scrollFactorY; const m = o.x; const g = o.y; const x = o.scaleX; const y = o.scaleY; n.pipelines.preBatch(o); for (let T = 0; T < a; T++) { const S = s[T]; const E = l[S.index]; if (E) { const C = E.getTileTextureCoordinates(S.index); if (C !== null) { const P = E.glTexture; const A = u.setTexture2D(P, o); const M = E.tileWidth; const L = E.tileHeight; const F = C.x; const I = C.y; const G = E.tileWidth * 0.5; const U = E.tileHeight * 0.5; const Y = v(S.tint, f * S.alpha); u.batchTexture(o, P, P.width, P.height, m + (G + S.pixelX) * x, g + (U + S.pixelY) * y, S.width, S.height, x, y, S.rotation, S.flipX, S.flipY, p, c, G, U, F, I, M, L, Y, Y, Y, Y, !1, 0, 0, r, null, !0, A) } } }n.pipelines.postBatch(o) } }; e.exports = h }, function (e, d, t) { const i = t(25); const h = new i(); const n = new i(); const o = new i(); const r = function (s, a, f, l) { const u = a.cull(f); const v = u.length; const p = f.alpha * a.alpha; if (!(v === 0 || p <= 0)) { const c = h; const m = n; const g = o; m.applyITRS(a.x, a.y, a.rotation, a.scaleX, a.scaleY), c.copyFrom(f.matrix); const x = s.currentContext; const y = a.gidMap; x.save(), l ? (c.multiplyWithOffset(l, -f.scrollX * a.scrollFactorX, -f.scrollY * a.scrollFactorY), m.e = a.x, m.f = a.y, c.multiply(m, g), g.copyToContext(x)) : (m.e -= f.scrollX * a.scrollFactorX, m.f -= f.scrollY * a.scrollFactorY, m.copyToContext(x)), (!s.antialias || a.scaleX > 1 || a.scaleY > 1) && (x.imageSmoothingEnabled = !1); for (let T = 0; T < v; T++) { const S = u[T]; const E = y[S.index]; if (E) { const C = E.image.getSourceImage(); const P = E.getTileTextureCoordinates(S.index); if (P !== null) { const A = E.tileWidth; const M = E.tileHeight; const L = A * 0.5; const F = M * 0.5; x.save(), x.translate(S.pixelX + L, S.pixelY + F), S.rotation !== 0 && x.rotate(S.rotation), (S.flipX || S.flipY) && x.scale(S.flipX ? -1 : 1, S.flipY ? -1 : 1), x.globalAlpha = p * S.alpha, x.drawImage(C, P.x, P.y, A, M, -L, -F, A, M), x.restore() } } }x.restore() } }; e.exports = r }, function (e, d, t) { const i = t(16); const h = t(262); i.register('tilemap', function (n) { const o = n !== void 0 ? n : {}; return h(this.scene, o.key, o.tileWidth, o.tileHeight, o.width, o.height, o.data, o.insertNull) }) }, function (e, d, t) { const i = t(5); const h = t(262); i.register('tilemap', function (n, o, r, s, a, f, l) { return n === null && (n = void 0), o === null && (o = void 0), r === null && (r = void 0), s === null && (s = void 0), a === null && (a = void 0), h(this.scene, n, o, r, s, a, f, l) }) }, function (e, d, t) { e.exports = { Clock: t(1462), TimerEvent: t(582) } }, function (e, d, t) { const i = t(0); const h = t(24); const n = t(20); const o = t(582); const r = t(93); const s = new i({ initialize: function (f) { this.scene = f, this.systems = f.sys, this.now = 0, this.timeScale = 1, this.paused = !1, this._active = [], this._pendingInsertion = [], this._pendingRemoval = [], f.sys.events.once(n.BOOT, this.boot, this), f.sys.events.on(n.START, this.start, this) }, boot: function () { this.now = this.systems.game.loop.time, this.systems.events.once(n.DESTROY, this.destroy, this) }, start: function () { const a = this.systems.events; a.on(n.PRE_UPDATE, this.preUpdate, this), a.on(n.UPDATE, this.update, this), a.once(n.SHUTDOWN, this.shutdown, this) }, addEvent: function (a) { let f; return a instanceof o ? (f = a, this.removeEvent(f), f.elapsed = f.startAt, f.hasDispatched = !1, f.repeatCount = f.repeat === -1 || f.loop ? 999999999999 : f.repeat) : f = new o(a), this._pendingInsertion.push(f), f }, delayedCall: function (a, f, l, u) { return this.addEvent({ delay: a, callback: f, args: l, callbackScope: u }) }, clearPendingEvents: function () { return this._pendingInsertion = [], this }, removeEvent: function (a) { Array.isArray(a) || (a = [a]); for (let f = 0; f < a.length; f++) { const l = a[f]; r(this._pendingRemoval, l), r(this._pendingInsertion, l), r(this._active, l) } return this }, removeAllEvents: function () { return this._pendingRemoval = this._pendingRemoval.concat(this._active), this }, preUpdate: function () { const a = this._pendingRemoval.length; const f = this._pendingInsertion.length; if (!(a === 0 && f === 0)) { let l, u; for (l = 0; l < a; l++) { u = this._pendingRemoval[l]; const v = this._active.indexOf(u); v > -1 && this._active.splice(v, 1), u.destroy() } for (l = 0; l < f; l++)u = this._pendingInsertion[l], this._active.push(u); this._pendingRemoval.length = 0, this._pendingInsertion.length = 0 } }, update: function (a, f) { if (this.now = a, !this.paused) { f *= this.timeScale; for (let l = 0; l < this._active.length; l++) { const u = this._active[l]; if (!u.paused && (u.elapsed += f * u.timeScale, u.elapsed >= u.delay)) { const v = u.elapsed - u.delay; u.elapsed = u.delay, !u.hasDispatched && u.callback && (u.hasDispatched = !0, u.callback.apply(u.callbackScope, u.args)), u.repeatCount > 0 ? (u.repeatCount--, u.elapsed = v, u.hasDispatched = !1) : this._pendingRemoval.push(u) } } } }, shutdown: function () { let a; for (a = 0; a < this._pendingInsertion.length; a++) this._pendingInsertion[a].destroy(); for (a = 0; a < this._active.length; a++) this._active[a].destroy(); for (a = 0; a < this._pendingRemoval.length; a++) this._pendingRemoval[a].destroy(); this._active.length = 0, this._pendingRemoval.length = 0, this._pendingInsertion.length = 0; const f = this.systems.events; f.off(n.PRE_UPDATE, this.preUpdate, this), f.off(n.UPDATE, this.update, this), f.off(n.SHUTDOWN, this.shutdown, this) }, destroy: function () { this.shutdown(), this.scene.sys.events.off(n.START, this.start, this), this.scene = null, this.systems = null } }); h.register('Clock', s, 'time'), e.exports = s }, function (e, d, t) { const i = t(100); const h = t(17); let n = { Builders: t(1464), Events: t(267), TweenManager: t(1480), Tween: t(266), TweenData: t(268), Timeline: t(588) }; n = h(!1, n, i), e.exports = n }, function (e, d, t) { e.exports = { GetBoolean: t(99), GetEaseFunction: t(80), GetNewValue: t(162), GetProps: t(583), GetTargets: t(263), GetTweens: t(584), GetValueOp: t(264), NumberTweenBuilder: t(585), StaggerBuilder: t(586), TimelineBuilder: t(587), TweenBuilder: t(163) } }, function (e, d) { e.exports = ['callbackScope', 'completeDelay', 'delay', 'duration', 'ease', 'easeParams', 'flipX', 'flipY', 'hold', 'loop', 'loopDelay', 'offset', 'onActive', 'onActiveParams', 'onActiveScope', 'onComplete', 'onCompleteParams', 'onCompleteScope', 'onLoop', 'onLoopParams', 'onLoopScope', 'onRepeat', 'onRepeatParams', 'onRepeatScope', 'onStart', 'onStartParams', 'onStartScope', 'onStop', 'onStopParams', 'onStopScope', 'onUpdate', 'onUpdateParams', 'onUpdateScope', 'onYoyo', 'onYoyoParams', 'onYoyoScope', 'paused', 'props', 'repeat', 'repeatDelay', 'targets', 'useFrames', 'yoyo'] }, function (e, d) { e.exports = 'complete' }, function (e, d) { e.exports = 'loop' }, function (e, d) { e.exports = 'pause' }, function (e, d) { e.exports = 'resume' }, function (e, d) { e.exports = 'start' }, function (e, d) { e.exports = 'update' }, function (e, d) { e.exports = 'active' }, function (e, d) { e.exports = 'complete' }, function (e, d) { e.exports = 'loop' }, function (e, d) { e.exports = 'repeat' }, function (e, d) { e.exports = 'start' }, function (e, d) { e.exports = 'stop' }, function (e, d) { e.exports = 'update' }, function (e, d) { e.exports = 'yoyo' }, function (e, d, t) { const i = t(93); const h = t(0); const n = t(585); const o = t(24); const r = t(20); const s = t(586); const a = t(587); const f = t(100); const l = t(163); const u = new h({ initialize: function (p) { this.scene = p, this.systems = p.sys, this.timeScale = 1, this._add = [], this._pending = [], this._active = [], this._destroy = [], this._toProcess = 0, p.sys.events.once(r.BOOT, this.boot, this), p.sys.events.on(r.START, this.start, this) }, boot: function () { this.systems.events.once(r.DESTROY, this.destroy, this) }, start: function () { const v = this.systems.events; v.on(r.PRE_UPDATE, this.preUpdate, this), v.on(r.UPDATE, this.update, this), v.once(r.SHUTDOWN, this.shutdown, this), this.timeScale = 1 }, createTimeline: function (v) { return a(this, v) }, timeline: function (v) { const p = a(this, v); return p.paused || (this._add.push(p), this._toProcess++), p }, create: function (v) { return l(this, v) }, add: function (v) { const p = l(this, v); return this._add.push(p), this._toProcess++, p }, existing: function (v) { return this._add.push(v), this._toProcess++, this }, addCounter: function (v) { const p = n(this, v); return this._add.push(p), this._toProcess++, p }, stagger: function (v, p) { return s(v, p) }, preUpdate: function () { if (this._toProcess !== 0) { let v = this._destroy; const p = this._active; const c = this._pending; let m; let g; for (m = 0; m < v.length; m++) { g = v[m]; let x = p.indexOf(g); x === -1 ? (x = c.indexOf(g), x > -1 && (g.state = f.REMOVED, c.splice(x, 1))) : (g.state = f.REMOVED, p.splice(x, 1)) } for (v.length = 0, v = this._add, m = 0; m < v.length; m++)g = v[m], g.state === f.PENDING_ADD && (g.init() ? (g.play(), this._active.push(g)) : this._pending.push(g)); v.length = 0, this._toProcess = 0 } }, update: function (v, p) { const c = this._active; let m; p *= this.timeScale; for (let g = 0; g < c.length; g++)m = c[g], m.update(v, p) && (this._destroy.push(m), this._toProcess++) }, remove: function (v) { return i(this._add, v), i(this._pending, v), i(this._active, v), i(this._destroy, v), v.state = f.REMOVED, this }, makeActive: function (v) { if (this._add.indexOf(v) !== -1 || this._active.indexOf(v) !== -1) return this; const p = this._pending.indexOf(v); return p !== -1 && this._pending.splice(p, 1), this._add.push(v), v.state = f.PENDING_ADD, this._toProcess++, this }, each: function (v, p) { for (var c = [null], m = 1; m < arguments.length; m++)c.push(arguments[m]); for (const g in this.list)c[0] = this.list[g], v.apply(p, c) }, getAllTweens: function () { for (var v = this._active, p = [], c = 0; c < v.length; c++)p.push(v[c]); return p }, getGlobalTimeScale: function () { return this.timeScale }, getTweensOf: function (v, p) { p === void 0 && (p = !1); let c = this._active; let m; const g = []; let x; let y; for (Array.isArray(v) || (v = [v]), x = 0; x < c.length; x++) for (m = c[x], y = 0; y < v.length; y++)m.hasTarget(v[y]) && g.push(m); if (p) for (c = this._pending, x = 0; x < c.length; x++) for (m = c[x], y = 0; y < v.length; y++)m.hasTarget(v[y]) && g.push(m); return g }, isTweening: function (v) { for (var p = this._active, c, m = 0; m < p.length; m++) if (c = p[m], c.hasTarget(v) && c.isPlaying()) return !0; return !1 }, killAll: function () { for (let v = this.getAllTweens(), p = 0; p < v.length; p++)v[p].stop(); return this }, killTweensOf: function (v) { for (let p = this.getTweensOf(v), c = 0; c < p.length; c++)p[c].stop(); return this }, pauseAll: function () { for (let v = this._active, p = 0; p < v.length; p++)v[p].pause(); return this }, resumeAll: function () { for (let v = this._active, p = 0; p < v.length; p++)v[p].resume(); return this }, setGlobalTimeScale: function (v) { return this.timeScale = v, this }, shutdown: function () { this.killAll(), this._add = [], this._pending = [], this._active = [], this._destroy = [], this._toProcess = 0; const v = this.systems.events; v.off(r.PRE_UPDATE, this.preUpdate, this), v.off(r.UPDATE, this.update, this), v.off(r.SHUTDOWN, this.shutdown, this) }, destroy: function () { this.shutdown(), this.scene.sys.events.off(r.START, this.start, this), this.scene = null, this.systems = null } }); o.register('TweenManager', u, 'tweens'), e.exports = u }, function (e, d, t) { e.exports = { Array: t(208), Base64: t(1482), Objects: t(1484), String: t(1488), NOOP: t(1) } }, function (e, d, t) { e.exports = { ArrayBufferToBase64: t(1483), Base64ToArrayBuffer: t(433) } }, function (e, d) { const t = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'; const i = function (h, n) { for (var o = new Uint8Array(h), r = o.length, s = n ? 'data:' + n + ';base64,' : '', a = 0; a < r; a += 3)s += t[o[a] >> 2], s += t[(o[a] & 3) << 4 | o[a + 1] >> 4], s += t[(o[a + 1] & 15) << 2 | o[a + 2] >> 6], s += t[o[a + 2] & 63]; return r % 3 == 2 ? s = s.substring(0, s.length - 1) + '=' : r % 3 == 1 && (s = s.substring(0, s.length - 2) + '=='), s }; e.exports = i }, function (e, d, t) { e.exports = { Clone: t(77), DeepCopy: t(175), Extend: t(17), GetAdvancedValue: t(13), GetFastValue: t(2), GetMinMaxValue: t(1485), GetValue: t(6), HasAll: t(1486), HasAny: t(455), HasValue: t(126), IsPlainObject: t(7), Merge: t(127), MergeRight: t(1487), Pick: t(571), SetValue: t(478) } }, function (e, d, t) { const i = t(6); const h = t(18); const n = function (o, r, s, a, f) { f === void 0 && (f = s); const l = i(o, r, f); return h(l, s, a) }; e.exports = n }, function (e, d) { const t = function (i, h) { for (let n = 0; n < h.length; n++) if (!i.hasOwnProperty(h[n])) return !1; return !0 }; e.exports = t }, function (e, d, t) { const i = t(77); const h = function (n, o) { const r = i(n); for (const s in o)r.hasOwnProperty(s) && (r[s] = o[s]); return r }; e.exports = h }, function (e, d, t) { e.exports = { Format: t(1489), Pad: t(186), RemoveAt: t(1490), Reverse: t(1491), UppercaseFirst: t(205), UUID: t(222) } }, function (e, d) { const t = function (i, h) { return i.replace(/%([0-9]+)/g, function (n, o) { return h[Number(o) - 1] }) }; e.exports = t }, function (e, d) { const t = function (i, h) { return h === 0 ? i.slice(1) : i.slice(0, h - 1) + i.slice(h) }; e.exports = t }, function (e, d) { const t = function (i) { return i.split('').reverse().join('') }; e.exports = t }, function (e, d, t) { e.exports = { SoundManagerCreator: t(426), Events: t(70), BaseSound: t(146), BaseSoundManager: t(145), WebAudioSound: t(434), WebAudioSoundManager: t(432), HTML5AudioSound: t(429), HTML5AudioSoundManager: t(427), NoAudioSound: t(431), NoAudioSoundManager: t(430) } }, function (e, d, t) { e.exports = { Arcade: t(1366), Matter: t(1494) } }, function (e, d, t) { e.exports = { BodyBounds: t(1392), Components: t(249), Events: t(272), Factory: t(1394), MatterGameObject: t(1395), Image: t(1396), Matter: t(594), MatterPhysics: t(1524), PolyDecomp: t(1393), Sprite: t(1397), TileBody: t(593), PhysicsEditorParser: t(589), PhysicsJSONParser: t(590), PointerConstraint: t(1398), World: t(1402) } }, function (e, d) { const t = { setBounce: function (i) { return this.body.restitution = i, this } }; e.exports = t }, function (e, d) { const t = { setCollisionCategory: function (i) { return this.body.collisionFilter.category = i, this }, setCollisionGroup: function (i) { return this.body.collisionFilter.group = i, this }, setCollidesWith: function (i) { let h = 0; if (!Array.isArray(i))h = i; else for (let n = 0; n < i.length; n++)h |= i[n]; return this.body.collisionFilter.mask = h, this }, setOnCollide: function (i) { return this.body.onCollideCallback = i, this }, setOnCollideEnd: function (i) { return this.body.onCollideEndCallback = i, this }, setOnCollideActive: function (i) { return this.body.onCollideActiveCallback = i, this }, setOnCollideWith: function (i, h) { Array.isArray(i) || (i = [i]); for (let n = 0; n < i.length; n++) { const o = i[n].hasOwnProperty('body') ? i[n].body : i[n]; this.body.setOnCollideWith(o, h) } return this } }; e.exports = t }, function (e, d, t) { const i = t(41); const h = { applyForce: function (n) { return this._tempVec2.set(this.body.position.x, this.body.position.y), i.applyForce(this.body, this._tempVec2, n), this }, applyForceFrom: function (n, o) { return i.applyForce(this.body, n, o), this }, thrust: function (n) { const o = this.body.angle; return this._tempVec2.set(n * Math.cos(o), n * Math.sin(o)), i.applyForce(this.body, { x: this.body.position.x, y: this.body.position.y }, this._tempVec2), this }, thrustLeft: function (n) { const o = this.body.angle - Math.PI / 2; return this._tempVec2.set(n * Math.cos(o), n * Math.sin(o)), i.applyForce(this.body, { x: this.body.position.x, y: this.body.position.y }, this._tempVec2), this }, thrustRight: function (n) { const o = this.body.angle + Math.PI / 2; return this._tempVec2.set(n * Math.cos(o), n * Math.sin(o)), i.applyForce(this.body, { x: this.body.position.x, y: this.body.position.y }, this._tempVec2), this }, thrustBack: function (n) { const o = this.body.angle - Math.PI; return this._tempVec2.set(n * Math.cos(o), n * Math.sin(o)), i.applyForce(this.body, { x: this.body.position.x, y: this.body.position.y }, this._tempVec2), this } }; e.exports = h }, function (e, d) { const t = { setFriction: function (i, h, n) { return this.body.friction = i, h !== void 0 && (this.body.frictionAir = h), n !== void 0 && (this.body.frictionStatic = n), this }, setFrictionAir: function (i) { return this.body.frictionAir = i, this }, setFrictionStatic: function (i) { return this.body.frictionStatic = i, this } }; e.exports = t }, function (e, d) { const t = { setIgnoreGravity: function (i) { return this.body.ignoreGravity = i, this } }; e.exports = t }, function (e, d, t) { const i = t(41); const h = t(3); const n = { setMass: function (o) { return i.setMass(this.body, o), this }, setDensity: function (o) { return i.setDensity(this.body, o), this }, centerOfMass: { get: function () { return new h(this.body.centerOfMass.x, this.body.centerOfMass.y) } } }; e.exports = n }, function (e, d) { const t = { setSensor: function (i) { return this.body.isSensor = i, this }, isSensor: function () { return this.body.isSensor } }; e.exports = t }, function (e, d, t) { const i = t(86); const h = t(41); const n = t(124); const o = t(2); const r = t(589); const s = t(590); const a = t(64); const f = { setRectangle: function (l, u, v) { return this.setBody({ type: 'rectangle', width: l, height: u }, v) }, setCircle: function (l, u) { return this.setBody({ type: 'circle', radius: l }, u) }, setPolygon: function (l, u, v) { return this.setBody({ type: 'polygon', sides: u, radius: l }, v) }, setTrapezoid: function (l, u, v, p) { return this.setBody({ type: 'trapezoid', width: l, height: u, slope: v }, p) }, setExistingBody: function (l, u) { u === void 0 && (u = !0), this.body && this.world.remove(this.body, !0), this.body = l; for (let v = 0; v < l.parts.length; v++)l.parts[v].gameObject = this; const p = this; if (l.destroy = function () { p.world.remove(p.body, !0), p.body.gameObject = null }, u && (this.world.has(l) && this.world.remove(l, !0), this.world.add(l)), this._originComponent) { const c = l.render.sprite.xOffset; const m = l.render.sprite.yOffset; const g = l.centerOfMass.x; const x = l.centerOfMass.y; if (n(g, 0.5) && n(x, 0.5)) this.setOrigin(c + 0.5, m + 0.5); else { const y = l.centerOffset.x; const T = l.centerOffset.y; this.setOrigin(c + y / this.displayWidth, m + T / this.displayHeight) } } return this }, setBody: function (l, u) { if (!l) return this; let v; typeof l === 'string' && (l = { type: l }); const p = o(l, 'type', 'rectangle'); const c = o(l, 'x', this._tempVec2.x); const m = o(l, 'y', this._tempVec2.y); const g = o(l, 'width', this.width); const x = o(l, 'height', this.height); switch (p) { case 'rectangle':v = i.rectangle(c, m, g, x, u); break; case 'circle':var y = o(l, 'radius', Math.max(g, x) / 2); var T = o(l, 'maxSides', 25); v = i.circle(c, m, y, u, T); break; case 'trapezoid':var S = o(l, 'slope', 0.5); v = i.trapezoid(c, m, g, x, S, u); break; case 'polygon':var E = o(l, 'sides', 5); var C = o(l, 'radius', Math.max(g, x) / 2); v = i.polygon(c, m, E, C, u); break; case 'fromVertices':case 'fromVerts':var P = o(l, 'verts', null); if (P) if (typeof P === 'string' && (P = a.fromPath(P)), this.body && !this.body.hasOwnProperty('temp'))h.setVertices(this.body, P), v = this.body; else { const A = o(l, 'flagInternal', !1); const M = o(l, 'removeCollinear', 0.01); const L = o(l, 'minimumArea', 10); v = i.fromVertices(c, m, P, u, A, M, L) } break; case 'fromPhysicsEditor':v = r.parseBody(c, m, l, u); break; case 'fromPhysicsTracer':v = s.parseBody(c, m, l, u); break } return v && this.setExistingBody(v, l.addToWorld), this } }; e.exports = f }, function (e, d, t) { const i = t(272); const h = t(165); const n = t(166); const o = { setToSleep: function () { return h.set(this.body, !0), this }, setAwake: function () { return h.set(this.body, !1), this }, setSleepThreshold: function (r) { return r === void 0 && (r = 60), this.body.sleepThreshold = r, this }, setSleepEvents: function (r, s) { return this.setSleepStartEvent(r), this.setSleepEndEvent(s), this }, setSleepStartEvent: function (r) { if (r) { const s = this.world; n.on(this.body, 'sleepStart', function (a) { s.emit(i.SLEEP_START, a, this) }) } else n.off(this.body, 'sleepStart'); return this }, setSleepEndEvent: function (r) { if (r) { const s = this.world; n.on(this.body, 'sleepEnd', function (a) { s.emit(i.SLEEP_END, a, this) }) } else n.off(this.body, 'sleepEnd'); return this } }; e.exports = o }, function (e, d) { e.exports = 'afteradd' }, function (e, d) { e.exports = 'afterremove' }, function (e, d) { e.exports = 'afterupdate' }, function (e, d) { e.exports = 'beforeadd' }, function (e, d) { e.exports = 'beforeremove' }, function (e, d) { e.exports = 'beforeupdate' }, function (e, d) { e.exports = 'collisionactive' }, function (e, d) { e.exports = 'collisionend' }, function (e, d) { e.exports = 'collisionstart' }, function (e, d) { e.exports = 'dragend' }, function (e, d) { e.exports = 'drag' }, function (e, d) { e.exports = 'dragstart' }, function (e, d) { e.exports = 'pause' }, function (e, d) { e.exports = 'resume' }, function (e, d) { e.exports = 'sleepend' }, function (e, d) { e.exports = 'sleepstart' }, function (e, d, t) { const i = t(41); const h = { setStatic: function (n) { return i.setStatic(this.body, n), this }, isStatic: function () { return this.body.isStatic } }; e.exports = h }, function (e, d, t) { const i = t(41); const h = t(14); const n = t(269); const o = t(270); const r = 4; const s = { x: { get: function () { return this.body.position.x }, set: function (a) { this._tempVec2.set(a, this.y), i.setPosition(this.body, this._tempVec2) } }, y: { get: function () { return this.body.position.y }, set: function (a) { this._tempVec2.set(this.x, a), i.setPosition(this.body, this._tempVec2) } }, scaleX: { get: function () { return this._scaleX }, set: function (a) { const f = 1 / this._scaleX; const l = 1 / this._scaleY; this._scaleX = a, this._scaleX === 0 ? this.renderFlags &= ~r : this.renderFlags |= r, i.scale(this.body, f, l), i.scale(this.body, a, this._scaleY) } }, scaleY: { get: function () { return this._scaleY }, set: function (a) { const f = 1 / this._scaleX; const l = 1 / this._scaleY; this._scaleY = a, this._scaleY === 0 ? this.renderFlags &= ~r : this.renderFlags |= r, i.scale(this.body, f, l), i.scale(this.body, this._scaleX, a) } }, angle: { get: function () { return o(this.body.angle * h.RAD_TO_DEG) }, set: function (a) { this.rotation = o(a) * h.DEG_TO_RAD } }, rotation: { get: function () { return this.body.angle }, set: function (a) { this._rotation = n(a), i.setAngle(this.body, this._rotation) } }, setPosition: function (a, f) { return a === void 0 && (a = 0), f === void 0 && (f = a), this._tempVec2.set(a, f), i.setPosition(this.body, this._tempVec2), this }, setRotation: function (a) { return a === void 0 && (a = 0), this._rotation = n(a), i.setAngle(this.body, a), this }, setFixedRotation: function () { return i.setInertia(this.body, 1 / 0), this }, setAngle: function (a) { return a === void 0 && (a = 0), this.angle = a, i.setAngle(this.body, this.rotation), this }, setScale: function (a, f, l) { a === void 0 && (a = 1), f === void 0 && (f = a); const u = 1 / this._scaleX; const v = 1 / this._scaleY; return this._scaleX = a, this._scaleY = f, i.scale(this.body, u, v, l), i.scale(this.body, a, f, l), this } }; e.exports = s }, function (e, d, t) { const i = t(41); const h = { setAngularVelocity: function (n) { return i.setAngularVelocity(this.body, n), this }, setVelocityX: function (n) { return this._tempVec2.set(n, this.body.velocity.y), i.setVelocity(this.body, this._tempVec2), this }, setVelocityY: function (n) { return this._tempVec2.set(this.body.velocity.x, n), i.setVelocity(this.body, this._tempVec2), this }, setVelocity: function (n, o) { return this._tempVec2.set(n, o), i.setVelocity(this.body, this._tempVec2), this } }; e.exports = h }, function (e, d, t) { const i = {}; e.exports = i; const h = t(118); const n = t(32); (function () { i.create = function (o) { const r = { extended: !1, narrowDetections: 0, narrowphaseTests: 0, narrowReuse: 0, narrowReuseCount: 0, midphaseTests: 0, broadphaseTests: 0, narrowEff: 1e-4, midEff: 1e-4, broadEff: 1e-4, collisions: 0, buckets: 0, bodies: 0, pairs: 0 }; return n.extend(r, !1, o) }, i.reset = function (o) { o.extended && (o.narrowDetections = 0, o.narrowphaseTests = 0, o.narrowReuse = 0, o.narrowReuseCount = 0, o.midphaseTests = 0, o.broadphaseTests = 0, o.narrowEff = 0, o.midEff = 0, o.broadEff = 0, o.collisions = 0, o.buckets = 0, o.pairs = 0, o.bodies = 0) }, i.update = function (o, r) { if (o.extended) { const s = r.world; const a = h.allBodies(s); o.collisions = o.narrowDetections, o.pairs = r.pairs.list.length, o.bodies = a.length, o.midEff = (o.narrowDetections / (o.midphaseTests || 1)).toFixed(2), o.narrowEff = (o.narrowDetections / (o.narrowphaseTests || 1)).toFixed(2), o.broadEff = (1 - o.broadphaseTests / (a.length || 1)).toFixed(2), o.narrowReuse = (o.narrowReuseCount / (o.narrowphaseTests || 1)).toFixed(2) } } })() }, function (e, d, t) { const i = t(123); const h = t(271); const n = t(86); const o = t(41); const r = t(1392); const s = t(84); const a = t(0); const f = t(118); const l = t(591); const u = t(128); const v = t(273); const p = t(50); const c = t(1394); const m = t(2); const g = t(6); const x = t(597); const y = t(1525); const T = t(1526); const S = t(1399); const E = t(1527); const C = t(127); const P = t(250); const A = t(598); const M = t(595); const L = t(24); const F = t(1400); const I = t(599); const G = t(274); const U = t(20); const Y = t(592); const X = t(83); const O = t(64); const R = t(1402); const D = new a({ initialize: function (N) { this.scene = N, this.systems = N.sys, this.config = this.getConfig(), this.world, this.add, this.bodyBounds, this.body = o, this.composite = f, this.detector = v, this.grid = x, this.pair = P, this.pairs = A, this.query = F, this.resolver = I, this.sat = G, this.constraint = u, this.bodies = n, this.composites = l, this.axes = h, this.bounds = s, this.svg = Y, this.vector = X, this.vertices = O, this.verts = O, this._tempVec2 = X.create(), g(this.config, 'plugins.collisionevents', !0) && this.enableCollisionEventsPlugin(), g(this.config, 'plugins.attractors', !1) && this.enableAttractorPlugin(), g(this.config, 'plugins.wrap', !1) && this.enableWrapPlugin(), I._restingThresh = g(this.config, 'restingThresh', 4), I._restingThreshTangent = g(this.config, 'restingThreshTangent', 6), I._positionDampen = g(this.config, 'positionDampen', 0.9), I._positionWarming = g(this.config, 'positionWarming', 0.8), I._frictionNormalMultiplier = g(this.config, 'frictionNormalMultiplier', 5), N.sys.events.once(U.BOOT, this.boot, this), N.sys.events.on(U.START, this.start, this) }, boot: function () { this.world = new R(this.scene, this.config), this.add = new c(this.world), this.bodyBounds = new r(), this.systems.events.once(U.DESTROY, this.destroy, this) }, start: function () { this.world || (this.world = new R(this.scene, this.config), this.add = new c(this.world)); const B = this.systems.events; B.on(U.UPDATE, this.world.update, this.world), B.on(U.POST_UPDATE, this.world.postUpdate, this.world), B.once(U.SHUTDOWN, this.shutdown, this) }, getConfig: function () { const B = this.systems.game.config.physics; const N = this.systems.settings.physics; const w = C(m(N, 'matter', {}), m(B, 'matter', {})); return w }, enableAttractorPlugin: function () { return M.register(y), M.use(S, y), this }, enableWrapPlugin: function () { return M.register(E), M.use(S, E), this }, enableCollisionEventsPlugin: function () { return M.register(T), M.use(S, T), this }, pause: function () { return this.world.pause() }, resume: function () { return this.world.resume() }, set60Hz: function () { return this.world.getDelta = this.world.update60Hz, this.world.autoUpdate = !0, this }, set30Hz: function () { return this.world.getDelta = this.world.update30Hz, this.world.autoUpdate = !0, this }, step: function (B, N) { this.world.step(B, N) }, containsPoint: function (B, N, w) { B = this.getMatterBodies(B); const z = X.create(N, w); const V = F.point(B, z); return V.length > 0 }, intersectPoint: function (B, N, w) { w = this.getMatterBodies(w); const z = X.create(B, N); const V = []; const W = F.point(w, z); return W.forEach(function (H) { V.indexOf(H) === -1 && V.push(H) }), V }, intersectRect: function (B, N, w, z, V, W) { V === void 0 && (V = !1), W = this.getMatterBodies(W); const H = { min: { x: B, y: N }, max: { x: B + w, y: N + z } }; const K = []; const Q = F.region(W, H, V); return Q.forEach(function (J) { K.indexOf(J) === -1 && K.push(J) }), K }, intersectRay: function (B, N, w, z, V, W) { V === void 0 && (V = 1), W = this.getMatterBodies(W); for (var H = [], K = F.ray(W, X.create(B, N), X.create(w, z), V), Q = 0; Q < K.length; Q++)H.push(K[Q].body); return H }, intersectBody: function (B, N) { N = this.getMatterBodies(N); for (var w = [], z = F.collides(B, N), V = 0; V < z.length; V++) { const W = z[V]; W.bodyA === B ? w.push(W.bodyB) : w.push(W.bodyA) } return w }, overlap: function (B, N, w, z, V) { w === void 0 && (w = null), z === void 0 && (z = null), V === void 0 && (V = w), Array.isArray(B) || (B = [B]), B = this.getMatterBodies(B), N = this.getMatterBodies(N); for (var W = !1, H = 0; H < B.length; H++) for (let K = B[H], Q = F.collides(K, N), J = 0; J < Q.length; J++) { const q = Q[J]; const j = q.bodyA.id === K.id ? q.bodyB : q.bodyA; if (!z || z.call(V, K, j, q)) { if (W = !0, w)w.call(V, K, j, q); else if (!z) return !0 } } return W }, setCollisionCategory: function (B, N) { return B = this.getMatterBodies(B), B.forEach(function (w) { w.collisionFilter.category = N }), this }, setCollisionGroup: function (B, N) { return B = this.getMatterBodies(B), B.forEach(function (w) { w.collisionFilter.group = N }), this }, setCollidesWith: function (B, N) { B = this.getMatterBodies(B); let w = 0; if (!Array.isArray(N))w = N; else for (let z = 0; z < N.length; z++)w |= N[z]; return B.forEach(function (V) { V.collisionFilter.mask = w }), this }, getMatterBodies: function (B) { if (!B) return this.world.getAllBodies(); Array.isArray(B) || (B = [B]); for (var N = [], w = 0; w < B.length; w++) { const z = B[w].hasOwnProperty('body') ? B[w].body : B[w]; N.push(z) } return N }, setVelocity: function (B, N, w) { B = this.getMatterBodies(B); const z = this._tempVec2; return z.x = N, z.y = w, B.forEach(function (V) { o.setVelocity(V, z) }), this }, setVelocityX: function (B, N) { B = this.getMatterBodies(B); const w = this._tempVec2; return w.x = N, B.forEach(function (z) { w.y = z.velocity.y, o.setVelocity(z, w) }), this }, setVelocityY: function (B, N) { B = this.getMatterBodies(B); const w = this._tempVec2; return w.y = N, B.forEach(function (z) { w.x = z.velocity.x, o.setVelocity(z, w) }), this }, setAngularVelocity: function (B, N) { return B = this.getMatterBodies(B), B.forEach(function (w) { o.setAngularVelocity(w, N) }), this }, applyForce: function (B, N) { B = this.getMatterBodies(B); const w = this._tempVec2; return B.forEach(function (z) { w.x = z.position.x, w.y = z.position.y, o.applyForce(z, w, N) }), this }, applyForceFromPosition: function (B, N, w, z) { B = this.getMatterBodies(B); const V = this._tempVec2; return B.forEach(function (W) { z === void 0 && (z = W.angle), V.x = w * Math.cos(z), V.y = w * Math.sin(z), o.applyForce(W, N, V) }), this }, applyForceFromAngle: function (B, N, w) { B = this.getMatterBodies(B); const z = this._tempVec2; return B.forEach(function (V) { w === void 0 && (w = V.angle), z.x = N * Math.cos(w), z.y = N * Math.sin(w), o.applyForce(V, { x: V.position.x, y: V.position.y }, z) }), this }, getConstraintLength: function (B) { let N = B.pointA.x; let w = B.pointA.y; let z = B.pointB.x; let V = B.pointB.y; return B.bodyA && (N += B.bodyA.position.x, w += B.bodyA.position.y), B.bodyB && (z += B.bodyB.position.x, V += B.bodyB.position.y), p(N, w, z, V) }, alignBody: function (B, N, w, z) { B = B.hasOwnProperty('body') ? B.body : B; let V; switch (z) { case i.TOP_LEFT:case i.LEFT_TOP:V = this.bodyBounds.getTopLeft(B, N, w); break; case i.TOP_CENTER:V = this.bodyBounds.getTopCenter(B, N, w); break; case i.TOP_RIGHT:case i.RIGHT_TOP:V = this.bodyBounds.getTopRight(B, N, w); break; case i.LEFT_CENTER:V = this.bodyBounds.getLeftCenter(B, N, w); break; case i.CENTER:V = this.bodyBounds.getCenter(B, N, w); break; case i.RIGHT_CENTER:V = this.bodyBounds.getRightCenter(B, N, w); break; case i.LEFT_BOTTOM:case i.BOTTOM_LEFT:V = this.bodyBounds.getBottomLeft(B, N, w); break; case i.BOTTOM_CENTER:V = this.bodyBounds.getBottomCenter(B, N, w); break; case i.BOTTOM_RIGHT:case i.RIGHT_BOTTOM:V = this.bodyBounds.getBottomRight(B, N, w); break } return V && o.setPosition(B, V), this }, shutdown: function () { const B = this.systems.events; this.world && (B.off(U.UPDATE, this.world.update, this.world), B.off(U.POST_UPDATE, this.world.postUpdate, this.world)), B.off(U.SHUTDOWN, this.shutdown, this), this.add && this.add.destroy(), this.world && this.world.destroy(), this.add = null, this.world = null }, destroy: function () { this.shutdown(), this.scene.sys.events.off(U.START, this.start, this), this.scene = null, this.systems = null } }); L.register('MatterPhysics', D, 'matterPhysics'), e.exports = D }, function (e, d, t) { const i = t(594); var h = { name: 'matter-attractors', version: '0.1.7', for: 'matter-js@^0.14.2', silent: !0, install: function (n) { n.after('Body.create', function () { h.Body.init(this) }), n.before('Engine.update', function (o) { h.Engine.update(o) }) }, Body: { init: function (n) { n.plugin.attractors = n.plugin.attractors || [] } }, Engine: { update: function (n) { for (let o = i.Composite.allBodies(n.world), r = 0; r < o.length; r++) { const s = o[r]; const a = s.plugin.attractors; if (a && a.length > 0) for (let f = 0; f < o.length; f++) { const l = o[f]; if (r !== f) for (let u = 0; u < a.length; u++) { const v = a[u]; let p = v; i.Common.isFunction(v) && (p = v(s, l)), p && i.Body.applyForce(l, l.position, p) } } } } }, Attractors: { gravityConstant: 0.001, gravity: function (n, o) { const r = i.Vector.sub(o.position, n.position); const s = i.Vector.magnitudeSquared(r) || 1e-4; const a = i.Vector.normalise(r); const f = -h.Attractors.gravityConstant * (n.mass * o.mass / s); const l = i.Vector.mult(a, f); i.Body.applyForce(n, n.position, i.Vector.neg(l)), i.Body.applyForce(o, o.position, l) } } }; e.exports = h }, function (e, d) { const t = { name: 'matter-collision-events', version: '0.1.6', for: 'matter-js@^0.14.2', silent: !0, install: function (i) { i.after('Engine.create', function () { i.Events.on(this, 'collisionStart', function (h) { h.pairs.map(function (n) { const o = n.bodyA; const r = n.bodyB; o.gameObject && o.gameObject.emit('collide', o, r, n), r.gameObject && r.gameObject.emit('collide', r, o, n), i.Events.trigger(o, 'onCollide', { pair: n }), i.Events.trigger(r, 'onCollide', { pair: n }), o.onCollideCallback && o.onCollideCallback(n), r.onCollideCallback && r.onCollideCallback(n), o.onCollideWith[r.id] && o.onCollideWith[r.id](r, n), r.onCollideWith[o.id] && r.onCollideWith[o.id](o, n) }) }), i.Events.on(this, 'collisionActive', function (h) { h.pairs.map(function (n) { const o = n.bodyA; const r = n.bodyB; o.gameObject && o.gameObject.emit('collideActive', o, r, n), r.gameObject && r.gameObject.emit('collideActive', r, o, n), i.Events.trigger(o, 'onCollideActive', { pair: n }), i.Events.trigger(r, 'onCollideActive', { pair: n }), o.onCollideActiveCallback && o.onCollideActiveCallback(n), r.onCollideActiveCallback && r.onCollideActiveCallback(n) }) }), i.Events.on(this, 'collisionEnd', function (h) { h.pairs.map(function (n) { const o = n.bodyA; const r = n.bodyB; o.gameObject && o.gameObject.emit('collideEnd', o, r, n), r.gameObject && r.gameObject.emit('collideEnd', r, o, n), i.Events.trigger(o, 'onCollideEnd', { pair: n }), i.Events.trigger(r, 'onCollideEnd', { pair: n }), o.onCollideEndCallback && o.onCollideEndCallback(n), r.onCollideEndCallback && r.onCollideEndCallback(n) }) }) }) } }; e.exports = t }, function (e, d, t) { const i = t(594); var h = { name: 'matter-wrap', version: '0.1.4', for: 'matter-js@^0.14.2', silent: !0, install: function (n) { n.after('Engine.update', function () { h.Engine.update(this) }) }, Engine: { update: function (n) { for (var o = n.world, r = i.Composite.allBodies(o), s = i.Composite.allComposites(o), a = 0; a < r.length; a += 1) { const f = r[a]; f.plugin.wrap && h.Body.wrap(f, f.plugin.wrap) } for (a = 0; a < s.length; a += 1) { const l = s[a]; l.plugin.wrap && h.Composite.wrap(l, l.plugin.wrap) } } }, Bounds: { wrap: function (n, o) { let r = null; let s = null; if (typeof o.min.x !== 'undefined' && typeof o.max.x !== 'undefined' && (n.min.x > o.max.x ? r = o.min.x - n.max.x : n.max.x < o.min.x && (r = o.max.x - n.min.x)), typeof o.min.y !== 'undefined' && typeof o.max.y !== 'undefined' && (n.min.y > o.max.y ? s = o.min.y - n.max.y : n.max.y < o.min.y && (s = o.max.y - n.min.y)), r !== null || s !== null) return { x: r || 0, y: s || 0 } } }, Body: { wrap: function (n, o) { const r = h.Bounds.wrap(n.bounds, o); return r && i.Body.translate(n, r), r } }, Composite: { bounds: function (n) { for (var o = i.Composite.allBodies(n), r = [], s = 0; s < o.length; s += 1) { const a = o[s]; r.push(a.bounds.min, a.bounds.max) } return i.Bounds.create(r) }, wrap: function (n, o) { const r = h.Bounds.wrap(h.Composite.bounds(n), o); return r && i.Composite.translate(n, r), r } } }; e.exports = h }, function (e, d, t) { (function (i) { const h = t(33); const n = t(17); let o = { Actions: t(275), Animations: t(723), BlendModes: t(35), Cache: t(735), Cameras: t(738), Core: t(806), Class: t(0), Create: t(888), Curves: t(894), Data: t(896), Display: t(898), DOM: t(917), Events: t(918), Game: t(920), GameObjects: t(1011), Geom: t(483), Input: t(1308), Loader: t(1338), Math: t(193), Physics: t(1493), Plugins: t(1403), Renderer: t(1405), Scale: t(1412), ScaleModes: t(168), Scene: t(418), Scenes: t(1413), Structs: t(1415), Textures: t(1416), Tilemaps: t(1418), Time: t(1461), Tweens: t(1463), Utils: t(1481) }; o.Sound = t(1492), o = n(!1, o, h), e.exports = o, i.Phaser = o }).call(this, t(600)) }]))
    })
  }); const $l = ci(ot => { 'use strict'; const yn = Symbol.for('react.element'); const ev = Symbol.for('react.portal'); const iv = Symbol.for('react.fragment'); const nv = Symbol.for('react.strict_mode'); const sv = Symbol.for('react.profiler'); const rv = Symbol.for('react.provider'); const av = Symbol.for('react.context'); const ov = Symbol.for('react.forward_ref'); const lv = Symbol.for('react.suspense'); const hv = Symbol.for('react.memo'); const uv = Symbol.for('react.lazy'); const Ul = Symbol.iterator; function fv (e) { return e === null || typeof e !== 'object' ? null : (e = Ul && e[Ul] || e['@@iterator'], typeof e === 'function' ? e : null) } const Yl = { isMounted: function () { return !1 }, enqueueForceUpdate: function () {}, enqueueReplaceState: function () {}, enqueueSetState: function () {} }; const Vl = Object.assign; const Xl = {}; function Ni (e, d, t) { this.props = e, this.context = d, this.refs = Xl, this.updater = t || Yl }Ni.prototype.isReactComponent = {}; Ni.prototype.setState = function (e, d) { if (typeof e !== 'object' && typeof e !== 'function' && e != null) throw Error('setState(...): takes an object of state variables to update or a function which returns an object of state variables.'); this.updater.enqueueSetState(this, e, d, 'setState') }; Ni.prototype.forceUpdate = function (e) { this.updater.enqueueForceUpdate(this, e, 'forceUpdate') }; function Wl () {}Wl.prototype = Ni.prototype; function ea (e, d, t) { this.props = e, this.context = d, this.refs = Xl, this.updater = t || Yl } const ia = ea.prototype = new Wl(); ia.constructor = ea; Vl(ia, Ni.prototype); ia.isPureReactComponent = !0; const Hl = Array.isArray; const Kl = Object.prototype.hasOwnProperty; const na = { current: null }; const Zl = { key: !0, ref: !0, __self: !0, __source: !0 }; function Ql (e, d, t) { let i; const h = {}; let n = null; let o = null; if (d != null) for (i in d.ref !== void 0 && (o = d.ref), d.key !== void 0 && (n = '' + d.key), d)Kl.call(d, i) && !Zl.hasOwnProperty(i) && (h[i] = d[i]); let r = arguments.length - 2; if (r === 1)h.children = t; else if (r > 1) { for (var s = Array(r), a = 0; a < r; a++)s[a] = arguments[a + 2]; h.children = s } if (e && e.defaultProps) for (i in r = e.defaultProps, r)h[i] === void 0 && (h[i] = r[i]); return { $$typeof: yn, type: e, key: n, ref: o, props: h, _owner: na.current } } function dv (e, d) { return { $$typeof: yn, type: e.type, key: d, ref: e.ref, props: e.props, _owner: e._owner } } function sa (e) { return typeof e === 'object' && e !== null && e.$$typeof === yn } function vv (e) { const d = { '=': '=0', ':': '=2' }; return '$' + e.replace(/[=:]/g, function (t) { return d[t] }) } const Jl = /\/+/g; function ra (e, d) { return typeof e === 'object' && e !== null && e.key != null ? vv('' + e.key) : d.toString(36) } function xs (e, d, t, i, h) { let n = typeof e; (n === 'undefined' || n === 'boolean') && (e = null); let o = !1; if (e === null)o = !0; else switch (n) { case 'string':case 'number':o = !0; break; case 'object':switch (e.$$typeof) { case yn:case ev:o = !0 } } if (o) return o = e, h = h(o), e = i === '' ? '.' + ra(o, 0) : i, Hl(h) ? (t = '', e != null && (t = e.replace(Jl, '$&/') + '/'), xs(h, d, t, '', function (a) { return a })) : h != null && (sa(h) && (h = dv(h, t + (!h.key || o && o.key === h.key ? '' : ('' + h.key).replace(Jl, '$&/') + '/') + e)), d.push(h)), 1; if (o = 0, i = i === '' ? '.' : i + ':', Hl(e)) for (var r = 0; r < e.length; r++) { n = e[r]; var s = i + ra(n, r); o += xs(n, d, t, s, h) } else if (s = fv(e), typeof s === 'function') for (e = s.call(e), r = 0; !(n = e.next()).done;)n = n.value, s = i + ra(n, r++), o += xs(n, d, t, s, h); else if (n === 'object') throw d = String(e), Error('Objects are not valid as a React child (found: ' + (d === '[object Object]' ? 'object with keys {' + Object.keys(e).join(', ') + '}' : d) + '). If you meant to render a collection of children, use an array instead.'); return o } function ys (e, d, t) { if (e == null) return e; const i = []; let h = 0; return xs(e, i, '', '', function (n) { return d.call(t, n, h++) }), i } function cv (e) { if (e._status === -1) { let d = e._result; d = d(), d.then(function (t) { (e._status === 0 || e._status === -1) && (e._status = 1, e._result = t) }, function (t) { (e._status === 0 || e._status === -1) && (e._status = 2, e._result = t) }), e._status === -1 && (e._status = 0, e._result = d) } if (e._status === 1) return e._result.default; throw e._result } const Vt = { current: null }; const Ts = { transition: null }; const pv = { ReactCurrentDispatcher: Vt, ReactCurrentBatchConfig: Ts, ReactCurrentOwner: na }; ot.Children = { map: ys, forEach: function (e, d, t) { ys(e, function () { d.apply(this, arguments) }, t) }, count: function (e) { let d = 0; return ys(e, function () { d++ }), d }, toArray: function (e) { return ys(e, function (d) { return d }) || [] }, only: function (e) { if (!sa(e)) throw Error('React.Children.only expected to receive a single React element child.'); return e } }; ot.Component = Ni; ot.Fragment = iv; ot.Profiler = sv; ot.PureComponent = ea; ot.StrictMode = nv; ot.Suspense = lv; ot.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = pv; ot.cloneElement = function (e, d, t) { if (e == null) throw Error('React.cloneElement(...): The argument must be a React element, but you passed ' + e + '.'); const i = Vl({}, e.props); let h = e.key; let n = e.ref; let o = e._owner; if (d != null) { if (d.ref !== void 0 && (n = d.ref, o = na.current), d.key !== void 0 && (h = '' + d.key), e.type && e.type.defaultProps) var r = e.type.defaultProps; for (s in d)Kl.call(d, s) && !Zl.hasOwnProperty(s) && (i[s] = d[s] === void 0 && r !== void 0 ? r[s] : d[s]) } var s = arguments.length - 2; if (s === 1)i.children = t; else if (s > 1) { r = Array(s); for (let a = 0; a < s; a++)r[a] = arguments[a + 2]; i.children = r } return { $$typeof: yn, type: e.type, key: h, ref: n, props: i, _owner: o } }; ot.createContext = function (e) { return e = { $$typeof: av, _currentValue: e, _currentValue2: e, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, e.Provider = { $$typeof: rv, _context: e }, e.Consumer = e }; ot.createElement = Ql; ot.createFactory = function (e) { const d = Ql.bind(null, e); return d.type = e, d }; ot.createRef = function () { return { current: null } }; ot.forwardRef = function (e) { return { $$typeof: ov, render: e } }; ot.isValidElement = sa; ot.lazy = function (e) { return { $$typeof: uv, _payload: { _status: -1, _result: e }, _init: cv } }; ot.memo = function (e, d) { return { $$typeof: hv, type: e, compare: d === void 0 ? null : d } }; ot.startTransition = function (e) { const d = Ts.transition; Ts.transition = {}; try { e() } finally { Ts.transition = d } }; ot.unstable_act = function () { throw Error('act(...) is not supported in production builds of React.') }; ot.useCallback = function (e, d) { return Vt.current.useCallback(e, d) }; ot.useContext = function (e) { return Vt.current.useContext(e) }; ot.useDebugValue = function () {}; ot.useDeferredValue = function (e) { return Vt.current.useDeferredValue(e) }; ot.useEffect = function (e, d) { return Vt.current.useEffect(e, d) }; ot.useId = function () { return Vt.current.useId() }; ot.useImperativeHandle = function (e, d, t) { return Vt.current.useImperativeHandle(e, d, t) }; ot.useInsertionEffect = function (e, d) { return Vt.current.useInsertionEffect(e, d) }; ot.useLayoutEffect = function (e, d) { return Vt.current.useLayoutEffect(e, d) }; ot.useMemo = function (e, d) { return Vt.current.useMemo(e, d) }; ot.useReducer = function (e, d, t) { return Vt.current.useReducer(e, d, t) }; ot.useRef = function (e) { return Vt.current.useRef(e) }; ot.useState = function (e) { return Vt.current.useState(e) }; ot.useSyncExternalStore = function (e, d, t) { return Vt.current.useSyncExternalStore(e, d, t) }; ot.useTransition = function () { return Vt.current.useTransition() }; ot.version = '18.1.0' }); const Tn = ci((Pp, jl) => { 'use strict'; jl.exports = $l() }); const rh = ci(dt => { 'use strict'; function aa (e, d) { let t = e.length; e.push(d); t:for (;t > 0;) { const i = t - 1 >>> 1; const h = e[i]; if (Es(h, d) > 0)e[i] = d, e[t] = h, t = i; else break t } } function ce (e) { return e.length === 0 ? null : e[0] } function Ss (e) { if (e.length === 0) return null; const d = e[0]; const t = e.pop(); if (t !== d) { e[0] = t; t:for (let i = 0, h = e.length, n = h >>> 1; i < n;) { const o = 2 * (i + 1) - 1; const r = e[o]; const s = o + 1; const a = e[s]; if (Es(r, t) < 0)s < h && Es(a, r) < 0 ? (e[i] = a, e[s] = t, i = s) : (e[i] = r, e[o] = t, i = o); else if (s < h && Es(a, t) < 0)e[i] = a, e[s] = t, i = s; else break t } } return d } function Es (e, d) { const t = e.sortIndex - d.sortIndex; return t !== 0 ? t : e.id - d.id } typeof performance === 'object' && typeof performance.now === 'function' ? (bl = performance, dt.unstable_now = function () { return bl.now() }) : (oa = Date, kl = oa.now(), dt.unstable_now = function () { return oa.now() - kl }); let bl; let oa; let kl; const Ce = []; const $e = []; let mv = 1; let se = null; let Gt = 3; let Cs = !1; let mi = !1; let Sn = !1; const ql = typeof setTimeout === 'function' ? setTimeout : null; const _l = typeof clearTimeout === 'function' ? clearTimeout : null; const th = typeof setImmediate !== 'undefined' ? setImmediate : null; typeof navigator !== 'undefined' && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function la (e) { for (let d = ce($e); d !== null;) { if (d.callback === null)Ss($e); else if (d.startTime <= e)Ss($e), d.sortIndex = d.expirationTime, aa(Ce, d); else break; d = ce($e) } } function ha (e) { if (Sn = !1, la(e), !mi) if (ce(Ce) !== null)mi = !0, va(ua); else { const d = ce($e); d !== null && ca(ha, d.startTime - e) } } function ua (e, d) { mi = !1, Sn && (Sn = !1, _l(En), En = -1), Cs = !0; const t = Gt; try { for (la(d), se = ce(Ce); se !== null && (!(se.expirationTime > d) || e && !nh());) { const i = se.callback; if (typeof i === 'function') { se.callback = null, Gt = se.priorityLevel; const h = i(se.expirationTime <= d); d = dt.unstable_now(), typeof h === 'function' ? se.callback = h : se === ce(Ce) && Ss(Ce), la(d) } else Ss(Ce); se = ce(Ce) } if (se !== null) var n = !0; else { const o = ce($e); o !== null && ca(ha, o.startTime - d), n = !1 } return n } finally { se = null, Gt = t, Cs = !1 } } let As = !1; let Ps = null; var En = -1; let eh = 5; let ih = -1; function nh () { return !(dt.unstable_now() - ih < eh) } function fa () { if (Ps !== null) { const e = dt.unstable_now(); ih = e; let d = !0; try { d = Ps(!0, e) } finally { d ? Cn() : (As = !1, Ps = null) } } else As = !1 } let Cn; typeof th === 'function' ? Cn = function () { th(fa) } : typeof MessageChannel !== 'undefined' ? (da = new MessageChannel(), sh = da.port2, da.port1.onmessage = fa, Cn = function () { sh.postMessage(null) }) : Cn = function () { ql(fa, 0) }; let da, sh; function va (e) { Ps = e, As || (As = !0, Cn()) } function ca (e, d) { En = ql(function () { e(dt.unstable_now()) }, d) }dt.unstable_IdlePriority = 5; dt.unstable_ImmediatePriority = 1; dt.unstable_LowPriority = 4; dt.unstable_NormalPriority = 3; dt.unstable_Profiling = null; dt.unstable_UserBlockingPriority = 2; dt.unstable_cancelCallback = function (e) { e.callback = null }; dt.unstable_continueExecution = function () { mi || Cs || (mi = !0, va(ua)) }; dt.unstable_forceFrameRate = function (e) { e < 0 || e > 125 ? console.error('forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported') : eh = e > 0 ? Math.floor(1e3 / e) : 5 }; dt.unstable_getCurrentPriorityLevel = function () { return Gt }; dt.unstable_getFirstCallbackNode = function () { return ce(Ce) }; dt.unstable_next = function (e) { switch (Gt) { case 1:case 2:case 3:var d = 3; break; default:d = Gt } const t = Gt; Gt = d; try { return e() } finally { Gt = t } }; dt.unstable_pauseExecution = function () {}; dt.unstable_requestPaint = function () {}; dt.unstable_runWithPriority = function (e, d) { switch (e) { case 1:case 2:case 3:case 4:case 5:break; default:e = 3 } const t = Gt; Gt = e; try { return d() } finally { Gt = t } }; dt.unstable_scheduleCallback = function (e, d, t) { const i = dt.unstable_now(); switch (typeof t === 'object' && t !== null ? (t = t.delay, t = typeof t === 'number' && t > 0 ? i + t : i) : t = i, e) { case 1:var h = -1; break; case 2:h = 250; break; case 5:h = 1073741823; break; case 4:h = 1e4; break; default:h = 5e3 } return h = t + h, e = { id: mv++, callback: d, priorityLevel: e, startTime: t, expirationTime: h, sortIndex: -1 }, t > i ? (e.sortIndex = t, aa($e, e), ce(Ce) === null && e === ce($e) && (Sn ? (_l(En), En = -1) : Sn = !0, ca(ha, t - i))) : (e.sortIndex = h, aa(Ce, e), mi || Cs || (mi = !0, va(ua))), e }; dt.unstable_shouldYield = nh; dt.unstable_wrapCallback = function (e) { const d = Gt; return function () { const t = Gt; Gt = d; try { return e.apply(this, arguments) } finally { Gt = t } } } }); const oh = ci((Rp, ah) => { 'use strict'; ah.exports = rh() }); const md = ci(ne => {
    'use strict'; const lh = Tn(); const _t = oh(); function k (e) { for (var d = 'https://reactjs.org/docs/error-decoder.html?invariant=' + e, t = 1; t < arguments.length; t++)d += '&args[]=' + encodeURIComponent(arguments[t]); return 'Minified React error #' + e + '; visit ' + d + ' for the full message or use the non-minified dev environment for full errors and additional helpful warnings.' } const hh = new Set(); const An = {}; function gi (e, d) { Gi(e, d), Gi(e + 'Capture', d) } function Gi (e, d) { for (An[e] = d, e = 0; e < d.length; e++)hh.add(d[e]) } const Ge = !(typeof window === 'undefined' || typeof window.document === 'undefined' || typeof window.document.createElement === 'undefined'); const pa = Object.prototype.hasOwnProperty; const gv = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/; const uh = {}; const fh = {}; function xv (e) { return pa.call(fh, e) ? !0 : pa.call(uh, e) ? !1 : gv.test(e) ? fh[e] = !0 : (uh[e] = !0, !1) } function yv (e, d, t, i) { if (t !== null && t.type === 0) return !1; switch (typeof d) { case 'function':case 'symbol':return !0; case 'boolean':return i ? !1 : t !== null ? !t.acceptsBooleans : (e = e.toLowerCase().slice(0, 5), e !== 'data-' && e !== 'aria-'); default:return !1 } } function Tv (e, d, t, i) { if (d === null || typeof d === 'undefined' || yv(e, d, t, i)) return !0; if (i) return !1; if (t !== null) switch (t.type) { case 3:return !d; case 4:return d === !1; case 5:return isNaN(d); case 6:return isNaN(d) || d < 1 } return !1 } function Xt (e, d, t, i, h, n, o) { this.acceptsBooleans = d === 2 || d === 3 || d === 4, this.attributeName = i, this.attributeNamespace = h, this.mustUseProperty = t, this.propertyName = e, this.type = d, this.sanitizeURL = n, this.removeEmptyString = o } const It = {}; 'children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style'.split(' ').forEach(function (e) { It[e] = new Xt(e, 0, !1, e, null, !1, !1) }); [['acceptCharset', 'accept-charset'], ['className', 'class'], ['htmlFor', 'for'], ['httpEquiv', 'http-equiv']].forEach(function (e) { const d = e[0]; It[d] = new Xt(d, 1, !1, e[1], null, !1, !1) }); ['contentEditable', 'draggable', 'spellCheck', 'value'].forEach(function (e) { It[e] = new Xt(e, 2, !1, e.toLowerCase(), null, !1, !1) }); ['autoReverse', 'externalResourcesRequired', 'focusable', 'preserveAlpha'].forEach(function (e) { It[e] = new Xt(e, 2, !1, e, null, !1, !1) }); 'allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope'.split(' ').forEach(function (e) { It[e] = new Xt(e, 3, !1, e.toLowerCase(), null, !1, !1) }); ['checked', 'multiple', 'muted', 'selected'].forEach(function (e) { It[e] = new Xt(e, 3, !0, e, null, !1, !1) }); ['capture', 'download'].forEach(function (e) { It[e] = new Xt(e, 4, !1, e, null, !1, !1) }); ['cols', 'rows', 'size', 'span'].forEach(function (e) { It[e] = new Xt(e, 6, !1, e, null, !1, !1) }); ['rowSpan', 'start'].forEach(function (e) { It[e] = new Xt(e, 5, !1, e.toLowerCase(), null, !1, !1) }); const ma = /[\-:]([a-z])/g; function ga (e) { return e[1].toUpperCase() }'accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height'.split(' ').forEach(function (e) { const d = e.replace(ma, ga); It[d] = new Xt(d, 1, !1, e, null, !1, !1) }); 'xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type'.split(' ').forEach(function (e) { const d = e.replace(ma, ga); It[d] = new Xt(d, 1, !1, e, 'http://www.w3.org/1999/xlink', !1, !1) }); ['xml:base', 'xml:lang', 'xml:space'].forEach(function (e) { const d = e.replace(ma, ga); It[d] = new Xt(d, 1, !1, e, 'http://www.w3.org/XML/1998/namespace', !1, !1) }); ['tabIndex', 'crossOrigin'].forEach(function (e) { It[e] = new Xt(e, 1, !1, e.toLowerCase(), null, !1, !1) }); It.xlinkHref = new Xt('xlinkHref', 1, !1, 'xlink:href', 'http://www.w3.org/1999/xlink', !0, !1); ['src', 'href', 'action', 'formAction'].forEach(function (e) { It[e] = new Xt(e, 1, !1, e.toLowerCase(), null, !0, !0) }); function xa (e, d, t, i) { let h = It.hasOwnProperty(d) ? It[d] : null; (h !== null ? h.type !== 0 : i || !(d.length > 2) || d[0] !== 'o' && d[0] !== 'O' || d[1] !== 'n' && d[1] !== 'N') && (Tv(d, t, h, i) && (t = null), i || h === null ? xv(d) && (t === null ? e.removeAttribute(d) : e.setAttribute(d, '' + t)) : h.mustUseProperty ? e[h.propertyName] = t === null ? h.type === 3 ? !1 : '' : t : (d = h.attributeName, i = h.attributeNamespace, t === null ? e.removeAttribute(d) : (h = h.type, t = h === 3 || h === 4 && t === !0 ? '' : '' + t, i ? e.setAttributeNS(i, d, t) : e.setAttribute(d, t)))) } const we = lh.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED; const Ms = Symbol.for('react.element'); const wi = Symbol.for('react.portal'); const zi = Symbol.for('react.fragment'); const ya = Symbol.for('react.strict_mode'); const Ta = Symbol.for('react.profiler'); const dh = Symbol.for('react.provider'); const vh = Symbol.for('react.context'); const Sa = Symbol.for('react.forward_ref'); const Ea = Symbol.for('react.suspense'); const Ca = Symbol.for('react.suspense_list'); const Aa = Symbol.for('react.memo'); const je = Symbol.for('react.lazy'); Symbol.for('react.scope'); Symbol.for('react.debug_trace_mode'); const ch = Symbol.for('react.offscreen'); Symbol.for('react.legacy_hidden'); Symbol.for('react.cache'); Symbol.for('react.tracing_marker'); const ph = Symbol.iterator; function Pn (e) { return e === null || typeof e !== 'object' ? null : (e = ph && e[ph] || e['@@iterator'], typeof e === 'function' ? e : null) } const xt = Object.assign; let Pa; function Mn (e) {
      if (Pa === void 0) try { throw Error() } catch (t) { const d = t.stack.trim().match(/\n( *(at )?)/); Pa = d && d[1] || '' } return `
` + Pa + e
    } let Ma = !1; function Ra (e, d) {
      if (!e || Ma) return ''; Ma = !0; const t = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (d) if (d = function () { throw Error() }, Object.defineProperty(d.prototype, 'props', { set: function () { throw Error() } }), typeof Reflect === 'object' && Reflect.construct) { try { Reflect.construct(d, []) } catch (a) { var i = a }Reflect.construct(e, [], d) } else { try { d.call() } catch (a) { i = a }e.call(d.prototype) } else { try { throw Error() } catch (a) { i = a }e() } } catch (a) {
        if (a && i && typeof a.stack === 'string') {
          for (var h = a.stack.split(`
`), n = i.stack.split(`
`), o = h.length - 1, r = n.length - 1; o >= 1 && r >= 0 && h[o] !== n[r];)r--; for (;o >= 1 && r >= 0; o--, r--) {
            if (h[o] !== n[r]) {
              if (o !== 1 || r !== 1) {
                do {
                  if (o--, r--, r < 0 || h[o] !== n[r]) {
                    let s = `
` + h[o].replace(' at new ', ' at '); return e.displayName && s.includes('<anonymous>') && (s = s.replace('<anonymous>', e.displayName)), s
                  }
                } while (o >= 1 && r >= 0)
              } break
            }
          }
        }
      } finally { Ma = !1, Error.prepareStackTrace = t } return (e = e ? e.displayName || e.name : '') ? Mn(e) : ''
    } function Sv (e) { switch (e.tag) { case 5:return Mn(e.type); case 16:return Mn('Lazy'); case 13:return Mn('Suspense'); case 19:return Mn('SuspenseList'); case 0:case 2:case 15:return e = Ra(e.type, !1), e; case 11:return e = Ra(e.type.render, !1), e; case 1:return e = Ra(e.type, !0), e; default:return '' } } function La (e) { if (e == null) return null; if (typeof e === 'function') return e.displayName || e.name || null; if (typeof e === 'string') return e; switch (e) { case zi:return 'Fragment'; case wi:return 'Portal'; case Ta:return 'Profiler'; case ya:return 'StrictMode'; case Ea:return 'Suspense'; case Ca:return 'SuspenseList' } if (typeof e === 'object') switch (e.$$typeof) { case vh:return (e.displayName || 'Context') + '.Consumer'; case dh:return (e._context.displayName || 'Context') + '.Provider'; case Sa:var d = e.render; return e = e.displayName, e || (e = d.displayName || d.name || '', e = e !== '' ? 'ForwardRef(' + e + ')' : 'ForwardRef'), e; case Aa:return d = e.displayName || null, d !== null ? d : La(e.type) || 'Memo'; case je:d = e._payload, e = e._init; try { return La(e(d)) } catch (t) {} } return null } function Ev (e) { const d = e.type; switch (e.tag) { case 24:return 'Cache'; case 9:return (d.displayName || 'Context') + '.Consumer'; case 10:return (d._context.displayName || 'Context') + '.Provider'; case 18:return 'DehydratedFragment'; case 11:return e = d.render, e = e.displayName || e.name || '', d.displayName || (e !== '' ? 'ForwardRef(' + e + ')' : 'ForwardRef'); case 7:return 'Fragment'; case 5:return d; case 4:return 'Portal'; case 3:return 'Root'; case 6:return 'Text'; case 16:return La(d); case 8:return d === ya ? 'StrictMode' : 'Mode'; case 22:return 'Offscreen'; case 12:return 'Profiler'; case 21:return 'Scope'; case 13:return 'Suspense'; case 19:return 'SuspenseList'; case 25:return 'TracingMarker'; case 1:case 0:case 17:case 2:case 14:case 15:if (typeof d === 'function') return d.displayName || d.name || null; if (typeof d === 'string') return d } return null } function be (e) { switch (typeof e) { case 'boolean':case 'number':case 'string':case 'undefined':return e; case 'object':return e; default:return '' } } function mh (e) { const d = e.type; return (e = e.nodeName) && e.toLowerCase() === 'input' && (d === 'checkbox' || d === 'radio') } function Cv (e) { const d = mh(e) ? 'checked' : 'value'; const t = Object.getOwnPropertyDescriptor(e.constructor.prototype, d); let i = '' + e[d]; if (!e.hasOwnProperty(d) && typeof t !== 'undefined' && typeof t.get === 'function' && typeof t.set === 'function') { const h = t.get; const n = t.set; return Object.defineProperty(e, d, { configurable: !0, get: function () { return h.call(this) }, set: function (o) { i = '' + o, n.call(this, o) } }), Object.defineProperty(e, d, { enumerable: t.enumerable }), { getValue: function () { return i }, setValue: function (o) { i = '' + o }, stopTracking: function () { e._valueTracker = null, delete e[d] } } } } function Rs (e) { e._valueTracker || (e._valueTracker = Cv(e)) } function gh (e) { if (!e) return !1; const d = e._valueTracker; if (!d) return !0; const t = d.getValue(); let i = ''; return e && (i = mh(e) ? e.checked ? 'true' : 'false' : e.value), e = i, e !== t ? (d.setValue(e), !0) : !1 } function Ls (e) { if (e = e || (typeof document !== 'undefined' ? document : void 0), typeof e === 'undefined') return null; try { return e.activeElement || e.body } catch (d) { return e.body } } function Oa (e, d) { const t = d.checked; return xt({}, d, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: t != null ? t : e._wrapperState.initialChecked }) } function xh (e, d) { let t = d.defaultValue == null ? '' : d.defaultValue; const i = d.checked != null ? d.checked : d.defaultChecked; t = be(d.value != null ? d.value : t), e._wrapperState = { initialChecked: i, initialValue: t, controlled: d.type === 'checkbox' || d.type === 'radio' ? d.checked != null : d.value != null } } function yh (e, d) { d = d.checked, d != null && xa(e, 'checked', d, !1) } function Fa (e, d) { yh(e, d); const t = be(d.value); const i = d.type; if (t != null)i === 'number' ? (t === 0 && e.value === '' || e.value != t) && (e.value = '' + t) : e.value !== '' + t && (e.value = '' + t); else if (i === 'submit' || i === 'reset') { e.removeAttribute('value'); return }d.hasOwnProperty('value') ? Da(e, d.type, t) : d.hasOwnProperty('defaultValue') && Da(e, d.type, be(d.defaultValue)), d.checked == null && d.defaultChecked != null && (e.defaultChecked = !!d.defaultChecked) } function Th (e, d, t) { if (d.hasOwnProperty('value') || d.hasOwnProperty('defaultValue')) { const i = d.type; if (!(i !== 'submit' && i !== 'reset' || d.value !== void 0 && d.value !== null)) return; d = '' + e._wrapperState.initialValue, t || d === e.value || (e.value = d), e.defaultValue = d }t = e.name, t !== '' && (e.name = ''), e.defaultChecked = !!e._wrapperState.initialChecked, t !== '' && (e.name = t) } function Da (e, d, t) { (d !== 'number' || Ls(e.ownerDocument) !== e) && (t == null ? e.defaultValue = '' + e._wrapperState.initialValue : e.defaultValue !== '' + t && (e.defaultValue = '' + t)) } const Rn = Array.isArray; function Ui (e, d, t, i) { if (e = e.options, d) { d = {}; for (var h = 0; h < t.length; h++)d['$' + t[h]] = !0; for (t = 0; t < e.length; t++)h = d.hasOwnProperty('$' + e[t].value), e[t].selected !== h && (e[t].selected = h), h && i && (e[t].defaultSelected = !0) } else { for (t = '' + be(t), d = null, h = 0; h < e.length; h++) { if (e[h].value === t) { e[h].selected = !0, i && (e[h].defaultSelected = !0); return }d !== null || e[h].disabled || (d = e[h]) }d !== null && (d.selected = !0) } } function Ia (e, d) { if (d.dangerouslySetInnerHTML != null) throw Error(k(91)); return xt({}, d, { value: void 0, defaultValue: void 0, children: '' + e._wrapperState.initialValue }) } function Sh (e, d) { let t = d.value; if (t == null) { if (t = d.children, d = d.defaultValue, t != null) { if (d != null) throw Error(k(92)); if (Rn(t)) { if (t.length > 1) throw Error(k(93)); t = t[0] }d = t }d == null && (d = ''), t = d }e._wrapperState = { initialValue: be(t) } } function Eh (e, d) { let t = be(d.value); const i = be(d.defaultValue); t != null && (t = '' + t, t !== e.value && (e.value = t), d.defaultValue == null && e.defaultValue !== t && (e.defaultValue = t)), i != null && (e.defaultValue = '' + i) } function Ch (e) { const d = e.textContent; d === e._wrapperState.initialValue && d !== '' && d !== null && (e.value = d) } function Ah (e) { switch (e) { case 'svg':return 'http://www.w3.org/2000/svg'; case 'math':return 'http://www.w3.org/1998/Math/MathML'; default:return 'http://www.w3.org/1999/xhtml' } } function Ba (e, d) { return e == null || e === 'http://www.w3.org/1999/xhtml' ? Ah(d) : e === 'http://www.w3.org/2000/svg' && d === 'foreignObject' ? 'http://www.w3.org/1999/xhtml' : e } let Os; const Ph = (function (e) { return typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction ? function (d, t, i, h) { MSApp.execUnsafeLocalFunction(function () { return e(d, t, i, h) }) } : e }(function (e, d) { if (e.namespaceURI !== 'http://www.w3.org/2000/svg' || 'innerHTML' in e)e.innerHTML = d; else { for (Os = Os || document.createElement('div'), Os.innerHTML = '<svg>' + d.valueOf().toString() + '</svg>', d = Os.firstChild; e.firstChild;)e.removeChild(e.firstChild); for (;d.firstChild;)e.appendChild(d.firstChild) } })); function Ln (e, d) { if (d) { const t = e.firstChild; if (t && t === e.lastChild && t.nodeType === 3) { t.nodeValue = d; return } }e.textContent = d } const On = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }; const Av = ['Webkit', 'ms', 'Moz', 'O']; Object.keys(On).forEach(function (e) { Av.forEach(function (d) { d = d + e.charAt(0).toUpperCase() + e.substring(1), On[d] = On[e] }) }); function Mh (e, d, t) { return d == null || typeof d === 'boolean' || d === '' ? '' : t || typeof d !== 'number' || d === 0 || On.hasOwnProperty(e) && On[e] ? ('' + d).trim() : d + 'px' } function Rh (e, d) { e = e.style; for (let t in d) if (d.hasOwnProperty(t)) { const i = t.indexOf('--') === 0; const h = Mh(t, d[t], i); t === 'float' && (t = 'cssFloat'), i ? e.setProperty(t, h) : e[t] = h } } const Pv = xt({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function Na (e, d) { if (d) { if (Pv[e] && (d.children != null || d.dangerouslySetInnerHTML != null)) throw Error(k(137, e)); if (d.dangerouslySetInnerHTML != null) { if (d.children != null) throw Error(k(60)); if (typeof d.dangerouslySetInnerHTML !== 'object' || !('__html' in d.dangerouslySetInnerHTML)) throw Error(k(61)) } if (d.style != null && typeof d.style !== 'object') throw Error(k(62)) } } function Ga (e, d) { if (e.indexOf('-') === -1) return typeof d.is === 'string'; switch (e) { case 'annotation-xml':case 'color-profile':case 'font-face':case 'font-face-src':case 'font-face-uri':case 'font-face-format':case 'font-face-name':case 'missing-glyph':return !1; default:return !0 } } let wa = null; function za (e) { return e = e.target || e.srcElement || window, e.correspondingUseElement && (e = e.correspondingUseElement), e.nodeType === 3 ? e.parentNode : e } let Ua = null; let Yi = null; let Vi = null; function Lh (e) { if (e = bn(e)) { if (typeof Ua !== 'function') throw Error(k(280)); let d = e.stateNode; d && (d = ir(d), Ua(e.stateNode, e.type, d)) } } function Oh (e) { Yi ? Vi ? Vi.push(e) : Vi = [e] : Yi = e } function Fh () { if (Yi) { let e = Yi; const d = Vi; if (Vi = Yi = null, Lh(e), d) for (e = 0; e < d.length; e++)Lh(d[e]) } } function Dh (e, d) { return e(d) } function Ih () {} let Ya = !1; function Bh (e, d, t) { if (Ya) return e(d, t); Ya = !0; try { return Dh(e, d, t) } finally { Ya = !1, (Yi !== null || Vi !== null) && (Ih(), Fh()) } } function Fn (e, d) { let t = e.stateNode; if (t === null) return null; let i = ir(t); if (i === null) return null; t = i[d]; t:switch (d) { case 'onClick':case 'onClickCapture':case 'onDoubleClick':case 'onDoubleClickCapture':case 'onMouseDown':case 'onMouseDownCapture':case 'onMouseMove':case 'onMouseMoveCapture':case 'onMouseUp':case 'onMouseUpCapture':case 'onMouseEnter':(i = !i.disabled) || (e = e.type, i = !(e === 'button' || e === 'input' || e === 'select' || e === 'textarea')), e = !i; break t; default:e = !1 } if (e) return null; if (t && typeof t !== 'function') throw Error(k(231, d, typeof t)); return t } let Va = !1; if (Ge) try { Xi = {}, Object.defineProperty(Xi, 'passive', { get: function () { Va = !0 } }), window.addEventListener('test', Xi, Xi), window.removeEventListener('test', Xi, Xi) } catch (e) { Va = !1 } let Xi; function Mv (e, d, t, i, h, n, o, r, s) { const a = Array.prototype.slice.call(arguments, 3); try { d.apply(t, a) } catch (f) { this.onError(f) } } let Dn = !1; let Fs = null; let Ds = !1; let Xa = null; const Rv = { onError: function (e) { Dn = !0, Fs = e } }; function Lv (e, d, t, i, h, n, o, r, s) { Dn = !1, Fs = null, Mv.apply(Rv, arguments) } function Ov (e, d, t, i, h, n, o, r, s) { if (Lv.apply(this, arguments), Dn) { if (Dn) { var a = Fs; Dn = !1, Fs = null } else throw Error(k(198)); Ds || (Ds = !0, Xa = a) } } function xi (e) { let d = e; let t = e; if (e.alternate) for (;d.return;)d = d.return; else { e = d; do d = e, (d.flags & 4098) != 0 && (t = d.return), e = d.return; while (e) } return d.tag === 3 ? t : null } function Nh (e) { if (e.tag === 13) { let d = e.memoizedState; if (d === null && (e = e.alternate, e !== null && (d = e.memoizedState)), d !== null) return d.dehydrated } return null } function Gh (e) { if (xi(e) !== e) throw Error(k(188)) } function Fv (e) { let d = e.alternate; if (!d) { if (d = xi(e), d === null) throw Error(k(188)); return d !== e ? null : e } for (var t = e, i = d; ;) { const h = t.return; if (h === null) break; let n = h.alternate; if (n === null) { if (i = h.return, i !== null) { t = i; continue } break } if (h.child === n.child) { for (n = h.child; n;) { if (n === t) return Gh(h), e; if (n === i) return Gh(h), d; n = n.sibling } throw Error(k(188)) } if (t.return !== i.return)t = h, i = n; else { for (var o = !1, r = h.child; r;) { if (r === t) { o = !0, t = h, i = n; break } if (r === i) { o = !0, i = h, t = n; break }r = r.sibling } if (!o) { for (r = n.child; r;) { if (r === t) { o = !0, t = n, i = h; break } if (r === i) { o = !0, i = n, t = h; break }r = r.sibling } if (!o) throw Error(k(189)) } } if (t.alternate !== i) throw Error(k(190)) } if (t.tag !== 3) throw Error(k(188)); return t.stateNode.current === t ? e : d } function wh (e) { return e = Fv(e), e !== null ? zh(e) : null } function zh (e) { if (e.tag === 5 || e.tag === 6) return e; for (e = e.child; e !== null;) { const d = zh(e); if (d !== null) return d; e = e.sibling } return null } const Uh = _t.unstable_scheduleCallback; const Yh = _t.unstable_cancelCallback; const Dv = _t.unstable_shouldYield; const Iv = _t.unstable_requestPaint; const At = _t.unstable_now; const Bv = _t.unstable_getCurrentPriorityLevel; const Wa = _t.unstable_ImmediatePriority; const Vh = _t.unstable_UserBlockingPriority; const Is = _t.unstable_NormalPriority; const Nv = _t.unstable_LowPriority; const Xh = _t.unstable_IdlePriority; let Bs = null; let Ae = null; function Gv (e) { if (Ae && typeof Ae.onCommitFiberRoot === 'function') try { Ae.onCommitFiberRoot(Bs, e, void 0, (e.current.flags & 128) == 128) } catch (d) {} } const pe = Math.clz32 ? Math.clz32 : Uv; const wv = Math.log; const zv = Math.LN2; function Uv (e) { return e >>>= 0, e === 0 ? 32 : 31 - (wv(e) / zv | 0) | 0 } let Ns = 64; let Gs = 4194304; function In (e) { switch (e & -e) { case 1:return 1; case 2:return 2; case 4:return 4; case 8:return 8; case 16:return 16; case 32:return 32; case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return e & 4194240; case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return e & 130023424; case 134217728:return 134217728; case 268435456:return 268435456; case 536870912:return 536870912; case 1073741824:return 1073741824; default:return e } } function ws (e, d) { let t = e.pendingLanes; if (t === 0) return 0; let i = 0; let h = e.suspendedLanes; let n = e.pingedLanes; let o = t & 268435455; if (o !== 0) { const r = o & ~h; r !== 0 ? i = In(r) : (n &= o, n !== 0 && (i = In(n))) } else o = t & ~h, o !== 0 ? i = In(o) : n !== 0 && (i = In(n)); if (i === 0) return 0; if (d !== 0 && d !== i && (d & h) == 0 && (h = i & -i, n = d & -d, h >= n || h === 16 && (n & 4194240) != 0)) return d; if ((i & 4) != 0 && (i |= t & 16), d = e.entangledLanes, d !== 0) for (e = e.entanglements, d &= i; d > 0;)t = 31 - pe(d), h = 1 << t, i |= e[t], d &= ~h; return i } function Yv (e, d) { switch (e) { case 1:case 2:case 4:return d + 250; case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return d + 5e3; case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return -1; case 134217728:case 268435456:case 536870912:case 1073741824:return -1; default:return -1 } } function Vv (e, d) { for (let t = e.suspendedLanes, i = e.pingedLanes, h = e.expirationTimes, n = e.pendingLanes; n > 0;) { const o = 31 - pe(n); const r = 1 << o; const s = h[o]; s === -1 ? ((r & t) == 0 || (r & i) != 0) && (h[o] = Yv(r, d)) : s <= d && (e.expiredLanes |= r), n &= ~r } } function Ha (e) { return e = e.pendingLanes & -1073741825, e !== 0 ? e : e & 1073741824 ? 1073741824 : 0 } function Wh () { const e = Ns; return Ns <<= 1, (Ns & 4194240) == 0 && (Ns = 64), e } function Ka (e) { for (var d = [], t = 0; t < 31; t++)d.push(e); return d } function Bn (e, d, t) { e.pendingLanes |= d, d !== 536870912 && (e.suspendedLanes = 0, e.pingedLanes = 0), e = e.eventTimes, d = 31 - pe(d), e[d] = t } function Xv (e, d) { let t = e.pendingLanes & ~d; e.pendingLanes = d, e.suspendedLanes = 0, e.pingedLanes = 0, e.expiredLanes &= d, e.mutableReadLanes &= d, e.entangledLanes &= d, d = e.entanglements; const i = e.eventTimes; for (e = e.expirationTimes; t > 0;) { const h = 31 - pe(t); const n = 1 << h; d[h] = 0, i[h] = -1, e[h] = -1, t &= ~n } } function Za (e, d) { let t = e.entangledLanes |= d; for (e = e.entanglements; t;) { const i = 31 - pe(t); const h = 1 << i; h & d | e[i] & d && (e[i] |= d), t &= ~h } } let ut = 0; function Hh (e) { return e &= -e, e > 1 ? e > 4 ? (e & 268435455) != 0 ? 16 : 536870912 : 4 : 1 } let Kh; let Qa; let Zh; let Qh; let Jh; let Ja = !1; const zs = []; let ke = null; let qe = null; let _e = null; const Nn = new Map(); const Gn = new Map(); const ti = []; const Wv = 'mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit'.split(' '); function $h (e, d) { switch (e) { case 'focusin':case 'focusout':ke = null; break; case 'dragenter':case 'dragleave':qe = null; break; case 'mouseover':case 'mouseout':_e = null; break; case 'pointerover':case 'pointerout':Nn.delete(d.pointerId); break; case 'gotpointercapture':case 'lostpointercapture':Gn.delete(d.pointerId) } } function wn (e, d, t, i, h, n) { return e === null || e.nativeEvent !== n ? (e = { blockedOn: d, domEventName: t, eventSystemFlags: i, nativeEvent: n, targetContainers: [h] }, d !== null && (d = bn(d), d !== null && Qa(d)), e) : (e.eventSystemFlags |= i, d = e.targetContainers, h !== null && d.indexOf(h) === -1 && d.push(h), e) } function Hv (e, d, t, i, h) { switch (d) { case 'focusin':return ke = wn(ke, e, d, t, i, h), !0; case 'dragenter':return qe = wn(qe, e, d, t, i, h), !0; case 'mouseover':return _e = wn(_e, e, d, t, i, h), !0; case 'pointerover':var n = h.pointerId; return Nn.set(n, wn(Nn.get(n) || null, e, d, t, i, h)), !0; case 'gotpointercapture':return n = h.pointerId, Gn.set(n, wn(Gn.get(n) || null, e, d, t, i, h)), !0 } return !1 } function jh (e) { let d = yi(e.target); if (d !== null) { const t = xi(d); if (t !== null) { if (d = t.tag, d === 13) { if (d = Nh(t), d !== null) { e.blockedOn = d, Jh(e.priority, function () { Zh(t) }); return } } else if (d === 3 && t.stateNode.current.memoizedState.isDehydrated) { e.blockedOn = t.tag === 3 ? t.stateNode.containerInfo : null; return } } }e.blockedOn = null } function Us (e) { if (e.blockedOn !== null) return !1; for (let d = e.targetContainers; d.length > 0;) { let t = ja(e.domEventName, e.eventSystemFlags, d[0], e.nativeEvent); if (t === null) { t = e.nativeEvent; const i = new t.constructor(t.type, t); wa = i, t.target.dispatchEvent(i), wa = null } else return d = bn(t), d !== null && Qa(d), e.blockedOn = t, !1; d.shift() } return !0 } function bh (e, d, t) { Us(e) && t.delete(d) } function Kv () { Ja = !1, ke !== null && Us(ke) && (ke = null), qe !== null && Us(qe) && (qe = null), _e !== null && Us(_e) && (_e = null), Nn.forEach(bh), Gn.forEach(bh) } function zn (e, d) { e.blockedOn === d && (e.blockedOn = null, Ja || (Ja = !0, _t.unstable_scheduleCallback(_t.unstable_NormalPriority, Kv))) } function Un (e) { function d (h) { return zn(h, e) } if (zs.length > 0) { zn(zs[0], e); for (var t = 1; t < zs.length; t++) { var i = zs[t]; i.blockedOn === e && (i.blockedOn = null) } } for (ke !== null && zn(ke, e), qe !== null && zn(qe, e), _e !== null && zn(_e, e), Nn.forEach(d), Gn.forEach(d), t = 0; t < ti.length; t++)i = ti[t], i.blockedOn === e && (i.blockedOn = null); for (;ti.length > 0 && (t = ti[0], t.blockedOn === null);)jh(t), t.blockedOn === null && ti.shift() } const Wi = we.ReactCurrentBatchConfig; let Ys = !0; function Zv (e, d, t, i) { const h = ut; const n = Wi.transition; Wi.transition = null; try { ut = 1, $a(e, d, t, i) } finally { ut = h, Wi.transition = n } } function Qv (e, d, t, i) { const h = ut; const n = Wi.transition; Wi.transition = null; try { ut = 4, $a(e, d, t, i) } finally { ut = h, Wi.transition = n } } function $a (e, d, t, i) { if (Ys) { let h = ja(e, d, t, i); if (h === null)ho(e, d, i, Vs, t), $h(e, i); else if (Hv(h, e, d, t, i))i.stopPropagation(); else if ($h(e, i), d & 4 && Wv.indexOf(e) > -1) { for (;h !== null;) { let n = bn(h); if (n !== null && Kh(n), n = ja(e, d, t, i), n === null && ho(e, d, i, Vs, t), n === h) break; h = n }h !== null && i.stopPropagation() } else ho(e, d, i, null, t) } } var Vs = null; function ja (e, d, t, i) { if (Vs = null, e = za(i), e = yi(e), e !== null) if (d = xi(e), d === null)e = null; else if (t = d.tag, t === 13) { if (e = Nh(d), e !== null) return e; e = null } else if (t === 3) { if (d.stateNode.current.memoizedState.isDehydrated) return d.tag === 3 ? d.stateNode.containerInfo : null; e = null } else d !== e && (e = null); return Vs = e, null } function kh (e) { switch (e) { case 'cancel':case 'click':case 'close':case 'contextmenu':case 'copy':case 'cut':case 'auxclick':case 'dblclick':case 'dragend':case 'dragstart':case 'drop':case 'focusin':case 'focusout':case 'input':case 'invalid':case 'keydown':case 'keypress':case 'keyup':case 'mousedown':case 'mouseup':case 'paste':case 'pause':case 'play':case 'pointercancel':case 'pointerdown':case 'pointerup':case 'ratechange':case 'reset':case 'resize':case 'seeked':case 'submit':case 'touchcancel':case 'touchend':case 'touchstart':case 'volumechange':case 'change':case 'selectionchange':case 'textInput':case 'compositionstart':case 'compositionend':case 'compositionupdate':case 'beforeblur':case 'afterblur':case 'beforeinput':case 'blur':case 'fullscreenchange':case 'focus':case 'hashchange':case 'popstate':case 'select':case 'selectstart':return 1; case 'drag':case 'dragenter':case 'dragexit':case 'dragleave':case 'dragover':case 'mousemove':case 'mouseout':case 'mouseover':case 'pointermove':case 'pointerout':case 'pointerover':case 'scroll':case 'toggle':case 'touchmove':case 'wheel':case 'mouseenter':case 'mouseleave':case 'pointerenter':case 'pointerleave':return 4; case 'message':switch (Bv()) { case Wa:return 1; case Vh:return 4; case Is:case Nv:return 16; case Xh:return 536870912; default:return 16 } default:return 16 } } let ei = null; let ba = null; let Xs = null; function qh () { if (Xs) return Xs; let e; const d = ba; const t = d.length; let i; const h = 'value' in ei ? ei.value : ei.textContent; const n = h.length; for (e = 0; e < t && d[e] === h[e]; e++);const o = t - e; for (i = 1; i <= o && d[t - i] === h[n - i]; i++);return Xs = h.slice(e, i > 1 ? 1 - i : void 0) } function Ws (e) { const d = e.keyCode; return 'charCode' in e ? (e = e.charCode, e === 0 && d === 13 && (e = 13)) : e = d, e === 10 && (e = 13), e >= 32 || e === 13 ? e : 0 } function Hs () { return !0 } function _h () { return !1 } function te (e) { function d (t, i, h, n, o) { this._reactName = t, this._targetInst = h, this.type = i, this.nativeEvent = n, this.target = o, this.currentTarget = null; for (const r in e)e.hasOwnProperty(r) && (t = e[r], this[r] = t ? t(n) : n[r]); return this.isDefaultPrevented = (n.defaultPrevented != null ? n.defaultPrevented : n.returnValue === !1) ? Hs : _h, this.isPropagationStopped = _h, this } return xt(d.prototype, { preventDefault: function () { this.defaultPrevented = !0; const t = this.nativeEvent; t && (t.preventDefault ? t.preventDefault() : typeof t.returnValue !== 'unknown' && (t.returnValue = !1), this.isDefaultPrevented = Hs) }, stopPropagation: function () { const t = this.nativeEvent; t && (t.stopPropagation ? t.stopPropagation() : typeof t.cancelBubble !== 'unknown' && (t.cancelBubble = !0), this.isPropagationStopped = Hs) }, persist: function () {}, isPersistent: Hs }), d } const Hi = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (e) { return e.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }; const ka = te(Hi); const Yn = xt({}, Hi, { view: 0, detail: 0 }); const Jv = te(Yn); let qa; let _a; let Vn; const Ks = xt({}, Yn, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: eo, button: 0, buttons: 0, relatedTarget: function (e) { return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget }, movementX: function (e) { return 'movementX' in e ? e.movementX : (e !== Vn && (Vn && e.type === 'mousemove' ? (qa = e.screenX - Vn.screenX, _a = e.screenY - Vn.screenY) : _a = qa = 0, Vn = e), qa) }, movementY: function (e) { return 'movementY' in e ? e.movementY : _a } }); const tu = te(Ks); const $v = xt({}, Ks, { dataTransfer: 0 }); const jv = te($v); const bv = xt({}, Yn, { relatedTarget: 0 }); const to = te(bv); const kv = xt({}, Hi, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }); const qv = te(kv); const _v = xt({}, Hi, { clipboardData: function (e) { return 'clipboardData' in e ? e.clipboardData : window.clipboardData } }); const tc = te(_v); const ec = xt({}, Hi, { data: 0 }); const eu = te(ec); const ic = { Esc: 'Escape', Spacebar: ' ', Left: 'ArrowLeft', Up: 'ArrowUp', Right: 'ArrowRight', Down: 'ArrowDown', Del: 'Delete', Win: 'OS', Menu: 'ContextMenu', Apps: 'ContextMenu', Scroll: 'ScrollLock', MozPrintableKey: 'Unidentified' }; const nc = { 8: 'Backspace', 9: 'Tab', 12: 'Clear', 13: 'Enter', 16: 'Shift', 17: 'Control', 18: 'Alt', 19: 'Pause', 20: 'CapsLock', 27: 'Escape', 32: ' ', 33: 'PageUp', 34: 'PageDown', 35: 'End', 36: 'Home', 37: 'ArrowLeft', 38: 'ArrowUp', 39: 'ArrowRight', 40: 'ArrowDown', 45: 'Insert', 46: 'Delete', 112: 'F1', 113: 'F2', 114: 'F3', 115: 'F4', 116: 'F5', 117: 'F6', 118: 'F7', 119: 'F8', 120: 'F9', 121: 'F10', 122: 'F11', 123: 'F12', 144: 'NumLock', 145: 'ScrollLock', 224: 'Meta' }; const sc = { Alt: 'altKey', Control: 'ctrlKey', Meta: 'metaKey', Shift: 'shiftKey' }; function rc (e) { const d = this.nativeEvent; return d.getModifierState ? d.getModifierState(e) : (e = sc[e]) ? !!d[e] : !1 } function eo () { return rc } const ac = xt({}, Yn, { key: function (e) { if (e.key) { const d = ic[e.key] || e.key; if (d !== 'Unidentified') return d } return e.type === 'keypress' ? (e = Ws(e), e === 13 ? 'Enter' : String.fromCharCode(e)) : e.type === 'keydown' || e.type === 'keyup' ? nc[e.keyCode] || 'Unidentified' : '' }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: eo, charCode: function (e) { return e.type === 'keypress' ? Ws(e) : 0 }, keyCode: function (e) { return e.type === 'keydown' || e.type === 'keyup' ? e.keyCode : 0 }, which: function (e) { return e.type === 'keypress' ? Ws(e) : e.type === 'keydown' || e.type === 'keyup' ? e.keyCode : 0 } }); const oc = te(ac); const lc = xt({}, Ks, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }); const iu = te(lc); const hc = xt({}, Yn, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: eo }); const uc = te(hc); const fc = xt({}, Hi, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }); const dc = te(fc); const vc = xt({}, Ks, { deltaX: function (e) { return 'deltaX' in e ? e.deltaX : 'wheelDeltaX' in e ? -e.wheelDeltaX : 0 }, deltaY: function (e) { return 'deltaY' in e ? e.deltaY : 'wheelDeltaY' in e ? -e.wheelDeltaY : 'wheelDelta' in e ? -e.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }); const cc = te(vc); const pc = [9, 13, 27, 32]; const io = Ge && 'CompositionEvent' in window; let Xn = null; Ge && 'documentMode' in document && (Xn = document.documentMode); const mc = Ge && 'TextEvent' in window && !Xn; const nu = Ge && (!io || Xn && Xn > 8 && Xn <= 11); const su = String.fromCharCode(32); let ru = !1; function au (e, d) { switch (e) { case 'keyup':return pc.indexOf(d.keyCode) !== -1; case 'keydown':return d.keyCode !== 229; case 'keypress':case 'mousedown':case 'focusout':return !0; default:return !1 } } function ou (e) { return e = e.detail, typeof e === 'object' && 'data' in e ? e.data : null } let Ki = !1; function gc (e, d) { switch (e) { case 'compositionend':return ou(d); case 'keypress':return d.which !== 32 ? null : (ru = !0, su); case 'textInput':return e = d.data, e === su && ru ? null : e; default:return null } } function xc (e, d) { if (Ki) return e === 'compositionend' || !io && au(e, d) ? (e = qh(), Xs = ba = ei = null, Ki = !1, e) : null; switch (e) { case 'paste':return null; case 'keypress':if (!(d.ctrlKey || d.altKey || d.metaKey) || d.ctrlKey && d.altKey) { if (d.char && d.char.length > 1) return d.char; if (d.which) return String.fromCharCode(d.which) } return null; case 'compositionend':return nu && d.locale !== 'ko' ? null : d.data; default:return null } } const yc = { color: !0, date: !0, datetime: !0, 'datetime-local': !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function lu (e) { const d = e && e.nodeName && e.nodeName.toLowerCase(); return d === 'input' ? !!yc[e.type] : d === 'textarea' } function hu (e, d, t, i) { Oh(i), d = _s(d, 'onChange'), d.length > 0 && (t = new ka('onChange', 'change', null, t, i), e.push({ event: t, listeners: d })) } let Wn = null; let Hn = null; function Tc (e) { Lu(e, 0) } function Zs (e) { const d = ji(e); if (gh(d)) return e } function Sc (e, d) { if (e === 'change') return d } let uu = !1; Ge && (Ge ? (Js = 'oninput' in document, Js || (no = document.createElement('div'), no.setAttribute('oninput', 'return;'), Js = typeof no.oninput === 'function'), Qs = Js) : Qs = !1, uu = Qs && (!document.documentMode || document.documentMode > 9)); let Qs, Js, no; function fu () { Wn && (Wn.detachEvent('onpropertychange', du), Hn = Wn = null) } function du (e) { if (e.propertyName === 'value' && Zs(Hn)) { const d = []; hu(d, Hn, e, za(e)), Bh(Tc, d) } } function Ec (e, d, t) { e === 'focusin' ? (fu(), Wn = d, Hn = t, Wn.attachEvent('onpropertychange', du)) : e === 'focusout' && fu() } function Cc (e) { if (e === 'selectionchange' || e === 'keyup' || e === 'keydown') return Zs(Hn) } function Ac (e, d) { if (e === 'click') return Zs(d) } function Pc (e, d) { if (e === 'input' || e === 'change') return Zs(d) } function Mc (e, d) { return e === d && (e !== 0 || 1 / e == 1 / d) || e !== e && d !== d } const me = typeof Object.is === 'function' ? Object.is : Mc; function Kn (e, d) { if (me(e, d)) return !0; if (typeof e !== 'object' || e === null || typeof d !== 'object' || d === null) return !1; const t = Object.keys(e); let i = Object.keys(d); if (t.length !== i.length) return !1; for (i = 0; i < t.length; i++) { const h = t[i]; if (!pa.call(d, h) || !me(e[h], d[h])) return !1 } return !0 } function vu (e) { for (;e && e.firstChild;)e = e.firstChild; return e } function cu (e, d) { let t = vu(e); e = 0; for (var i; t;) { if (t.nodeType === 3) { if (i = e + t.textContent.length, e <= d && i >= d) return { node: t, offset: d - e }; e = i }t: { for (;t;) { if (t.nextSibling) { t = t.nextSibling; break t }t = t.parentNode }t = void 0 }t = vu(t) } } function pu (e, d) { return e && d ? e === d ? !0 : e && e.nodeType === 3 ? !1 : d && d.nodeType === 3 ? pu(e, d.parentNode) : 'contains' in e ? e.contains(d) : e.compareDocumentPosition ? !!(e.compareDocumentPosition(d) & 16) : !1 : !1 } function mu () { for (var e = window, d = Ls(); d instanceof e.HTMLIFrameElement;) { try { var t = typeof d.contentWindow.location.href === 'string' } catch (i) { t = !1 } if (t)e = d.contentWindow; else break; d = Ls(e.document) } return d } function so (e) { const d = e && e.nodeName && e.nodeName.toLowerCase(); return d && (d === 'input' && (e.type === 'text' || e.type === 'search' || e.type === 'tel' || e.type === 'url' || e.type === 'password') || d === 'textarea' || e.contentEditable === 'true') } function Rc (e) { let d = mu(); let t = e.focusedElem; let i = e.selectionRange; if (d !== t && t && t.ownerDocument && pu(t.ownerDocument.documentElement, t)) { if (i !== null && so(t)) { if (d = i.start, e = i.end, e === void 0 && (e = d), 'selectionStart' in t)t.selectionStart = d, t.selectionEnd = Math.min(e, t.value.length); else if (e = (d = t.ownerDocument || document) && d.defaultView || window, e.getSelection) { e = e.getSelection(); let h = t.textContent.length; let n = Math.min(i.start, h); i = i.end === void 0 ? n : Math.min(i.end, h), !e.extend && n > i && (h = i, i = n, n = h), h = cu(t, n); const o = cu(t, i); h && o && (e.rangeCount !== 1 || e.anchorNode !== h.node || e.anchorOffset !== h.offset || e.focusNode !== o.node || e.focusOffset !== o.offset) && (d = d.createRange(), d.setStart(h.node, h.offset), e.removeAllRanges(), n > i ? (e.addRange(d), e.extend(o.node, o.offset)) : (d.setEnd(o.node, o.offset), e.addRange(d))) } } for (d = [], e = t; e = e.parentNode;)e.nodeType === 1 && d.push({ element: e, left: e.scrollLeft, top: e.scrollTop }); for (typeof t.focus === 'function' && t.focus(), t = 0; t < d.length; t++)e = d[t], e.element.scrollLeft = e.left, e.element.scrollTop = e.top } } const Lc = Ge && 'documentMode' in document && document.documentMode <= 11; let Zi = null; let ro = null; let Zn = null; let ao = !1; function gu (e, d, t) { let i = t.window === t ? t.document : t.nodeType === 9 ? t : t.ownerDocument; ao || Zi == null || Zi !== Ls(i) || (i = Zi, 'selectionStart' in i && so(i) ? i = { start: i.selectionStart, end: i.selectionEnd } : (i = (i.ownerDocument && i.ownerDocument.defaultView || window).getSelection(), i = { anchorNode: i.anchorNode, anchorOffset: i.anchorOffset, focusNode: i.focusNode, focusOffset: i.focusOffset }), Zn && Kn(Zn, i) || (Zn = i, i = _s(ro, 'onSelect'), i.length > 0 && (d = new ka('onSelect', 'select', null, d, t), e.push({ event: d, listeners: i }), d.target = Zi))) } function $s (e, d) { const t = {}; return t[e.toLowerCase()] = d.toLowerCase(), t['Webkit' + e] = 'webkit' + d, t['Moz' + e] = 'moz' + d, t } const Qi = { animationend: $s('Animation', 'AnimationEnd'), animationiteration: $s('Animation', 'AnimationIteration'), animationstart: $s('Animation', 'AnimationStart'), transitionend: $s('Transition', 'TransitionEnd') }; const oo = {}; let xu = {}; Ge && (xu = document.createElement('div').style, 'AnimationEvent' in window || (delete Qi.animationend.animation, delete Qi.animationiteration.animation, delete Qi.animationstart.animation), 'TransitionEvent' in window || delete Qi.transitionend.transition); function js (e) { if (oo[e]) return oo[e]; if (!Qi[e]) return e; const d = Qi[e]; let t; for (t in d) if (d.hasOwnProperty(t) && t in xu) return oo[e] = d[t]; return e } const yu = js('animationend'); const Tu = js('animationiteration'); const Su = js('animationstart'); const Eu = js('transitionend'); const Cu = new Map(); const Au = 'abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel'.split(' '); function ii (e, d) { Cu.set(e, d), gi(d, [e]) } for (bs = 0; bs < Au.length; bs++)ks = Au[bs], Pu = ks.toLowerCase(), Mu = ks[0].toUpperCase() + ks.slice(1), ii(Pu, 'on' + Mu); let ks, Pu, Mu, bs; ii(yu, 'onAnimationEnd'); ii(Tu, 'onAnimationIteration'); ii(Su, 'onAnimationStart'); ii('dblclick', 'onDoubleClick'); ii('focusin', 'onFocus'); ii('focusout', 'onBlur'); ii(Eu, 'onTransitionEnd'); Gi('onMouseEnter', ['mouseout', 'mouseover']); Gi('onMouseLeave', ['mouseout', 'mouseover']); Gi('onPointerEnter', ['pointerout', 'pointerover']); Gi('onPointerLeave', ['pointerout', 'pointerover']); gi('onChange', 'change click focusin focusout input keydown keyup selectionchange'.split(' ')); gi('onSelect', 'focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange'.split(' ')); gi('onBeforeInput', ['compositionend', 'keypress', 'textInput', 'paste']); gi('onCompositionEnd', 'compositionend focusout keydown keypress keyup mousedown'.split(' ')); gi('onCompositionStart', 'compositionstart focusout keydown keypress keyup mousedown'.split(' ')); gi('onCompositionUpdate', 'compositionupdate focusout keydown keypress keyup mousedown'.split(' ')); const Qn = 'abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting'.split(' '); const Oc = new Set('cancel close invalid load scroll toggle'.split(' ').concat(Qn)); function Ru (e, d, t) { const i = e.type || 'unknown-event'; e.currentTarget = t, Ov(i, d, void 0, e), e.currentTarget = null } function Lu (e, d) { d = (d & 4) != 0; for (let t = 0; t < e.length; t++) { let i = e[t]; const h = i.event; i = i.listeners; t: { let n = void 0; if (d) for (var o = i.length - 1; o >= 0; o--) { var r = i[o]; var s = r.instance; var a = r.currentTarget; if (r = r.listener, s !== n && h.isPropagationStopped()) break t; Ru(h, r, a), n = s } else for (o = 0; o < i.length; o++) { if (r = i[o], s = r.instance, a = r.currentTarget, r = r.listener, s !== n && h.isPropagationStopped()) break t; Ru(h, r, a), n = s } } } if (Ds) throw e = Xa, Ds = !1, Xa = null, e } function pt (e, d) { let t = d[mo]; t === void 0 && (t = d[mo] = new Set()); const i = e + '__bubble'; t.has(i) || (Ou(d, e, 2, !1), t.add(i)) } function lo (e, d, t) { let i = 0; d && (i |= 4), Ou(t, e, i, d) } const qs = '_reactListening' + Math.random().toString(36).slice(2); function Jn (e) { if (!e[qs]) { e[qs] = !0, hh.forEach(function (t) { t !== 'selectionchange' && (Oc.has(t) || lo(t, !1, e), lo(t, !0, e)) }); const d = e.nodeType === 9 ? e : e.ownerDocument; d === null || d[qs] || (d[qs] = !0, lo('selectionchange', !1, d)) } } function Ou (e, d, t, i) { switch (kh(d)) { case 1:var h = Zv; break; case 4:h = Qv; break; default:h = $a }t = h.bind(null, d, t, e), h = void 0, !Va || d !== 'touchstart' && d !== 'touchmove' && d !== 'wheel' || (h = !0), i ? h !== void 0 ? e.addEventListener(d, t, { capture: !0, passive: h }) : e.addEventListener(d, t, !0) : h !== void 0 ? e.addEventListener(d, t, { passive: h }) : e.addEventListener(d, t, !1) } function ho (e, d, t, i, h) { let n = i; if ((d & 1) == 0 && (d & 2) == 0 && i !== null)t:for (;;) { if (i === null) return; let o = i.tag; if (o === 3 || o === 4) { let r = i.stateNode.containerInfo; if (r === h || r.nodeType === 8 && r.parentNode === h) break; if (o === 4) for (o = i.return; o !== null;) { var s = o.tag; if ((s === 3 || s === 4) && (s = o.stateNode.containerInfo, s === h || s.nodeType === 8 && s.parentNode === h)) return; o = o.return } for (;r !== null;) { if (o = yi(r), o === null) return; if (s = o.tag, s === 5 || s === 6) { i = n = o; continue t }r = r.parentNode } }i = i.return }Bh(function () { let a = n; let f = za(t); const l = []; t: { var u = Cu.get(e); if (u !== void 0) { var v = ka; var p = e; switch (e) { case 'keypress':if (Ws(t) === 0) break t; case 'keydown':case 'keyup':v = oc; break; case 'focusin':p = 'focus', v = to; break; case 'focusout':p = 'blur', v = to; break; case 'beforeblur':case 'afterblur':v = to; break; case 'click':if (t.button === 2) break t; case 'auxclick':case 'dblclick':case 'mousedown':case 'mousemove':case 'mouseup':case 'mouseout':case 'mouseover':case 'contextmenu':v = tu; break; case 'drag':case 'dragend':case 'dragenter':case 'dragexit':case 'dragleave':case 'dragover':case 'dragstart':case 'drop':v = jv; break; case 'touchcancel':case 'touchend':case 'touchmove':case 'touchstart':v = uc; break; case yu:case Tu:case Su:v = qv; break; case Eu:v = dc; break; case 'scroll':v = Jv; break; case 'wheel':v = cc; break; case 'copy':case 'cut':case 'paste':v = tc; break; case 'gotpointercapture':case 'lostpointercapture':case 'pointercancel':case 'pointerdown':case 'pointermove':case 'pointerout':case 'pointerover':case 'pointerup':v = iu } var c = (d & 4) != 0; var m = !c && e === 'scroll'; var g = c ? u !== null ? u + 'Capture' : null : u; c = []; for (var x = a, y; x !== null;) { y = x; var T = y.stateNode; if (y.tag === 5 && T !== null && (y = T, g !== null && (T = Fn(x, g), T != null && c.push($n(x, T, y)))), m) break; x = x.return }c.length > 0 && (u = new v(u, p, null, t, f), l.push({ event: u, listeners: c })) } } if ((d & 7) == 0) { t: { if (u = e === 'mouseover' || e === 'pointerover', v = e === 'mouseout' || e === 'pointerout', u && t !== wa && (p = t.relatedTarget || t.fromElement) && (yi(p) || p[Ue])) break t; if ((v || u) && (u = f.window === f ? f : (u = f.ownerDocument) ? u.defaultView || u.parentWindow : window, v ? (p = t.relatedTarget || t.toElement, v = a, p = p ? yi(p) : null, p !== null && (m = xi(p), p !== m || p.tag !== 5 && p.tag !== 6) && (p = null)) : (v = null, p = a), v !== p)) { if (c = tu, T = 'onMouseLeave', g = 'onMouseEnter', x = 'mouse', (e === 'pointerout' || e === 'pointerover') && (c = iu, T = 'onPointerLeave', g = 'onPointerEnter', x = 'pointer'), m = v == null ? u : ji(v), y = p == null ? u : ji(p), u = new c(T, x + 'leave', v, t, f), u.target = m, u.relatedTarget = y, T = null, yi(f) === a && (c = new c(g, x + 'enter', p, t, f), c.target = y, c.relatedTarget = m, T = c), m = T, v && p)e: { for (c = v, g = p, x = 0, y = c; y; y = Ji(y))x++; for (y = 0, T = g; T; T = Ji(T))y++; for (;x - y > 0;)c = Ji(c), x--; for (;y - x > 0;)g = Ji(g), y--; for (;x--;) { if (c === g || g !== null && c === g.alternate) break e; c = Ji(c), g = Ji(g) }c = null } else c = null; v !== null && Fu(l, u, v, c, !1), p !== null && m !== null && Fu(l, m, p, c, !0) } }t: { if (u = a ? ji(a) : window, v = u.nodeName && u.nodeName.toLowerCase(), v === 'select' || v === 'input' && u.type === 'file') var S = Sc; else if (lu(u)) if (uu)S = Pc; else { S = Cc; var E = Ec } else (v = u.nodeName) && v.toLowerCase() === 'input' && (u.type === 'checkbox' || u.type === 'radio') && (S = Ac); if (S && (S = S(e, a))) { hu(l, S, t, f); break t }E && E(e, u, a), e === 'focusout' && (E = u._wrapperState) && E.controlled && u.type === 'number' && Da(u, 'number', u.value) } switch (E = a ? ji(a) : window, e) { case 'focusin':(lu(E) || E.contentEditable === 'true') && (Zi = E, ro = a, Zn = null); break; case 'focusout':Zn = ro = Zi = null; break; case 'mousedown':ao = !0; break; case 'contextmenu':case 'mouseup':case 'dragend':ao = !1, gu(l, t, f); break; case 'selectionchange':if (Lc) break; case 'keydown':case 'keyup':gu(l, t, f) } let C; if (io)t: { switch (e) { case 'compositionstart':var P = 'onCompositionStart'; break t; case 'compositionend':P = 'onCompositionEnd'; break t; case 'compositionupdate':P = 'onCompositionUpdate'; break t }P = void 0 } else Ki ? au(e, t) && (P = 'onCompositionEnd') : e === 'keydown' && t.keyCode === 229 && (P = 'onCompositionStart'); P && (nu && t.locale !== 'ko' && (Ki || P !== 'onCompositionStart' ? P === 'onCompositionEnd' && Ki && (C = qh()) : (ei = f, ba = 'value' in ei ? ei.value : ei.textContent, Ki = !0)), E = _s(a, P), E.length > 0 && (P = new eu(P, e, null, t, f), l.push({ event: P, listeners: E }), C ? P.data = C : (C = ou(t), C !== null && (P.data = C)))), (C = mc ? gc(e, t) : xc(e, t)) && (a = _s(a, 'onBeforeInput'), a.length > 0 && (f = new eu('onBeforeInput', 'beforeinput', null, t, f), l.push({ event: f, listeners: a }), f.data = C)) }Lu(l, d) }) } function $n (e, d, t) { return { instance: e, listener: d, currentTarget: t } } function _s (e, d) { for (var t = d + 'Capture', i = []; e !== null;) { let h = e; let n = h.stateNode; h.tag === 5 && n !== null && (h = n, n = Fn(e, t), n != null && i.unshift($n(e, n, h)), n = Fn(e, d), n != null && i.push($n(e, n, h))), e = e.return } return i } function Ji (e) { if (e === null) return null; do e = e.return; while (e && e.tag !== 5); return e || null } function Fu (e, d, t, i, h) { for (var n = d._reactName, o = []; t !== null && t !== i;) { let r = t; let s = r.alternate; const a = r.stateNode; if (s !== null && s === i) break; r.tag === 5 && a !== null && (r = a, h ? (s = Fn(t, n), s != null && o.unshift($n(t, s, r))) : h || (s = Fn(t, n), s != null && o.push($n(t, s, r)))), t = t.return }o.length !== 0 && e.push({ event: d, listeners: o }) } const Fc = /\r\n?/g; const Dc = /\u0000|\uFFFD/g; function Du (e) {
      return (typeof e === 'string' ? e : '' + e).replace(Fc, `
`).replace(Dc, '')
    } function tr (e, d, t) { if (d = Du(d), Du(e) !== d && t) throw Error(k(425)) } function er () {} let uo = null; let fo = null; function vo (e, d) { return e === 'textarea' || e === 'noscript' || typeof d.children === 'string' || typeof d.children === 'number' || typeof d.dangerouslySetInnerHTML === 'object' && d.dangerouslySetInnerHTML !== null && d.dangerouslySetInnerHTML.__html != null } const co = typeof setTimeout === 'function' ? setTimeout : void 0; const Ic = typeof clearTimeout === 'function' ? clearTimeout : void 0; const Iu = typeof Promise === 'function' ? Promise : void 0; const Bc = typeof queueMicrotask === 'function' ? queueMicrotask : typeof Iu !== 'undefined' ? function (e) { return Iu.resolve(null).then(e).catch(Nc) } : co; function Nc (e) { setTimeout(function () { throw e }) } function po (e, d) { let t = d; let i = 0; do { const h = t.nextSibling; if (e.removeChild(t), h && h.nodeType === 8) if (t = h.data, t === '/$') { if (i === 0) { e.removeChild(h), Un(d); return }i-- } else t !== '$' && t !== '$?' && t !== '$!' || i++; t = h } while (t); Un(d) } function ze (e) { for (;e != null; e = e.nextSibling) { let d = e.nodeType; if (d === 1 || d === 3) break; if (d === 8) { if (d = e.data, d === '$' || d === '$!' || d === '$?') break; if (d === '/$') return null } } return e } function Bu (e) { e = e.previousSibling; for (let d = 0; e;) { if (e.nodeType === 8) { const t = e.data; if (t === '$' || t === '$!' || t === '$?') { if (d === 0) return e; d-- } else t === '/$' && d++ }e = e.previousSibling } return null } const $i = Math.random().toString(36).slice(2); const Pe = '__reactFiber$' + $i; const jn = '__reactProps$' + $i; var Ue = '__reactContainer$' + $i; var mo = '__reactEvents$' + $i; const Gc = '__reactListeners$' + $i; const wc = '__reactHandles$' + $i; function yi (e) { let d = e[Pe]; if (d) return d; for (let t = e.parentNode; t;) { if (d = t[Ue] || t[Pe]) { if (t = d.alternate, d.child !== null || t !== null && t.child !== null) for (e = Bu(e); e !== null;) { if (t = e[Pe]) return t; e = Bu(e) } return d }e = t, t = e.parentNode } return null } function bn (e) { return e = e[Pe] || e[Ue], !e || e.tag !== 5 && e.tag !== 6 && e.tag !== 13 && e.tag !== 3 ? null : e } function ji (e) { if (e.tag === 5 || e.tag === 6) return e.stateNode; throw Error(k(33)) } function ir (e) { return e[jn] || null } const go = []; let bi = -1; function ni (e) { return { current: e } } function mt (e) { bi < 0 || (e.current = go[bi], go[bi] = null, bi--) } function vt (e, d) { bi++, go[bi] = e.current, e.current = d } const si = {}; const wt = ni(si); const Jt = ni(!1); let Ti = si; function ki (e, d) { const t = e.type.contextTypes; if (!t) return si; const i = e.stateNode; if (i && i.__reactInternalMemoizedUnmaskedChildContext === d) return i.__reactInternalMemoizedMaskedChildContext; const h = {}; let n; for (n in t)h[n] = d[n]; return i && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = d, e.__reactInternalMemoizedMaskedChildContext = h), h } function $t (e) { return e = e.childContextTypes, e != null } function nr () { mt(Jt), mt(wt) } function Nu (e, d, t) { if (wt.current !== si) throw Error(k(168)); vt(wt, d), vt(Jt, t) } function Gu (e, d, t) { let i = e.stateNode; if (d = d.childContextTypes, typeof i.getChildContext !== 'function') return t; i = i.getChildContext(); for (const h in i) if (!(h in d)) throw Error(k(108, Ev(e) || 'Unknown', h)); return xt({}, t, i) } function sr (e) { return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || si, Ti = wt.current, vt(wt, e), vt(Jt, Jt.current), !0 } function wu (e, d, t) { const i = e.stateNode; if (!i) throw Error(k(169)); t ? (e = Gu(e, d, Ti), i.__reactInternalMemoizedMergedChildContext = e, mt(Jt), mt(wt), vt(wt, e)) : mt(Jt), vt(Jt, t) } let Ye = null; let rr = !1; let xo = !1; function zu (e) { Ye === null ? Ye = [e] : Ye.push(e) } function zc (e) { rr = !0, zu(e) } function ri () { if (!xo && Ye !== null) { xo = !0; let e = 0; const d = ut; try { const t = Ye; for (ut = 1; e < t.length; e++) { let i = t[e]; do i = i(!0); while (i !== null) }Ye = null, rr = !1 } catch (h) { throw Ye !== null && (Ye = Ye.slice(e + 1)), Uh(Wa, ri), h } finally { ut = d, xo = !1 } } return null } const Uc = we.ReactCurrentBatchConfig; function ge (e, d) { if (e && e.defaultProps) { d = xt({}, d), e = e.defaultProps; for (const t in e)d[t] === void 0 && (d[t] = e[t]); return d } return d } const ar = ni(null); let or = null; let qi = null; let yo = null; function To () { yo = qi = or = null } function So (e) { const d = ar.current; mt(ar), e._currentValue = d } function Eo (e, d, t) { for (;e !== null;) { const i = e.alternate; if ((e.childLanes & d) !== d ? (e.childLanes |= d, i !== null && (i.childLanes |= d)) : i !== null && (i.childLanes & d) !== d && (i.childLanes |= d), e === t) break; e = e.return } } function _i (e, d) { or = e, yo = qi = null, e = e.dependencies, e !== null && e.firstContext !== null && ((e.lanes & d) != 0 && (bt = !0), e.firstContext = null) } function re (e) { const d = e._currentValue; if (yo !== e) if (e = { context: e, memoizedValue: d, next: null }, qi === null) { if (or === null) throw Error(k(308)); qi = e, or.dependencies = { lanes: 0, firstContext: e } } else qi = qi.next = e; return d } let xe = null; let ai = !1; function Co (e) { e.updateQueue = { baseState: e.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function Uu (e, d) { e = e.updateQueue, d.updateQueue === e && (d.updateQueue = { baseState: e.baseState, firstBaseUpdate: e.firstBaseUpdate, lastBaseUpdate: e.lastBaseUpdate, shared: e.shared, effects: e.effects }) } function Ve (e, d) { return { eventTime: e, lane: d, tag: 0, payload: null, callback: null, next: null } } function oi (e, d) { let t = e.updateQueue; t !== null && (t = t.shared, td(e) ? (e = t.interleaved, e === null ? (d.next = d, xe === null ? xe = [t] : xe.push(t)) : (d.next = e.next, e.next = d), t.interleaved = d) : (e = t.pending, e === null ? d.next = d : (d.next = e.next, e.next = d), t.pending = d)) } function lr (e, d, t) { if (d = d.updateQueue, d !== null && (d = d.shared, (t & 4194240) != 0)) { let i = d.lanes; i &= e.pendingLanes, t |= i, d.lanes = t, Za(e, t) } } function Yu (e, d) { let t = e.updateQueue; let i = e.alternate; if (i !== null && (i = i.updateQueue, t === i)) { let h = null; let n = null; if (t = t.firstBaseUpdate, t !== null) { do { const o = { eventTime: t.eventTime, lane: t.lane, tag: t.tag, payload: t.payload, callback: t.callback, next: null }; n === null ? h = n = o : n = n.next = o, t = t.next } while (t !== null); n === null ? h = n = d : n = n.next = d } else h = n = d; t = { baseState: i.baseState, firstBaseUpdate: h, lastBaseUpdate: n, shared: i.shared, effects: i.effects }, e.updateQueue = t; return }e = t.lastBaseUpdate, e === null ? t.firstBaseUpdate = d : e.next = d, t.lastBaseUpdate = d } function hr (e, d, t, i) { let h = e.updateQueue; ai = !1; let n = h.firstBaseUpdate; let o = h.lastBaseUpdate; let r = h.shared.pending; if (r !== null) { h.shared.pending = null; var s = r; var a = s.next; s.next = null, o === null ? n = a : o.next = a, o = s; var f = e.alternate; f !== null && (f = f.updateQueue, r = f.lastBaseUpdate, r !== o && (r === null ? f.firstBaseUpdate = a : r.next = a, f.lastBaseUpdate = s)) } if (n !== null) { let l = h.baseState; o = 0, f = a = s = null, r = n; do { let u = r.lane; let v = r.eventTime; if ((i & u) === u) { f !== null && (f = f.next = { eventTime: v, lane: 0, tag: r.tag, payload: r.payload, callback: r.callback, next: null }); t: { let p = e; const c = r; switch (u = d, v = t, c.tag) { case 1:if (p = c.payload, typeof p === 'function') { l = p.call(v, l, u); break t }l = p; break t; case 3:p.flags = p.flags & -65537 | 128; case 0:if (p = c.payload, u = typeof p === 'function' ? p.call(v, l, u) : p, u == null) break t; l = xt({}, l, u); break t; case 2:ai = !0 } }r.callback !== null && r.lane !== 0 && (e.flags |= 64, u = h.effects, u === null ? h.effects = [r] : u.push(r)) } else v = { eventTime: v, lane: u, tag: r.tag, payload: r.payload, callback: r.callback, next: null }, f === null ? (a = f = v, s = l) : f = f.next = v, o |= u; if (r = r.next, r === null) { if (r = h.shared.pending, r === null) break; u = r, r = u.next, u.next = null, h.lastBaseUpdate = u, h.shared.pending = null } } while (1); if (f === null && (s = l), h.baseState = s, h.firstBaseUpdate = a, h.lastBaseUpdate = f, d = h.shared.interleaved, d !== null) { h = d; do o |= h.lane, h = h.next; while (h !== d) } else n === null && (h.shared.lanes = 0); Pi |= o, e.lanes = o, e.memoizedState = l } } function Vu (e, d, t) { if (e = d.effects, d.effects = null, e !== null) for (d = 0; d < e.length; d++) { let i = e[d]; const h = i.callback; if (h !== null) { if (i.callback = null, i = t, typeof h !== 'function') throw Error(k(191, h)); h.call(i) } } } const Xu = new lh.Component().refs; function Ao (e, d, t, i) { d = e.memoizedState, t = t(i, d), t = t == null ? d : xt({}, d, t), e.memoizedState = t, e.lanes === 0 && (e.updateQueue.baseState = t) } const ur = { isMounted: function (e) { return (e = e._reactInternals) ? xi(e) === e : !1 }, enqueueSetState: function (e, d, t) { e = e._reactInternals; const i = Ht(); const h = fi(e); const n = Ve(i, h); n.payload = d, t != null && (n.callback = t), oi(e, n), d = ue(e, h, i), d !== null && lr(d, e, h) }, enqueueReplaceState: function (e, d, t) { e = e._reactInternals; const i = Ht(); const h = fi(e); const n = Ve(i, h); n.tag = 1, n.payload = d, t != null && (n.callback = t), oi(e, n), d = ue(e, h, i), d !== null && lr(d, e, h) }, enqueueForceUpdate: function (e, d) { e = e._reactInternals; const t = Ht(); const i = fi(e); const h = Ve(t, i); h.tag = 2, d != null && (h.callback = d), oi(e, h), d = ue(e, i, t), d !== null && lr(d, e, i) } }; function Wu (e, d, t, i, h, n, o) { return e = e.stateNode, typeof e.shouldComponentUpdate === 'function' ? e.shouldComponentUpdate(i, n, o) : d.prototype && d.prototype.isPureReactComponent ? !Kn(t, i) || !Kn(h, n) : !0 } function Hu (e, d, t) { let i = !1; let h = si; let n = d.contextType; return typeof n === 'object' && n !== null ? n = re(n) : (h = $t(d) ? Ti : wt.current, i = d.contextTypes, n = (i = i != null) ? ki(e, h) : si), d = new d(t, n), e.memoizedState = d.state !== null && d.state !== void 0 ? d.state : null, d.updater = ur, e.stateNode = d, d._reactInternals = e, i && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = h, e.__reactInternalMemoizedMaskedChildContext = n), d } function Ku (e, d, t, i) { e = d.state, typeof d.componentWillReceiveProps === 'function' && d.componentWillReceiveProps(t, i), typeof d.UNSAFE_componentWillReceiveProps === 'function' && d.UNSAFE_componentWillReceiveProps(t, i), d.state !== e && ur.enqueueReplaceState(d, d.state, null) } function Po (e, d, t, i) { const h = e.stateNode; h.props = t, h.state = e.memoizedState, h.refs = Xu, Co(e); let n = d.contextType; typeof n === 'object' && n !== null ? h.context = re(n) : (n = $t(d) ? Ti : wt.current, h.context = ki(e, n)), h.state = e.memoizedState, n = d.getDerivedStateFromProps, typeof n === 'function' && (Ao(e, d, n, t), h.state = e.memoizedState), typeof d.getDerivedStateFromProps === 'function' || typeof h.getSnapshotBeforeUpdate === 'function' || typeof h.UNSAFE_componentWillMount !== 'function' && typeof h.componentWillMount !== 'function' || (d = h.state, typeof h.componentWillMount === 'function' && h.componentWillMount(), typeof h.UNSAFE_componentWillMount === 'function' && h.UNSAFE_componentWillMount(), d !== h.state && ur.enqueueReplaceState(h, h.state, null), hr(e, t, h, i), h.state = e.memoizedState), typeof h.componentDidMount === 'function' && (e.flags |= 4194308) } const tn = []; let en = 0; let fr = null; let dr = 0; const ae = []; let oe = 0; let Si = null; let Xe = 1; let We = ''; function Ei (e, d) { tn[en++] = dr, tn[en++] = fr, fr = e, dr = d } function Zu (e, d, t) { ae[oe++] = Xe, ae[oe++] = We, ae[oe++] = Si, Si = e; let i = Xe; e = We; let h = 32 - pe(i) - 1; i &= ~(1 << h), t += 1; let n = 32 - pe(d) + h; if (n > 30) { const o = h - h % 5; n = (i & (1 << o) - 1).toString(32), i >>= o, h -= o, Xe = 1 << 32 - pe(d) + h | t << h | i, We = n + e } else Xe = 1 << n | t << h | i, We = e } function Mo (e) { e.return !== null && (Ei(e, 1), Zu(e, 1, 0)) } function Ro (e) { for (;e === fr;)fr = tn[--en], tn[en] = null, dr = tn[--en], tn[en] = null; for (;e === Si;)Si = ae[--oe], ae[oe] = null, We = ae[--oe], ae[oe] = null, Xe = ae[--oe], ae[oe] = null } let ee = null; let jt = null; let gt = !1; let ye = null; function Qu (e, d) { const t = fe(5, null, null, 0); t.elementType = 'DELETED', t.stateNode = d, t.return = e, d = e.deletions, d === null ? (e.deletions = [t], e.flags |= 16) : d.push(t) } function Ju (e, d) { switch (e.tag) { case 5:var t = e.type; return d = d.nodeType !== 1 || t.toLowerCase() !== d.nodeName.toLowerCase() ? null : d, d !== null ? (e.stateNode = d, ee = e, jt = ze(d.firstChild), !0) : !1; case 6:return d = e.pendingProps === '' || d.nodeType !== 3 ? null : d, d !== null ? (e.stateNode = d, ee = e, jt = null, !0) : !1; case 13:return d = d.nodeType !== 8 ? null : d, d !== null ? (t = Si !== null ? { id: Xe, overflow: We } : null, e.memoizedState = { dehydrated: d, treeContext: t, retryLane: 1073741824 }, t = fe(18, null, null, 0), t.stateNode = d, t.return = e, e.child = t, ee = e, jt = null, !0) : !1; default:return !1 } } function Lo (e) { return (e.mode & 1) != 0 && (e.flags & 128) == 0 } function Oo (e) { if (gt) { let d = jt; if (d) { const t = d; if (!Ju(e, d)) { if (Lo(e)) throw Error(k(418)); d = ze(t.nextSibling); const i = ee; d && Ju(e, d) ? Qu(i, t) : (e.flags = e.flags & -4097 | 2, gt = !1, ee = e) } } else { if (Lo(e)) throw Error(k(418)); e.flags = e.flags & -4097 | 2, gt = !1, ee = e } } } function $u (e) { for (e = e.return; e !== null && e.tag !== 5 && e.tag !== 3 && e.tag !== 13;)e = e.return; ee = e } function kn (e) { if (e !== ee) return !1; if (!gt) return $u(e), gt = !0, !1; let d; if ((d = e.tag !== 3) && !(d = e.tag !== 5) && (d = e.type, d = d !== 'head' && d !== 'body' && !vo(e.type, e.memoizedProps)), d && (d = jt)) { if (Lo(e)) { for (e = jt; e;)e = ze(e.nextSibling); throw Error(k(418)) } for (;d;)Qu(e, d), d = ze(d.nextSibling) } if ($u(e), e.tag === 13) { if (e = e.memoizedState, e = e !== null ? e.dehydrated : null, !e) throw Error(k(317)); t: { for (e = e.nextSibling, d = 0; e;) { if (e.nodeType === 8) { const t = e.data; if (t === '/$') { if (d === 0) { jt = ze(e.nextSibling); break t }d-- } else t !== '$' && t !== '$!' && t !== '$?' || d++ }e = e.nextSibling }jt = null } } else jt = ee ? ze(e.stateNode.nextSibling) : null; return !0 } function nn () { jt = ee = null, gt = !1 } function Fo (e) { ye === null ? ye = [e] : ye.push(e) } function qn (e, d, t) { if (e = t.ref, e !== null && typeof e !== 'function' && typeof e !== 'object') { if (t._owner) { if (t = t._owner, t) { if (t.tag !== 1) throw Error(k(309)); var i = t.stateNode } if (!i) throw Error(k(147, e)); const h = i; const n = '' + e; return d !== null && d.ref !== null && typeof d.ref === 'function' && d.ref._stringRef === n ? d.ref : (d = function (o) { let r = h.refs; r === Xu && (r = h.refs = {}), o === null ? delete r[n] : r[n] = o }, d._stringRef = n, d) } if (typeof e !== 'string') throw Error(k(284)); if (!t._owner) throw Error(k(290, e)) } return e } function vr (e, d) { throw e = Object.prototype.toString.call(d), Error(k(31, e === '[object Object]' ? 'object with keys {' + Object.keys(d).join(', ') + '}' : e)) } function ju (e) { const d = e._init; return d(e._payload) } function bu (e) { function d (g, x) { if (e) { const y = g.deletions; y === null ? (g.deletions = [x], g.flags |= 16) : y.push(x) } } function t (g, x) { if (!e) return null; for (;x !== null;)d(g, x), x = x.sibling; return null } function i (g, x) { for (g = new Map(); x !== null;)x.key !== null ? g.set(x.key, x) : g.set(x.index, x), x = x.sibling; return g } function h (g, x) { return g = vi(g, x), g.index = 0, g.sibling = null, g } function n (g, x, y) { return g.index = y, e ? (y = g.alternate, y !== null ? (y = y.index, y < x ? (g.flags |= 2, x) : y) : (g.flags |= 2, x)) : (g.flags |= 1048576, x) } function o (g) { return e && g.alternate === null && (g.flags |= 2), g } function r (g, x, y, T) { return x === null || x.tag !== 6 ? (x = fl(y, g.mode, T), x.return = g, x) : (x = h(x, y), x.return = g, x) } function s (g, x, y, T) { const S = y.type; return S === zi ? f(g, x, y.props.children, T, y.key) : x !== null && (x.elementType === S || typeof S === 'object' && S !== null && S.$$typeof === je && ju(S) === x.type) ? (T = h(x, y.props), T.ref = qn(g, x, y), T.return = g, T) : (T = Nr(y.type, y.key, y.props, null, g.mode, T), T.ref = qn(g, x, y), T.return = g, T) } function a (g, x, y, T) { return x === null || x.tag !== 4 || x.stateNode.containerInfo !== y.containerInfo || x.stateNode.implementation !== y.implementation ? (x = dl(y, g.mode, T), x.return = g, x) : (x = h(x, y.children || []), x.return = g, x) } function f (g, x, y, T, S) { return x === null || x.tag !== 7 ? (x = Oi(y, g.mode, T, S), x.return = g, x) : (x = h(x, y), x.return = g, x) } function l (g, x, y) { if (typeof x === 'string' && x !== '' || typeof x === 'number') return x = fl('' + x, g.mode, y), x.return = g, x; if (typeof x === 'object' && x !== null) { switch (x.$$typeof) { case Ms:return y = Nr(x.type, x.key, x.props, null, g.mode, y), y.ref = qn(g, null, x), y.return = g, y; case wi:return x = dl(x, g.mode, y), x.return = g, x; case je:var T = x._init; return l(g, T(x._payload), y) } if (Rn(x) || Pn(x)) return x = Oi(x, g.mode, y, null), x.return = g, x; vr(g, x) } return null } function u (g, x, y, T) { let S = x !== null ? x.key : null; if (typeof y === 'string' && y !== '' || typeof y === 'number') return S !== null ? null : r(g, x, '' + y, T); if (typeof y === 'object' && y !== null) { switch (y.$$typeof) { case Ms:return y.key === S ? s(g, x, y, T) : null; case wi:return y.key === S ? a(g, x, y, T) : null; case je:return S = y._init, u(g, x, S(y._payload), T) } if (Rn(y) || Pn(y)) return S !== null ? null : f(g, x, y, T, null); vr(g, y) } return null } function v (g, x, y, T, S) { if (typeof T === 'string' && T !== '' || typeof T === 'number') return g = g.get(y) || null, r(x, g, '' + T, S); if (typeof T === 'object' && T !== null) { switch (T.$$typeof) { case Ms:return g = g.get(T.key === null ? y : T.key) || null, s(x, g, T, S); case wi:return g = g.get(T.key === null ? y : T.key) || null, a(x, g, T, S); case je:var E = T._init; return v(g, x, y, E(T._payload), S) } if (Rn(T) || Pn(T)) return g = g.get(y) || null, f(x, g, T, S, null); vr(x, T) } return null } function p (g, x, y, T) { for (var S = null, E = null, C = x, P = x = 0, A = null; C !== null && P < y.length; P++) { C.index > P ? (A = C, C = null) : A = C.sibling; const M = u(g, C, y[P], T); if (M === null) { C === null && (C = A); break }e && C && M.alternate === null && d(g, C), x = n(M, x, P), E === null ? S = M : E.sibling = M, E = M, C = A } if (P === y.length) return t(g, C), gt && Ei(g, P), S; if (C === null) { for (;P < y.length; P++)C = l(g, y[P], T), C !== null && (x = n(C, x, P), E === null ? S = C : E.sibling = C, E = C); return gt && Ei(g, P), S } for (C = i(g, C); P < y.length; P++)A = v(C, g, P, y[P], T), A !== null && (e && A.alternate !== null && C.delete(A.key === null ? P : A.key), x = n(A, x, P), E === null ? S = A : E.sibling = A, E = A); return e && C.forEach(function (L) { return d(g, L) }), gt && Ei(g, P), S } function c (g, x, y, T) { let S = Pn(y); if (typeof S !== 'function') throw Error(k(150)); if (y = S.call(y), y == null) throw Error(k(151)); for (var E = S = null, C = x, P = x = 0, A = null, M = y.next(); C !== null && !M.done; P++, M = y.next()) { C.index > P ? (A = C, C = null) : A = C.sibling; const L = u(g, C, M.value, T); if (L === null) { C === null && (C = A); break }e && C && L.alternate === null && d(g, C), x = n(L, x, P), E === null ? S = L : E.sibling = L, E = L, C = A } if (M.done) return t(g, C), gt && Ei(g, P), S; if (C === null) { for (;!M.done; P++, M = y.next())M = l(g, M.value, T), M !== null && (x = n(M, x, P), E === null ? S = M : E.sibling = M, E = M); return gt && Ei(g, P), S } for (C = i(g, C); !M.done; P++, M = y.next())M = v(C, g, P, M.value, T), M !== null && (e && M.alternate !== null && C.delete(M.key === null ? P : M.key), x = n(M, x, P), E === null ? S = M : E.sibling = M, E = M); return e && C.forEach(function (F) { return d(g, F) }), gt && Ei(g, P), S } function m (g, x, y, T) { if (typeof y === 'object' && y !== null && y.type === zi && y.key === null && (y = y.props.children), typeof y === 'object' && y !== null) { switch (y.$$typeof) { case Ms:t: { for (var S = y.key, E = x; E !== null;) { if (E.key === S) { if (S = y.type, S === zi) { if (E.tag === 7) { t(g, E.sibling), x = h(E, y.props.children), x.return = g, g = x; break t } } else if (E.elementType === S || typeof S === 'object' && S !== null && S.$$typeof === je && ju(S) === E.type) { t(g, E.sibling), x = h(E, y.props), x.ref = qn(g, E, y), x.return = g, g = x; break t }t(g, E); break } else d(g, E); E = E.sibling }y.type === zi ? (x = Oi(y.props.children, g.mode, T, y.key), x.return = g, g = x) : (T = Nr(y.type, y.key, y.props, null, g.mode, T), T.ref = qn(g, x, y), T.return = g, g = T) } return o(g); case wi:t: { for (E = y.key; x !== null;) { if (x.key === E) if (x.tag === 4 && x.stateNode.containerInfo === y.containerInfo && x.stateNode.implementation === y.implementation) { t(g, x.sibling), x = h(x, y.children || []), x.return = g, g = x; break t } else { t(g, x); break } else d(g, x); x = x.sibling }x = dl(y, g.mode, T), x.return = g, g = x } return o(g); case je:return E = y._init, m(g, x, E(y._payload), T) } if (Rn(y)) return p(g, x, y, T); if (Pn(y)) return c(g, x, y, T); vr(g, y) } return typeof y === 'string' && y !== '' || typeof y === 'number' ? (y = '' + y, x !== null && x.tag === 6 ? (t(g, x.sibling), x = h(x, y), x.return = g, g = x) : (t(g, x), x = fl(y, g.mode, T), x.return = g, g = x), o(g)) : t(g, x) } return m } const sn = bu(!0); const ku = bu(!1); const _n = {}; const Me = ni(_n); const ts = ni(_n); const es = ni(_n); function Ci (e) { if (e === _n) throw Error(k(174)); return e } function Do (e, d) { switch (vt(es, d), vt(ts, e), vt(Me, _n), e = d.nodeType, e) { case 9:case 11:d = (d = d.documentElement) ? d.namespaceURI : Ba(null, ''); break; default:e = e === 8 ? d.parentNode : d, d = e.namespaceURI || null, e = e.tagName, d = Ba(d, e) }mt(Me), vt(Me, d) } function rn () { mt(Me), mt(ts), mt(es) } function qu (e) { Ci(es.current); const d = Ci(Me.current); const t = Ba(d, e.type); d !== t && (vt(ts, e), vt(Me, t)) } function Io (e) { ts.current === e && (mt(Me), mt(ts)) } const yt = ni(0); function cr (e) { for (let d = e; d !== null;) { if (d.tag === 13) { let t = d.memoizedState; if (t !== null && (t = t.dehydrated, t === null || t.data === '$?' || t.data === '$!')) return d } else if (d.tag === 19 && d.memoizedProps.revealOrder !== void 0) { if ((d.flags & 128) != 0) return d } else if (d.child !== null) { d.child.return = d, d = d.child; continue } if (d === e) break; for (;d.sibling === null;) { if (d.return === null || d.return === e) return null; d = d.return }d.sibling.return = d.return, d = d.sibling } return null } const Bo = []; function No () { for (let e = 0; e < Bo.length; e++)Bo[e]._workInProgressVersionPrimary = null; Bo.length = 0 } const pr = we.ReactCurrentDispatcher; const Go = we.ReactCurrentBatchConfig; let Ai = 0; let Tt = null; let Rt = null; let Dt = null; let mr = !1; let is = !1; let ns = 0; let Yc = 0; function zt () { throw Error(k(321)) } function wo (e, d) { if (d === null) return !1; for (let t = 0; t < d.length && t < e.length; t++) if (!me(e[t], d[t])) return !1; return !0 } function zo (e, d, t, i, h, n) { if (Ai = n, Tt = d, d.memoizedState = null, d.updateQueue = null, d.lanes = 0, pr.current = e === null || e.memoizedState === null ? Hc : Kc, e = t(i, h), is) { n = 0; do { if (is = !1, ns = 0, n >= 25) throw Error(k(301)); n += 1, Dt = Rt = null, d.updateQueue = null, pr.current = Zc, e = t(i, h) } while (is) } if (pr.current = yr, d = Rt !== null && Rt.next !== null, Ai = 0, Dt = Rt = Tt = null, mr = !1, d) throw Error(k(300)); return e } function Uo () { const e = ns !== 0; return ns = 0, e } function Re () { const e = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return Dt === null ? Tt.memoizedState = Dt = e : Dt = Dt.next = e, Dt } function le () { if (Rt === null) { var e = Tt.alternate; e = e !== null ? e.memoizedState : null } else e = Rt.next; const d = Dt === null ? Tt.memoizedState : Dt.next; if (d !== null)Dt = d, Rt = e; else { if (e === null) throw Error(k(310)); Rt = e, e = { memoizedState: Rt.memoizedState, baseState: Rt.baseState, baseQueue: Rt.baseQueue, queue: Rt.queue, next: null }, Dt === null ? Tt.memoizedState = Dt = e : Dt = Dt.next = e } return Dt } function ss (e, d) { return typeof d === 'function' ? d(e) : d } function Yo (e) { const d = le(); const t = d.queue; if (t === null) throw Error(k(311)); t.lastRenderedReducer = e; let i = Rt; let h = i.baseQueue; let n = t.pending; if (n !== null) { if (h !== null) { var o = h.next; h.next = n.next, n.next = o }i.baseQueue = h = n, t.pending = null } if (h !== null) { n = h.next, i = i.baseState; let r = o = null; let s = null; let a = n; do { const f = a.lane; if ((Ai & f) === f)s !== null && (s = s.next = { lane: 0, action: a.action, hasEagerState: a.hasEagerState, eagerState: a.eagerState, next: null }), i = a.hasEagerState ? a.eagerState : e(i, a.action); else { const l = { lane: f, action: a.action, hasEagerState: a.hasEagerState, eagerState: a.eagerState, next: null }; s === null ? (r = s = l, o = i) : s = s.next = l, Tt.lanes |= f, Pi |= f }a = a.next } while (a !== null && a !== n); s === null ? o = i : s.next = r, me(i, d.memoizedState) || (bt = !0), d.memoizedState = i, d.baseState = o, d.baseQueue = s, t.lastRenderedState = i } if (e = t.interleaved, e !== null) { h = e; do n = h.lane, Tt.lanes |= n, Pi |= n, h = h.next; while (h !== e) } else h === null && (t.lanes = 0); return [d.memoizedState, t.dispatch] } function Vo (e) { const d = le(); const t = d.queue; if (t === null) throw Error(k(311)); t.lastRenderedReducer = e; const i = t.dispatch; let h = t.pending; let n = d.memoizedState; if (h !== null) { t.pending = null; let o = h = h.next; do n = e(n, o.action), o = o.next; while (o !== h); me(n, d.memoizedState) || (bt = !0), d.memoizedState = n, d.baseQueue === null && (d.baseState = n), t.lastRenderedState = n } return [n, i] } function _u () {} function tf (e, d) { const t = Tt; let i = le(); const h = d(); const n = !me(i.memoizedState, h); if (n && (i.memoizedState = h, bt = !0), i = i.queue, Xo(sf.bind(null, t, i, e), [e]), i.getSnapshot !== d || n || Dt !== null && Dt.memoizedState.tag & 1) { if (t.flags |= 2048, rs(9, nf.bind(null, t, i, h, d), void 0, null), Lt === null) throw Error(k(349)); (Ai & 30) != 0 || ef(t, d, h) } return h } function ef (e, d, t) { e.flags |= 16384, e = { getSnapshot: d, value: t }, d = Tt.updateQueue, d === null ? (d = { lastEffect: null, stores: null }, Tt.updateQueue = d, d.stores = [e]) : (t = d.stores, t === null ? d.stores = [e] : t.push(e)) } function nf (e, d, t, i) { d.value = t, d.getSnapshot = i, rf(d) && ue(e, 1, -1) } function sf (e, d, t) { return t(function () { rf(d) && ue(e, 1, -1) }) } function rf (e) { const d = e.getSnapshot; e = e.value; try { const t = d(); return !me(e, t) } catch (i) { return !0 } } function af (e) { const d = Re(); return typeof e === 'function' && (e = e()), d.memoizedState = d.baseState = e, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ss, lastRenderedState: e }, d.queue = e, e = e.dispatch = Wc.bind(null, Tt, e), [d.memoizedState, e] } function rs (e, d, t, i) { return e = { tag: e, create: d, destroy: t, deps: i, next: null }, d = Tt.updateQueue, d === null ? (d = { lastEffect: null, stores: null }, Tt.updateQueue = d, d.lastEffect = e.next = e) : (t = d.lastEffect, t === null ? d.lastEffect = e.next = e : (i = t.next, t.next = e, e.next = i, d.lastEffect = e)), e } function of () { return le().memoizedState } function gr (e, d, t, i) { const h = Re(); Tt.flags |= e, h.memoizedState = rs(1 | d, t, void 0, i === void 0 ? null : i) } function xr (e, d, t, i) { const h = le(); i = i === void 0 ? null : i; let n = void 0; if (Rt !== null) { const o = Rt.memoizedState; if (n = o.destroy, i !== null && wo(i, o.deps)) { h.memoizedState = rs(d, t, n, i); return } }Tt.flags |= e, h.memoizedState = rs(1 | d, t, n, i) } function lf (e, d) { return gr(8390656, 8, e, d) } function Xo (e, d) { return xr(2048, 8, e, d) } function hf (e, d) { return xr(4, 2, e, d) } function uf (e, d) { return xr(4, 4, e, d) } function ff (e, d) { if (typeof d === 'function') return e = e(), d(e), function () { d(null) }; if (d != null) return e = e(), d.current = e, function () { d.current = null } } function df (e, d, t) { return t = t != null ? t.concat([e]) : null, xr(4, 4, ff.bind(null, d, e), t) } function Wo () {} function vf (e, d) { const t = le(); d = d === void 0 ? null : d; const i = t.memoizedState; return i !== null && d !== null && wo(d, i[1]) ? i[0] : (t.memoizedState = [e, d], e) } function cf (e, d) { const t = le(); d = d === void 0 ? null : d; const i = t.memoizedState; return i !== null && d !== null && wo(d, i[1]) ? i[0] : (e = e(), t.memoizedState = [e, d], e) } function pf (e, d, t) { return (Ai & 21) == 0 ? (e.baseState && (e.baseState = !1, bt = !0), e.memoizedState = t) : (me(t, d) || (t = Wh(), Tt.lanes |= t, Pi |= t, e.baseState = !0), d) } function Vc (e, d) { const t = ut; ut = t !== 0 && t < 4 ? t : 4, e(!0); const i = Go.transition; Go.transition = {}; try { e(!1), d() } finally { ut = t, Go.transition = i } } function mf () { return le().memoizedState } function Xc (e, d, t) { const i = fi(e); t = { lane: i, action: t, hasEagerState: !1, eagerState: null, next: null }, gf(e) ? xf(d, t) : (yf(e, d, t), t = Ht(), e = ue(e, i, t), e !== null && Tf(e, d, i)) } function Wc (e, d, t) { const i = fi(e); const h = { lane: i, action: t, hasEagerState: !1, eagerState: null, next: null }; if (gf(e))xf(d, h); else { yf(e, d, h); let n = e.alternate; if (e.lanes === 0 && (n === null || n.lanes === 0) && (n = d.lastRenderedReducer, n !== null)) try { const o = d.lastRenderedState; const r = n(o, t); if (h.hasEagerState = !0, h.eagerState = r, me(r, o)) return } catch (s) {} finally {}t = Ht(), e = ue(e, i, t), e !== null && Tf(e, d, i) } } function gf (e) { const d = e.alternate; return e === Tt || d !== null && d === Tt } function xf (e, d) { is = mr = !0; const t = e.pending; t === null ? d.next = d : (d.next = t.next, t.next = d), e.pending = d } function yf (e, d, t) { td(e) ? (e = d.interleaved, e === null ? (t.next = t, xe === null ? xe = [d] : xe.push(d)) : (t.next = e.next, e.next = t), d.interleaved = t) : (e = d.pending, e === null ? t.next = t : (t.next = e.next, e.next = t), d.pending = t) } function Tf (e, d, t) { if ((t & 4194240) != 0) { let i = d.lanes; i &= e.pendingLanes, t |= i, d.lanes = t, Za(e, t) } } var yr = { readContext: re, useCallback: zt, useContext: zt, useEffect: zt, useImperativeHandle: zt, useInsertionEffect: zt, useLayoutEffect: zt, useMemo: zt, useReducer: zt, useRef: zt, useState: zt, useDebugValue: zt, useDeferredValue: zt, useTransition: zt, useMutableSource: zt, useSyncExternalStore: zt, useId: zt, unstable_isNewReconciler: !1 }; var Hc = { readContext: re, useCallback: function (e, d) { return Re().memoizedState = [e, d === void 0 ? null : d], e }, useContext: re, useEffect: lf, useImperativeHandle: function (e, d, t) { return t = t != null ? t.concat([e]) : null, gr(4194308, 4, ff.bind(null, d, e), t) }, useLayoutEffect: function (e, d) { return gr(4194308, 4, e, d) }, useInsertionEffect: function (e, d) { return gr(4, 2, e, d) }, useMemo: function (e, d) { const t = Re(); return d = d === void 0 ? null : d, e = e(), t.memoizedState = [e, d], e }, useReducer: function (e, d, t) { const i = Re(); return d = t !== void 0 ? t(d) : d, i.memoizedState = i.baseState = d, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: e, lastRenderedState: d }, i.queue = e, e = e.dispatch = Xc.bind(null, Tt, e), [i.memoizedState, e] }, useRef: function (e) { const d = Re(); return e = { current: e }, d.memoizedState = e }, useState: af, useDebugValue: Wo, useDeferredValue: function (e) { return Re().memoizedState = e }, useTransition: function () { let e = af(!1); const d = e[0]; return e = Vc.bind(null, e[1]), Re().memoizedState = e, [d, e] }, useMutableSource: function () {}, useSyncExternalStore: function (e, d, t) { const i = Tt; const h = Re(); if (gt) { if (t === void 0) throw Error(k(407)); t = t() } else { if (t = d(), Lt === null) throw Error(k(349)); (Ai & 30) != 0 || ef(i, d, t) }h.memoizedState = t; const n = { value: t, getSnapshot: d }; return h.queue = n, lf(sf.bind(null, i, n, e), [e]), i.flags |= 2048, rs(9, nf.bind(null, i, n, t, d), void 0, null), t }, useId: function () { const e = Re(); let d = Lt.identifierPrefix; if (gt) { var t = We; const i = Xe; t = (i & ~(1 << 32 - pe(i) - 1)).toString(32) + t, d = ':' + d + 'R' + t, t = ns++, t > 0 && (d += 'H' + t.toString(32)), d += ':' } else t = Yc++, d = ':' + d + 'r' + t.toString(32) + ':'; return e.memoizedState = d }, unstable_isNewReconciler: !1 }; var Kc = { readContext: re, useCallback: vf, useContext: re, useEffect: Xo, useImperativeHandle: df, useInsertionEffect: hf, useLayoutEffect: uf, useMemo: cf, useReducer: Yo, useRef: of, useState: function () { return Yo(ss) }, useDebugValue: Wo, useDeferredValue: function (e) { const d = le(); return pf(d, Rt.memoizedState, e) }, useTransition: function () { const e = Yo(ss)[0]; const d = le().memoizedState; return [e, d] }, useMutableSource: _u, useSyncExternalStore: tf, useId: mf, unstable_isNewReconciler: !1 }; var Zc = { readContext: re, useCallback: vf, useContext: re, useEffect: Xo, useImperativeHandle: df, useInsertionEffect: hf, useLayoutEffect: uf, useMemo: cf, useReducer: Vo, useRef: of, useState: function () { return Vo(ss) }, useDebugValue: Wo, useDeferredValue: function (e) { const d = le(); return Rt === null ? d.memoizedState = e : pf(d, Rt.memoizedState, e) }, useTransition: function () { const e = Vo(ss)[0]; const d = le().memoizedState; return [e, d] }, useMutableSource: _u, useSyncExternalStore: tf, useId: mf, unstable_isNewReconciler: !1 }; function Ho (e, d) {
      try { let t = ''; let i = d; do t += Sv(i), i = i.return; while (i); var h = t } catch (n) {
        h = `
Error generating stack: ` + n.message + `
` + n.stack
      } return { value: e, source: d, stack: h }
    } function Ko (e, d) { try { console.error(d.value) } catch (t) { setTimeout(function () { throw t }) } } const Qc = typeof WeakMap === 'function' ? WeakMap : Map; function Sf (e, d, t) { t = Ve(-1, t), t.tag = 3, t.payload = { element: null }; const i = d.value; return t.callback = function () { Rr || (Rr = !0, nl = i), Ko(e, d) }, t } function Ef (e, d, t) { t = Ve(-1, t), t.tag = 3; const i = e.type.getDerivedStateFromError; if (typeof i === 'function') { const h = d.value; t.payload = function () { return i(h) }, t.callback = function () { Ko(e, d) } } const n = e.stateNode; return n !== null && typeof n.componentDidCatch === 'function' && (t.callback = function () { Ko(e, d), typeof i !== 'function' && (hi === null ? hi = new Set([this]) : hi.add(this)); const o = d.stack; this.componentDidCatch(d.value, { componentStack: o !== null ? o : '' }) }), t } function Cf (e, d, t) { let i = e.pingCache; if (i === null) { i = e.pingCache = new Qc(); var h = new Set(); i.set(d, h) } else h = i.get(d), h === void 0 && (h = new Set(), i.set(d, h)); h.has(t) || (h.add(t), e = rp.bind(null, e, d, t), d.then(e, e)) } function Af (e) { do { var d; if ((d = e.tag === 13) && (d = e.memoizedState, d = d !== null ? d.dehydrated !== null : !0), d) return e; e = e.return } while (e !== null); return null } function Pf (e, d, t, i, h) { return (e.mode & 1) == 0 ? (e === d ? e.flags |= 65536 : (e.flags |= 128, t.flags |= 131072, t.flags &= -52805, t.tag === 1 && (t.alternate === null ? t.tag = 17 : (d = Ve(-1, 1), d.tag = 2, oi(t, d))), t.lanes |= 1), e) : (e.flags |= 65536, e.lanes = h, e) } let Mf, Zo, Rf, Lf; Mf = function (e, d) { for (let t = d.child; t !== null;) { if (t.tag === 5 || t.tag === 6)e.appendChild(t.stateNode); else if (t.tag !== 4 && t.child !== null) { t.child.return = t, t = t.child; continue } if (t === d) break; for (;t.sibling === null;) { if (t.return === null || t.return === d) return; t = t.return }t.sibling.return = t.return, t = t.sibling } }; Zo = function () {}; Rf = function (e, d, t, i) { let h = e.memoizedProps; if (h !== i) { e = d.stateNode, Ci(Me.current); let n = null; switch (t) { case 'input':h = Oa(e, h), i = Oa(e, i), n = []; break; case 'select':h = xt({}, h, { value: void 0 }), i = xt({}, i, { value: void 0 }), n = []; break; case 'textarea':h = Ia(e, h), i = Ia(e, i), n = []; break; default:typeof h.onClick !== 'function' && typeof i.onClick === 'function' && (e.onclick = er) }Na(t, i); let o; t = null; for (a in h) if (!i.hasOwnProperty(a) && h.hasOwnProperty(a) && h[a] != null) if (a === 'style') { var r = h[a]; for (o in r)r.hasOwnProperty(o) && (t || (t = {}), t[o] = '') } else a !== 'dangerouslySetInnerHTML' && a !== 'children' && a !== 'suppressContentEditableWarning' && a !== 'suppressHydrationWarning' && a !== 'autoFocus' && (An.hasOwnProperty(a) ? n || (n = []) : (n = n || []).push(a, null)); for (a in i) { let s = i[a]; if (r = h != null ? h[a] : void 0, i.hasOwnProperty(a) && s !== r && (s != null || r != null)) if (a === 'style') if (r) { for (o in r)!r.hasOwnProperty(o) || s && s.hasOwnProperty(o) || (t || (t = {}), t[o] = ''); for (o in s)s.hasOwnProperty(o) && r[o] !== s[o] && (t || (t = {}), t[o] = s[o]) } else t || (n || (n = []), n.push(a, t)), t = s; else a === 'dangerouslySetInnerHTML' ? (s = s ? s.__html : void 0, r = r ? r.__html : void 0, s != null && r !== s && (n = n || []).push(a, s)) : a === 'children' ? typeof s !== 'string' && typeof s !== 'number' || (n = n || []).push(a, '' + s) : a !== 'suppressContentEditableWarning' && a !== 'suppressHydrationWarning' && (An.hasOwnProperty(a) ? (s != null && a === 'onScroll' && pt('scroll', e), n || r === s || (n = [])) : (n = n || []).push(a, s)) }t && (n = n || []).push('style', t); var a = n; (d.updateQueue = a) && (d.flags |= 4) } }; Lf = function (e, d, t, i) { t !== i && (d.flags |= 4) }; function as (e, d) { if (!gt) switch (e.tailMode) { case 'hidden':d = e.tail; for (var t = null; d !== null;)d.alternate !== null && (t = d), d = d.sibling; t === null ? e.tail = null : t.sibling = null; break; case 'collapsed':t = e.tail; for (var i = null; t !== null;)t.alternate !== null && (i = t), t = t.sibling; i === null ? d || e.tail === null ? e.tail = null : e.tail.sibling = null : i.sibling = null } } function Ut (e) { const d = e.alternate !== null && e.alternate.child === e.child; let t = 0; let i = 0; if (d) for (var h = e.child; h !== null;)t |= h.lanes | h.childLanes, i |= h.subtreeFlags & 14680064, i |= h.flags & 14680064, h.return = e, h = h.sibling; else for (h = e.child; h !== null;)t |= h.lanes | h.childLanes, i |= h.subtreeFlags, i |= h.flags, h.return = e, h = h.sibling; return e.subtreeFlags |= i, e.childLanes = t, d } function Jc (e, d, t) { let i = d.pendingProps; switch (Ro(d), d.tag) { case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Ut(d), null; case 1:return $t(d.type) && nr(), Ut(d), null; case 3:return i = d.stateNode, rn(), mt(Jt), mt(wt), No(), i.pendingContext && (i.context = i.pendingContext, i.pendingContext = null), (e === null || e.child === null) && (kn(d) ? d.flags |= 4 : e === null || e.memoizedState.isDehydrated && (d.flags & 256) == 0 || (d.flags |= 1024, ye !== null && (al(ye), ye = null))), Zo(e, d), Ut(d), null; case 5:Io(d); var h = Ci(es.current); if (t = d.type, e !== null && d.stateNode != null)Rf(e, d, t, i, h), e.ref !== d.ref && (d.flags |= 512, d.flags |= 2097152); else { if (!i) { if (d.stateNode === null) throw Error(k(166)); return Ut(d), null } if (e = Ci(Me.current), kn(d)) { i = d.stateNode, t = d.type; var n = d.memoizedProps; switch (i[Pe] = d, i[jn] = n, e = (d.mode & 1) != 0, t) { case 'dialog':pt('cancel', i), pt('close', i); break; case 'iframe':case 'object':case 'embed':pt('load', i); break; case 'video':case 'audio':for (h = 0; h < Qn.length; h++)pt(Qn[h], i); break; case 'source':pt('error', i); break; case 'img':case 'image':case 'link':pt('error', i), pt('load', i); break; case 'details':pt('toggle', i); break; case 'input':xh(i, n), pt('invalid', i); break; case 'select':i._wrapperState = { wasMultiple: !!n.multiple }, pt('invalid', i); break; case 'textarea':Sh(i, n), pt('invalid', i) }Na(t, n), h = null; for (var o in n) if (n.hasOwnProperty(o)) { var r = n[o]; o === 'children' ? typeof r === 'string' ? i.textContent !== r && (n.suppressHydrationWarning !== !0 && tr(i.textContent, r, e), h = ['children', r]) : typeof r === 'number' && i.textContent !== '' + r && (n.suppressHydrationWarning !== !0 && tr(i.textContent, r, e), h = ['children', '' + r]) : An.hasOwnProperty(o) && r != null && o === 'onScroll' && pt('scroll', i) } switch (t) { case 'input':Rs(i), Th(i, n, !0); break; case 'textarea':Rs(i), Ch(i); break; case 'select':case 'option':break; default:typeof n.onClick === 'function' && (i.onclick = er) }i = h, d.updateQueue = i, i !== null && (d.flags |= 4) } else { o = h.nodeType === 9 ? h : h.ownerDocument, e === 'http://www.w3.org/1999/xhtml' && (e = Ah(t)), e === 'http://www.w3.org/1999/xhtml' ? t === 'script' ? (e = o.createElement('div'), e.innerHTML = '<script><\/script>', e = e.removeChild(e.firstChild)) : typeof i.is === 'string' ? e = o.createElement(t, { is: i.is }) : (e = o.createElement(t), t === 'select' && (o = e, i.multiple ? o.multiple = !0 : i.size && (o.size = i.size))) : e = o.createElementNS(e, t), e[Pe] = d, e[jn] = i, Mf(e, d, !1, !1), d.stateNode = e; t: { switch (o = Ga(t, i), t) { case 'dialog':pt('cancel', e), pt('close', e), h = i; break; case 'iframe':case 'object':case 'embed':pt('load', e), h = i; break; case 'video':case 'audio':for (h = 0; h < Qn.length; h++)pt(Qn[h], e); h = i; break; case 'source':pt('error', e), h = i; break; case 'img':case 'image':case 'link':pt('error', e), pt('load', e), h = i; break; case 'details':pt('toggle', e), h = i; break; case 'input':xh(e, i), h = Oa(e, i), pt('invalid', e); break; case 'option':h = i; break; case 'select':e._wrapperState = { wasMultiple: !!i.multiple }, h = xt({}, i, { value: void 0 }), pt('invalid', e); break; case 'textarea':Sh(e, i), h = Ia(e, i), pt('invalid', e); break; default:h = i }Na(t, h), r = h; for (n in r) if (r.hasOwnProperty(n)) { let s = r[n]; n === 'style' ? Rh(e, s) : n === 'dangerouslySetInnerHTML' ? (s = s ? s.__html : void 0, s != null && Ph(e, s)) : n === 'children' ? typeof s === 'string' ? (t !== 'textarea' || s !== '') && Ln(e, s) : typeof s === 'number' && Ln(e, '' + s) : n !== 'suppressContentEditableWarning' && n !== 'suppressHydrationWarning' && n !== 'autoFocus' && (An.hasOwnProperty(n) ? s != null && n === 'onScroll' && pt('scroll', e) : s != null && xa(e, n, s, o)) } switch (t) { case 'input':Rs(e), Th(e, i, !1); break; case 'textarea':Rs(e), Ch(e); break; case 'option':i.value != null && e.setAttribute('value', '' + be(i.value)); break; case 'select':e.multiple = !!i.multiple, n = i.value, n != null ? Ui(e, !!i.multiple, n, !1) : i.defaultValue != null && Ui(e, !!i.multiple, i.defaultValue, !0); break; default:typeof h.onClick === 'function' && (e.onclick = er) } switch (t) { case 'button':case 'input':case 'select':case 'textarea':i = !!i.autoFocus; break t; case 'img':i = !0; break t; default:i = !1 } }i && (d.flags |= 4) }d.ref !== null && (d.flags |= 512, d.flags |= 2097152) } return Ut(d), null; case 6:if (e && d.stateNode != null)Lf(e, d, e.memoizedProps, i); else { if (typeof i !== 'string' && d.stateNode === null) throw Error(k(166)); if (t = Ci(es.current), Ci(Me.current), kn(d)) { if (i = d.stateNode, t = d.memoizedProps, i[Pe] = d, (n = i.nodeValue !== t) && (e = ee, e !== null)) switch (e.tag) { case 3:tr(i.nodeValue, t, (e.mode & 1) != 0); break; case 5:e.memoizedProps.suppressHydrationWarning !== !0 && tr(i.nodeValue, t, (e.mode & 1) != 0) }n && (d.flags |= 4) } else i = (t.nodeType === 9 ? t : t.ownerDocument).createTextNode(i), i[Pe] = d, d.stateNode = i } return Ut(d), null; case 13:if (mt(yt), i = d.memoizedState, gt && jt !== null && (d.mode & 1) != 0 && (d.flags & 128) == 0) { for (i = jt; i;)i = ze(i.nextSibling); return nn(), d.flags |= 98560, d } if (i !== null && i.dehydrated !== null) { if (i = kn(d), e === null) { if (!i) throw Error(k(318)); if (i = d.memoizedState, i = i !== null ? i.dehydrated : null, !i) throw Error(k(317)); i[Pe] = d } else nn(), (d.flags & 128) == 0 && (d.memoizedState = null), d.flags |= 4; return Ut(d), null } return ye !== null && (al(ye), ye = null), (d.flags & 128) != 0 ? (d.lanes = t, d) : (i = i !== null, t = !1, e === null ? kn(d) : t = e.memoizedState !== null, i !== t && i && (d.child.flags |= 8192, (d.mode & 1) != 0 && (e === null || (yt.current & 1) != 0 ? Ot === 0 && (Ot = 3) : hl())), d.updateQueue !== null && (d.flags |= 4), Ut(d), null); case 4:return rn(), Zo(e, d), e === null && Jn(d.stateNode.containerInfo), Ut(d), null; case 10:return So(d.type._context), Ut(d), null; case 17:return $t(d.type) && nr(), Ut(d), null; case 19:if (mt(yt), n = d.memoizedState, n === null) return Ut(d), null; if (i = (d.flags & 128) != 0, o = n.rendering, o === null) if (i)as(n, !1); else { if (Ot !== 0 || e !== null && (e.flags & 128) != 0) for (e = d.child; e !== null;) { if (o = cr(e), o !== null) { for (d.flags |= 128, as(n, !1), i = o.updateQueue, i !== null && (d.updateQueue = i, d.flags |= 4), d.subtreeFlags = 0, i = t, t = d.child; t !== null;)n = t, e = i, n.flags &= 14680066, o = n.alternate, o === null ? (n.childLanes = 0, n.lanes = e, n.child = null, n.subtreeFlags = 0, n.memoizedProps = null, n.memoizedState = null, n.updateQueue = null, n.dependencies = null, n.stateNode = null) : (n.childLanes = o.childLanes, n.lanes = o.lanes, n.child = o.child, n.subtreeFlags = 0, n.deletions = null, n.memoizedProps = o.memoizedProps, n.memoizedState = o.memoizedState, n.updateQueue = o.updateQueue, n.type = o.type, e = o.dependencies, n.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }), t = t.sibling; return vt(yt, yt.current & 1 | 2), d.child }e = e.sibling }n.tail !== null && At() > ln && (d.flags |= 128, i = !0, as(n, !1), d.lanes = 4194304) } else { if (!i) if (e = cr(o), e !== null) { if (d.flags |= 128, i = !0, t = e.updateQueue, t !== null && (d.updateQueue = t, d.flags |= 4), as(n, !0), n.tail === null && n.tailMode === 'hidden' && !o.alternate && !gt) return Ut(d), null } else 2 * At() - n.renderingStartTime > ln && t !== 1073741824 && (d.flags |= 128, i = !0, as(n, !1), d.lanes = 4194304); n.isBackwards ? (o.sibling = d.child, d.child = o) : (t = n.last, t !== null ? t.sibling = o : d.child = o, n.last = o) } return n.tail !== null ? (d = n.tail, n.rendering = d, n.tail = d.sibling, n.renderingStartTime = At(), d.sibling = null, t = yt.current, vt(yt, i ? t & 1 | 2 : t & 1), d) : (Ut(d), null); case 22:case 23:return ll(), i = d.memoizedState !== null, e !== null && e.memoizedState !== null !== i && (d.flags |= 8192), i && (d.mode & 1) != 0 ? (ie & 1073741824) != 0 && (Ut(d), d.subtreeFlags & 6 && (d.flags |= 8192)) : Ut(d), null; case 24:return null; case 25:return null } throw Error(k(156, d.tag)) } const $c = we.ReactCurrentOwner; var bt = !1; function Wt (e, d, t, i) { d.child = e === null ? ku(d, null, t, i) : sn(d, e.child, t, i) } function Of (e, d, t, i, h) { t = t.render; const n = d.ref; return _i(d, h), i = zo(e, d, t, i, n, h), t = Uo(), e !== null && !bt ? (d.updateQueue = e.updateQueue, d.flags &= -2053, e.lanes &= ~h, He(e, d, h)) : (gt && t && Mo(d), d.flags |= 1, Wt(e, d, i, h), d.child) } function Ff (e, d, t, i, h) { if (e === null) { var n = t.type; return typeof n === 'function' && !ul(n) && n.defaultProps === void 0 && t.compare === null && t.defaultProps === void 0 ? (d.tag = 15, d.type = n, Df(e, d, n, i, h)) : (e = Nr(t.type, null, i, d, d.mode, h), e.ref = d.ref, e.return = d, d.child = e) } if (n = e.child, (e.lanes & h) == 0) { const o = n.memoizedProps; if (t = t.compare, t = t !== null ? t : Kn, t(o, i) && e.ref === d.ref) return He(e, d, h) } return d.flags |= 1, e = vi(n, i), e.ref = d.ref, e.return = d, d.child = e } function Df (e, d, t, i, h) { if (e !== null) { const n = e.memoizedProps; if (Kn(n, i) && e.ref === d.ref) if (bt = !1, d.pendingProps = i = n, (e.lanes & h) != 0)(e.flags & 131072) != 0 && (bt = !0); else return d.lanes = e.lanes, He(e, d, h) } return Qo(e, d, t, i, h) } function If (e, d, t) { let i = d.pendingProps; const h = i.children; const n = e !== null ? e.memoizedState : null; if (i.mode === 'hidden') if ((d.mode & 1) == 0)d.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, vt(on, ie), ie |= t; else if ((t & 1073741824) != 0)d.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, i = n !== null ? n.baseLanes : t, vt(on, ie), ie |= i; else return e = n !== null ? n.baseLanes | t : t, d.lanes = d.childLanes = 1073741824, d.memoizedState = { baseLanes: e, cachePool: null, transitions: null }, d.updateQueue = null, vt(on, ie), ie |= e, null; else n !== null ? (i = n.baseLanes | t, d.memoizedState = null) : i = t, vt(on, ie), ie |= i; return Wt(e, d, h, t), d.child } function Bf (e, d) { const t = d.ref; (e === null && t !== null || e !== null && e.ref !== t) && (d.flags |= 512, d.flags |= 2097152) } function Qo (e, d, t, i, h) { let n = $t(t) ? Ti : wt.current; return n = ki(d, n), _i(d, h), t = zo(e, d, t, i, n, h), i = Uo(), e !== null && !bt ? (d.updateQueue = e.updateQueue, d.flags &= -2053, e.lanes &= ~h, He(e, d, h)) : (gt && i && Mo(d), d.flags |= 1, Wt(e, d, t, h), d.child) } function Nf (e, d, t, i, h) { if ($t(t)) { var n = !0; sr(d) } else n = !1; if (_i(d, h), d.stateNode === null)e !== null && (e.alternate = null, d.alternate = null, d.flags |= 2), Hu(d, t, i), Po(d, t, i, h), i = !0; else if (e === null) { var o = d.stateNode; var r = d.memoizedProps; o.props = r; var s = o.context; var a = t.contextType; typeof a === 'object' && a !== null ? a = re(a) : (a = $t(t) ? Ti : wt.current, a = ki(d, a)); var f = t.getDerivedStateFromProps; var l = typeof f === 'function' || typeof o.getSnapshotBeforeUpdate === 'function'; l || typeof o.UNSAFE_componentWillReceiveProps !== 'function' && typeof o.componentWillReceiveProps !== 'function' || (r !== i || s !== a) && Ku(d, o, i, a), ai = !1; var u = d.memoizedState; o.state = u, hr(d, i, o, h), s = d.memoizedState, r !== i || u !== s || Jt.current || ai ? (typeof f === 'function' && (Ao(d, t, f, i), s = d.memoizedState), (r = ai || Wu(d, t, r, i, u, s, a)) ? (l || typeof o.UNSAFE_componentWillMount !== 'function' && typeof o.componentWillMount !== 'function' || (typeof o.componentWillMount === 'function' && o.componentWillMount(), typeof o.UNSAFE_componentWillMount === 'function' && o.UNSAFE_componentWillMount()), typeof o.componentDidMount === 'function' && (d.flags |= 4194308)) : (typeof o.componentDidMount === 'function' && (d.flags |= 4194308), d.memoizedProps = i, d.memoizedState = s), o.props = i, o.state = s, o.context = a, i = r) : (typeof o.componentDidMount === 'function' && (d.flags |= 4194308), i = !1) } else { o = d.stateNode, Uu(e, d), r = d.memoizedProps, a = d.type === d.elementType ? r : ge(d.type, r), o.props = a, l = d.pendingProps, u = o.context, s = t.contextType, typeof s === 'object' && s !== null ? s = re(s) : (s = $t(t) ? Ti : wt.current, s = ki(d, s)); const v = t.getDerivedStateFromProps; (f = typeof v === 'function' || typeof o.getSnapshotBeforeUpdate === 'function') || typeof o.UNSAFE_componentWillReceiveProps !== 'function' && typeof o.componentWillReceiveProps !== 'function' || (r !== l || u !== s) && Ku(d, o, i, s), ai = !1, u = d.memoizedState, o.state = u, hr(d, i, o, h); let p = d.memoizedState; r !== l || u !== p || Jt.current || ai ? (typeof v === 'function' && (Ao(d, t, v, i), p = d.memoizedState), (a = ai || Wu(d, t, a, i, u, p, s) || !1) ? (f || typeof o.UNSAFE_componentWillUpdate !== 'function' && typeof o.componentWillUpdate !== 'function' || (typeof o.componentWillUpdate === 'function' && o.componentWillUpdate(i, p, s), typeof o.UNSAFE_componentWillUpdate === 'function' && o.UNSAFE_componentWillUpdate(i, p, s)), typeof o.componentDidUpdate === 'function' && (d.flags |= 4), typeof o.getSnapshotBeforeUpdate === 'function' && (d.flags |= 1024)) : (typeof o.componentDidUpdate !== 'function' || r === e.memoizedProps && u === e.memoizedState || (d.flags |= 4), typeof o.getSnapshotBeforeUpdate !== 'function' || r === e.memoizedProps && u === e.memoizedState || (d.flags |= 1024), d.memoizedProps = i, d.memoizedState = p), o.props = i, o.state = p, o.context = s, i = a) : (typeof o.componentDidUpdate !== 'function' || r === e.memoizedProps && u === e.memoizedState || (d.flags |= 4), typeof o.getSnapshotBeforeUpdate !== 'function' || r === e.memoizedProps && u === e.memoizedState || (d.flags |= 1024), i = !1) } return Jo(e, d, t, i, n, h) } function Jo (e, d, t, i, h, n) { Bf(e, d); const o = (d.flags & 128) != 0; if (!i && !o) return h && wu(d, t, !1), He(e, d, n); i = d.stateNode, $c.current = d; const r = o && typeof t.getDerivedStateFromError !== 'function' ? null : i.render(); return d.flags |= 1, e !== null && o ? (d.child = sn(d, e.child, null, n), d.child = sn(d, null, r, n)) : Wt(e, d, r, n), d.memoizedState = i.state, h && wu(d, t, !0), d.child } function Gf (e) { const d = e.stateNode; d.pendingContext ? Nu(e, d.pendingContext, d.pendingContext !== d.context) : d.context && Nu(e, d.context, !1), Do(e, d.containerInfo) } function wf (e, d, t, i, h) { return nn(), Fo(h), d.flags |= 256, Wt(e, d, t, i), d.child } const Tr = { dehydrated: null, treeContext: null, retryLane: 0 }; function Sr (e) { return { baseLanes: e, cachePool: null, transitions: null } } function zf (e, d) { return { baseLanes: e.baseLanes | d, cachePool: null, transitions: e.transitions } } function Uf (e, d, t) { let i = d.pendingProps; let h = yt.current; let n = !1; const o = (d.flags & 128) != 0; let r; if ((r = o) || (r = e !== null && e.memoizedState === null ? !1 : (h & 2) != 0), r ? (n = !0, d.flags &= -129) : (e === null || e.memoizedState !== null) && (h |= 1), vt(yt, h & 1), e === null) return Oo(d), e = d.memoizedState, e !== null && (e = e.dehydrated, e !== null) ? ((d.mode & 1) == 0 ? d.lanes = 1 : e.data === '$!' ? d.lanes = 8 : d.lanes = 1073741824, null) : (h = i.children, e = i.fallback, n ? (i = d.mode, n = d.child, h = { mode: 'hidden', children: h }, (i & 1) == 0 && n !== null ? (n.childLanes = 0, n.pendingProps = h) : n = Gr(h, i, 0, null), e = Oi(e, i, t, null), n.return = d, e.return = d, n.sibling = e, d.child = n, d.child.memoizedState = Sr(t), d.memoizedState = Tr, e) : $o(d, h)); if (h = e.memoizedState, h !== null) { if (r = h.dehydrated, r !== null) { if (o) return d.flags & 256 ? (d.flags &= -257, Er(e, d, t, Error(k(422)))) : d.memoizedState !== null ? (d.child = e.child, d.flags |= 128, null) : (n = i.fallback, h = d.mode, i = Gr({ mode: 'visible', children: i.children }, h, 0, null), n = Oi(n, h, t, null), n.flags |= 2, i.return = d, n.return = d, i.sibling = n, d.child = i, (d.mode & 1) != 0 && sn(d, e.child, null, t), d.child.memoizedState = Sr(t), d.memoizedState = Tr, n); if ((d.mode & 1) == 0)d = Er(e, d, t, null); else if (r.data === '$!')d = Er(e, d, t, Error(k(419))); else if (i = (t & e.childLanes) != 0, bt || i) { if (i = Lt, i !== null) { switch (t & -t) { case 4:n = 2; break; case 16:n = 8; break; case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:n = 32; break; case 536870912:n = 268435456; break; default:n = 0 }i = (n & (i.suspendedLanes | t)) != 0 ? 0 : n, i !== 0 && i !== h.retryLane && (h.retryLane = i, ue(e, i, -1)) }hl(), d = Er(e, d, t, Error(k(421))) } else r.data === '$?' ? (d.flags |= 128, d.child = e.child, d = ap.bind(null, e), r._reactRetry = d, d = null) : (t = h.treeContext, jt = ze(r.nextSibling), ee = d, gt = !0, ye = null, t !== null && (ae[oe++] = Xe, ae[oe++] = We, ae[oe++] = Si, Xe = t.id, We = t.overflow, Si = d), d = $o(d, d.pendingProps.children), d.flags |= 4096); return d } return n ? (i = Vf(e, d, i.children, i.fallback, t), n = d.child, h = e.child.memoizedState, n.memoizedState = h === null ? Sr(t) : zf(h, t), n.childLanes = e.childLanes & ~t, d.memoizedState = Tr, i) : (t = Yf(e, d, i.children, t), d.memoizedState = null, t) } return n ? (i = Vf(e, d, i.children, i.fallback, t), n = d.child, h = e.child.memoizedState, n.memoizedState = h === null ? Sr(t) : zf(h, t), n.childLanes = e.childLanes & ~t, d.memoizedState = Tr, i) : (t = Yf(e, d, i.children, t), d.memoizedState = null, t) } function $o (e, d) { return d = Gr({ mode: 'visible', children: d }, e.mode, 0, null), d.return = e, e.child = d } function Yf (e, d, t, i) { const h = e.child; return e = h.sibling, t = vi(h, { mode: 'visible', children: t }), (d.mode & 1) == 0 && (t.lanes = i), t.return = d, t.sibling = null, e !== null && (i = d.deletions, i === null ? (d.deletions = [e], d.flags |= 16) : i.push(e)), d.child = t } function Vf (e, d, t, i, h) { const n = d.mode; e = e.child; const o = e.sibling; const r = { mode: 'hidden', children: t }; return (n & 1) == 0 && d.child !== e ? (t = d.child, t.childLanes = 0, t.pendingProps = r, d.deletions = null) : (t = vi(e, r), t.subtreeFlags = e.subtreeFlags & 14680064), o !== null ? i = vi(o, i) : (i = Oi(i, n, h, null), i.flags |= 2), i.return = d, t.return = d, t.sibling = i, d.child = t, i } function Er (e, d, t, i) { return i !== null && Fo(i), sn(d, e.child, null, t), e = $o(d, d.pendingProps.children), e.flags |= 2, d.memoizedState = null, e } function Xf (e, d, t) { e.lanes |= d; const i = e.alternate; i !== null && (i.lanes |= d), Eo(e.return, d, t) } function jo (e, d, t, i, h) { const n = e.memoizedState; n === null ? e.memoizedState = { isBackwards: d, rendering: null, renderingStartTime: 0, last: i, tail: t, tailMode: h } : (n.isBackwards = d, n.rendering = null, n.renderingStartTime = 0, n.last = i, n.tail = t, n.tailMode = h) } function Wf (e, d, t) { let i = d.pendingProps; let h = i.revealOrder; const n = i.tail; if (Wt(e, d, i.children, t), i = yt.current, (i & 2) != 0)i = i & 1 | 2, d.flags |= 128; else { if (e !== null && (e.flags & 128) != 0)t:for (e = d.child; e !== null;) { if (e.tag === 13)e.memoizedState !== null && Xf(e, t, d); else if (e.tag === 19)Xf(e, t, d); else if (e.child !== null) { e.child.return = e, e = e.child; continue } if (e === d) break t; for (;e.sibling === null;) { if (e.return === null || e.return === d) break t; e = e.return }e.sibling.return = e.return, e = e.sibling }i &= 1 } if (vt(yt, i), (d.mode & 1) == 0)d.memoizedState = null; else switch (h) { case 'forwards':for (t = d.child, h = null; t !== null;)e = t.alternate, e !== null && cr(e) === null && (h = t), t = t.sibling; t = h, t === null ? (h = d.child, d.child = null) : (h = t.sibling, t.sibling = null), jo(d, !1, h, t, n); break; case 'backwards':for (t = null, h = d.child, d.child = null; h !== null;) { if (e = h.alternate, e !== null && cr(e) === null) { d.child = h; break }e = h.sibling, h.sibling = t, t = h, h = e }jo(d, !0, t, null, n); break; case 'together':jo(d, !1, null, null, void 0); break; default:d.memoizedState = null } return d.child } function He (e, d, t) { if (e !== null && (d.dependencies = e.dependencies), Pi |= d.lanes, (t & d.childLanes) == 0) return null; if (e !== null && d.child !== e.child) throw Error(k(153)); if (d.child !== null) { for (e = d.child, t = vi(e, e.pendingProps), d.child = t, t.return = d; e.sibling !== null;)e = e.sibling, t = t.sibling = vi(e, e.pendingProps), t.return = d; t.sibling = null } return d.child } function jc (e, d, t) { switch (d.tag) { case 3:Gf(d), nn(); break; case 5:qu(d); break; case 1:$t(d.type) && sr(d); break; case 4:Do(d, d.stateNode.containerInfo); break; case 10:var i = d.type._context; var h = d.memoizedProps.value; vt(ar, i._currentValue), i._currentValue = h; break; case 13:if (i = d.memoizedState, i !== null) return i.dehydrated !== null ? (vt(yt, yt.current & 1), d.flags |= 128, null) : (t & d.child.childLanes) != 0 ? Uf(e, d, t) : (vt(yt, yt.current & 1), e = He(e, d, t), e !== null ? e.sibling : null); vt(yt, yt.current & 1); break; case 19:if (i = (t & d.childLanes) != 0, (e.flags & 128) != 0) { if (i) return Wf(e, d, t); d.flags |= 128 } if (h = d.memoizedState, h !== null && (h.rendering = null, h.tail = null, h.lastEffect = null), vt(yt, yt.current), i) break; return null; case 22:case 23:return d.lanes = 0, If(e, d, t) } return He(e, d, t) } function bc (e, d) { switch (Ro(d), d.tag) { case 1:return $t(d.type) && nr(), e = d.flags, e & 65536 ? (d.flags = e & -65537 | 128, d) : null; case 3:return rn(), mt(Jt), mt(wt), No(), e = d.flags, (e & 65536) != 0 && (e & 128) == 0 ? (d.flags = e & -65537 | 128, d) : null; case 5:return Io(d), null; case 13:if (mt(yt), e = d.memoizedState, e !== null && e.dehydrated !== null) { if (d.alternate === null) throw Error(k(340)); nn() } return e = d.flags, e & 65536 ? (d.flags = e & -65537 | 128, d) : null; case 19:return mt(yt), null; case 4:return rn(), null; case 10:return So(d.type._context), null; case 22:case 23:return ll(), null; case 24:return null; default:return null } } let Cr = !1; let Yt = !1; const kc = typeof WeakSet === 'function' ? WeakSet : Set; let tt = null; function an (e, d) { const t = e.ref; if (t !== null) if (typeof t === 'function') try { t(null) } catch (i) { Et(e, d, i) } else t.current = null } function bo (e, d, t) { try { t() } catch (i) { Et(e, d, i) } } let Hf = !1; function qc (e, d) { if (uo = Ys, e = mu(), so(e)) { if ('selectionStart' in e) var t = { start: e.selectionStart, end: e.selectionEnd }; else t: { t = (t = e.ownerDocument) && t.defaultView || window; let i = t.getSelection && t.getSelection(); if (i && i.rangeCount !== 0) { t = i.anchorNode; const h = i.anchorOffset; const n = i.focusNode; i = i.focusOffset; try { t.nodeType, n.nodeType } catch (S) { t = null; break t } let o = 0; let r = -1; let s = -1; let a = 0; let f = 0; let l = e; let u = null; e:for (;;) { for (var v; l !== t || h !== 0 && l.nodeType !== 3 || (r = o + h), l !== n || i !== 0 && l.nodeType !== 3 || (s = o + i), l.nodeType === 3 && (o += l.nodeValue.length), (v = l.firstChild) !== null;)u = l, l = v; for (;;) { if (l === e) break e; if (u === t && ++a === h && (r = o), u === n && ++f === i && (s = o), (v = l.nextSibling) !== null) break; l = u, u = l.parentNode }l = v }t = r === -1 || s === -1 ? null : { start: r, end: s } } else t = null }t = t || { start: 0, end: 0 } } else t = null; for (fo = { focusedElem: e, selectionRange: t }, Ys = !1, tt = d; tt !== null;) if (d = tt, e = d.child, (d.subtreeFlags & 1028) != 0 && e !== null)e.return = d, tt = e; else for (;tt !== null;) { d = tt; try { var p = d.alternate; if ((d.flags & 1024) != 0) switch (d.tag) { case 0:case 11:case 15:break; case 1:if (p !== null) { const c = p.memoizedProps; const m = p.memoizedState; const g = d.stateNode; const x = g.getSnapshotBeforeUpdate(d.elementType === d.type ? c : ge(d.type, c), m); g.__reactInternalSnapshotBeforeUpdate = x } break; case 3:var y = d.stateNode.containerInfo; if (y.nodeType === 1)y.textContent = ''; else if (y.nodeType === 9) { const T = y.body; T != null && (T.textContent = '') } break; case 5:case 6:case 4:case 17:break; default:throw Error(k(163)) } } catch (S) { Et(d, d.return, S) } if (e = d.sibling, e !== null) { e.return = d.return, tt = e; break }tt = d.return } return p = Hf, Hf = !1, p } function os (e, d, t) { let i = d.updateQueue; if (i = i !== null ? i.lastEffect : null, i !== null) { let h = i = i.next; do { if ((h.tag & e) === e) { const n = h.destroy; h.destroy = void 0, n !== void 0 && bo(d, t, n) }h = h.next } while (h !== i) } } function Ar (e, d) { if (d = d.updateQueue, d = d !== null ? d.lastEffect : null, d !== null) { let t = d = d.next; do { if ((t.tag & e) === e) { const i = t.create; t.destroy = i() }t = t.next } while (t !== d) } } function ko (e) { const d = e.ref; if (d !== null) { const t = e.stateNode; switch (e.tag) { case 5:e = t; break; default:e = t } typeof d === 'function' ? d(e) : d.current = e } } function Kf (e) { let d = e.alternate; d !== null && (e.alternate = null, Kf(d)), e.child = null, e.deletions = null, e.sibling = null, e.tag === 5 && (d = e.stateNode, d !== null && (delete d[Pe], delete d[jn], delete d[mo], delete d[Gc], delete d[wc])), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null } function Zf (e) { return e.tag === 5 || e.tag === 3 || e.tag === 4 } function Qf (e) { t:for (;;) { for (;e.sibling === null;) { if (e.return === null || Zf(e.return)) return null; e = e.return } for (e.sibling.return = e.return, e = e.sibling; e.tag !== 5 && e.tag !== 6 && e.tag !== 18;) { if (e.flags & 2 || e.child === null || e.tag === 4) continue t; e.child.return = e, e = e.child } if (!(e.flags & 2)) return e.stateNode } } function qo (e, d, t) { const i = e.tag; if (i === 5 || i === 6)e = e.stateNode, d ? t.nodeType === 8 ? t.parentNode.insertBefore(e, d) : t.insertBefore(e, d) : (t.nodeType === 8 ? (d = t.parentNode, d.insertBefore(e, t)) : (d = t, d.appendChild(e)), t = t._reactRootContainer, t != null || d.onclick !== null || (d.onclick = er)); else if (i !== 4 && (e = e.child, e !== null)) for (qo(e, d, t), e = e.sibling; e !== null;)qo(e, d, t), e = e.sibling } function _o (e, d, t) { const i = e.tag; if (i === 5 || i === 6)e = e.stateNode, d ? t.insertBefore(e, d) : t.appendChild(e); else if (i !== 4 && (e = e.child, e !== null)) for (_o(e, d, t), e = e.sibling; e !== null;)_o(e, d, t), e = e.sibling } let Bt = null; let Te = !1; function li (e, d, t) { for (t = t.child; t !== null;)Jf(e, d, t), t = t.sibling } function Jf (e, d, t) { if (Ae && typeof Ae.onCommitFiberUnmount === 'function') try { Ae.onCommitFiberUnmount(Bs, t) } catch (r) {} switch (t.tag) { case 5:Yt || an(t, d); case 6:var i = Bt; var h = Te; Bt = null, li(e, d, t), Bt = i, Te = h, Bt !== null && (Te ? (e = Bt, t = t.stateNode, e.nodeType === 8 ? e.parentNode.removeChild(t) : e.removeChild(t)) : Bt.removeChild(t.stateNode)); break; case 18:Bt !== null && (Te ? (e = Bt, t = t.stateNode, e.nodeType === 8 ? po(e.parentNode, t) : e.nodeType === 1 && po(e, t), Un(e)) : po(Bt, t.stateNode)); break; case 4:i = Bt, h = Te, Bt = t.stateNode.containerInfo, Te = !0, li(e, d, t), Bt = i, Te = h; break; case 0:case 11:case 14:case 15:if (!Yt && (i = t.updateQueue, i !== null && (i = i.lastEffect, i !== null))) { h = i = i.next; do { let n = h; const o = n.destroy; n = n.tag, o !== void 0 && ((n & 2) != 0 || (n & 4) != 0) && bo(t, d, o), h = h.next } while (h !== i) }li(e, d, t); break; case 1:if (!Yt && (an(t, d), i = t.stateNode, typeof i.componentWillUnmount === 'function')) try { i.props = t.memoizedProps, i.state = t.memoizedState, i.componentWillUnmount() } catch (r) { Et(t, d, r) }li(e, d, t); break; case 21:li(e, d, t); break; case 22:t.mode & 1 ? (Yt = (i = Yt) || t.memoizedState !== null, li(e, d, t), Yt = i) : li(e, d, t); break; default:li(e, d, t) } } function $f (e) { const d = e.updateQueue; if (d !== null) { e.updateQueue = null; let t = e.stateNode; t === null && (t = e.stateNode = new kc()), d.forEach(function (i) { const h = op.bind(null, e, i); t.has(i) || (t.add(i), i.then(h, h)) }) } } function Se (e, d) { const t = d.deletions; if (t !== null) for (let i = 0; i < t.length; i++) { const h = t[i]; try { const n = e; const o = d; let r = o; t:for (;r !== null;) { switch (r.tag) { case 5:Bt = r.stateNode, Te = !1; break t; case 3:Bt = r.stateNode.containerInfo, Te = !0; break t; case 4:Bt = r.stateNode.containerInfo, Te = !0; break t }r = r.return } if (Bt === null) throw Error(k(160)); Jf(n, o, h), Bt = null, Te = !1; const s = h.alternate; s !== null && (s.return = null), h.return = null } catch (a) { Et(h, d, a) } } if (d.subtreeFlags & 12854) for (d = d.child; d !== null;)jf(d, e), d = d.sibling } function jf (e, d) { const t = e.alternate; const i = e.flags; switch (e.tag) { case 0:case 11:case 14:case 15:if (Se(d, e), Le(e), i & 4) { try { os(3, e, e.return), Ar(3, e) } catch (p) { Et(e, e.return, p) } try { os(5, e, e.return) } catch (p) { Et(e, e.return, p) } } break; case 1:Se(d, e), Le(e), i & 512 && t !== null && an(t, t.return); break; case 5:if (Se(d, e), Le(e), i & 512 && t !== null && an(t, t.return), e.flags & 32) { var h = e.stateNode; try { Ln(h, '') } catch (p) { Et(e, e.return, p) } } if (i & 4 && (h = e.stateNode, h != null)) { var n = e.memoizedProps; var o = t !== null ? t.memoizedProps : n; var r = e.type; var s = e.updateQueue; if (e.updateQueue = null, s !== null) try { r === 'input' && n.type === 'radio' && n.name != null && yh(h, n), Ga(r, o); var a = Ga(r, n); for (o = 0; o < s.length; o += 2) { var f = s[o]; var l = s[o + 1]; f === 'style' ? Rh(h, l) : f === 'dangerouslySetInnerHTML' ? Ph(h, l) : f === 'children' ? Ln(h, l) : xa(h, f, l, a) } switch (r) { case 'input':Fa(h, n); break; case 'textarea':Eh(h, n); break; case 'select':var u = h._wrapperState.wasMultiple; h._wrapperState.wasMultiple = !!n.multiple; var v = n.value; v != null ? Ui(h, !!n.multiple, v, !1) : u !== !!n.multiple && (n.defaultValue != null ? Ui(h, !!n.multiple, n.defaultValue, !0) : Ui(h, !!n.multiple, n.multiple ? [] : '', !1)) }h[jn] = n } catch (p) { Et(e, e.return, p) } } break; case 6:if (Se(d, e), Le(e), i & 4) { if (e.stateNode === null) throw Error(k(162)); a = e.stateNode, f = e.memoizedProps; try { a.nodeValue = f } catch (p) { Et(e, e.return, p) } } break; case 3:if (Se(d, e), Le(e), i & 4 && t !== null && t.memoizedState.isDehydrated) try { Un(d.containerInfo) } catch (p) { Et(e, e.return, p) } break; case 4:Se(d, e), Le(e); break; case 13:Se(d, e), Le(e), a = e.child, a.flags & 8192 && a.memoizedState !== null && (a.alternate === null || a.alternate.memoizedState === null) && (il = At()), i & 4 && $f(e); break; case 22:if (a = t !== null && t.memoizedState !== null, e.mode & 1 ? (Yt = (f = Yt) || a, Se(d, e), Yt = f) : Se(d, e), Le(e), i & 8192) { f = e.memoizedState !== null; t:for (l = null, u = e; ;) { if (u.tag === 5) { if (l === null) { l = u; try { h = u.stateNode, f ? (n = h.style, typeof n.setProperty === 'function' ? n.setProperty('display', 'none', 'important') : n.display = 'none') : (r = u.stateNode, s = u.memoizedProps.style, o = s != null && s.hasOwnProperty('display') ? s.display : null, r.style.display = Mh('display', o)) } catch (p) { Et(e, e.return, p) } } } else if (u.tag === 6) { if (l === null) try { u.stateNode.nodeValue = f ? '' : u.memoizedProps } catch (p) { Et(e, e.return, p) } } else if ((u.tag !== 22 && u.tag !== 23 || u.memoizedState === null || u === e) && u.child !== null) { u.child.return = u, u = u.child; continue } if (u === e) break t; for (;u.sibling === null;) { if (u.return === null || u.return === e) break t; l === u && (l = null), u = u.return }l === u && (l = null), u.sibling.return = u.return, u = u.sibling } if (f && !a && (e.mode & 1) != 0) for (tt = e, e = e.child; e !== null;) { for (a = tt = e; tt !== null;) { switch (f = tt, l = f.child, f.tag) { case 0:case 11:case 14:case 15:os(4, f, f.return); break; case 1:if (an(f, f.return), n = f.stateNode, typeof n.componentWillUnmount === 'function') { u = f, v = f.return; try { h = u, n.props = h.memoizedProps, n.state = h.memoizedState, n.componentWillUnmount() } catch (p) { Et(u, v, p) } } break; case 5:an(f, f.return); break; case 22:if (f.memoizedState !== null) { qf(a); continue } }l !== null ? (l.return = f, tt = l) : qf(a) }e = e.sibling } } break; case 19:Se(d, e), Le(e), i & 4 && $f(e); break; case 21:break; default:Se(d, e), Le(e) } } function Le (e) { const d = e.flags; if (d & 2) { try { t: { for (let t = e.return; t !== null;) { if (Zf(t)) { var i = t; break t }t = t.return } throw Error(k(160)) } switch (i.tag) { case 5:var h = i.stateNode; i.flags & 32 && (Ln(h, ''), i.flags &= -33); var n = Qf(e); _o(e, n, h); break; case 3:case 4:var o = i.stateNode.containerInfo; var r = Qf(e); qo(e, r, o); break; default:throw Error(k(161)) } } catch (s) { Et(e, e.return, s) }e.flags &= -3 }d & 4096 && (e.flags &= -4097) } function _c (e, d, t) { tt = e, bf(e, d, t) } function bf (e, d, t) { for (let i = (e.mode & 1) != 0; tt !== null;) { const h = tt; let n = h.child; if (h.tag === 22 && i) { let o = h.memoizedState !== null || Cr; if (!o) { let r = h.alternate; let s = r !== null && r.memoizedState !== null || Yt; r = Cr; const a = Yt; if (Cr = o, (Yt = s) && !a) for (tt = h; tt !== null;)o = tt, s = o.child, o.tag === 22 && o.memoizedState !== null ? _f(h) : s !== null ? (s.return = o, tt = s) : _f(h); for (;n !== null;)tt = n, bf(n, d, t), n = n.sibling; tt = h, Cr = r, Yt = a }kf(e, d, t) } else (h.subtreeFlags & 8772) != 0 && n !== null ? (n.return = h, tt = n) : kf(e, d, t) } } function kf (e) { for (;tt !== null;) { const d = tt; if ((d.flags & 8772) != 0) { var t = d.alternate; try { if ((d.flags & 8772) != 0) switch (d.tag) { case 0:case 11:case 15:Yt || Ar(5, d); break; case 1:var i = d.stateNode; if (d.flags & 4 && !Yt) if (t === null)i.componentDidMount(); else { const h = d.elementType === d.type ? t.memoizedProps : ge(d.type, t.memoizedProps); i.componentDidUpdate(h, t.memoizedState, i.__reactInternalSnapshotBeforeUpdate) } var n = d.updateQueue; n !== null && Vu(d, n, i); break; case 3:var o = d.updateQueue; if (o !== null) { if (t = null, d.child !== null) switch (d.child.tag) { case 5:t = d.child.stateNode; break; case 1:t = d.child.stateNode }Vu(d, o, t) } break; case 5:var r = d.stateNode; if (t === null && d.flags & 4) { t = r; const s = d.memoizedProps; switch (d.type) { case 'button':case 'input':case 'select':case 'textarea':s.autoFocus && t.focus(); break; case 'img':s.src && (t.src = s.src) } } break; case 6:break; case 4:break; case 12:break; case 13:if (d.memoizedState === null) { const a = d.alternate; if (a !== null) { const f = a.memoizedState; if (f !== null) { const l = f.dehydrated; l !== null && Un(l) } } } break; case 19:case 17:case 21:case 22:case 23:break; default:throw Error(k(163)) }Yt || d.flags & 512 && ko(d) } catch (u) { Et(d, d.return, u) } } if (d === e) { tt = null; break } if (t = d.sibling, t !== null) { t.return = d.return, tt = t; break }tt = d.return } } function qf (e) { for (;tt !== null;) { const d = tt; if (d === e) { tt = null; break } const t = d.sibling; if (t !== null) { t.return = d.return, tt = t; break }tt = d.return } } function _f (e) { for (;tt !== null;) { const d = tt; try { switch (d.tag) { case 0:case 11:case 15:var t = d.return; try { Ar(4, d) } catch (s) { Et(d, t, s) } break; case 1:var i = d.stateNode; if (typeof i.componentDidMount === 'function') { const h = d.return; try { i.componentDidMount() } catch (s) { Et(d, h, s) } } var n = d.return; try { ko(d) } catch (s) { Et(d, n, s) } break; case 5:var o = d.return; try { ko(d) } catch (s) { Et(d, o, s) } } } catch (s) { Et(d, d.return, s) } if (d === e) { tt = null; break } const r = d.sibling; if (r !== null) { r.return = d.return, tt = r; break }tt = d.return } } const tp = Math.ceil; const Pr = we.ReactCurrentDispatcher; const tl = we.ReactCurrentOwner; const he = we.ReactCurrentBatchConfig; let ht = 0; var Lt = null; let Mt = null; let Nt = 0; var ie = 0; var on = ni(0); var Ot = 0; let ls = null; var Pi = 0; let Mr = 0; let el = 0; let hs = null; let kt = null; var il = 0; var ln = 1 / 0; let Ke = null; var Rr = !1; var nl = null; var hi = null; let Lr = !1; let ui = null; let Or = 0; let us = 0; let sl = null; let Fr = -1; let Dr = 0; function Ht () { return (ht & 6) != 0 ? At() : Fr !== -1 ? Fr : Fr = At() } function fi (e) { return (e.mode & 1) == 0 ? 1 : (ht & 2) != 0 && Nt !== 0 ? Nt & -Nt : Uc.transition !== null ? (Dr === 0 && (Dr = Wh()), Dr) : (e = ut, e !== 0 || (e = window.event, e = e === void 0 ? 16 : kh(e.type)), e) } function ue (e, d, t) { if (us > 50) throw us = 0, sl = null, Error(k(185)); const i = Ir(e, d); return i === null ? null : (Bn(i, d, t), ((ht & 2) == 0 || i !== Lt) && (i === Lt && ((ht & 2) == 0 && (Mr |= d), Ot === 4 && di(i, Nt)), qt(i, t), d === 1 && ht === 0 && (e.mode & 1) == 0 && (ln = At() + 500, rr && ri())), i) } function Ir (e, d) { e.lanes |= d; let t = e.alternate; for (t !== null && (t.lanes |= d), t = e, e = e.return; e !== null;)e.childLanes |= d, t = e.alternate, t !== null && (t.childLanes |= d), t = e, e = e.return; return t.tag === 3 ? t.stateNode : null } function td (e) { return (Lt !== null || xe !== null) && (e.mode & 1) != 0 && (ht & 2) == 0 } function qt (e, d) { let t = e.callbackNode; Vv(e, d); const i = ws(e, e === Lt ? Nt : 0); if (i === 0)t !== null && Yh(t), e.callbackNode = null, e.callbackPriority = 0; else if (d = i & -i, e.callbackPriority !== d) { if (t != null && Yh(t), d === 1)e.tag === 0 ? zc(id.bind(null, e)) : zu(id.bind(null, e)), Bc(function () { ht === 0 && ri() }), t = null; else { switch (Hh(i)) { case 1:t = Wa; break; case 4:t = Vh; break; case 16:t = Is; break; case 536870912:t = Xh; break; default:t = Is }t = ud(t, ed.bind(null, e)) }e.callbackPriority = d, e.callbackNode = t } } function ed (e, d) { if (Fr = -1, Dr = 0, (ht & 6) != 0) throw Error(k(327)); let t = e.callbackNode; if (hn() && e.callbackNode !== t) return null; let i = ws(e, e === Lt ? Nt : 0); if (i === 0) return null; if ((i & 30) != 0 || (i & e.expiredLanes) != 0 || d)d = Br(e, i); else { d = i; var h = ht; ht |= 2; var n = sd(); (Lt !== e || Nt !== d) && (Ke = null, ln = At() + 500, Ri(e, d)); do try { np(); break } catch (r) { nd(e, r) } while (1); To(), Pr.current = n, ht = h, Mt !== null ? d = 0 : (Lt = null, Nt = 0, d = Ot) } if (d !== 0) { if (d === 2 && (h = Ha(e), h !== 0 && (i = h, d = rl(e, h))), d === 1) throw t = ls, Ri(e, 0), di(e, i), qt(e, At()), t; if (d === 6)di(e, i); else { if (h = e.current.alternate, (i & 30) == 0 && !ep(h) && (d = Br(e, i), d === 2 && (n = Ha(e), n !== 0 && (i = n, d = rl(e, n))), d === 1)) throw t = ls, Ri(e, 0), di(e, i), qt(e, At()), t; switch (e.finishedWork = h, e.finishedLanes = i, d) { case 0:case 1:throw Error(k(345)); case 2:Li(e, kt, Ke); break; case 3:if (di(e, i), (i & 130023424) === i && (d = il + 500 - At(), d > 10)) { if (ws(e, 0) !== 0) break; if (h = e.suspendedLanes, (h & i) !== i) { Ht(), e.pingedLanes |= e.suspendedLanes & h; break }e.timeoutHandle = co(Li.bind(null, e, kt, Ke), d); break }Li(e, kt, Ke); break; case 4:if (di(e, i), (i & 4194240) === i) break; for (d = e.eventTimes, h = -1; i > 0;) { let o = 31 - pe(i); n = 1 << o, o = d[o], o > h && (h = o), i &= ~n } if (i = h, i = At() - i, i = (i < 120 ? 120 : i < 480 ? 480 : i < 1080 ? 1080 : i < 1920 ? 1920 : i < 3e3 ? 3e3 : i < 4320 ? 4320 : 1960 * tp(i / 1960)) - i, i > 10) { e.timeoutHandle = co(Li.bind(null, e, kt, Ke), i); break }Li(e, kt, Ke); break; case 5:Li(e, kt, Ke); break; default:throw Error(k(329)) } } } return qt(e, At()), e.callbackNode === t ? ed.bind(null, e) : null } function rl (e, d) { const t = hs; return e.current.memoizedState.isDehydrated && (Ri(e, d).flags |= 256), e = Br(e, d), e !== 2 && (d = kt, kt = t, d !== null && al(d)), e } function al (e) { kt === null ? kt = e : kt.push.apply(kt, e) } function ep (e) { for (let d = e; ;) { if (d.flags & 16384) { var t = d.updateQueue; if (t !== null && (t = t.stores, t !== null)) for (let i = 0; i < t.length; i++) { let h = t[i]; const n = h.getSnapshot; h = h.value; try { if (!me(n(), h)) return !1 } catch (o) { return !1 } } } if (t = d.child, d.subtreeFlags & 16384 && t !== null)t.return = d, d = t; else { if (d === e) break; for (;d.sibling === null;) { if (d.return === null || d.return === e) return !0; d = d.return }d.sibling.return = d.return, d = d.sibling } } return !0 } function di (e, d) { for (d &= ~el, d &= ~Mr, e.suspendedLanes |= d, e.pingedLanes &= ~d, e = e.expirationTimes; d > 0;) { const t = 31 - pe(d); const i = 1 << t; e[t] = -1, d &= ~i } } function id (e) { if ((ht & 6) != 0) throw Error(k(327)); hn(); let d = ws(e, 0); if ((d & 1) == 0) return qt(e, At()), null; let t = Br(e, d); if (e.tag !== 0 && t === 2) { const i = Ha(e); i !== 0 && (d = i, t = rl(e, i)) } if (t === 1) throw t = ls, Ri(e, 0), di(e, d), qt(e, At()), t; if (t === 6) throw Error(k(345)); return e.finishedWork = e.current.alternate, e.finishedLanes = d, Li(e, kt, Ke), qt(e, At()), null } function ol (e, d) { const t = ht; ht |= 1; try { return e(d) } finally { ht = t, ht === 0 && (ln = At() + 500, rr && ri()) } } function Mi (e) { ui !== null && ui.tag === 0 && (ht & 6) == 0 && hn(); const d = ht; ht |= 1; const t = he.transition; const i = ut; try { if (he.transition = null, ut = 1, e) return e() } finally { ut = i, he.transition = t, ht = d, (ht & 6) == 0 && ri() } } function ll () { ie = on.current, mt(on) } function Ri (e, d) { e.finishedWork = null, e.finishedLanes = 0; let t = e.timeoutHandle; if (t !== -1 && (e.timeoutHandle = -1, Ic(t)), Mt !== null) for (t = Mt.return; t !== null;) { var i = t; switch (Ro(i), i.tag) { case 1:i = i.type.childContextTypes, i != null && nr(); break; case 3:rn(), mt(Jt), mt(wt), No(); break; case 5:Io(i); break; case 4:rn(); break; case 13:mt(yt); break; case 19:mt(yt); break; case 10:So(i.type._context); break; case 22:case 23:ll() }t = t.return } if (Lt = e, Mt = e = vi(e.current, null), Nt = ie = d, Ot = 0, ls = null, el = Mr = Pi = 0, kt = hs = null, xe !== null) { for (d = 0; d < xe.length; d++) if (t = xe[d], i = t.interleaved, i !== null) { t.interleaved = null; const h = i.next; const n = t.pending; if (n !== null) { const o = n.next; n.next = h, i.next = o }t.pending = i }xe = null } return e } function nd (e, d) { do { let t = Mt; try { if (To(), pr.current = yr, mr) { for (let i = Tt.memoizedState; i !== null;) { const h = i.queue; h !== null && (h.pending = null), i = i.next }mr = !1 } if (Ai = 0, Dt = Rt = Tt = null, is = !1, ns = 0, tl.current = null, t === null || t.return === null) { Ot = 1, ls = d, Mt = null; break }t: { let n = e; const o = t.return; let r = t; let s = d; if (d = Nt, r.flags |= 32768, s !== null && typeof s === 'object' && typeof s.then === 'function') { const a = s; const f = r; const l = f.tag; if ((f.mode & 1) == 0 && (l === 0 || l === 11 || l === 15)) { const u = f.alternate; u ? (f.updateQueue = u.updateQueue, f.memoizedState = u.memoizedState, f.lanes = u.lanes) : (f.updateQueue = null, f.memoizedState = null) } const v = Af(o); if (v !== null) { v.flags &= -257, Pf(v, o, r, n, d), v.mode & 1 && Cf(n, a, d), d = v, s = a; const p = d.updateQueue; if (p === null) { const c = new Set(); c.add(s), d.updateQueue = c } else p.add(s); break t } else { if ((d & 1) == 0) { Cf(n, a, d), hl(); break t }s = Error(k(426)) } } else if (gt && r.mode & 1) { const m = Af(o); if (m !== null) { (m.flags & 65536) == 0 && (m.flags |= 256), Pf(m, o, r, n, d), Fo(s); break t } }n = s, Ot !== 4 && (Ot = 2), hs === null ? hs = [n] : hs.push(n), s = Ho(s, r), r = o; do { switch (r.tag) { case 3:r.flags |= 65536, d &= -d, r.lanes |= d; var g = Sf(r, s, d); Yu(r, g); break t; case 1:n = s; var x = r.type; var y = r.stateNode; if ((r.flags & 128) == 0 && (typeof x.getDerivedStateFromError === 'function' || y !== null && typeof y.componentDidCatch === 'function' && (hi === null || !hi.has(y)))) { r.flags |= 65536, d &= -d, r.lanes |= d; const T = Ef(r, n, d); Yu(r, T); break t } }r = r.return } while (r !== null) }ad(t) } catch (S) { d = S, Mt === t && t !== null && (Mt = t = t.return); continue } break } while (1) } function sd () { const e = Pr.current; return Pr.current = yr, e === null ? yr : e } function hl () { (Ot === 0 || Ot === 3 || Ot === 2) && (Ot = 4), Lt === null || (Pi & 268435455) == 0 && (Mr & 268435455) == 0 || di(Lt, Nt) } function Br (e, d) { const t = ht; ht |= 2; const i = sd(); (Lt !== e || Nt !== d) && (Ke = null, Ri(e, d)); do try { ip(); break } catch (h) { nd(e, h) } while (1); if (To(), ht = t, Pr.current = i, Mt !== null) throw Error(k(261)); return Lt = null, Nt = 0, Ot } function ip () { for (;Mt !== null;)rd(Mt) } function np () { for (;Mt !== null && !Dv();)rd(Mt) } function rd (e) { const d = hd(e.alternate, e, ie); e.memoizedProps = e.pendingProps, d === null ? ad(e) : Mt = d, tl.current = null } function ad (e) { let d = e; do { let t = d.alternate; if (e = d.return, (d.flags & 32768) == 0) { if (t = Jc(t, d, ie), t !== null) { Mt = t; return } } else { if (t = bc(t, d), t !== null) { t.flags &= 32767, Mt = t; return } if (e !== null)e.flags |= 32768, e.subtreeFlags = 0, e.deletions = null; else { Ot = 6, Mt = null; return } } if (d = d.sibling, d !== null) { Mt = d; return }Mt = d = e } while (d !== null); Ot === 0 && (Ot = 5) } function Li (e, d, t) { const i = ut; const h = he.transition; try { he.transition = null, ut = 1, sp(e, d, t, i) } finally { he.transition = h, ut = i } return null } function sp (e, d, t, i) { do hn(); while (ui !== null); if ((ht & 6) != 0) throw Error(k(327)); t = e.finishedWork; const h = e.finishedLanes; if (t === null) return null; if (e.finishedWork = null, e.finishedLanes = 0, t === e.current) throw Error(k(177)); e.callbackNode = null, e.callbackPriority = 0; let n = t.lanes | t.childLanes; if (Xv(e, n), e === Lt && (Mt = Lt = null, Nt = 0), (t.subtreeFlags & 2064) == 0 && (t.flags & 2064) == 0 || Lr || (Lr = !0, ud(Is, function () { return hn(), null })), n = (t.flags & 15990) != 0, (t.subtreeFlags & 15990) != 0 || n) { n = he.transition, he.transition = null; const o = ut; ut = 1; const r = ht; ht |= 4, tl.current = null, qc(e, t), jf(t, e), Rc(fo), Ys = !!uo, fo = uo = null, e.current = t, _c(t, e, h), Iv(), ht = r, ut = o, he.transition = n } else e.current = t; if (Lr && (Lr = !1, ui = e, Or = h), n = e.pendingLanes, n === 0 && (hi = null), Gv(t.stateNode, i), qt(e, At()), d !== null) for (i = e.onRecoverableError, t = 0; t < d.length; t++)i(d[t]); if (Rr) throw Rr = !1, e = nl, nl = null, e; return (Or & 1) != 0 && e.tag !== 0 && hn(), n = e.pendingLanes, (n & 1) != 0 ? e === sl ? us++ : (us = 0, sl = e) : us = 0, ri(), null } function hn () { if (ui !== null) { let e = Hh(Or); const d = he.transition; const t = ut; try { if (he.transition = null, ut = e < 16 ? 16 : e, ui === null) var i = !1; else { if (e = ui, ui = null, Or = 0, (ht & 6) != 0) throw Error(k(331)); const h = ht; for (ht |= 4, tt = e.current; tt !== null;) { let n = tt; var o = n.child; if ((tt.flags & 16) != 0) { var r = n.deletions; if (r !== null) { for (let s = 0; s < r.length; s++) { const a = r[s]; for (tt = a; tt !== null;) { let f = tt; switch (f.tag) { case 0:case 11:case 15:os(8, f, n) } const l = f.child; if (l !== null)l.return = f, tt = l; else for (;tt !== null;) { f = tt; const u = f.sibling; const v = f.return; if (Kf(f), f === a) { tt = null; break } if (u !== null) { u.return = v, tt = u; break }tt = v } } } const p = n.alternate; if (p !== null) { let c = p.child; if (c !== null) { p.child = null; do { const m = c.sibling; c.sibling = null, c = m } while (c !== null) } }tt = n } } if ((n.subtreeFlags & 2064) != 0 && o !== null)o.return = n, tt = o; else t:for (;tt !== null;) { if (n = tt, (n.flags & 2048) != 0) switch (n.tag) { case 0:case 11:case 15:os(9, n, n.return) } const g = n.sibling; if (g !== null) { g.return = n.return, tt = g; break t }tt = n.return } } const x = e.current; for (tt = x; tt !== null;) { o = tt; const y = o.child; if ((o.subtreeFlags & 2064) != 0 && y !== null)y.return = o, tt = y; else t:for (o = x; tt !== null;) { if (r = tt, (r.flags & 2048) != 0) try { switch (r.tag) { case 0:case 11:case 15:Ar(9, r) } } catch (S) { Et(r, r.return, S) } if (r === o) { tt = null; break t } const T = r.sibling; if (T !== null) { T.return = r.return, tt = T; break t }tt = r.return } } if (ht = h, ri(), Ae && typeof Ae.onPostCommitFiberRoot === 'function') try { Ae.onPostCommitFiberRoot(Bs, e) } catch (S) {}i = !0 } return i } finally { ut = t, he.transition = d } } return !1 } function od (e, d, t) { d = Ho(t, d), d = Sf(e, d, 1), oi(e, d), d = Ht(), e = Ir(e, 1), e !== null && (Bn(e, 1, d), qt(e, d)) } function Et (e, d, t) { if (e.tag === 3)od(e, e, t); else for (;d !== null;) { if (d.tag === 3) { od(d, e, t); break } else if (d.tag === 1) { const i = d.stateNode; if (typeof d.type.getDerivedStateFromError === 'function' || typeof i.componentDidCatch === 'function' && (hi === null || !hi.has(i))) { e = Ho(t, e), e = Ef(d, e, 1), oi(d, e), e = Ht(), d = Ir(d, 1), d !== null && (Bn(d, 1, e), qt(d, e)); break } }d = d.return } } function rp (e, d, t) { const i = e.pingCache; i !== null && i.delete(d), d = Ht(), e.pingedLanes |= e.suspendedLanes & t, Lt === e && (Nt & t) === t && (Ot === 4 || Ot === 3 && (Nt & 130023424) === Nt && At() - il < 500 ? Ri(e, 0) : el |= t), qt(e, d) } function ld (e, d) { d === 0 && ((e.mode & 1) == 0 ? d = 1 : (d = Gs, Gs <<= 1, (Gs & 130023424) == 0 && (Gs = 4194304))); const t = Ht(); e = Ir(e, d), e !== null && (Bn(e, d, t), qt(e, t)) } function ap (e) { const d = e.memoizedState; let t = 0; d !== null && (t = d.retryLane), ld(e, t) } function op (e, d) { let t = 0; switch (e.tag) { case 13:var i = e.stateNode; var h = e.memoizedState; h !== null && (t = h.retryLane); break; case 19:i = e.stateNode; break; default:throw Error(k(314)) }i !== null && i.delete(d), ld(e, t) } let hd; hd = function (e, d, t) { if (e !== null) if (e.memoizedProps !== d.pendingProps || Jt.current)bt = !0; else { if ((e.lanes & t) == 0 && (d.flags & 128) == 0) return bt = !1, jc(e, d, t); bt = (e.flags & 131072) != 0 } else bt = !1, gt && (d.flags & 1048576) != 0 && Zu(d, dr, d.index); switch (d.lanes = 0, d.tag) { case 2:var i = d.type; e !== null && (e.alternate = null, d.alternate = null, d.flags |= 2), e = d.pendingProps; var h = ki(d, wt.current); _i(d, t), h = zo(null, d, i, e, h, t); var n = Uo(); return d.flags |= 1, typeof h === 'object' && h !== null && typeof h.render === 'function' && h.$$typeof === void 0 ? (d.tag = 1, d.memoizedState = null, d.updateQueue = null, $t(i) ? (n = !0, sr(d)) : n = !1, d.memoizedState = h.state !== null && h.state !== void 0 ? h.state : null, Co(d), h.updater = ur, d.stateNode = h, h._reactInternals = d, Po(d, i, e, t), d = Jo(null, d, i, !0, n, t)) : (d.tag = 0, gt && n && Mo(d), Wt(null, d, h, t), d = d.child), d; case 16:i = d.elementType; t: { switch (e !== null && (e.alternate = null, d.alternate = null, d.flags |= 2), e = d.pendingProps, h = i._init, i = h(i._payload), d.type = i, h = d.tag = hp(i), e = ge(i, e), h) { case 0:d = Qo(null, d, i, e, t); break t; case 1:d = Nf(null, d, i, e, t); break t; case 11:d = Of(null, d, i, e, t); break t; case 14:d = Ff(null, d, i, ge(i.type, e), t); break t } throw Error(k(306, i, '')) } return d; case 0:return i = d.type, h = d.pendingProps, h = d.elementType === i ? h : ge(i, h), Qo(e, d, i, h, t); case 1:return i = d.type, h = d.pendingProps, h = d.elementType === i ? h : ge(i, h), Nf(e, d, i, h, t); case 3:t: { if (Gf(d), e === null) throw Error(k(387)); i = d.pendingProps, n = d.memoizedState, h = n.element, Uu(e, d), hr(d, i, null, t); var o = d.memoizedState; if (i = o.element, n.isDehydrated) if (n = { element: i, isDehydrated: !1, cache: o.cache, pendingSuspenseBoundaries: o.pendingSuspenseBoundaries, transitions: o.transitions }, d.updateQueue.baseState = n, d.memoizedState = n, d.flags & 256) { h = Error(k(423)), d = wf(e, d, i, t, h); break t } else if (i !== h) { h = Error(k(424)), d = wf(e, d, i, t, h); break t } else for (jt = ze(d.stateNode.containerInfo.firstChild), ee = d, gt = !0, ye = null, t = ku(d, null, i, t), d.child = t; t;)t.flags = t.flags & -3 | 4096, t = t.sibling; else { if (nn(), i === h) { d = He(e, d, t); break t }Wt(e, d, i, t) }d = d.child } return d; case 5:return qu(d), e === null && Oo(d), i = d.type, h = d.pendingProps, n = e !== null ? e.memoizedProps : null, o = h.children, vo(i, h) ? o = null : n !== null && vo(i, n) && (d.flags |= 32), Bf(e, d), Wt(e, d, o, t), d.child; case 6:return e === null && Oo(d), null; case 13:return Uf(e, d, t); case 4:return Do(d, d.stateNode.containerInfo), i = d.pendingProps, e === null ? d.child = sn(d, null, i, t) : Wt(e, d, i, t), d.child; case 11:return i = d.type, h = d.pendingProps, h = d.elementType === i ? h : ge(i, h), Of(e, d, i, h, t); case 7:return Wt(e, d, d.pendingProps, t), d.child; case 8:return Wt(e, d, d.pendingProps.children, t), d.child; case 12:return Wt(e, d, d.pendingProps.children, t), d.child; case 10:t: { if (i = d.type._context, h = d.pendingProps, n = d.memoizedProps, o = h.value, vt(ar, i._currentValue), i._currentValue = o, n !== null) if (me(n.value, o)) { if (n.children === h.children && !Jt.current) { d = He(e, d, t); break t } } else for (n = d.child, n !== null && (n.return = d); n !== null;) { let r = n.dependencies; if (r !== null) { o = n.child; for (let s = r.firstContext; s !== null;) { if (s.context === i) { if (n.tag === 1) { s = Ve(-1, t & -t), s.tag = 2; let a = n.updateQueue; if (a !== null) { a = a.shared; const f = a.pending; f === null ? s.next = s : (s.next = f.next, f.next = s), a.pending = s } }n.lanes |= t, s = n.alternate, s !== null && (s.lanes |= t), Eo(n.return, t, d), r.lanes |= t; break }s = s.next } } else if (n.tag === 10)o = n.type === d.type ? null : n.child; else if (n.tag === 18) { if (o = n.return, o === null) throw Error(k(341)); o.lanes |= t, r = o.alternate, r !== null && (r.lanes |= t), Eo(o, t, d), o = n.sibling } else o = n.child; if (o !== null)o.return = n; else for (o = n; o !== null;) { if (o === d) { o = null; break } if (n = o.sibling, n !== null) { n.return = o.return, o = n; break }o = o.return }n = o }Wt(e, d, h.children, t), d = d.child } return d; case 9:return h = d.type, i = d.pendingProps.children, _i(d, t), h = re(h), i = i(h), d.flags |= 1, Wt(e, d, i, t), d.child; case 14:return i = d.type, h = ge(i, d.pendingProps), h = ge(i.type, h), Ff(e, d, i, h, t); case 15:return Df(e, d, d.type, d.pendingProps, t); case 17:return i = d.type, h = d.pendingProps, h = d.elementType === i ? h : ge(i, h), e !== null && (e.alternate = null, d.alternate = null, d.flags |= 2), d.tag = 1, $t(i) ? (e = !0, sr(d)) : e = !1, _i(d, t), Hu(d, i, h), Po(d, i, h, t), Jo(null, d, i, !0, e, t); case 19:return Wf(e, d, t); case 22:return If(e, d, t) } throw Error(k(156, d.tag)) }; function ud (e, d) { return Uh(e, d) } function lp (e, d, t, i) { this.tag = e, this.key = t, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = d, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = i, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function fe (e, d, t, i) { return new lp(e, d, t, i) } function ul (e) { return e = e.prototype, !(!e || !e.isReactComponent) } function hp (e) { if (typeof e === 'function') return ul(e) ? 1 : 0; if (e != null) { if (e = e.$$typeof, e === Sa) return 11; if (e === Aa) return 14 } return 2 } function vi (e, d) { let t = e.alternate; return t === null ? (t = fe(e.tag, d, e.key, e.mode), t.elementType = e.elementType, t.type = e.type, t.stateNode = e.stateNode, t.alternate = e, e.alternate = t) : (t.pendingProps = d, t.type = e.type, t.flags = 0, t.subtreeFlags = 0, t.deletions = null), t.flags = e.flags & 14680064, t.childLanes = e.childLanes, t.lanes = e.lanes, t.child = e.child, t.memoizedProps = e.memoizedProps, t.memoizedState = e.memoizedState, t.updateQueue = e.updateQueue, d = e.dependencies, t.dependencies = d === null ? null : { lanes: d.lanes, firstContext: d.firstContext }, t.sibling = e.sibling, t.index = e.index, t.ref = e.ref, t } function Nr (e, d, t, i, h, n) { let o = 2; if (i = e, typeof e === 'function')ul(e) && (o = 1); else if (typeof e === 'string')o = 5; else t:switch (e) { case zi:return Oi(t.children, h, n, d); case ya:o = 8, h |= 8; break; case Ta:return e = fe(12, t, d, h | 2), e.elementType = Ta, e.lanes = n, e; case Ea:return e = fe(13, t, d, h), e.elementType = Ea, e.lanes = n, e; case Ca:return e = fe(19, t, d, h), e.elementType = Ca, e.lanes = n, e; case ch:return Gr(t, h, n, d); default:if (typeof e === 'object' && e !== null) switch (e.$$typeof) { case dh:o = 10; break t; case vh:o = 9; break t; case Sa:o = 11; break t; case Aa:o = 14; break t; case je:o = 16, i = null; break t } throw Error(k(130, e == null ? e : typeof e, '')) } return d = fe(o, t, d, h), d.elementType = e, d.type = i, d.lanes = n, d } function Oi (e, d, t, i) { return e = fe(7, e, i, d), e.lanes = t, e } function Gr (e, d, t, i) { return e = fe(22, e, i, d), e.elementType = ch, e.lanes = t, e.stateNode = {}, e } function fl (e, d, t) { return e = fe(6, e, null, d), e.lanes = t, e } function dl (e, d, t) { return d = fe(4, e.children !== null ? e.children : [], e.key, d), d.lanes = t, d.stateNode = { containerInfo: e.containerInfo, pendingChildren: null, implementation: e.implementation }, d } function up (e, d, t, i, h) { this.tag = d, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Ka(0), this.expirationTimes = Ka(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Ka(0), this.identifierPrefix = i, this.onRecoverableError = h, this.mutableSourceEagerHydrationData = null } function vl (e, d, t, i, h, n, o, r, s) { return e = new up(e, d, t, r, s), d === 1 ? (d = 1, n === !0 && (d |= 8)) : d = 0, n = fe(3, null, null, d), e.current = n, n.stateNode = e, n.memoizedState = { element: i, isDehydrated: t, cache: null, transitions: null, pendingSuspenseBoundaries: null }, Co(n), e } function fp (e, d, t) { const i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: wi, key: i == null ? null : '' + i, children: e, containerInfo: d, implementation: t } } function fd (e) { if (!e) return si; e = e._reactInternals; t: { if (xi(e) !== e || e.tag !== 1) throw Error(k(170)); var d = e; do { switch (d.tag) { case 3:d = d.stateNode.context; break t; case 1:if ($t(d.type)) { d = d.stateNode.__reactInternalMemoizedMergedChildContext; break t } }d = d.return } while (d !== null); throw Error(k(171)) } if (e.tag === 1) { const t = e.type; if ($t(t)) return Gu(e, t, d) } return d } function dd (e, d, t, i, h, n, o, r, s) { return e = vl(t, i, !0, e, h, n, o, r, s), e.context = fd(null), t = e.current, i = Ht(), h = fi(t), n = Ve(i, h), n.callback = d != null ? d : null, oi(t, n), e.current.lanes = h, Bn(e, h, i), qt(e, i), e } function wr (e, d, t, i) { const h = d.current; const n = Ht(); const o = fi(h); return t = fd(t), d.context === null ? d.context = t : d.pendingContext = t, d = Ve(n, o), d.payload = { element: e }, i = i === void 0 ? null : i, i !== null && (d.callback = i), oi(h, d), e = ue(h, o, n), e !== null && lr(e, h, o), o } function zr (e) { if (e = e.current, !e.child) return null; switch (e.child.tag) { case 5:return e.child.stateNode; default:return e.child.stateNode } } function vd (e, d) { if (e = e.memoizedState, e !== null && e.dehydrated !== null) { const t = e.retryLane; e.retryLane = t !== 0 && t < d ? t : d } } function cl (e, d) { vd(e, d), (e = e.alternate) && vd(e, d) } function dp () { return null } const cd = typeof reportError === 'function' ? reportError : function (e) { console.error(e) }; function pl (e) { this._internalRoot = e }Ur.prototype.render = pl.prototype.render = function (e) { const d = this._internalRoot; if (d === null) throw Error(k(409)); wr(e, d, null, null) }; Ur.prototype.unmount = pl.prototype.unmount = function () { const e = this._internalRoot; if (e !== null) { this._internalRoot = null; const d = e.containerInfo; Mi(function () { wr(null, e, null, null) }), d[Ue] = null } }; function Ur (e) { this._internalRoot = e }Ur.prototype.unstable_scheduleHydration = function (e) { if (e) { const d = Qh(); e = { blockedOn: null, target: e, priority: d }; for (var t = 0; t < ti.length && d !== 0 && d < ti[t].priority; t++);ti.splice(t, 0, e), t === 0 && jh(e) } }; function ml (e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11) } function Yr (e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11 && (e.nodeType !== 8 || e.nodeValue !== ' react-mount-point-unstable ')) } function pd () {} function vp (e, d, t, i, h) { if (h) { if (typeof i === 'function') { const n = i; i = function () { const a = zr(o); n.call(a) } } var o = dd(d, i, e, 0, null, !1, !1, '', pd); return e._reactRootContainer = o, e[Ue] = o.current, Jn(e.nodeType === 8 ? e.parentNode : e), Mi(), o } for (;h = e.lastChild;)e.removeChild(h); if (typeof i === 'function') { const r = i; i = function () { const a = zr(s); r.call(a) } } var s = vl(e, 0, !1, null, null, !1, !1, '', pd); return e._reactRootContainer = s, e[Ue] = s.current, Jn(e.nodeType === 8 ? e.parentNode : e), Mi(function () { wr(d, s, t, i) }), s } function Vr (e, d, t, i, h) { const n = t._reactRootContainer; if (n) { var o = n; if (typeof h === 'function') { const r = h; h = function () { const s = zr(o); r.call(s) } }wr(d, o, e, h) } else o = vp(t, d, e, h, i); return zr(o) }Kh = function (e) { switch (e.tag) { case 3:var d = e.stateNode; if (d.current.memoizedState.isDehydrated) { const t = In(d.pendingLanes); t !== 0 && (Za(d, t | 1), qt(d, At()), (ht & 6) == 0 && (ln = At() + 500, ri())) } break; case 13:var i = Ht(); Mi(function () { return ue(e, 1, i) }), cl(e, 1) } }; Qa = function (e) { if (e.tag === 13) { const d = Ht(); ue(e, 134217728, d), cl(e, 134217728) } }; Zh = function (e) { if (e.tag === 13) { const d = Ht(); const t = fi(e); ue(e, t, d), cl(e, t) } }; Qh = function () { return ut }; Jh = function (e, d) { const t = ut; try { return ut = e, d() } finally { ut = t } }; Ua = function (e, d, t) { switch (d) { case 'input':if (Fa(e, t), d = t.name, t.type === 'radio' && d != null) { for (t = e; t.parentNode;)t = t.parentNode; for (t = t.querySelectorAll('input[name=' + JSON.stringify('' + d) + '][type="radio"]'), d = 0; d < t.length; d++) { const i = t[d]; if (i !== e && i.form === e.form) { const h = ir(i); if (!h) throw Error(k(90)); gh(i), Fa(i, h) } } } break; case 'textarea':Eh(e, t); break; case 'select':d = t.value, d != null && Ui(e, !!t.multiple, d, !1) } }; Dh = ol; Ih = Mi; const cp = { usingClientEntryPoint: !1, Events: [bn, ji, ir, Oh, Fh, ol] }; const fs = { findFiberByHostInstance: yi, bundleType: 0, version: '18.1.0', rendererPackageName: 'react-dom' }; const pp = { bundleType: fs.bundleType, version: fs.version, rendererPackageName: fs.rendererPackageName, rendererConfig: fs.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: we.ReactCurrentDispatcher, findHostInstanceByFiber: function (e) { return e = wh(e), e === null ? null : e.stateNode }, findFiberByHostInstance: fs.findFiberByHostInstance || dp, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: '18.1.0-next-22edb9f77-20220426' }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && (ds = __REACT_DEVTOOLS_GLOBAL_HOOK__, !ds.isDisabled && ds.supportsFiber)) try { Bs = ds.inject(pp), Ae = ds } catch (e) {} let ds; ne.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = cp; ne.createPortal = function (e, d) { const t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null; if (!ml(d)) throw Error(k(200)); return fp(e, d, null, t) }; ne.createRoot = function (e, d) { if (!ml(e)) throw Error(k(299)); let t = !1; let i = ''; let h = cd; return d != null && (d.unstable_strictMode === !0 && (t = !0), d.identifierPrefix !== void 0 && (i = d.identifierPrefix), d.onRecoverableError !== void 0 && (h = d.onRecoverableError)), d = vl(e, 1, !1, null, null, t, !1, i, h), e[Ue] = d.current, Jn(e.nodeType === 8 ? e.parentNode : e), new pl(d) }; ne.findDOMNode = function (e) { if (e == null) return null; if (e.nodeType === 1) return e; const d = e._reactInternals; if (d === void 0) throw typeof e.render === 'function' ? Error(k(188)) : (e = Object.keys(e).join(','), Error(k(268, e))); return e = wh(d), e = e === null ? null : e.stateNode, e }; ne.flushSync = function (e) { return Mi(e) }; ne.hydrate = function (e, d, t) { if (!Yr(d)) throw Error(k(200)); return Vr(null, e, d, !0, t) }; ne.hydrateRoot = function (e, d, t) { if (!ml(e)) throw Error(k(405)); const i = t != null && t.hydratedSources || null; let h = !1; let n = ''; let o = cd; if (t != null && (t.unstable_strictMode === !0 && (h = !0), t.identifierPrefix !== void 0 && (n = t.identifierPrefix), t.onRecoverableError !== void 0 && (o = t.onRecoverableError)), d = dd(d, null, e, 1, t != null ? t : null, h, !1, n, o), e[Ue] = d.current, Jn(e), i) for (e = 0; e < i.length; e++)t = i[e], h = t._getVersion, h = h(t._source), d.mutableSourceEagerHydrationData == null ? d.mutableSourceEagerHydrationData = [t, h] : d.mutableSourceEagerHydrationData.push(t, h); return new Ur(d) }; ne.render = function (e, d, t) { if (!Yr(d)) throw Error(k(200)); return Vr(null, e, d, !1, t) }; ne.unmountComponentAtNode = function (e) { if (!Yr(e)) throw Error(k(40)); return e._reactRootContainer ? (Mi(function () { Vr(null, null, e, !1, function () { e._reactRootContainer = null, e[Ue] = null }) }), !0) : !1 }; ne.unstable_batchedUpdates = ol; ne.unstable_renderSubtreeIntoContainer = function (e, d, t, i) { if (!Yr(t)) throw Error(k(200)); if (e == null || e._reactInternals === void 0) throw Error(k(38)); return Vr(e, d, t, !1, i) }; ne.version = '18.1.0-next-22edb9f77-20220426'
  }); const yd = ci((Op, xd) => { 'use strict'; function gd () { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function')) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(gd) } catch (e) { console.error(e) } }gd(), xd.exports = md() }); const vs = Fi(Kr()); const xn = Fi(Kr()); function Nd (e) { if (!!e && typeof window !== 'undefined') { const d = document.createElement('style'); return d.setAttribute('type', 'text/css'), d.innerHTML = e, document.head.appendChild(d), e } } function Di (e, d) { const t = e.__state.conversionName.toString(); const i = Math.round(e.r); const h = Math.round(e.g); const n = Math.round(e.b); const o = e.a; const r = Math.round(e.h); const s = e.s.toFixed(1); const a = e.v.toFixed(1); if (d || t === 'THREE_CHAR_HEX' || t === 'SIX_CHAR_HEX') { for (var f = e.hex.toString(16); f.length < 6;)f = '0' + f; return '#' + f } else { if (t === 'CSS_RGB') return 'rgb(' + i + ',' + h + ',' + n + ')'; if (t === 'CSS_RGBA') return 'rgba(' + i + ',' + h + ',' + n + ',' + o + ')'; if (t === 'HEX') return '0x' + e.hex.toString(16); if (t === 'RGB_ARRAY') return '[' + i + ',' + h + ',' + n + ']'; if (t === 'RGBA_ARRAY') return '[' + i + ',' + h + ',' + n + ',' + o + ']'; if (t === 'RGB_OBJ') return '{r:' + i + ',g:' + h + ',b:' + n + '}'; if (t === 'RGBA_OBJ') return '{r:' + i + ',g:' + h + ',b:' + n + ',a:' + o + '}'; if (t === 'HSV_OBJ') return '{h:' + r + ',s:' + s + ',v:' + a + '}'; if (t === 'HSVA_OBJ') return '{h:' + r + ',s:' + s + ',v:' + a + ',a:' + o + '}' } return 'unknown format' } const gl = Array.prototype.forEach; const dn = Array.prototype.slice; const $ = { BREAK: {}, extend: function (d) { return this.each(dn.call(arguments, 1), function (t) { const i = this.isObject(t) ? Object.keys(t) : []; i.forEach(function (h) { this.isUndefined(t[h]) || (d[h] = t[h]) }.bind(this)) }, this), d }, defaults: function (d) { return this.each(dn.call(arguments, 1), function (t) { const i = this.isObject(t) ? Object.keys(t) : []; i.forEach(function (h) { this.isUndefined(d[h]) && (d[h] = t[h]) }.bind(this)) }, this), d }, compose: function () { const d = dn.call(arguments); return function () { for (var t = dn.call(arguments), i = d.length - 1; i >= 0; i--)t = [d[i].apply(this, t)]; return t[0] } }, each: function (d, t, i) { if (d) { if (gl && d.forEach && d.forEach === gl)d.forEach(t, i); else if (d.length === d.length + 0) { let h = void 0; let n = void 0; for (h = 0, n = d.length; h < n; h++) if (h in d && t.call(i, d[h], h) === this.BREAK) return } else for (const o in d) if (t.call(i, d[o], o) === this.BREAK) return } }, defer: function (d) { setTimeout(d, 0) }, debounce: function (d, t, i) { let h = void 0; return function () { const n = this; const o = arguments; function r () { h = null, i || d.apply(n, o) } const s = i || !h; clearTimeout(h), h = setTimeout(r, t), s && d.apply(n, o) } }, toArray: function (d) { return d.toArray ? d.toArray() : dn.call(d) }, isUndefined: function (d) { return d === void 0 }, isNull: function (d) { return d === null }, isNaN: (function (e) { function d (t) { return e.apply(this, arguments) } return d.toString = function () { return e.toString() }, d }(function (e) { return isNaN(e) })), isArray: Array.isArray || function (e) { return e.constructor === Array }, isObject: function (d) { return d === Object(d) }, isNumber: function (d) { return d === d + 0 }, isString: function (d) { return d === d + '' }, isBoolean: function (d) { return d === !1 || d === !0 }, isFunction: function (d) { return d instanceof Function } }; const Gd = [{ litmus: $.isString, conversions: { THREE_CHAR_HEX: { read: function (d) { const t = d.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i); return t === null ? !1 : { space: 'HEX', hex: parseInt('0x' + t[1].toString() + t[1].toString() + t[2].toString() + t[2].toString() + t[3].toString() + t[3].toString(), 0) } }, write: Di }, SIX_CHAR_HEX: { read: function (d) { const t = d.match(/^#([A-F0-9]{6})$/i); return t === null ? !1 : { space: 'HEX', hex: parseInt('0x' + t[1].toString(), 0) } }, write: Di }, CSS_RGB: { read: function (d) { const t = d.match(/^rgb\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/); return t === null ? !1 : { space: 'RGB', r: parseFloat(t[1]), g: parseFloat(t[2]), b: parseFloat(t[3]) } }, write: Di }, CSS_RGBA: { read: function (d) { const t = d.match(/^rgba\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/); return t === null ? !1 : { space: 'RGB', r: parseFloat(t[1]), g: parseFloat(t[2]), b: parseFloat(t[3]), a: parseFloat(t[4]) } }, write: Di } } }, { litmus: $.isNumber, conversions: { HEX: { read: function (d) { return { space: 'HEX', hex: d, conversionName: 'HEX' } }, write: function (d) { return d.hex } } } }, { litmus: $.isArray, conversions: { RGB_ARRAY: { read: function (d) { return d.length !== 3 ? !1 : { space: 'RGB', r: d[0], g: d[1], b: d[2] } }, write: function (d) { return [d.r, d.g, d.b] } }, RGBA_ARRAY: { read: function (d) { return d.length !== 4 ? !1 : { space: 'RGB', r: d[0], g: d[1], b: d[2], a: d[3] } }, write: function (d) { return [d.r, d.g, d.b, d.a] } } } }, { litmus: $.isObject, conversions: { RGBA_OBJ: { read: function (d) { return $.isNumber(d.r) && $.isNumber(d.g) && $.isNumber(d.b) && $.isNumber(d.a) ? { space: 'RGB', r: d.r, g: d.g, b: d.b, a: d.a } : !1 }, write: function (d) { return { r: d.r, g: d.g, b: d.b, a: d.a } } }, RGB_OBJ: { read: function (d) { return $.isNumber(d.r) && $.isNumber(d.g) && $.isNumber(d.b) ? { space: 'RGB', r: d.r, g: d.g, b: d.b } : !1 }, write: function (d) { return { r: d.r, g: d.g, b: d.b } } }, HSVA_OBJ: { read: function (d) { return $.isNumber(d.h) && $.isNumber(d.s) && $.isNumber(d.v) && $.isNumber(d.a) ? { space: 'HSV', h: d.h, s: d.s, v: d.v, a: d.a } : !1 }, write: function (d) { return { h: d.h, s: d.s, v: d.v, a: d.a } } }, HSV_OBJ: { read: function (d) { return $.isNumber(d.h) && $.isNumber(d.s) && $.isNumber(d.v) ? { space: 'HSV', h: d.h, s: d.s, v: d.v } : !1 }, write: function (d) { return { h: d.h, s: d.s, v: d.v } } } } }]; let vn = void 0; let cs = void 0; const Zr = function () { cs = !1; const d = arguments.length > 1 ? $.toArray(arguments) : arguments[0]; return $.each(Gd, function (t) { if (t.litmus(d)) return $.each(t.conversions, function (i, h) { if (vn = i.read(d), cs === !1 && vn !== !1) return cs = vn, vn.conversionName = h, vn.conversion = i, $.BREAK }), $.BREAK }), cs }; let xl = void 0; const ps = { hsv_to_rgb: function (d, t, i) { const h = Math.floor(d / 60) % 6; const n = d / 60 - Math.floor(d / 60); const o = i * (1 - t); const r = i * (1 - n * t); const s = i * (1 - (1 - n) * t); const a = [[i, s, o], [r, i, o], [o, i, s], [o, r, i], [s, o, i], [i, o, r]][h]; return { r: a[0] * 255, g: a[1] * 255, b: a[2] * 255 } }, rgb_to_hsv: function (d, t, i) { const h = Math.min(d, t, i); const n = Math.max(d, t, i); const o = n - h; let r = void 0; let s = void 0; if (n !== 0)s = o / n; else return { h: NaN, s: 0, v: 0 }; return d === n ? r = (t - i) / o : t === n ? r = 2 + (i - d) / o : r = 4 + (d - t) / o, r /= 6, r < 0 && (r += 1), { h: r * 360, s, v: n / 255 } }, rgb_to_hex: function (d, t, i) { let h = this.hex_with_component(0, 2, d); return h = this.hex_with_component(h, 1, t), h = this.hex_with_component(h, 0, i), h }, component_from_hex: function (d, t) { return d >> t * 8 & 255 }, hex_with_component: function (d, t, i) { return i << (xl = t * 8) | d & ~(255 << xl) } }; const wd = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e }; const de = function (e, d) { if (!(e instanceof d)) throw new TypeError('Cannot call a class as a function') }; const ve = (function () { function e (d, t) { for (let i = 0; i < t.length; i++) { const h = t[i]; h.enumerable = h.enumerable || !1, h.configurable = !0, 'value' in h && (h.writable = !0), Object.defineProperty(d, h.key, h) } } return function (d, t, i) { return t && e(d.prototype, t), i && e(d, i), d } }()); const Ze = function e (d, t, i) { d === null && (d = Function.prototype); const h = Object.getOwnPropertyDescriptor(d, t); if (h === void 0) { const n = Object.getPrototypeOf(d); return n === null ? void 0 : e(n, t, i) } else { if ('value' in h) return h.value; const o = h.get; return o === void 0 ? void 0 : o.call(i) } }; const Qe = function (e, d) { if (typeof d !== 'function' && d !== null) throw new TypeError('Super expression must either be null or a function, not ' + typeof d); e.prototype = Object.create(d && d.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), d && (Object.setPrototypeOf ? Object.setPrototypeOf(e, d) : e.__proto__ = d) }; const Je = function (e, d) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return d && (typeof d === 'object' || typeof d === 'function') ? d : e }; const Ft = (function () { function e () { if (de(this, e), this.__state = Zr.apply(this, arguments), this.__state === !1) throw new Error('Failed to interpret color arguments'); this.__state.a = this.__state.a || 1 } return ve(e, [{ key: 'toString', value: function () { return Di(this) } }, { key: 'toHexString', value: function () { return Di(this, !0) } }, { key: 'toOriginal', value: function () { return this.__state.conversion.write(this) } }]), e }()); function Qr (e, d, t) { Object.defineProperty(e, d, { get: function () { return this.__state.space === 'RGB' ? this.__state[d] : (Ft.recalculateRGB(this, d, t), this.__state[d]) }, set: function (h) { this.__state.space !== 'RGB' && (Ft.recalculateRGB(this, d, t), this.__state.space = 'RGB'), this.__state[d] = h } }) } function Jr (e, d) { Object.defineProperty(e, d, { get: function () { return this.__state.space === 'HSV' ? this.__state[d] : (Ft.recalculateHSV(this), this.__state[d]) }, set: function (i) { this.__state.space !== 'HSV' && (Ft.recalculateHSV(this), this.__state.space = 'HSV'), this.__state[d] = i } }) }Ft.recalculateRGB = function (e, d, t) { if (e.__state.space === 'HEX')e.__state[d] = ps.component_from_hex(e.__state.hex, t); else if (e.__state.space === 'HSV')$.extend(e.__state, ps.hsv_to_rgb(e.__state.h, e.__state.s, e.__state.v)); else throw new Error('Corrupted color state') }; Ft.recalculateHSV = function (e) { const d = ps.rgb_to_hsv(e.r, e.g, e.b); $.extend(e.__state, { s: d.s, v: d.v }), $.isNaN(d.h) ? $.isUndefined(e.__state.h) && (e.__state.h = 0) : e.__state.h = d.h }; Ft.COMPONENTS = ['r', 'g', 'b', 'h', 's', 'v', 'hex', 'a']; Qr(Ft.prototype, 'r', 2); Qr(Ft.prototype, 'g', 1); Qr(Ft.prototype, 'b', 0); Jr(Ft.prototype, 'h'); Jr(Ft.prototype, 's'); Jr(Ft.prototype, 'v'); Object.defineProperty(Ft.prototype, 'a', { get: function () { return this.__state.a }, set: function (d) { this.__state.a = d } }); Object.defineProperty(Ft.prototype, 'hex', { get: function () { return this.__state.space !== 'HEX' && (this.__state.hex = ps.rgb_to_hex(this.r, this.g, this.b), this.__state.space = 'HEX'), this.__state.hex }, set: function (d) { this.__state.space = 'HEX', this.__state.hex = d } }); const pi = (function () { function e (d, t) { de(this, e), this.initialValue = d[t], this.domElement = document.createElement('div'), this.object = d, this.property = t, this.__onChange = void 0, this.__onFinishChange = void 0 } return ve(e, [{ key: 'onChange', value: function (t) { return this.__onChange = t, this } }, { key: 'onFinishChange', value: function (t) { return this.__onFinishChange = t, this } }, { key: 'setValue', value: function (t) { return this.object[this.property] = t, this.__onChange && this.__onChange.call(this, t), this.updateDisplay(), this } }, { key: 'getValue', value: function () { return this.object[this.property] } }, { key: 'updateDisplay', value: function () { return this } }, { key: 'isModified', value: function () { return this.initialValue !== this.getValue() } }]), e }()); const zd = { HTMLEvents: ['change'], MouseEvents: ['click', 'mousemove', 'mousedown', 'mouseup', 'mouseover'], KeyboardEvents: ['keydown'] }; const yl = {}; $.each(zd, function (e, d) { $.each(e, function (t) { yl[t] = d }) }); const Ud = /(\d+(\.\d+)?)px/; function Ee (e) { if (e === '0' || $.isUndefined(e)) return 0; const d = e.match(Ud); return $.isNull(d) ? 0 : parseFloat(d[1]) } var Z = { makeSelectable: function (d, t) { d === void 0 || d.style === void 0 || (d.onselectstart = t ? function () { return !1 } : function () {}, d.style.MozUserSelect = t ? 'auto' : 'none', d.style.KhtmlUserSelect = t ? 'auto' : 'none', d.unselectable = t ? 'on' : 'off') }, makeFullscreen: function (d, t, i) { let h = i; let n = t; $.isUndefined(n) && (n = !0), $.isUndefined(h) && (h = !0), d.style.position = 'absolute', n && (d.style.left = 0, d.style.right = 0), h && (d.style.top = 0, d.style.bottom = 0) }, fakeEvent: function (d, t, i, h) { const n = i || {}; const o = yl[t]; if (!o) throw new Error('Event type ' + t + ' not supported.'); const r = document.createEvent(o); switch (o) { case 'MouseEvents': { const s = n.x || n.clientX || 0; const a = n.y || n.clientY || 0; r.initMouseEvent(t, n.bubbles || !1, n.cancelable || !0, window, n.clickCount || 1, 0, 0, s, a, !1, !1, !1, !1, 0, null); break } case 'KeyboardEvents': { const f = r.initKeyboardEvent || r.initKeyEvent; $.defaults(n, { cancelable: !0, ctrlKey: !1, altKey: !1, shiftKey: !1, metaKey: !1, keyCode: void 0, charCode: void 0 }), f(t, n.bubbles || !1, n.cancelable, window, n.ctrlKey, n.altKey, n.shiftKey, n.metaKey, n.keyCode, n.charCode); break } default: { r.initEvent(t, n.bubbles || !1, n.cancelable || !0); break } }$.defaults(r, h), d.dispatchEvent(r) }, bind: function (d, t, i, h) { const n = h || !1; return d.addEventListener ? d.addEventListener(t, i, n) : d.attachEvent && d.attachEvent('on' + t, i), Z }, unbind: function (d, t, i, h) { const n = h || !1; return d.removeEventListener ? d.removeEventListener(t, i, n) : d.detachEvent && d.detachEvent('on' + t, i), Z }, addClass: function (d, t) { if (d.className === void 0)d.className = t; else if (d.className !== t) { const i = d.className.split(/ +/); i.indexOf(t) === -1 && (i.push(t), d.className = i.join(' ').replace(/^\s+/, '').replace(/\s+$/, '')) } return Z }, removeClass: function (d, t) { if (t) if (d.className === t)d.removeAttribute('class'); else { const i = d.className.split(/ +/); const h = i.indexOf(t); h !== -1 && (i.splice(h, 1), d.className = i.join(' ')) } else d.className = void 0; return Z }, hasClass: function (d, t) { return new RegExp('(?:^|\\s+)' + t + '(?:\\s+|$)').test(d.className) || !1 }, getWidth: function (d) { const t = getComputedStyle(d); return Ee(t['border-left-width']) + Ee(t['border-right-width']) + Ee(t['padding-left']) + Ee(t['padding-right']) + Ee(t.width) }, getHeight: function (d) { const t = getComputedStyle(d); return Ee(t['border-top-width']) + Ee(t['border-bottom-width']) + Ee(t['padding-top']) + Ee(t['padding-bottom']) + Ee(t.height) }, getOffset: function (d) { let t = d; const i = { left: 0, top: 0 }; if (t.offsetParent) do i.left += t.offsetLeft, i.top += t.offsetTop, t = t.offsetParent; while (t); return i }, isActive: function (d) { return d === document.activeElement && (d.type || d.href) } }; const Tl = (function (e) { Qe(d, e); function d (t, i) { de(this, d); const h = Je(this, (d.__proto__ || Object.getPrototypeOf(d)).call(this, t, i)); const n = h; h.__prev = h.getValue(), h.__checkbox = document.createElement('input'), h.__checkbox.setAttribute('type', 'checkbox'); function o () { n.setValue(!n.__prev) } return Z.bind(h.__checkbox, 'change', o, !1), h.domElement.appendChild(h.__checkbox), h.updateDisplay(), h } return ve(d, [{ key: 'setValue', value: function (i) { const h = Ze(d.prototype.__proto__ || Object.getPrototypeOf(d.prototype), 'setValue', this).call(this, i); return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), this.__prev = this.getValue(), h } }, { key: 'updateDisplay', value: function () { return this.getValue() === !0 ? (this.__checkbox.setAttribute('checked', 'checked'), this.__checkbox.checked = !0, this.__prev = !0) : (this.__checkbox.checked = !1, this.__prev = !1), Ze(d.prototype.__proto__ || Object.getPrototypeOf(d.prototype), 'updateDisplay', this).call(this) } }]), d }(pi)); const Yd = (function (e) { Qe(d, e); function d (t, i, h) { de(this, d); const n = Je(this, (d.__proto__ || Object.getPrototypeOf(d)).call(this, t, i)); let o = h; const r = n; if (n.__select = document.createElement('select'), $.isArray(o)) { const s = {}; $.each(o, function (a) { s[a] = a }), o = s } return $.each(o, function (a, f) { const l = document.createElement('option'); l.innerHTML = f, l.setAttribute('value', a), r.__select.appendChild(l) }), n.updateDisplay(), Z.bind(n.__select, 'change', function () { const a = this.options[this.selectedIndex].value; r.setValue(a) }), n.domElement.appendChild(n.__select), n } return ve(d, [{ key: 'setValue', value: function (i) { const h = Ze(d.prototype.__proto__ || Object.getPrototypeOf(d.prototype), 'setValue', this).call(this, i); return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), h } }, { key: 'updateDisplay', value: function () { return Z.isActive(this.__select) ? this : (this.__select.value = this.getValue(), Ze(d.prototype.__proto__ || Object.getPrototypeOf(d.prototype), 'updateDisplay', this).call(this)) } }]), d }(pi)); const Vd = (function (e) { Qe(d, e); function d (t, i) { de(this, d); const h = Je(this, (d.__proto__ || Object.getPrototypeOf(d)).call(this, t, i)); const n = h; function o () { n.setValue(n.__input.value) } function r () { n.__onFinishChange && n.__onFinishChange.call(n, n.getValue()) } return h.__input = document.createElement('input'), h.__input.setAttribute('type', 'text'), Z.bind(h.__input, 'keyup', o), Z.bind(h.__input, 'change', o), Z.bind(h.__input, 'blur', r), Z.bind(h.__input, 'keydown', function (s) { s.keyCode === 13 && this.blur() }), h.updateDisplay(), h.domElement.appendChild(h.__input), h } return ve(d, [{ key: 'updateDisplay', value: function () { return Z.isActive(this.__input) || (this.__input.value = this.getValue()), Ze(d.prototype.__proto__ || Object.getPrototypeOf(d.prototype), 'updateDisplay', this).call(this) } }]), d }(pi)); function Sl (e) { const d = e.toString(); return d.indexOf('.') > -1 ? d.length - d.indexOf('.') - 1 : 0 } const El = (function (e) { Qe(d, e); function d (t, i, h) { de(this, d); const n = Je(this, (d.__proto__ || Object.getPrototypeOf(d)).call(this, t, i)); const o = h || {}; return n.__min = o.min, n.__max = o.max, n.__step = o.step, $.isUndefined(n.__step) ? n.initialValue === 0 ? n.__impliedStep = 1 : n.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(n.initialValue)) / Math.LN10)) / 10 : n.__impliedStep = n.__step, n.__precision = Sl(n.__impliedStep), n } return ve(d, [{ key: 'setValue', value: function (i) { let h = i; return this.__min !== void 0 && h < this.__min ? h = this.__min : this.__max !== void 0 && h > this.__max && (h = this.__max), this.__step !== void 0 && h % this.__step != 0 && (h = Math.round(h / this.__step) * this.__step), Ze(d.prototype.__proto__ || Object.getPrototypeOf(d.prototype), 'setValue', this).call(this, h) } }, { key: 'min', value: function (i) { return this.__min = i, this } }, { key: 'max', value: function (i) { return this.__max = i, this } }, { key: 'step', value: function (i) { return this.__step = i, this.__impliedStep = i, this.__precision = Sl(i), this } }]), d }(pi)); function Xd (e, d) { const t = Math.pow(10, d); return Math.round(e * t) / t } const ms = (function (e) { Qe(d, e); function d (t, i, h) { de(this, d); const n = Je(this, (d.__proto__ || Object.getPrototypeOf(d)).call(this, t, i, h)); n.__truncationSuspended = !1; const o = n; let r = void 0; function s () { const p = parseFloat(o.__input.value); $.isNaN(p) || o.setValue(p) } function a () { o.__onFinishChange && o.__onFinishChange.call(o, o.getValue()) } function f () { a() } function l (p) { const c = r - p.clientY; o.setValue(o.getValue() + c * o.__impliedStep), r = p.clientY } function u () { Z.unbind(window, 'mousemove', l), Z.unbind(window, 'mouseup', u), a() } function v (p) { Z.bind(window, 'mousemove', l), Z.bind(window, 'mouseup', u), r = p.clientY } return n.__input = document.createElement('input'), n.__input.setAttribute('type', 'text'), Z.bind(n.__input, 'change', s), Z.bind(n.__input, 'blur', f), Z.bind(n.__input, 'mousedown', v), Z.bind(n.__input, 'keydown', function (p) { p.keyCode === 13 && (o.__truncationSuspended = !0, this.blur(), o.__truncationSuspended = !1, a()) }), n.updateDisplay(), n.domElement.appendChild(n.__input), n } return ve(d, [{ key: 'updateDisplay', value: function () { return this.__input.value = this.__truncationSuspended ? this.getValue() : Xd(this.getValue(), this.__precision), Ze(d.prototype.__proto__ || Object.getPrototypeOf(d.prototype), 'updateDisplay', this).call(this) } }]), d }(El)); function Cl (e, d, t, i, h) { return i + (h - i) * ((e - d) / (t - d)) } const $r = (function (e) { Qe(d, e); function d (t, i, h, n, o) { de(this, d); const r = Je(this, (d.__proto__ || Object.getPrototypeOf(d)).call(this, t, i, { min: h, max: n, step: o })); const s = r; r.__background = document.createElement('div'), r.__foreground = document.createElement('div'), Z.bind(r.__background, 'mousedown', a), Z.bind(r.__background, 'touchstart', u), Z.addClass(r.__background, 'slider'), Z.addClass(r.__foreground, 'slider-fg'); function a (c) { document.activeElement.blur(), Z.bind(window, 'mousemove', f), Z.bind(window, 'mouseup', l), f(c) } function f (c) { c.preventDefault(); const m = s.__background.getBoundingClientRect(); return s.setValue(Cl(c.clientX, m.left, m.right, s.__min, s.__max)), !1 } function l () { Z.unbind(window, 'mousemove', f), Z.unbind(window, 'mouseup', l), s.__onFinishChange && s.__onFinishChange.call(s, s.getValue()) } function u (c) { c.touches.length === 1 && (Z.bind(window, 'touchmove', v), Z.bind(window, 'touchend', p), v(c)) } function v (c) { const m = c.touches[0].clientX; const g = s.__background.getBoundingClientRect(); s.setValue(Cl(m, g.left, g.right, s.__min, s.__max)) } function p () { Z.unbind(window, 'touchmove', v), Z.unbind(window, 'touchend', p), s.__onFinishChange && s.__onFinishChange.call(s, s.getValue()) } return r.updateDisplay(), r.__background.appendChild(r.__foreground), r.domElement.appendChild(r.__background), r } return ve(d, [{ key: 'updateDisplay', value: function () { const i = (this.getValue() - this.__min) / (this.__max - this.__min); return this.__foreground.style.width = i * 100 + '%', Ze(d.prototype.__proto__ || Object.getPrototypeOf(d.prototype), 'updateDisplay', this).call(this) } }]), d }(El)); const Al = (function (e) { Qe(d, e); function d (t, i, h) { de(this, d); const n = Je(this, (d.__proto__ || Object.getPrototypeOf(d)).call(this, t, i)); const o = n; return n.__button = document.createElement('div'), n.__button.innerHTML = h === void 0 ? 'Fire' : h, Z.bind(n.__button, 'click', function (r) { return r.preventDefault(), o.fire(), !1 }), Z.addClass(n.__button, 'button'), n.domElement.appendChild(n.__button), n } return ve(d, [{ key: 'fire', value: function () { this.__onChange && this.__onChange.call(this), this.getValue().call(this.object), this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()) } }]), d }(pi)); const jr = (function (e) { Qe(d, e); function d (t, i) { de(this, d); const h = Je(this, (d.__proto__ || Object.getPrototypeOf(d)).call(this, t, i)); h.__color = new Ft(h.getValue()), h.__temp = new Ft(0); const n = h; h.domElement = document.createElement('div'), Z.makeSelectable(h.domElement, !1), h.__selector = document.createElement('div'), h.__selector.className = 'selector', h.__saturation_field = document.createElement('div'), h.__saturation_field.className = 'saturation-field', h.__field_knob = document.createElement('div'), h.__field_knob.className = 'field-knob', h.__field_knob_border = '2px solid ', h.__hue_knob = document.createElement('div'), h.__hue_knob.className = 'hue-knob', h.__hue_field = document.createElement('div'), h.__hue_field.className = 'hue-field', h.__input = document.createElement('input'), h.__input.type = 'text', h.__input_textShadow = '0 1px 1px ', Z.bind(h.__input, 'keydown', function (c) { c.keyCode === 13 && l.call(this) }), Z.bind(h.__input, 'blur', l), Z.bind(h.__selector, 'mousedown', function () { Z.addClass(this, 'drag').bind(window, 'mouseup', function () { Z.removeClass(n.__selector, 'drag') }) }), Z.bind(h.__selector, 'touchstart', function () { Z.addClass(this, 'drag').bind(window, 'touchend', function () { Z.removeClass(n.__selector, 'drag') }) }); const o = document.createElement('div'); $.extend(h.__selector.style, { width: '122px', height: '102px', padding: '3px', backgroundColor: '#222', boxShadow: '0px 1px 3px rgba(0,0,0,0.3)' }), $.extend(h.__field_knob.style, { position: 'absolute', width: '12px', height: '12px', border: h.__field_knob_border + (h.__color.v < 0.5 ? '#fff' : '#000'), boxShadow: '0px 1px 3px rgba(0,0,0,0.5)', borderRadius: '12px', zIndex: 1 }), $.extend(h.__hue_knob.style, { position: 'absolute', width: '15px', height: '2px', borderRight: '4px solid #fff', zIndex: 1 }), $.extend(h.__saturation_field.style, { width: '100px', height: '100px', border: '1px solid #555', marginRight: '3px', display: 'inline-block', cursor: 'pointer' }), $.extend(o.style, { width: '100%', height: '100%', background: 'none' }), Pl(o, 'top', 'rgba(0,0,0,0)', '#000'), $.extend(h.__hue_field.style, { width: '15px', height: '100px', border: '1px solid #555', cursor: 'ns-resize', position: 'absolute', top: '3px', right: '3px' }), Hd(h.__hue_field), $.extend(h.__input.style, { outline: 'none', textAlign: 'center', color: '#fff', border: 0, fontWeight: 'bold', textShadow: h.__input_textShadow + 'rgba(0,0,0,0.7)' }), Z.bind(h.__saturation_field, 'mousedown', r), Z.bind(h.__saturation_field, 'touchstart', r), Z.bind(h.__field_knob, 'mousedown', r), Z.bind(h.__field_knob, 'touchstart', r), Z.bind(h.__hue_field, 'mousedown', s), Z.bind(h.__hue_field, 'touchstart', s); function r (c) { v(c), Z.bind(window, 'mousemove', v), Z.bind(window, 'touchmove', v), Z.bind(window, 'mouseup', a), Z.bind(window, 'touchend', a) } function s (c) { p(c), Z.bind(window, 'mousemove', p), Z.bind(window, 'touchmove', p), Z.bind(window, 'mouseup', f), Z.bind(window, 'touchend', f) } function a () { Z.unbind(window, 'mousemove', v), Z.unbind(window, 'touchmove', v), Z.unbind(window, 'mouseup', a), Z.unbind(window, 'touchend', a), u() } function f () { Z.unbind(window, 'mousemove', p), Z.unbind(window, 'touchmove', p), Z.unbind(window, 'mouseup', f), Z.unbind(window, 'touchend', f), u() } function l () { const c = Zr(this.value); c !== !1 ? (n.__color.__state = c, n.setValue(n.__color.toOriginal())) : this.value = n.__color.toString() } function u () { n.__onFinishChange && n.__onFinishChange.call(n, n.__color.toOriginal()) }h.__saturation_field.appendChild(o), h.__selector.appendChild(h.__field_knob), h.__selector.appendChild(h.__saturation_field), h.__selector.appendChild(h.__hue_field), h.__hue_field.appendChild(h.__hue_knob), h.domElement.appendChild(h.__input), h.domElement.appendChild(h.__selector), h.updateDisplay(); function v (c) { c.type.indexOf('touch') === -1 && c.preventDefault(); const m = n.__saturation_field.getBoundingClientRect(); const g = c.touches && c.touches[0] || c; const x = g.clientX; const y = g.clientY; let T = (x - m.left) / (m.right - m.left); let S = 1 - (y - m.top) / (m.bottom - m.top); return S > 1 ? S = 1 : S < 0 && (S = 0), T > 1 ? T = 1 : T < 0 && (T = 0), n.__color.v = S, n.__color.s = T, n.setValue(n.__color.toOriginal()), !1 } function p (c) { c.type.indexOf('touch') === -1 && c.preventDefault(); const m = n.__hue_field.getBoundingClientRect(); const g = c.touches && c.touches[0] || c; const x = g.clientY; let y = 1 - (x - m.top) / (m.bottom - m.top); return y > 1 ? y = 1 : y < 0 && (y = 0), n.__color.h = y * 360, n.setValue(n.__color.toOriginal()), !1 } return h } return ve(d, [{ key: 'updateDisplay', value: function () { const i = Zr(this.getValue()); if (i !== !1) { let h = !1; $.each(Ft.COMPONENTS, function (r) { if (!$.isUndefined(i[r]) && !$.isUndefined(this.__color.__state[r]) && i[r] !== this.__color.__state[r]) return h = !0, {} }, this), h && $.extend(this.__color.__state, i) }$.extend(this.__temp.__state, this.__color.__state), this.__temp.a = 1; const n = this.__color.v < 0.5 || this.__color.s > 0.5 ? 255 : 0; const o = 255 - n; $.extend(this.__field_knob.style, { marginLeft: 100 * this.__color.s - 7 + 'px', marginTop: 100 * (1 - this.__color.v) - 7 + 'px', backgroundColor: this.__temp.toHexString(), border: this.__field_knob_border + 'rgb(' + n + ',' + n + ',' + n + ')' }), this.__hue_knob.style.marginTop = (1 - this.__color.h / 360) * 100 + 'px', this.__temp.s = 1, this.__temp.v = 1, Pl(this.__saturation_field, 'left', '#fff', this.__temp.toHexString()), this.__input.value = this.__color.toString(), $.extend(this.__input.style, { backgroundColor: this.__color.toHexString(), color: 'rgb(' + n + ',' + n + ',' + n + ')', textShadow: this.__input_textShadow + 'rgba(' + o + ',' + o + ',' + o + ',.7)' }) } }]), d }(pi)); const Wd = ['-moz-', '-o-', '-webkit-', '-ms-', '']; function Pl (e, d, t, i) { e.style.background = '', $.each(Wd, function (h) { e.style.cssText += 'background: ' + h + 'linear-gradient(' + d + ', ' + t + ' 0%, ' + i + ' 100%); ' }) } function Hd (e) { e.style.background = '', e.style.cssText += 'background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);', e.style.cssText += 'background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);', e.style.cssText += 'background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);', e.style.cssText += 'background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);', e.style.cssText += 'background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);' } const Kd = { load: function (d, t) { const i = t || document; const h = i.createElement('link'); h.type = 'text/css', h.rel = 'stylesheet', h.href = d, i.getElementsByTagName('head')[0].appendChild(h) }, inject: function (d, t) { const i = t || document; const h = document.createElement('style'); h.type = 'text/css', h.innerHTML = d; const n = i.getElementsByTagName('head')[0]; try { n.appendChild(h) } catch (o) {} } }; const Zd = `<div id="dg-save" class="dg dialogue">

  Here's the new load parameter for your <code>GUI</code>'s constructor:

  <textarea id="dg-new-constructor"></textarea>

  <div id="dg-save-locally">

    <input id="dg-local-storage" type="checkbox"/> Automatically save
    values to <code>localStorage</code> on exit.

    <div id="dg-local-explain">The values saved to <code>localStorage</code> will
      override those passed to <code>dat.GUI</code>'s constructor. This makes it
      easier to work incrementally, but <code>localStorage</code> is fragile,
      and your friends may not see the same values you do.

    </div>

  </div>

</div>`; const Qd = function (d, t) { const i = d[t]; return $.isArray(arguments[2]) || $.isObject(arguments[2]) ? new Yd(d, t, arguments[2]) : $.isNumber(i) ? $.isNumber(arguments[2]) && $.isNumber(arguments[3]) ? $.isNumber(arguments[4]) ? new $r(d, t, arguments[2], arguments[3], arguments[4]) : new $r(d, t, arguments[2], arguments[3]) : $.isNumber(arguments[4]) ? new ms(d, t, { min: arguments[2], max: arguments[3], step: arguments[4] }) : new ms(d, t, { min: arguments[2], max: arguments[3] }) : $.isString(i) ? new Vd(d, t) : $.isFunction(i) ? new Al(d, t, '') : $.isBoolean(i) ? new Tl(d, t) : null }; function Jd (e) { setTimeout(e, 1e3 / 60) } const $d = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || Jd; const jd = (function () { function e () { de(this, e), this.backgroundElement = document.createElement('div'), $.extend(this.backgroundElement.style, { backgroundColor: 'rgba(0,0,0,0.8)', top: 0, left: 0, display: 'none', zIndex: '1000', opacity: 0, WebkitTransition: 'opacity 0.2s linear', transition: 'opacity 0.2s linear' }), Z.makeFullscreen(this.backgroundElement), this.backgroundElement.style.position = 'fixed', this.domElement = document.createElement('div'), $.extend(this.domElement.style, { position: 'fixed', display: 'none', zIndex: '1001', opacity: 0, WebkitTransition: '-webkit-transform 0.2s ease-out, opacity 0.2s linear', transition: 'transform 0.2s ease-out, opacity 0.2s linear' }), document.body.appendChild(this.backgroundElement), document.body.appendChild(this.domElement); const d = this; Z.bind(this.backgroundElement, 'click', function () { d.hide() }) } return ve(e, [{ key: 'show', value: function () { const t = this; this.backgroundElement.style.display = 'block', this.domElement.style.display = 'block', this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = 'scale(1.1)', this.layout(), $.defer(function () { t.backgroundElement.style.opacity = 1, t.domElement.style.opacity = 1, t.domElement.style.webkitTransform = 'scale(1)' }) } }, { key: 'hide', value: function () { const t = this; const i = function h () { t.domElement.style.display = 'none', t.backgroundElement.style.display = 'none', Z.unbind(t.domElement, 'webkitTransitionEnd', h), Z.unbind(t.domElement, 'transitionend', h), Z.unbind(t.domElement, 'oTransitionEnd', h) }; Z.bind(this.domElement, 'webkitTransitionEnd', i), Z.bind(this.domElement, 'transitionend', i), Z.bind(this.domElement, 'oTransitionEnd', i), this.backgroundElement.style.opacity = 0, this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = 'scale(1.1)' } }, { key: 'layout', value: function () { this.domElement.style.left = window.innerWidth / 2 - Z.getWidth(this.domElement) / 2 + 'px', this.domElement.style.top = window.innerHeight / 2 - Z.getHeight(this.domElement) / 2 + 'px' } }]), e }()); const bd = Nd(`.dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .cr.function .property-name{width:100%}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}
`); Kd.inject(bd); const Ml = 'dg'; const Rl = 72; const Ll = 20; const cn = 'Default'; const pn = (function () { try { return !!window.localStorage } catch (e) { return !1 } }()); let mn = void 0; let Ol = !0; let Ii = void 0; let br = !1; const Fl = []; const ft = function e (d) { const t = this; let i = d || {}; this.domElement = document.createElement('div'), this.__ul = document.createElement('ul'), this.domElement.appendChild(this.__ul), Z.addClass(this.domElement, Ml), this.__folders = {}, this.__controllers = [], this.__rememberedObjects = [], this.__rememberedObjectIndecesToControllers = [], this.__listening = [], i = $.defaults(i, { closeOnTop: !1, autoPlace: !0, width: e.DEFAULT_WIDTH }), i = $.defaults(i, { resizable: i.autoPlace, hideable: i.autoPlace }), $.isUndefined(i.load) ? i.load = { preset: cn } : i.preset && (i.load.preset = i.preset), $.isUndefined(i.parent) && i.hideable && Fl.push(this), i.resizable = $.isUndefined(i.parent) && i.resizable, i.autoPlace && $.isUndefined(i.scrollable) && (i.scrollable = !0); let h = pn && localStorage.getItem(Bi(this, 'isLocal')) === 'true'; let n = void 0; let o = void 0; if (Object.defineProperties(this, { parent: { get: function () { return i.parent } }, scrollable: { get: function () { return i.scrollable } }, autoPlace: { get: function () { return i.autoPlace } }, closeOnTop: { get: function () { return i.closeOnTop } }, preset: { get: function () { return t.parent ? t.getRoot().preset : i.load.preset }, set: function (u) { t.parent ? t.getRoot().preset = u : i.load.preset = u, tv(this), t.revert() } }, width: { get: function () { return i.width }, set: function (u) { i.width = u, ta(t, u) } }, name: { get: function () { return i.name }, set: function (u) { i.name = u, o && (o.innerHTML = i.name) } }, closed: { get: function () { return i.closed }, set: function (u) { i.closed = u, i.closed ? Z.addClass(t.__ul, e.CLASS_CLOSED) : Z.removeClass(t.__ul, e.CLASS_CLOSED), this.onResize(), t.__closeButton && (t.__closeButton.innerHTML = u ? e.TEXT_OPEN : e.TEXT_CLOSED) } }, load: { get: function () { return i.load } }, useLocalStorage: { get: function () { return h }, set: function (u) { pn && (h = u, u ? Z.bind(window, 'unload', n) : Z.unbind(window, 'unload', n), localStorage.setItem(Bi(t, 'isLocal'), u)) } } }), $.isUndefined(i.parent)) { if (this.closed = i.closed || !1, Z.addClass(this.domElement, e.CLASS_MAIN), Z.makeSelectable(this.domElement, !1), pn && h) { t.useLocalStorage = !0; const r = localStorage.getItem(Bi(this, 'gui')); r && (i.load = JSON.parse(r)) } this.__closeButton = document.createElement('div'), this.__closeButton.innerHTML = e.TEXT_CLOSED, Z.addClass(this.__closeButton, e.CLASS_CLOSE_BUTTON), i.closeOnTop ? (Z.addClass(this.__closeButton, e.CLASS_CLOSE_TOP), this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0])) : (Z.addClass(this.__closeButton, e.CLASS_CLOSE_BOTTOM), this.domElement.appendChild(this.__closeButton)), Z.bind(this.__closeButton, 'click', function () { t.closed = !t.closed }) } else { i.closed === void 0 && (i.closed = !0); const s = document.createTextNode(i.name); Z.addClass(s, 'controller-name'), o = kr(t, s); const a = function (u) { return u.preventDefault(), t.closed = !t.closed, !1 }; Z.addClass(this.__ul, e.CLASS_CLOSED), Z.addClass(o, 'title'), Z.bind(o, 'click', a), i.closed || (this.closed = !1) }i.autoPlace && ($.isUndefined(i.parent) && (Ol && (Ii = document.createElement('div'), Z.addClass(Ii, Ml), Z.addClass(Ii, e.CLASS_AUTO_PLACE_CONTAINER), document.body.appendChild(Ii), Ol = !1), Ii.appendChild(this.domElement), Z.addClass(this.domElement, e.CLASS_AUTO_PLACE)), this.parent || ta(t, i.width)), this.__resizeHandler = function () { t.onResizeDebounced() }, Z.bind(window, 'resize', this.__resizeHandler), Z.bind(this.__ul, 'webkitTransitionEnd', this.__resizeHandler), Z.bind(this.__ul, 'transitionend', this.__resizeHandler), Z.bind(this.__ul, 'oTransitionEnd', this.__resizeHandler), this.onResize(), i.resizable && _d(this), n = function () { pn && localStorage.getItem(Bi(t, 'isLocal')) === 'true' && localStorage.setItem(Bi(t, 'gui'), JSON.stringify(t.getSaveObject())) }, this.saveToLocalStorageIfPossible = n; function f () { const l = t.getRoot(); l.width += 1, $.defer(function () { l.width -= 1 }) }i.parent || f() }; ft.toggleHide = function () { br = !br, $.each(Fl, function (e) { e.domElement.style.display = br ? 'none' : '' }) }; ft.CLASS_AUTO_PLACE = 'a'; ft.CLASS_AUTO_PLACE_CONTAINER = 'ac'; ft.CLASS_MAIN = 'main'; ft.CLASS_CONTROLLER_ROW = 'cr'; ft.CLASS_TOO_TALL = 'taller-than-window'; ft.CLASS_CLOSED = 'closed'; ft.CLASS_CLOSE_BUTTON = 'close-button'; ft.CLASS_CLOSE_TOP = 'close-top'; ft.CLASS_CLOSE_BOTTOM = 'close-bottom'; ft.CLASS_DRAG = 'drag'; ft.DEFAULT_WIDTH = 245; ft.TEXT_CLOSED = 'Close Controls'; ft.TEXT_OPEN = 'Open Controls'; ft._keydownHandler = function (e) { document.activeElement.type !== 'text' && (e.which === Rl || e.keyCode === Rl) && ft.toggleHide() }; Z.bind(window, 'keydown', ft._keydownHandler, !1); $.extend(ft.prototype, { add: function (d, t) { return gn(this, d, t, { factoryArgs: Array.prototype.slice.call(arguments, 2) }) }, addColor: function (d, t) { return gn(this, d, t, { color: !0 }) }, remove: function (d) { this.__ul.removeChild(d.__li), this.__controllers.splice(this.__controllers.indexOf(d), 1); const t = this; $.defer(function () { t.onResize() }) }, destroy: function () { if (this.parent) throw new Error('Only the root GUI should be removed with .destroy(). For subfolders, use gui.removeFolder(folder) instead.'); this.autoPlace && Ii.removeChild(this.domElement); const d = this; $.each(this.__folders, function (t) { d.removeFolder(t) }), Z.unbind(window, 'keydown', ft._keydownHandler, !1), Dl(this) }, addFolder: function (d) { if (this.__folders[d] !== void 0) throw new Error('You already have a folder in this GUI by the name "' + d + '"'); const t = { name: d, parent: this }; t.autoPlace = this.autoPlace, this.load && this.load.folders && this.load.folders[d] && (t.closed = this.load.folders[d].closed, t.load = this.load.folders[d]); const i = new ft(t); this.__folders[d] = i; const h = kr(this, i.domElement); return Z.addClass(h, 'folder'), i }, removeFolder: function (d) { this.__ul.removeChild(d.domElement.parentElement), delete this.__folders[d.name], this.load && this.load.folders && this.load.folders[d.name] && delete this.load.folders[d.name], Dl(d); const t = this; $.each(d.__folders, function (i) { d.removeFolder(i) }), $.defer(function () { t.onResize() }) }, open: function () { this.closed = !1 }, close: function () { this.closed = !0 }, hide: function () { this.domElement.style.display = 'none' }, show: function () { this.domElement.style.display = '' }, onResize: function () { const d = this.getRoot(); if (d.scrollable) { const t = Z.getOffset(d.__ul).top; let i = 0; $.each(d.__ul.childNodes, function (h) { d.autoPlace && h === d.__save_row || (i += Z.getHeight(h)) }), window.innerHeight - t - Ll < i ? (Z.addClass(d.domElement, ft.CLASS_TOO_TALL), d.__ul.style.height = window.innerHeight - t - Ll + 'px') : (Z.removeClass(d.domElement, ft.CLASS_TOO_TALL), d.__ul.style.height = 'auto') }d.__resize_handle && $.defer(function () { d.__resize_handle.style.height = d.__ul.offsetHeight + 'px' }), d.__closeButton && (d.__closeButton.style.width = d.width + 'px') }, onResizeDebounced: $.debounce(function () { this.onResize() }, 50), remember: function () { if ($.isUndefined(mn) && (mn = new jd(), mn.domElement.innerHTML = Zd), this.parent) throw new Error('You can only call remember on a top level GUI.'); const d = this; $.each(Array.prototype.slice.call(arguments), function (t) { d.__rememberedObjects.length === 0 && qd(d), d.__rememberedObjects.indexOf(t) === -1 && d.__rememberedObjects.push(t) }), this.autoPlace && ta(this, this.width) }, getRoot: function () { for (var d = this; d.parent;)d = d.parent; return d }, getSaveObject: function () { const d = this.load; return d.closed = this.closed, this.__rememberedObjects.length > 0 && (d.preset = this.preset, d.remembered || (d.remembered = {}), d.remembered[this.preset] = gs(this)), d.folders = {}, $.each(this.__folders, function (t, i) { d.folders[i] = t.getSaveObject() }), d }, save: function () { this.load.remembered || (this.load.remembered = {}), this.load.remembered[this.preset] = gs(this), qr(this, !1), this.saveToLocalStorageIfPossible() }, saveAs: function (d) { this.load.remembered || (this.load.remembered = {}, this.load.remembered[cn] = gs(this, !0)), this.load.remembered[d] = gs(this), this.preset = d, _r(this, d, !0), this.saveToLocalStorageIfPossible() }, revert: function (d) { $.each(this.__controllers, function (t) { this.getRoot().load.remembered ? Il(d || this.getRoot(), t) : t.setValue(t.initialValue), t.__onFinishChange && t.__onFinishChange.call(t, t.getValue()) }, this), $.each(this.__folders, function (t) { t.revert(t) }), d || qr(this.getRoot(), !1) }, listen: function (d) { const t = this.__listening.length === 0; this.__listening.push(d), t && Nl(this.__listening) }, updateDisplay: function () { $.each(this.__controllers, function (d) { d.updateDisplay() }), $.each(this.__folders, function (d) { d.updateDisplay() }) } }); function kr (e, d, t) { const i = document.createElement('li'); return d && i.appendChild(d), t ? e.__ul.insertBefore(i, t) : e.__ul.appendChild(i), e.onResize(), i } function Dl (e) { Z.unbind(window, 'resize', e.__resizeHandler), e.saveToLocalStorageIfPossible && Z.unbind(window, 'unload', e.saveToLocalStorageIfPossible) } function qr (e, d) { const t = e.__preset_select[e.__preset_select.selectedIndex]; d ? t.innerHTML = t.value + '*' : t.innerHTML = t.value } function kd (e, d, t) { if (t.__li = d, t.__gui = e, $.extend(t, { options: function (o) { if (arguments.length > 1) { const r = t.__li.nextElementSibling; return t.remove(), gn(e, t.object, t.property, { before: r, factoryArgs: [$.toArray(arguments)] }) } if ($.isArray(o) || $.isObject(o)) { const s = t.__li.nextElementSibling; return t.remove(), gn(e, t.object, t.property, { before: s, factoryArgs: [o] }) } }, name: function (o) { return t.__li.firstElementChild.firstElementChild.innerHTML = o, t }, listen: function () { return t.__gui.listen(t), t }, remove: function () { return t.__gui.remove(t), t } }), t instanceof $r) { const i = new ms(t.object, t.property, { min: t.__min, max: t.__max, step: t.__step }); $.each(['updateDisplay', 'onChange', 'onFinishChange', 'step', 'min', 'max'], function (n) { const o = t[n]; const r = i[n]; t[n] = i[n] = function () { const s = Array.prototype.slice.call(arguments); return r.apply(i, s), o.apply(t, s) } }), Z.addClass(d, 'has-slider'), t.domElement.insertBefore(i.domElement, t.domElement.firstElementChild) } else if (t instanceof ms) { const h = function (o) { if ($.isNumber(t.__min) && $.isNumber(t.__max)) { const r = t.__li.firstElementChild.firstElementChild.innerHTML; const s = t.__gui.__listening.indexOf(t) > -1; t.remove(); const a = gn(e, t.object, t.property, { before: t.__li.nextElementSibling, factoryArgs: [t.__min, t.__max, t.__step] }); return a.name(r), s && a.listen(), a } return o }; t.min = $.compose(h, t.min), t.max = $.compose(h, t.max) } else t instanceof Tl ? (Z.bind(d, 'click', function () { Z.fakeEvent(t.__checkbox, 'click') }), Z.bind(t.__checkbox, 'click', function (n) { n.stopPropagation() })) : t instanceof Al ? (Z.bind(d, 'click', function () { Z.fakeEvent(t.__button, 'click') }), Z.bind(d, 'mouseover', function () { Z.addClass(t.__button, 'hover') }), Z.bind(d, 'mouseout', function () { Z.removeClass(t.__button, 'hover') })) : t instanceof jr && (Z.addClass(d, 'color'), t.updateDisplay = $.compose(function (n) { return d.style.borderLeftColor = t.__color.toString(), n }, t.updateDisplay), t.updateDisplay()); t.setValue = $.compose(function (n) { return e.getRoot().__preset_select && t.isModified() && qr(e.getRoot(), !0), n }, t.setValue) } function Il (e, d) { const t = e.getRoot(); const i = t.__rememberedObjects.indexOf(d.object); if (i !== -1) { let h = t.__rememberedObjectIndecesToControllers[i]; if (h === void 0 && (h = {}, t.__rememberedObjectIndecesToControllers[i] = h), h[d.property] = d, t.load && t.load.remembered) { const n = t.load.remembered; let o = void 0; if (n[e.preset])o = n[e.preset]; else if (n[cn])o = n[cn]; else return; if (o[i] && o[i][d.property] !== void 0) { const r = o[i][d.property]; d.initialValue = r, d.setValue(r) } } } } function gn (e, d, t, i) { if (d[t] === void 0) throw new Error('Object "' + d + '" has no property "' + t + '"'); let h = void 0; if (i.color)h = new jr(d, t); else { const n = [d, t].concat(i.factoryArgs); h = Qd.apply(e, n) }i.before instanceof pi && (i.before = i.before.__li), Il(e, h), Z.addClass(h.domElement, 'c'); const o = document.createElement('span'); Z.addClass(o, 'property-name'), o.innerHTML = h.property; const r = document.createElement('div'); r.appendChild(o), r.appendChild(h.domElement); const s = kr(e, r, i.before); return Z.addClass(s, ft.CLASS_CONTROLLER_ROW), h instanceof jr ? Z.addClass(s, 'color') : Z.addClass(s, wd(h.getValue())), kd(e, s, h), e.__controllers.push(h), h } function Bi (e, d) { return document.location.href + '.' + d } function _r (e, d, t) { const i = document.createElement('option'); i.innerHTML = d, i.value = d, e.__preset_select.appendChild(i), t && (e.__preset_select.selectedIndex = e.__preset_select.length - 1) } function Bl (e, d) { d.style.display = e.useLocalStorage ? 'block' : 'none' } function qd (e) { const d = e.__save_row = document.createElement('li'); Z.addClass(e.domElement, 'has-save'), e.__ul.insertBefore(d, e.__ul.firstChild), Z.addClass(d, 'save-row'); const t = document.createElement('span'); t.innerHTML = '&nbsp;', Z.addClass(t, 'button gears'); const i = document.createElement('span'); i.innerHTML = 'Save', Z.addClass(i, 'button'), Z.addClass(i, 'save'); const h = document.createElement('span'); h.innerHTML = 'New', Z.addClass(h, 'button'), Z.addClass(h, 'save-as'); const n = document.createElement('span'); n.innerHTML = 'Revert', Z.addClass(n, 'button'), Z.addClass(n, 'revert'); const o = e.__preset_select = document.createElement('select'); if (e.load && e.load.remembered ? $.each(e.load.remembered, function (l, u) { _r(e, u, u === e.preset) }) : _r(e, cn, !1), Z.bind(o, 'change', function () { for (let l = 0; l < e.__preset_select.length; l++)e.__preset_select[l].innerHTML = e.__preset_select[l].value; e.preset = this.value }), d.appendChild(o), d.appendChild(t), d.appendChild(i), d.appendChild(h), d.appendChild(n), pn) { const r = document.getElementById('dg-local-explain'); const s = document.getElementById('dg-local-storage'); const a = document.getElementById('dg-save-locally'); a.style.display = 'block', localStorage.getItem(Bi(e, 'isLocal')) === 'true' && s.setAttribute('checked', 'checked'), Bl(e, r), Z.bind(s, 'change', function () { e.useLocalStorage = !e.useLocalStorage, Bl(e, r) }) } const f = document.getElementById('dg-new-constructor'); Z.bind(f, 'keydown', function (l) { l.metaKey && (l.which === 67 || l.keyCode === 67) && mn.hide() }), Z.bind(t, 'click', function () { f.innerHTML = JSON.stringify(e.getSaveObject(), void 0, 2), mn.show(), f.focus(), f.select() }), Z.bind(i, 'click', function () { e.save() }), Z.bind(h, 'click', function () { const l = prompt('Enter a new preset name.'); l && e.saveAs(l) }), Z.bind(n, 'click', function () { e.revert() }) } function _d (e) { let d = void 0; e.__resize_handle = document.createElement('div'), $.extend(e.__resize_handle.style, { width: '6px', marginLeft: '-3px', height: '200px', cursor: 'ew-resize', position: 'absolute' }); function t (n) { return n.preventDefault(), e.width += d - n.clientX, e.onResize(), d = n.clientX, !1 } function i () { Z.removeClass(e.__closeButton, ft.CLASS_DRAG), Z.unbind(window, 'mousemove', t), Z.unbind(window, 'mouseup', i) } function h (n) { return n.preventDefault(), d = n.clientX, Z.addClass(e.__closeButton, ft.CLASS_DRAG), Z.bind(window, 'mousemove', t), Z.bind(window, 'mouseup', i), !1 }Z.bind(e.__resize_handle, 'mousedown', h), Z.bind(e.__closeButton, 'mousedown', h), e.domElement.insertBefore(e.__resize_handle, e.domElement.firstElementChild) } function ta (e, d) { e.domElement.style.width = d + 'px', e.__save_row && e.autoPlace && (e.__save_row.style.width = d + 'px'), e.__closeButton && (e.__closeButton.style.width = d + 'px') } function gs (e, d) { const t = {}; return $.each(e.__rememberedObjects, function (i, h) { const n = {}; const o = e.__rememberedObjectIndecesToControllers[h]; $.each(o, function (r, s) { n[s] = d ? r.initialValue : r.getValue() }), t[h] = n }), t } function tv (e) { for (let d = 0; d < e.__preset_select.length; d++)e.__preset_select[d].value === e.preset && (e.__preset_select.selectedIndex = d) } function Nl (e) { e.length !== 0 && $d.call(window, function () { Nl(e) }), $.each(e, function (d) { d.updateDisplay() }) } const Gl = ft; const wl = class extends xn.default.Scene {preload () { this.objects = [{ name: 'sun', parent: null, radius: 20, zoom: { size: 1, speed: 100 }, features: { color: 3407854 }, orbit: { angle: 0, period: 4, distance: 200 } }, { name: 'planet', parent: 'sun', radius: 10, zoom: { size: 10, speed: 1e3 }, features: { color: 6711039 }, orbit: { angle: 0, period: 9, distance: 200 } }, { name: 'moon', radius: 5, parent: 'planet', zoom: { size: 20, speed: 1e3 }, features: { color: 6710886 }, orbit: { angle: 0, period: 3, distance: 40 } }, { name: 'planet2', parent: 'sun', radius: 10, zoom: { size: 10, speed: 1e3 }, features: { color: 15636223 }, orbit: { angle: 98, period: 12, distance: 140 } }, { name: 'moon2', radius: 5, parent: 'planet2', zoom: { size: 20, speed: 1e3 }, features: { color: 6710886 }, orbit: { angle: 45, period: 3, distance: 20 } }, { name: 'planet3', parent: 'sun', radius: 10, zoom: { size: 10, speed: 1e3 }, features: { color: 15662916 }, orbit: { angle: 145, period: 15, distance: 80 } }, { name: 'moon3', radius: 5, parent: 'planet3', zoom: { size: 20, speed: 1e3 }, features: { color: 6710886 }, orbit: { angle: 55, period: 2, distance: 20 } }, { name: 'meteor', parent: 'sun', radius: 5, zoom: { size: 10, speed: 1e3 }, features: { color: 6710886 }, orbit: { angle: 220, period: 40, distance: 300 } }, { name: 'meteor2', parent: 'sun', radius: 5, zoom: { size: 10, speed: 1e3 }, features: { color: 6710886 }, orbit: { angle: 40, period: 40, distance: 300 } }, { name: 'meteor3', parent: 'sun', radius: 5, zoom: { size: 10, speed: 1e3 }, features: { color: 6710886 }, orbit: { angle: 120, period: 40, distance: 300 } }, { name: 'meteor4', parent: 'sun', radius: 5, zoom: { size: 10, speed: 1e3 }, features: { color: 6710886 }, orbit: { angle: 160, period: 40, distance: 300 } }] }create () { const t = new Date().getTime(); console.log('BUILDING SOLAR SYSTEM ********* StarDATE: ' + t); const i = this.cameras.main; const h = window.innerWidth / 2; const n = window.innerHeight / 2; console.log('WINDOW DIMENSIONS ', h + ' : ' + n); const o = 1e4; i.setBounds(-o, -o, o * 2, o * 2), i.setScroll(-h, -n), i.setOrigin(0.5, 0.5), i.setZoom(1); for (let u = 0; u < this.objects.length; u++) this[this.objects[u].name + 'Object'] = this.add.circle(0, 0, this.objects[u].radius, this.objects[u].features.color), this[this.objects[u].name + 'Object'].setInteractive(), this[this.objects[u].name + 'Object'].name = this.objects[u].name, this[this.objects[u].name + 'Object'].data = this.objects[u], this[this.objects[u].name + 'Object'].on('pointerdown', function (v) { console.log(this), i.zoomTo(this.data.zoom.size, this.data.zoom.speed, 'Sine.easeInOut', !0), this.scene.selected = { obj: this, id: this.data } }); this.selected = { obj: this.sunObject, id: this.sunObject.data }; const r = this.input.keyboard.createCursorKeys(); const s = { camera: this.cameras.main, left: r.left, right: r.right, up: r.up, down: r.down, zoomIn: this.input.keyboard.addKey(xn.default.Input.Keyboard.KeyCodes.Q), zoomOut: this.input.keyboard.addKey(xn.default.Input.Keyboard.KeyCodes.E), acceleration: 0.6, drag: 5e-4, maxSpeed: 1 }; this.controls = new xn.default.Cameras.Controls.SmoothedKeyControl(s); const a = new Gl(); const f = { line1: 'Cursors to move', line2: 'Q & E to zoom' }; const l = a.addFolder('Camera'); l.add(i, 'x').listen(), l.add(i, 'y').listen(), l.add(i, 'scrollX').listen(), l.add(i, 'scrollY').listen(), l.add(i, 'rotation').min(0).step(0.01).listen(), l.add(i, 'zoom', 0.1, 2).step(0.1).listen(), l.add(f, 'line1'), l.add(f, 'line2'), l.open() }update (d, t) { const i = this.cameras.main; const h = window.innerWidth / 2; const n = window.innerHeight / 2; const o = 10; i.scrollX -= i.scrollX + h - this.selected.obj.x, i.scrollY -= i.scrollY + n - this.selected.obj.y, this.controls.update(t); for (let a = 0; a < this.objects.length; a++) if (this.objects[a].parent != null) { const r = s(this[this.objects[a].parent + 'Object'], this.objects[a]); this[this.objects[a].name + 'Object'].x = r.x, this[this.objects[a].name + 'Object'].y = r.y } function s (a, f) { f.orbit.angle += 1 / f.orbit.period; const l = f.orbit.angle * 2 * Math.PI / 180; const u = f.orbit.distance; return { x: Math.cos(l) * u - Math.sin(l) * u + a.x, y: Math.sin(l) * u + Math.cos(l) * u + a.y } } }keyReleased () { console.log('Key released') }}; const zl = wl; const Xr = Fi(Tn()); const Ad = Fi(yd()); const un = Fi(Tn()); const Sd = Fi(Tn()); const Td = {}; function gp () { return Sd.default.createElement('div', { style: Td.button }, 'HELLO') } const Ed = gp; function xp () { return un.default.createElement('div', { className: 'App' }, un.default.createElement('header', { className: 'App-header' }, un.default.createElement('h1', null, 'Hello World')), un.default.createElement('main', null, un.default.createElement(Ed, null))) } const Cd = xp; Ad.default.render(Xr.default.createElement(Xr.default.StrictMode, null, Xr.default.createElement(Cd, null)), document.querySelector('#root')); const yp = { type: vs.default.AUTO, scale: { parent: 'game', mode: vs.default.Scale.FIT, autoCenter: vs.default.Scale.CENTER_HORIZONTALLY, width: '100%', height: '100%' } }; const Pd = new vs.default.Game(yp); Pd.scene.add('GameScene', zl); Pd.scene.start('GameScene')
})()
/**
 * @author       @dxu https://github.com/dxu/matter-collision-events
 * @author       Richard Davey <rich@photonstorm.com>
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
/**
 * @author       Florian Vazelle
 * @author       Geoffrey Glaive
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
/**
 * @author       Jason Nicholls <nicholls.jason@gmail.com>
 * @copyright    2018 Photon Storm Ltd.
 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
 */
/**
 * @author       Joachim Grill <joachim@codeandweb.com>
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2018 CodeAndWeb GmbH
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
/**
 * @author       Niklas von Hertzen (https://github.com/niklasvh/base64-arraybuffer)
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
/**
 * @author       Richard Davey
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       @samme
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Angry Bytes (and contributors)
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Benjamin D. Richards <benjamindrichards@gmail.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Felipe Alfonso <@bitnenfer>
 * @author       Matthew Groves <@doormat>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Felipe Alfonso <@bitnenfer>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Florian Mertens
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Igor Ognichenko <ognichenko.igor@gmail.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       samme <samme.npm@gmail.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
/**
 * @author       Seth Berrier <berriers@uwstout.edu>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
/**
 * @author       Stefan Hedman <schteppe@gmail.com> (http://steffe.se)
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
/**
 * @author       Vladimir Agafonkin
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
/**
 * @author       Vladislav Forsh <vlad@robowhale.com>
 * @copyright    2021 RoboWhale
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
/**
 * @author       pi-kei
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
/**
 * @author       samme
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
/**
 * @author       samme
 * @copyright    2021 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2020 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser3-plugin-template/blob/master/LICENSE|MIT License}
*/
/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2020 Photon Storm Ltd.
* @license      {@link https://opensource.org/licenses/MIT|MIT License}
*/
